<!DOCTYPE html>
<html>
<head>
  <!--
   - CppModels.htm
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Syracuse University
  -->
  <title>UML Diagrams</title>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsSizerComp.js"></script>
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 0.5fr;
      grid-column-gap: 0em;
      padding: 0px;
    }

    .item1 {
      grid-column: 1;
      padding: 0px;
    }

    .item2 {
      grid-column: 2;
      padding: 0px;
    }

    .border {
      border: 1px solid black;
      padding-bottom: 10px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeysContainer>
    <navKey onclick="location.reload()">R</navKey>
    <navKey onclick="scrollPageTop()">T</navKey>
    <navKey onclick="scrollPageBottom()">B</navKey>
    <navKey onclick="helpWin()">H</navKey>
    <navKey onclick="loadPrev()">P</navKey>
    <navKey onclick="loadNext()">N</navKey>
  </navKeysContainer>

  <nav>
    <div id="navbar"></div>
  </nav>
  <!--<a id="Next" href="CodeWebifier.html">N</a>
  <a id="Prev" href="FindFiles.html">P</a>-->

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">UML Diagrams</h1>
      <h3 id="subtitle">Package, Class, and Activity diagrams</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <indent-block>
    <h3>UML Diagrams</h3>
    <indent-block>
      Universal Modeling Diagrams (UML) are diagrams that provide very useful abstractions for object-oriented code.
      There are many diagram types:
      <ul class="tight pad10">
        <li>
          <strong>Package Diagram:</strong><br />
          Shows each package in a design, using a package symbol, and their dependency relationships.
        </li>
        <li>
          <strong>Class Diagram:</strong><br />
          Shows each class in a package, using one of two class symbols, and their relationships, e.g.,
          inheritance, composition, aggregation, and using.
        </li>
        <li>
          <strong>Activity Diagram:</strong><br />
          Uses symbols for processing, flow, synchronization, and rarely, conditional logic, to show
          the order of processing activities in a design.
        </li>
        <li>
          <strong>Sequence Diagram:</strong><br />
          Uses symbols for classes and class life-times and communication between each class.
        </li>
        <li>
          <strong>State Diagram:</strong><br />
          Uses symbols for states and transitions between states.
        </li>
        <li>
          <strong>Use Case Diagram:</strong><br />
          Widely used to represent design cases, however, they are much more useful for showing
          the various ways that users will interact with a system.
        </li>
        <li>
          A few other less important diagrams.
        </li>
      </ul>
      In these notes, we will discuss the first three: Package, Class, and Activity Diagrams.
    </indent-block>
    <h3>Diagrams:</h3>
    <indent-block>
      <details>
        <summary><strong>Package Diagrams</strong></summary>
        <div id="fig1"></div>
        <indent-block class="indent">
          A package is, for C++, a pair of files - header and implementation.  The header file (*.h)
          contains prologue comments that describe the responsibilities of the package, declarations
          and inline definitions.  The implementation file (*.cpp) contains all definitions not
          contained in the header.  It also contains a test stub that is enclosed by a preprocessor
          definition that allows it to be included for stand-alone testing, and excluded for use
          with other code.
          <spacer-15></spacer-15>
          A package diagram shows each of the packages in a design, using a package symbol,
          and shows their dependency relationships.  In Figure 1. we show the package diagram for TextFinder,
          one of the tools from our code repositories.  The package reponsibilities are:
          <ul class="tight pad10">
            <li>
              TextFinder is responsible for finding every file, in a specified directory tree, that
              contains text matching a specified regular expression.  It does that using services of
              the other packages shown
            </li>
            <li>
              CodeUtilities provides processing of the program&apos;s command line, capturing each of
              the options specified there, and encapsulating them for use later in the program.
            </li>
            <li>
              DirExplorerT is a reusable directory navigator that does a recursive depth first search
              of a specified directory tree.  For each directory and file encountered, it calls doDir
              and doFile methods in a class that manages application specific details.
            </li>
            <li>
              FileSystem is used by DirExplorerT to discover directories and files using the Windows API.
            </li>
            <li>
              Application is an application specific class that defines processing for directories and
              files.
            </li>
            <li>
              TextSearch defines how text files are opened and searched for regular expression matches.
            </li>
          </ul>
          Notice that the package diagram, augmented with package responsibilities, gives a quite clear
          top-level appreciation for the operations of this facility.
          <spacer-15></spacer-15>
          These diagrams present a very abstract representation of a design.  They give us an opportunity
          to discuss the responsibilities of each of the parts, e.g., packages.  They provide essential
          support for understanding large systems, without getting overwhelmed with details.
          <spacer-15></spacer-15>
          <strong>Summary:</strong>
        </indent-block>
      </details>
      <indent-block>
        Show packages and their dependency relationships.
      </indent-block>
      <spacer-15></spacer-15>
      <details>
        <summary><strong>Class Diagrams</strong></summary>
        <div id="fig2"></div>
        <indent-block class="indent">
          A class declares, and provides the facilities to construct, manipulate, and destroy
          encapsulated state, e.g., fundamental language types or library entities like vectors and deques.
          <spacer-15></spacer-15>
          A class diagram shows each of the classes in a package, using one of two class symbols - see Fig 2,
          and shows their relationships.  Classes have four kinds of relationships with other classes:
          inheritance, composition, aggregation, and using.
          <spacer-15></spacer-15>
          Inheritance is shown with a triangle symbol pointing to a base class and line extending to one or
          more derived classes.  It represents an &quot;is-a&quot; relationship, as in a student is-a person.
          <spacer-15></spacer-15>
          Composition is shown with a solid diamond that is adjacent to the composer with a line reaching
          to the composed class.  Composition is a strong ownership relationship.  The composer and composed
          have the same life-time.  The composed is an integral part of the composer.
          <spacer-15></spacer-15>
          Aggregation is shown with a hollow diamond that is adjacent to the aggregator with a line extending
          to the aggregated class.  Aggregation is a weaker ownership relationship.  An aggregated part may
          or may not exist throughout the lifetime of the aggregator.  It is created and disposed by the
          aggregating class.  Aggregation may occur when a method of the aggregator creates the aggregated
          instance on the native heap.  It may also occur when the aggregator creates a local instance
          of the aggregated in one of its methods.
          <spacer-15></spacer-15>
          Using is a non-owning relationship, shown by an arrow directed from the user to the used.
          Instances of used classes are passed to the user as a reference argument in one of its methods.
          <spacer-15></spacer-15>
          These diagrams present an abstract representation of a design, in that they disclose no code,
          but they do present its logical structure.
          <spacer-15></spacer-15>
          In Figure 2. we show the classes for TextFinder. TextFinder inherits the interface ITextFinder,
          composes an instance of DirExplorerT&lt;Application&gt;, and aggregates an instance of TextSearch.
          It does that by creating the instance as a local data member of its searchFile method.  Application
          uses TextFinder through its interface ITextFinder.  Finally, DirExplorerT&lt;Application&gt;
          composes an instance of ProcessCmdLine.  We haven&apos;t shown the FileSystem classes as they are
          implementation details of the DirExplorerT&lt;Application&gt; class.
          <spacer-15></spacer-15>
          We see that the Application class is used as
          a template parameter for DirExplorerT&lt;Application&gt;.  Its methods doDir and doFile provide
          application specific processing so that DirExplorerT&lt;Application&gt; can be used without
          modification.  We&apos;ve seen that Application uses the interface ITextFinder
          (to access it&apos;s searchFile
          method).  Because ITextFinder is an interface, Application can use TextFinder without incurring a
          build dependency.  TextFinder uses the Application class definition to instantiate an instance
          of DirExplorerT&lt;Application&gt;.
          <spacer-15></spacer-15>
          <strong>Summary:</strong>
        </indent-block>
      </details>
      <indent-block>
        Show classes and their relationships: inheritance, composition, aggregation, and using.
      </indent-block>
      <spacer-15></spacer-15>
      <details>
        <summary><strong>Activity Diagrams</strong></summary>
        <div id="fig3"></div>
        <indent-block class="indent">
          Processing activities are shown as process &quot;bubbles&quot; connected with directed
          lines that describe processing flow. Every processing activity has at least one entering flow 
          and at least one
          exit flow. There is always one initial flow indicated with a filled circle at the beginning
          end.  There are always one or more exit flows that terminate on a hollow circle that contains
          a filled circle.
          <spacer-15></spacer-15>
          I&apos;ve shown bidirectional flows to represent flow from one process to another and then back.
          It is conventional to use two one-way flows in these diagrams.  The bidirectional flows were used
          because the tool I used to generate them doesn&apos;t provide enough anchor points on the process
          bubbles.
          <spacer-15></spacer-15>
          &quot;Swim-lanes&quot; are optionally used to show how processing is packaged in a design.
          That was done in Figure 3. for TextFinder.  That helps us understand the sequence of calls
          made between packages and when they occur.
          <spacer-15></spacer-15>
        </indent-block>
        <div id="fig4"></div>
        <indent-block>
          There is one more feature that may be used in activity diagrams, not shown in Figure 3.,
          synchronization bars.  In Figure 4. we show processing activity for a message-passing
          communication channel.  That diagram uses several synchronizing bars to indicate places
          where processing may wait and where it may fork processing into concurrent activities.
          <spacer-15></spacer-15>
          A synchronization bar is a filled narrow rectangle that may be either horizontal or vertical,
          based on the needs of the diagram.  Each synchronizer represents a place where processing must
          wait, as for a deQueue operation or in a form waiting for user input, or where processing
          may fork by creating a child thread or process.
          <spacer-15></spacer-15>
          The message-passing diagram illustrates activities that occur in a communication channel,
          where sender&apos;s messages are enQueued and later deQueued for processing.  Also, they are
          used to represent the channel connection activity.
          <spacer-15></spacer-15>
          There are specific semantics for multiple inputs to a synchronizer and multiple outputs from
          a synchronizer:
          <ul>
            <li>
              Mulitple inputs to a synchronizer indicate that no processing on the output side can
              occur until all of the input processing activities have completed.
            </li>
            <li>
              Multiple outputs from a synchronizer indicate that each output is independent of the others
              and are forked for concurrent processing.
            </li>
          </ul>
          This is an extraordinarily useful representation, helping us to understand timing relationships
          between a program&apos;s processing parts.
          <spacer-15></spacer-15>
          Note that the processing &quot;bubbles&quot; often correspond to processing in a single function.
          However, there is no mandate for that.  We collect activities into a single process in any way that
          helps a reader to understand the design.
          <spacer-15></spacer-15>
          <strong>Summary:</strong>
        </indent-block>
      </details>
      <indent-block>
        Show a design&apos;s processing flows and synchronization.
      </indent-block>
      <spacer-15></spacer-15>
      UML diagrams are an essentail part of the documentation for complex programs and systems.  They help us
      understand how large systems work without reading every single line of code.  Imagine, for example,
      you are working on a system with millions of lines of code (Linux has about 12 million lines of code).  
      You could never understand a system that large
      by reading all of its code.  By the time you got to the end you would have forgotten most of what you 
      learned while reading.
      <spacer-15></spacer-15>
      We need the abstraction power of diagrams, combined with some carefully constructed prose, to help us
      quickly understand enough to get to work.  We frequently use diagrams that are not in the UML pantheon,
      call-stack and architectural block diagrams, for example.  But the UML diagrams are by far the most
      frequently used and discussed documentation artifacts.
      <spacer-15></spacer-15>
      A final note: I use gliffy, a tool available from the chrome webstore, to draw most of the UML diagrams
      I use.  It&apos;s easy to acquire and use.
    </indent-block>
  </indent-block>
  <script>createSizer("Pictures/TextFinderPackageDiagram.JPG", "Figure 1. Package Diagram for TextFinder", 340, "fig1")</script>
  <script>createSizer("Pictures/TextFinderClassDiagram.JPG", "Figure 2. Class Diagram for TextFinder", 340, "fig2")</script>
  <script>createSizer("Pictures/TextFinderActivityDiagram.JPG", "Figure 3. Activity Diagram for TextFinder", 450, "fig3")</script>
  <script>createSizer("Pictures/MsgPassActivity.JPG", "Figure 4. Activity for MsgPassComm", 450, "fig4")</script>
  <spacer-25 class="clear"></spacer-25>
  <spacer-25 class="clear"></spacer-25>
  <spacer-25 class="clear"></spacer-25>
  <info-bar></info-bar>
</body>
</html>