<!DOCTYPE html>
<html>
<head>
  <!--
   - MLiPS_1.htm
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>SiteStory 4</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsSizerComp.js"></script>
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }

    #github photo-container {
      display: flex;
      flex-direction: row;
      /*float: right;*/
      width: min-content;
      flex: 1 1 auto;
      padding: 10px 15px;
      background-color: white;
      overflow: hidden;
      border-radius: 7px;
      border: 1px solid black;
      /*touch-action: none;*/
      user-select: none;
    }

    #github photo-image {
      user-select: none;
    }

    #github photo-caption {
      display: block;
      font-family: 'Comic Sans MS', Consolas, sans-serif;
      background-color: white;
      padding-top: 5px;
      font-size: 1.25em;
      width: 100%;
      text-align: center;
    }

    .pad15 {
      padding-top: 15px;
      padding-bottom: 15px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>
  <a id="Next" href="SiteStory_5.html">N</a>
  <a id="Prev" href="SiteStory_3.html">P</a>

  <header>
    <a class="repoLink" href="https://github.com/JimFawcett">https://github.com/JimFawcett</a>
    <hgroup id="pagetitle">
      <h1 id="title">Site Experiments</h1>
    </hgroup>
  </header>
  <hr class="spread" />
  <indent-block>
    <h3>Experiments publishing code:</h3>
    <indent-blocks>
      In addition to providing access to repositories, this site is an experiment on ways to publish code.
      The experiment has several parts:
      <ol>
        <li>
          <strong>Can a static website provide an effective user experience?</strong>
          <spacer-15></spacer-15>
          I used a static website for my Syracuse University courses for about 15 years.  With static
          pages I could present from whatever laptop or desktop I was using, loading pages directly from
          the local drive without any installation.  That is important in an enviroment where several players
          determine what a site is allowed or not allowed to do.  Also, that greatly expedites the creation
          and editing of new pages, because you can immediately view the contents affected by change without
          uploading to a constrained environment.
          <spacer-15></spacer-15>
          I continued with that approach because github will host (only) static websites and does so in a very
          easy to use process. But can a static site do everything needed?  That, of course, depends on the
          site&apos;s mission.  You can&apos;t use database facilities nor facilities provided by a framework
          like Asp.Net Core.
          <spacer-15></spacer-15>
          However, you can do a lot in rendering content.  A good example is the StoryTeller.  Its processing
          is determined using only JavaScript, CSS, and HTML.  That took some interesting designs to make that
          work: see <a href="StoryTellerDesign.html">StoryTeller Design</a>. But the result works well, probably
          as well as you could do with a web framework hosted in a webserver.
          <spacer-15></spacer-15>
          <strong>Conslusion:</strong> I see little reason to use anything other than static sites to publish
          code.  For those who would use a site generator rather than craft a lot of JavaScipt, CSS, and
          HTML code there are static site generators available, e.g.,
          <a href="https://www.staticgen.com/">Jekyll and Hugo</a>.
          <spacer-15></spacer-15>
        </li>
        <li>
          <strong>How to organize a large collection of code resources that scales well with increasing content?</strong>
          <spacer-15></spacer-15>
          This experiment implemented a repository menu with dropdown links, one for each category:
          utilities, tools, components, libraries, projects, and code demonstrations.
          <spacer-15></spacer-15>
          A user can find any code published by the site simply by hovering over each of these links
          to open the associated dropdown. Clicking a link in the dropdown opens a documentation file
          for the code, which in-turn links to the code folder.
          <spacer-15></spacer-15>
          Will this scale well?  The current organization works well for about 50 repositories.  If
          a site needs more, the Repository.html page can be factored into RepositoryCpp.html,
          RepositoryCs.html, RepositoryJv.html, ..., very similar to database sharding.
          That would require an extra user click, and we
          always want to minimize click counts to do anything.  But that is probably just a symptom
          of the domain complexity, not a failure of the approach, or at least that is what I currently
          believe.
          <spacer-15></spacer-15>
          <strong>Conclusion:</strong>
          Using repository summary pages, RepositoryCpp.html, RepositoryCs.html, ... with dropdown menus
          making contents visible with simple hover actions seems like a very effective way for users
          to find what they need or explore what&apos;s available in large code collections.
          <spacer-15></spacer-15>
          Would this work on a national scale, e.g., code made available from Federal research institutions?
          Probably not, although a hierarchy of sites like this probably would.  An alternative might be
          to use something like the &#8734;DataLibrary, described in a sister story.
          <spacer-10></spacer-10>
        </li>
        <li>
          <strong>How to help users understand what a repository&apos;s code does and how it is designed?</strong>
          <spacer-15></spacer-15>
          We want something akin to the Unix/Linux man pages, but decidedly easier to find information
          and providing the smallest descriptions that work.
          <spacer-15></spacer-15>
          We decided to place the documentation adjacent to the code it represents.  Here, by adjacency
          we mean direct linkages, not necessarily colocation in folders. So, clicking on a Repository
          menu item takes you directly to the documentation page.  At the top of each page is a link to
          the associated code folder, e.g., the github repository.
          <spacer-15></spacer-15>
          Most documentation pages provide: Concept, Usage, Design, and Status sections.  The intent is
          that the document fits on a single webpage with little scrolling necessary to see all the text.
          The sections may vary from repository to repository, but most follow this schema.
          <spacer-15></spacer-15>
          <strong>Conclusion:</strong>
          Fairly brief documentation pages with the sections listed above, or something similar, helps
          users determine if code will satisfy their needs and give them an idea of how it works.  That
          probably won&apos;t eliminate the need to look at code once a use decision has been made.  However
          the process of reading the code, if it is well structured and uses good names, will be significantly
          easier and more productive with the help of documentation, as describe here.
          <spacer-10></spacer-10>
        </li>
        <li>
          <strong>How to balance the use of precious webpage real estate when displaying text, images, and diagrams?</strong>
          <spacer-15></spacer-15>
          Currently, we use expandable image/diagram blocks.  Clicking on the body expands the block,
          clicking on its title contracts.  So most pages start with images that may be too small to see
          all their details, but make a lot of space for text.  Users simply click on the image or diagram
          to see all its detail.
          <spacer-15></spacer-15>
          That seems to work quite well, although I&apos;m still experimenting with other widgets, e.g.,
          splitter bars and images that drag to enlarge.
          <spacer-15></spacer-15>
          <strong>Conclusion:</strong>
          I&apos;ve experimented with image resizing using the major browsers and in tablet environments
          as well as laptops and desktops. I believe it will be hard to do much better.  Note that the use
          of HTML5&apos;s &lt;details&gt; tags also helps greatly managing page real estate.  In several
          places in this site I&apos;ve used them together with good results.
          <spacer-10></spacer-10>
        </li>
        <li>
          <strong>How do we make navigation through a sequence of pages as painless as possible?</strong>
          <spacer-15></spacer-15>
          A lot of the site material is organized into sequences of pages.  Examples are Blog pages,
          repository documentation pages, and story content.
          You will see [next] and [prev]
          buttons on the top menu if you are looking at one of a sequence of pages.
          In addition to the top menu [next] and [prev]
          we provide a navigation block at the lower right of each page, with a series of buttons. We did
          that because we wanted to provide more options than just next and prev, for example snapping to the
          top or bottom of the current page and didn&apos;t have enough menu real estate for that.
          <spacer-15></spacer-15>
          If the user doesn&apos;t want to see those buttons they can
          be toggled off from the &quot;About&quot; dropdown available on all the site menus.
          Each of the buttons in the navigation block has a corresponding keypress event.  Pressing the N key
          has the same effect as using the navigation block [n] button.
          <spacer-15></spacer-15>
          Another experiment was to provide touch-based swipe events. Those are useful for viewing the site
          with a tablet.  However, when using a laptop or desktop computer, the buttons and keys seem much
          more effective.
          <spacer-15></spacer-15>
          <strong>Conslusion:</strong>
          I&apos;ve used schemes similar to these on my
          <a href="https://ecs.syr.edu/faculty/fawcett/handouts/webpages/fawcetthome.htm">Syracuse University website</a> and gotten
          a lot of mostly positive feedback about ease of finding things.  The biggest complaints I received
          were about finding specific code needed for class projects.  That is the reason I&apos;ve use the
          repository structure here - that was done in a much less effective way on the SU site and spurred
          the use of the current schema.
          <div id="fig1"></div>
          <spacer-15></spacer-15>
          I believe that the design used here is close to optimal.  I&apos;m open to suggestions, but don&apos;t
          expect to change the approach used here, other than possibly to refactor, as described above, as more
          content is added.
          <spacer-10></spacer-10>
        </li>
        <li>
          Physical organisation of files in directories has some issues.  This site currently has more than
          100 pages and perhaps 50 images.  I initially started locating code in directories by function, e.g.,
          main pages, stories, resource pages, etc.  But almost all pages have menus, and if you put them in
          seperate directories the menu links need to reflect their location.  That causes a lot of maintenance.
          <spacer-15></spacer-15>
          I decided to put almost all pages in the same directory and all the images and diagrams, scripts, and
          styles in child directories.  That could make finding files in the main directory somewhat difficult.
          <spacer-15></spacer-15>
          I&apos;ve address that by using naming conventions, all the blogs start with Blog... and all the pages
          in each story start with the story name.  That helps a bit.  Things got much more managable when I started
          using IDE (virtual) folders to organize code.
          <spacer-15></spacer-15>
          See Figure 1 for a view of Visual Studio&apos;s Solution Explorer View with these folders. Note that
          these are not physical folders, just Visual Studio&apos;s way of presenting the view to you.  So there is no
          issue with menu link paths.
        </li>
        <li>
          <strong>Other Experiments</strong>
          <spacer-15></spacer-15>
          I plan to implement page widgets like imageSizer as standard WebComponents.  There are several
          similar options, e.g., React or Vue widgets.  Using WebComponents probably won&apos;t affect the user experience,
          but it will make the website developer (me in this case) more productive. Will the benefit be worth
          the development effort?  I expect so, but the jury is still out.
          <spacer-15></spacer-15>
          There isn&apos;t much material in this website on the relationships between software structure,
          platform tools, and the build process.  I expect to try several approaches for that fairly soon.
          <spacer-10></spacer-10>
        </li>
      </ol>
    </indent-blocks>
    The experimentation won&apos;t stop here, but will slow down as I turn to improving site content.
  </indent-block>
  <spacer-25></spacer-25>
  <info-bar></info-bar>
  <script>createSizer("Pictures/SolutionExplorerVirtualFolders.JPG", "Fig 1. Soln Expl Virtl Fldrs", 300, "fig1")</script>
  <!--<script>createSizer("Pictures/SiteIndexPage.JPG", "Fig 2. Home Page", 400, "fig2")</script>
  <script>createSizer("Pictures/SiteReposPage.JPG", "Fig 3. Repos Page", 400, "fig3")</script>-->
</body>
</html>