<!DOCTYPE html>
<html>
<head>
  <!--
   - CppReferences.htm
   - ver 1.0 - 03 June 2012
   - Jim Fawcett, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Engineering course notes. Code Samples. Software Links" />
  <meta name="keywords" content="Lecture, Notes, Code, Syracuse,University" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <title>Summer Reading</title>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <style>
    h3 {
      margin-top:10px;
      margin-bottom:10px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeysContainer>
    <navKey onclick="scrollPageTop()">T</navKey>
    <navKey onclick="scrollPageBottom()">B</navKey>
    <navKey onclick="helpWin()">H</navKey>
    <navKey onclick="loadPrev()">P</navKey>
    <navKey onclick="loadNext()">N</navKey>
  </navKeysContainer>

  <nav>
    <div id="navbar"></div>
  </nav>
  <!--<a id="Next" href="BlogStructure.html">N</a>
  <a id="Prev" href="BlogTesting.html">P</a>-->

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">C++ References</h1>
    </hgroup>
  </header>

  <!-- page content -->

  <blockquote style="text-align:left;">
    “Some books should be tasted, some devoured, but only a few should be chewed and digested thoroughly.”
    <br />
    - Sir Francis Bacon
  </blockquote>

  <under-construction>
    This content needs to be changed significantly.
  </under-construction>
  <h3>Initial Thoughts:</h3>
  While taking courses we usually have a "Required Course Text" that we study in detail to acquire specific bits of technology.
  The books I recommend here serve a different purpose; most discuss a philosophy of development or the foundations of a
  technology that we consume by reflecting on the material as well as practicing specific skills.
  <p />
  Developing skills with detailed study and practice is an essential beginning.  These books help us polish
  skills into professional expertise.  I think it is a really good idea to pick one concept book each summer to read and digest,
  especially if its topics are outside your normal sphere of work and thought.
  <p />
  While I worked in industry we would form a group of a half dozen or so people with a common interest, pick a good book, and
  digest it over a a couple of months of lunch-time discussions.  Each of us would take a chapter, digest it, and present to the
  others.  That way we all came away with a working knowledge of an area with relatively little effort and a lot of enjoyment.
  <p />
  Anyway, here's my list of books that will profitably take you out of your comfort zones, listed roughly in order of effort
  required, with the quickest first.
  <h3>Books for Summer Reading:</h3>
  <ol class="tight">
    <li>
      <h3>A Philosophy of Software Design, John Ousterhout, Yaknyam Press, 2018</h3>
      <ul class="tight">
        <li>
          <strong>Why read?</strong><br />
          Very well written opinions about what makes good and bad software design.  I haven&apos;t
          finished the book yet, but I agree with most things the author says, so far, and commend
          the book to you.
        </li>
        <li>
          <strong>Required Time:</strong><br />
          One week of evenings.
        </li>
        <li>
          <strong>Selected Topics:</strong><br />
          The nature of complexity, Working code isn't enough, Modules should be deep, Information
          hiding (and leakage), General-purpose modules are deeper, Different layer, different abstraction,
          Pull complexity downwards, Better togeather or better apart?, Define errors out of existance,
          Design it twice, Comments should ....
        </li>
      </ul>
    </li>
    <li>
      <h3>Effective C++, Third Edition, Scott Meyers, Addison-Wesley, 2005</h3>
      <ul class="tight">
        <li>
          <strong>Why read?</strong><br />
          Very well written coverage of most of the essential language features discussed in CSE687-OOD.
          This is a nice review of a significant part of the course.
        </li>
        <li>
          <strong>Required Time:</strong><br />
          Two weeks of evenings.
        </li>
        <li>
          <strong>Selected Topics:</strong><br />
          Most of the things covered in the first ten lectures, excluding project design discussions.
        </li>
      </ul>
    </li>
    <li>
      <h3>Effective Modern C++, Scott Meyers, O'Reilly, 2014</h3>
      <ul class="tight">
        <li>
          <strong>Why read?</strong><br />
          Very well written coverage of most of the essential language features added to C++ in the
          standards: C++11, C++14, and C++17.
          This focuses on how the new standards have reshaped the language.
        </li>
        <li>
          <strong>Required Time:</strong><br />
          Three weeks of evenings.
        </li>
        <li>
          <strong>Selected Topics:</strong><br />
          Type deduction, initialization, aliases, smart pointers, move semantics and perfect forwarding,
          lambda expressions, and concurrency.
        </li>
      </ul>
    </li>
    <li>
      <h3>The Art of Readable Code, Boswell and Foucher, O'Reilly, 2012</h3>
      <ul class="tight">
        <li>
          <strong>Why read?</strong><br />
          This book offers very practical advice about writing code that has implications for design as well as implementation.
        </li>
        <li>
          <strong>Required Time:</strong><br />Two weeks of evenings.
        </li>
        <li>
          <strong>Topics:</strong><br />
          Code should be easy to understand, Packing information into names, Names that can't be misconstrued, Aesthetics, Knowing what to comment,
          Making comments precise and compact, Making control flow easy to read, breaking down giant expressions, variables and readability,
          extracting unrelated subproblems, One task at a time, turning thoughts into code, writing less code, testing and readability.
        </li>
      </ul>
    </li>
    <li>
      <h3>Implementation Patterns, Kent Beck, Addison-Wesley, 2008</h3>
      <ul class="tight">
        <li>
          <strong>Why read?</strong><br />
          This book offers very practical patterns for code implementation at the idiom and refactoring level.
        </li>
        <li>
          <strong>Required Time:</strong><br />Two weeks of evenings.
        </li>
        <li>
          <strong>Selected Topics:</strong><br />
          Communication, Simplicity, Flexibility, Local consequences, Minimize repetition, Logic and data together,
          Symmetry, Declarative expression, Rate of change, Class, Simple superclass name, Qualified subclass name,
          Abstract interface, Value Object, Specialization, Instance-specific behavior, Delegation,
          State, Access, Common state, Collecting parameter, Parameter object, Initialization,
          Control Flow, Message, Double dispatch, Exceptional flow, Guard clause, Composed method, Method object,
          Overridden method, Overloaded method, Helper method, Conversion, Creation, Query method, Safe copy,
          Collections, Evolving Frameworks, Performance measurement.
        </li>
      </ul>
    </li>
    <li>
      <h3>Writing with Style: Conversations on the Art of Writing (3rd Edition), John Trimble, Prentice-Hall, 2011</h3>
      <ul class="tight">
        <li>
          <strong>Why Read?</strong><br />
          This is a beautifully written, stylish, and easy to read manual on writing well.
        </li>
        <li>
          <strong>Required Time:</strong><br />
          You can read it in a week of evenings.
        </li>
        <li>
          <strong>Topics:</strong><br />
          Thinking well, Getting launched, Openers, Middles, Closers, Diction, Readability, Superstition, Critical Analysis, Dramatizing your ideas,
          Revising, Proofreadding, Punctuation, Quoting, Abbreviations, Tips on Usage, Epilogue.
        </li>
        <li>
          <strong>Note:</strong><br />
          This book is one of the best books for you to learn how to write software - even though it has noting to do with software.  The ideas
          and advice are very appropriate - Thinking well, Getting Launched, Readability, Critical Analysis, Revising, and Proofreading are
          particularly appropriate.
        </li>
      </ul>
    </li>
    <li>
      <h3>Probably Approximately Correct</h3>
      <ul class="tight">
        <li>
          <strong>Why read?</strong><br />
          Written by a Computer Scientist, this book looks at learning and evolution of Biological and Artificially Intelligent Systems.
        </li>
        <li>
          <strong>Required Time:</strong><br />
          Two or three weeks of evenings.
        </li>
        <li>
          <strong>Selected Topics:</strong><br />
          Ecorithms, Prediction and adaption, The computable, Mechanistic explanations of nature,
          The evolvable, The deductible, Humans as ecorithms, Machines as echorithms, Questions.
        </li>
      </ul>
    </li>
    <li>
      <h3>Secure Coding in C and C++, 2nd Edition, Robert Seacord, Addison-Wesley, 2013</h3>
      <ul class="tight">
        <li>
          <strong>Why Read?</strong><br />
          This is an important topic for all software professionals and one that my course sequence does not emphasize.
          I think it would be a really good idea to read this book, practice its methods, and take one or two of Dr. Du's
          security-based courses.
        </li>
        <li>
          <strong>Required Time:</strong><br />
          A summer of not so casual reading and probing.
        </li>
        <li>
          <strong>Topics:</strong><br />
          Gauging the threat, Security concepts, C and C++, Development platforms, Strings [this chapter is a comprehensive discussion of string types],
          Pointer subterfuge, Dynamic memory management, Integer security, Formatted output, Concurrency, File I/O, Recommended Practices.
        </li>
      </ul>
    </li>
    <li>
      <h3>Beautiful Architecture, Spinellis, Gousios, O'Reilly, 2009</h3>
      <ul class="tight">
        <li>
          <strong>Why Read?</strong><br />
          This book presents essays on Software Architecture.  Some are very interesting views into thoughts and processes you may not be
          exposed to anywhere else.
        </li>
        <li>
          <strong>Required Time:</strong><br />
          Half a Summer of evenings.
        </li>
        <li>
          <strong>Topics:</strong><br />
          What is Architecture?, A tale of two systems, Architecting for scale, Making memories, Resource-oriented architectures, Data grows up,
          Xen and the beauty of virtualization, Guardian: a fault-tolerant operating system environment, JPC: an x86 emulatore in pure java,
          The strength of metacircular virtual machines, GNU Emacs: creeping featurism is a strength, When the bazaar sets out to build cathedrals,
          Software architecture: object-oriented versus functional, Rereading the classics.
        </li>
      </ul>
    </li>
    <li>
      <h3>C++ Coding Standards, Sutter and Alexandrescu, Addison-Wesley, 2005</h3>
      <ul class="tight">
        <li>
          <strong>Why Read?</strong><br />
          This book presents guidelines for writing correct, robust, and flexible C++ by two of the best.
        </li>
        <li>
          <strong>Required Time:</strong><br />
          Half a Summer of evenings reading and testing ideas.
        </li>
        <li>
          <strong>Topics:</strong><br />
          Organizational and policy issues, Design style, Coding style, Functions and operators, Class design and inheritance,
          Construction, destruction, and copying, Namespaces and modules, Templates and genericity, Error handling and exceptions,
          STL containers, STL algorithms, Type safety.
        </li>
      </ul>
    </li>
    <li>
      <h3>CLR via C#, Fourth Edition, Jeffrey Richter, Microsoft Press</h3>
      <ul class="tight">
        <li>
          <strong>Why Read?</strong><br />
          If you want to know the foundations on which the .Net environment is built, this is an excellent place to acquire that knowledge.
        </li>
        <li>
          <strong>Required Time:</strong><br />
          A Summer of evenings if you've already taken CSE681 - Software Modeling and Analysis.
        </li>
        <li>
          <strong>Topics:</strong><br />
          CLR Basics: Execution model, Life cycle of applications and types, Shared assemblies<br />
          Designing Types:  Fundaments, primitive, reference, and value types, ...<br />
          Fundamental types: ...<br />
          Core Facilities: Exceptions, Managed heap, CLR hosting, Assembly loading and reflection, Runtime serialization, Interoperating with WinRT<br />
          Threading: Basics, Compute bound asynchronous operations, I/O bound asynchronous operations, Primitive synchronization, Hybrid synchronization.
        </li>
      </ul>
    </li>
    <li>
      <h3>Java Concurrency in Practice, Goetz, et. al., Addison-Wesley, 2006</h3>
      <ul class="tight">
        <li>
          <strong>Why Read?</strong><br />
          Discusses essential concurrency concepts in a clear, and very complete manner.  Much of the material is language agnostic.
        </li>
        <li>
          <strong>Required Time:</strong><br />
          A year of careful reading and experimenting, perhaps 8 hours per week.
        </li>
        <li>
          <strong>Selected Topics:</strong><br />
          Benefits of threads, Risks of threads, What is thread safety?, Atomicity, Locking, Guarding state with locks, Liveness and performance,
          Visibility, Publication and escape, Thread confinement, Immutability, Safe publication,
          Designing a thread-safe class, Instance confinement, Delegating thread safety, Adding functionality to existing thread-safe classes,
          Documenting synchronization policies, Synchronized collections, Concurrent collections, Blocking queues, Blocking and interruptable methods,
          Synchronizers, Building an efficient, scalable result cache,
          Executing tasks in threads, The executor framework, Finding exploitable parallelism, Task cancellation, Stopping a thread-based service,
          Handling abnormal thread termination, JVM shutdown,
          Implicit couplings between tasks and execution policies, Sizing thread pools, Configuring ThreadPoolExecutor, Parallelizing recursive algorithms,
          Why are GUIs single-threaded?, Short-running tasks, Long-running tasks, Shared data mode3ls, Other forms of single-threaded systems,
          Deadlock, Avoiding and diagnosing deadlocks, Other liveness hazards,
          Thinking about performance, Amdahl's law, Costs introduced by threads, Reducing lock contention,
          Testing for correctness, Testing for performance, Avoiding performance testing pitfalls, Complementary testing approaches.
        </li>
        <li>
          <strong>Note:</strong><br />
          There obviously is a lot of material here - more than you can digest in one Summer.  A sensible approach would take one quarter of the book
          each season and work on lots of probing examples as you go.
        </li>
      </ul>
    </li>
    <li>
      <h3>Artificial Intelligence, A Modern Approach, Third Edition, Russell and Novig, Prentice Hall, 2010</h3>
      <ul class="tight">
        <li>
          <strong>Why Read?</strong><br />
          Artificial Intelligence technology has been evolving for a long time, has had some significant successes and frustrations.  It appears
          that AI will play an increasing role in the development of systems in many areas and is likely to be important over the span of your
          careers.
        </li>
        <li>
          <strong>Required Time:</strong><br />
          A Summer and Fall of careful reading and testing ideas, perhaps 8 hours per week.
        </li>
        <li>
          <strong>Topics:</strong><br />
          Introduction, Intelligent agents, Solving problems by searching, Beyond classical search, Adversarial search, Constraint satisfaction,
          Logical agents, First-order logic, Inference in first-order logic, Classical planning, Planning and acting in the real world,
          Knowledge representation, Quantifying uncertainty, Probabilistic reasoning, Probabilistic reasoning over time, Making simple decisions,
          Making complex decisions, Learning from examples, Knowledge in learning, Learning probabilistic models, Reinforcement learning,
          Natural language processing, Natural language for communication, Perception, Robotics, Conclusions.
        </li>
        <li>
          <strong>Note:</strong><br />
          You aren't going to master AI in a summer reading of this book.  But doing a lunch-time seminar using this text for a half year with
          enough participants to spread the load would be a really good idea.  The idea is to learn about the concepts and know where to look
          for more details when you need them.
        </li>
      </ul>
    </li>
    <li>
      <h3>Other Books Worth Visiting:</h3>
      <ul class="tight">
        <li>The Developer's Code: What Real Programmers Do, Ka Wai Cheung, The Pragmatic Programmers, 2012</li>
        <li>Effective JavaScript, David Herman, Addison-Wesley, 2013</li>
        <li>Windows via C/C++, Richter and Nasarre, Microsoft Press, 2008</li>
      </ul>
    </li>
  </ol>
  <p>
    <img class="photo" src="Pictures/whittmanStrip.jpg" alt="Newhouse" width="98%" />
  </p>
  <info-bar></info-bar>
</body>
</html>