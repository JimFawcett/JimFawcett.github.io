<!DOCTYPE html>
<html>
<!--
  BasicBites_Tooling.html
-->
<head>
  <title>Help ChatGPT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeDefault.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrameHelp.js"></script>
  <script src="js/ScriptsPageFramePagesHelp.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <style>
    #github table {
      width: 90%;
      border: 1px solid var(--dark);
    }

    #github table tr {
      /* border: 1px solid var(--dark); */
    }

      /* #github table tr th {
        color: var(--dark);
        background-color: var(--menu);
      } */

      #github table tr th {
        color: var(--dark);
        background-color: var(--light);
        border:1px solid var(--dark);
      }

      #github table tr td {
        color: var(--dark);
        background-color: var(--light);
      }

      #github table a:link {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:visited {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:hover {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:active {
        color: var(--dark);
        background-color: transparent;
      }

    #github hr.dotted {
      border: none;
      border-top: 2px dashed var(--dark);
      color: var(--light);
      background-color: var(--light);
      height: 1px;
      width: 55em;
      margin-top: 0.5em;
      margin-bottom: 1.5em;
    }
  </style>
  <script>
    function loadif() {
      var loc = window.location.href;
      if (window.self === window.top) {
        window.location.href = 'TOC.html?src=' + loc;
      }
      else {
        window.top.location.href = loc;
      }
    }
  </script>
  <script>
    function toggleShow(id, width) {
      let showit = document.getElementById(id);
      if (showit) {
        if (showit.style.display === 'none') {
          showit.style.display = 'block';
          showit.firstElementChild.style.width = width + "px";
        }
        else {
          let d3 = showit.style.width;
          showit.firstElementChild.style.width = width + "px";
          showit.style.display = 'None';
          // location.reload();
        }
      }
      else {
        //alert('showit not defined');
      }
    }
    function bigger(img) {
      img.style.width = (img.clientWidth * 1.25) + "px";
    }
  </script>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="Help.html">Next</a>
  <a id="Prev" href="Help_RegEx.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about" onclick="this.style.display = 'none'">about</div>
      <div id="modified">11/03/2024</div>
      <div id="page">Help: ChatGPT</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <header>
          <hgroup id="pagetitle" onclick="loadif()" style="cursor:pointer;">
            <h1>Help: ChatGPT</h1>
            <h3 id="subtitle" class="indent">exploring code syntax and shell commands</h3>
          </hgroup>
          <div class="darkItem" style="position:relative; padding:0.25em 0em 0.75em 0em; margin-top:-0.15em; border:2px solid var(--dark);">
            <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--light); margin-left:1.5em;">About</a>
            <div style="font-size:0.9em; position:absolute; top:0.4em; right:2.5em;">click header to toggle Site Explorer</div>
          </div>
        </header>
        <div style="height:0.5em;"></div>
        <div class="indent">&quot;I hear and I forget. I see and I remember. I do and I understand.&quot;</div>
        <div class="inset">- Confucius, Chinese Philosopher (551-479 BCE)</div>
        <hr class="spread" />
        <!-- <div class="indent pad5">
          Some people, when confronted with a problem, think "I know, I'll use regular expressions."
          Now they have two problems.<br />
          - Jamie Zawinski
        </div> -->
        <div style="height:0.5em;"></div>
        <!-- <hr class="spread" /> -->
        <!-- <t-b style="margin:0.5em; padding:0.25em 0.5em 0.5em 0.5em; border:2px solid red; width: fit-content;">
          This Post is under construction: needs vetting of both code and text.
        </t-b> -->
        <a id="prologue"></a>
        <div style="height:1.0em;"></div>
        <div style="border:2px solid var(--dark); margin-top:-1.0em; width:max-content; max-width:65em; padding:0.5em 1.5em;">
          <h3 style="margin:0em;">Synopsis:</h3>
          <t-b>
            ChatGPT is an AI assistant, useful for code development. It is effective for:
            <ul class="tight">
              <li>
                Finding references and other help for special language syntax that may not be well documented.
              </li>
              <li>
                Listing commands and options for Windows Terminal, PowerShell terminal, and project managers
                for Rust (Cargo) and C# (dotnet CLI).
              </li>
              <li>
                Debugging small JavaScript functions and CSS styles.
              </li>
              <li>
                Creating JavaScript event handlers.
              </li>
              <li>
                Writing Regular Expressions based on informal text descriptions,
              </li>
            </ul>
          </t-b>
          <t-b>
            It is not, at this time (November 2024), very effective for: 
            <ul class="tight">
              <li>
                Laying out code structure except in small very specific scenarios.
              </li>
              <li>
                Consistently delivering trustworthy answers. It will occasionally confidently assert as true things that are demonstrably false.
              </li>
              <li>
                Writing flexible code. It often generates code that works only for the exact prompt specification when minor modification
                would make the code more broadly useful.
              </li>
              <li>
                Some of its generated code has missing dependencies so will not compile as-is.
              </li>
            </ul>
          </t-b>
          <t-b>
            I expect that ChatGPT might be useful for generating test cases for supplied code.  I have not investigated this yet.
          </t-b>
          <hr />
          <t-b>
            None of the codes or texts in this site have been generated by ChatGPT or other AI assistents. I have used ChatGPT frequently for 
            exploring code syntax and shell commands.
          </t-b>
        </div>
        <div style="height:1.5em;"></div>
        <h3 id="examples">1.0- ChatGPT use Examples</h3>
        <t-b>
          This section presents examples of using ChatGPT for developing scripts and exploring tools, finding details of language syntax 
          and exploring beginning to advanced language concepts.
        </t-b>
        <div>
          <h3>Table 1 - Examples of ChatGPT Assistances</h3>
          <t-b style="border:1px solid var(--dark); padding:0.25em 0.5em">
            Each row of the table below shows:
            <ul class="tight">
              <li style="font-size:1.15em; color:maroon;">
                Context of a question
              </li>
              <hr style="margin:0.5em 0em" />
              <li>
                Specific user Prompt for ChatGPT
              </li>
              <li>
                <details>
                  <summary class="darkItem">ChatGPT replies</summary>
                  contents of reply
                </details>
              </li>
            </ul>
            Note that most of the prompts are quite specific. Vague or open-ended prompts often yield weak answers.
          </t-b>
          <div style="height:0.5em;"></div>
          <table style="width:60em">
            <tr>
              <td class="darkItem" style="border: 2px solid var(--dark);"">
                <strong>Help with Scripts and Tools</strong>
              </td>
            </tr>
            <tr id="ps-script">
              <td>
                <t-b style="font-size:1.15em; color:maroon;">
                  Are there any links in my website that target unsecured sites?
                </t-b>
                <hr />
                <t-b>
                  ChatGPT Prompt: write a powershell script to find all "http://" strings in any 
                  html page in a directory subtree of the current folder
                </t-b>
                <details>
                  <summary class="darkItem">Find links to unsecured websites</summary>
                  <pre>
Here’s a PowerShell script that searches through all HTML files in a directory subtree from 
the current folder, looking for instances of `http://` strings:

```powershell
# Define the starting directory
$startDir = Get-Location

# Get all HTML files in the directory subtree
$htmlFiles = Get-ChildItem -Path $startDir -Recurse -Filter *.html

# Iterate through each HTML file
foreach ($file in $htmlFiles) {
    # Read the contents of the file
    $content = Get-Content -Path $file.FullName -Raw

    # Find all "http://" occurrences using a regular expression
    $matches = [regex]::Matches($content, 'http://\S+')

    # If matches are found, output them
    if ($matches.Count -gt 0) {
        Write-Output "Found in file: $($file.FullName)"
        foreach ($match in $matches) {
            Write-Output $match.Value
        }
        Write-Output "" # Add a blank line for separation
    }
}
```

### Explanation of the Script:
- `Get-Location`: Gets the current directory.
- `Get-ChildItem -Recurse -Filter *.html`: Recursively gets all HTML files in the directory
  and its subdirectories.
- `Get-Content -Raw`: Reads the entire content of each HTML file as a single string.
- `[regex]::Matches`: Uses a regular expression to search for `http://` followed by any 
  non-whitespace characters.
- The script outputs the file path and each matching `http://` string found.

### How to Use:
1. Save the script in a `.ps1` file, e.g., `FindHttpLinks.ps1`.
2. Open PowerShell and navigate to the directory where the script is saved.
3. Run the script using `.\FindHttpLinks.ps1`.

This script will output the file paths and `http://` strings found in the HTML files within the 
entire directory subtree.                    
                  </pre>
                </details>
              </td>
            </tr>
            <tr id="ips-script">
              <td>
                <t-b style="font-size:1.15em; color:maroon;">
                  The previous response was quite clear, but could be condensed using pipes. You can refine 
                  answers by follow-up questions. ChatGPT will remember the context.
                </t-b>
                <hr />
                <t-b>
                  ChatGPT Prompt: Repeat using PowerShell pipes
                </t-b>
                <details>
                  <summary class="darkItem">Make script more consise using pipes</summary>
                  <pre>
Here is a more concise version of the PowerShell script using pipes:

```powershell
# Use PowerShell pipes to streamline the script
Get-ChildItem -Recurse -Filter *.html | ForEach-Object {
    $content = Get-Content -Path $_.FullName -Raw
    [regex]::Matches($content, 'http://\S+') | ForEach-Object {
        Write-Output "Found in file: $($_.FullName)"
        Write-Output $_.Value
        Write-Output "" # Add a blank line for separation
    }
}
```

### Explanation:
- `Get-ChildItem -Recurse -Filter *.html`: Finds all HTML files recursively.
- `ForEach-Object`: Processes each HTML file found.
- `Get-Content -Raw`: Reads the entire content of each file as a single string.
- `[regex]::Matches`: Finds all occurrences of `http://`.
- The `ForEach-Object` loop then outputs each match along with the file name.

### How to Use:
1. Save the script as `FindHttpLinksPiped.ps1`.
2. Open PowerShell, navigate to the directory, and run the script:
   ```powershell
   .\FindHttpLinksPiped.ps1
   ```

This version leverages PowerShell’s pipeline to simplify the code while maintaining functionality.                    
                  </pre>
                </details>
              </td>
            </tr>
            <tr id="ex-script">
              <td>
                <t-b style="font-size:1.15em; color:maroon;">
                  ChatGPT didn&apos;t explain that PowerShell scripts will not run on a local machine
                  unless it has a policy setting to allow that.
                </t-b>
                <hr />
                <t-b>
                  ChatGPT Prompt: how do I enable running powershell scripts on my local computer
                </t-b>
                <details>
                  <summary class="darkItem">Enabling Script Execution</summary>
                  <pre>
To enable running PowerShell scripts on your computer, you need to change the PowerShell 
**execution policy**. The execution policy determines the conditions under which PowerShell 
loads configuration files and runs scripts. Here’s how you can enable script execution:

### Step 1: Open PowerShell with Administrative Privileges
1. Right-click the **Start** menu and select **Windows PowerShell (Admin)** or **Terminal (Admin)**.
2. Click **Yes** if a User Account Control (UAC) prompt appears.

### Step 2: Check the Current Execution Policy
Run the following command to check your current execution policy:

```powershell
Get-ExecutionPolicy
```

The result will show the current policy, which could be `Restricted` (scripts are not allowed), 
`RemoteSigned`, `AllSigned`, or another policy.

### Step 3: Set the Execution Policy
To enable running scripts, you can set the execution policy to `RemoteSigned` or `Unrestricted`:

- **RemoteSigned**: Requires that downloaded scripts are signed by a trusted publisher but allows 
  running local scripts without a signature.
- **Unrestricted**: Allows running all scripts, but will warn you before running scripts downloaded 
  from the internet.

```powershell
Set-ExecutionPolicy RemoteSigned
```

or

```powershell
Set-ExecutionPolicy Unrestricted
```

### Step 4: Confirm the Change
If prompted, type `Y` and press **Enter** to confirm the change.

### Step 5: Verify the Execution Policy
Run the following command again to ensure the policy has been changed:

```powershell
Get-ExecutionPolicy
```

### Important Notes
1. **Security Implications**: Setting the execution policy to `Unrestricted` can pose security risks, 
   especially if you run scripts from untrusted sources. `RemoteSigned` is generally safer and recommended 
   for most users.
2. **Policy Scope**: You can specify the scope of the policy (e.g., `CurrentUser`, `LocalMachine`) if 
   needed:
   ```powershell
   Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
   ```

### Execution Policy Options
- **Restricted**: No scripts can be run. PowerShell is limited to interactive commands only.
- **AllSigned**: Only scripts signed by a trusted publisher can be run.
- **RemoteSigned**: Scripts created locally can run, but downloaded scripts must be signed by a trusted 
  publisher.
- **Unrestricted**: No restrictions; all scripts can be run, but you’ll get a warning for downloaded 
  scripts.

Once you've set the appropriate policy, you should be able to run your PowerShell scripts.                    
                  </pre>
                </details>
              </td>
            </tr>
            <tr id="regex">
              <td>
                <t-b style="font-size:1.15em; color:maroon;">
                  This example shows that ChatGPT may return a response more nuanced than the original prompt.
                </t-b>
                <hr />
                <t-b>
                  ChatGPT Prompt: create a regular expression to detect all occurrences of a specified 
                  string in lines of a file
                </t-b>
                <details>
                  <summary class="darkItem">Help with Regular Expressions</summary>
                  <pre>
Here's how you can create a regular expression to detect all occurrences of a specified string
in lines of a file using a regular expression in Rust or a similar environment:

### General Regular Expression Pattern
To detect all occurrences of a specified string, use the following regular expression:

```regex
(?i)\bSPECIFIED_STRING\b
```

- `(?i)`: This makes the search case-insensitive. You can omit it if you want the search to be 
  case-sensitive.
- `\b`: Word boundaries to ensure you match the string as a whole word, not as a substring within 
  another word. You can remove `\b` if you want to match substrings.

### Example in Rust
Here's how you could use this in a Rust program to detect a specified string in lines of a file:

```rust
use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;
use regex::Regex;

fn main() -> io::Result<()> {
    // Specify the file path
    let path = "path/to/your/file.txt";
    let specified_string = "your_string"; // String to search for

    // Create a regular expression to detect the specified string
    let re = Regex::new(&format!(r"(?i)\b{}\b", regex::escape(specified_string)))
        .expect("Invalid regular expression");

    // Open the file and iterate through each line
    if let Ok(lines) = read_lines(path) {
        for line in lines {
            if let Ok(content) = line {
                // Check for matches and print the line if a match is found
                if re.is_match(&content) {
                    println!("Match found: {}", content);
                }
            }
        }
    }

    Ok(())
}

// Helper function to read lines from a file
fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
```

### Explanation
1. **Regex Library**: The `regex` crate is used for regular expression handling in Rust. Make sure 
   to add `regex = "1"` to your `Cargo.toml` dependencies.
2. **regex::escape**: This function escapes any special characters in `specified_string` to treat it 
   as a literal string in the regular expression.
3. **Reading Lines**: The `read_lines` function reads lines from the file one by one and checks if the 
   line contains the specified string using the regular expression.

### Notes
- **Adjust the Regex**: If you want to detect substrings instead of whole words, remove the `\b` word 
  boundaries from the regular expression.
- **Case Sensitivity**: To make the search case-sensitive, remove the `(?i)` part from the regular 
  expression.

This setup will help you detect and work with all occurrences of the specified string in lines of a file.                    
                  </pre>
                </details>
              </td>
            </tr>
            <tr id="vsc-plugin">
              <td>
                <t-b style="font-size:1.15em; color:maroon;">
                  ChatGPT can be quite useful for quickly finding ways to make a tool work more effectively. note 
                  that you may need to be quite specific with prompts, as shown below.
                </t-b>
                <hr />
                <t-b>
                  ChatGPT Prompt: Are there HTML plugins for VS Code that support wrapping selected text within an HTML element?
                </t-b>
                <details>
                  <summary class="darkItem">HTML plugins for wrapping selections</summary>
                  <pre>
Yes, Visual Studio Code (VS Code) offers several extensions that allow you to wrap
selected text within HTML elements. Here are some notable ones:

1. **htmltagwrap**: This extension enables you to wrap selected code with HTML tags. 
   After selecting the desired text, press `Alt + W` (or `Option + W` on Mac), type 
   the tag name, and the extension will insert the opening and closing tags 
   accordingly. 

2. **html tag wrapper**: With this extension, you can wrap selected HTML code by 
   pressing `Ctrl + I`. It also allows you to change the wrapper tag name as needed. 

3. **HTML WrapMagic**: This extension provides a command to wrap selected text with 
   an HTML tag. Use the keyboard shortcut `Ctrl + Shift + Z` (or `⇧ + ⌘ + Z` on macOS) 
   to activate it. 

4. **wrapper html**: This extension allows you to wrap selected HTML code with common 
   tags like `<div>`, `<section>`, or `<article>`. Select the code, press `Ctrl + 1` 
    (or `Cmd + 1` on macOS), and choose your desired tag from the options provided. 

Additionally, VS Code's built-in Emmet support offers a similar feature without the 
need for extensions:

1. **Emmet: Wrap with Abbreviation**: Select the text you want to wrap, open the 
   Command Palette (`Ctrl + Shift + P` or `Cmd + Shift + P` on macOS), type 
   "Emmet: Wrap with Abbreviation," and enter the desired tag or abbreviation. 
   This will wrap the selected text accordingly. 

These tools can enhance your HTML editing experience in VS Code by streamlining the 
process of wrapping text with HTML elements.                   
</pre>
                </details>
                <div style="height: 0.5em;"></div>
              </td>
            </tr>
            <tr>
              <td class="darkItem" style="border: 2px solid var(--dark);"">
                <strong>Help with Programming Languages</strong>
              </td>
            </tr>
            <tr id="typesys">
              <td>
                <t-b style="font-size:1.15em; color:maroon;">
                  ChatGPT can help developers new to Rust to quickly acquire basic knowledge.
                </t-b>
                <hr />
                <t-b>
                  ChatGPT Prompt: Describe the Rust type system
                </t-b>
                <details>
                  <summary class="darkItem">Rust type system</summary>
                  <pre>
The Rust type system is one of the most essential features that contribute to its safety and 
performance guarantees. Here’s an overview of its key components and concepts:

---

### 1. **Strongly Typed System**
Rust is a **strongly typed** language, which means that types are checked and enforced at compile 
time. The compiler ensures that operations on values are type-safe, preventing many classes of 
runtime errors.

- **Type Inference**: Rust has powerful type inference, meaning you don’t always need to specify types 
  explicitly. The compiler can often deduce types from the context, making code more concise while 
  still being type-safe.
- **Static Typing**: Rust's type system is static, meaning that all types are known at compile time. 
  This allows for extensive compiler optimizations and catching errors before the code runs.

---

### 2. **Primitive Types**
Rust includes a variety of **primitive types** that are directly supported by the language:
- **Scalar Types**:
  - **Integers**: `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`, and `usize`
  - **Floating-Point Numbers**: `f32`, `f64`
  - **Booleans**: `bool` (`true` or `false`)
  - **Characters**: `char` (a Unicode scalar value, represented in single quotes, e.g., `'a'`)
- **Compound Types**:
  - **Tuples**: Fixed-size collections of values with different types, e.g., `(i32, bool, f64)`
  - **Arrays**: Fixed-size collections of elements of the same type, e.g., `[i32; 5]`

---

### 3. **Complex Types**
- **Structs**: Custom data types that group multiple values, possibly of different types, into a single 
  entity. They come in three forms: `struct`, tuple structs, and unit structs.
- **Enums**: Define a type by enumerating its possible variants. Enums are powerful because each variant 
  can hold different data types and structures.
- **Unions**: A feature similar to enums but used for defining a type that can store different values at 
  the same memory location, often used in low-level programming.

---

### 4. **Ownership and Borrowing**
Rust's type system incorporates the concepts of **ownership**, **borrowing**, and **lifetimes**, which are 
integral to memory safety:
- **Ownership**: Each value in Rust has a unique owner, and when the owner goes out of scope, the value is 
  automatically deallocated.
- **Borrowing**: Allows references to a value without taking ownership. There are two types: immutable (`&T`) 
  and mutable (`&mut T`) references, with strict rules about how many references can exist at a time.
- **Lifetimes**: Help the compiler ensure that references are always valid. Lifetimes are often inferred but 
  can be explicitly specified when necessary.

---

### 5. **Generics**
Rust has a robust system for **generics**, which allows you to write code that works with any data type. 
Generics are parameterized types, making your code more flexible and reusable.

```rust
fn largest&lt;T: PartialOrd>(list: &[T]) -> &T { /* ... */ }
```

- **Traits**: Used to define shared behavior in Rust. They are similar to interfaces in other languages. 
  You can use traits to specify bounds on generics, constraining which types can be used.
- **Trait Objects**: Allow for dynamic dispatch, enabling polymorphism. You can use `dyn Trait` to create 
  objects that can be of different types as long as they implement a specific trait.

---

### 6. **Trait System**
- **Traits**: Define methods that can be implemented by types to share common behavior. You can implement 
  traits on your custom types or on standard types using Rust's `impl` syntax.
- **Associated Types**: A feature of traits that lets you define placeholder types within a trait, which 
  implementing types must specify.

```rust
trait Iterator {
    type Item;
    fn next(&mut self) -> Option&lt;Self::Item>;
}
```

---

### 7. **Pattern Matching**
Rust has a powerful **pattern matching** system, allowing you to destructure and work with complex data types 
like enums and tuples.

- `match` expressions provide exhaustive pattern matching, ensuring you cover all possible cases.
- **`if let` and `while let`**: Simplified constructs for matching specific patterns.

---

### 8. **Type Aliases and Newtypes**
- **Type Aliases**: Create alternative names for existing types for clarity.
- **Newtype Pattern**: A way to create distinct types from existing ones for better type safety.

```rust
type Kilometers = i32; // Type alias
struct MyInt(i32);     // Newtype pattern
```

---

### 9. **Smart Pointers**
Rust includes types like `Box&lt;T>`, `Rc&lt;T>`, and `RefCell&lt;T>` that enable more advanced memory management patterns:
- **Box&lt;T>**: A heap-allocated smart pointer.
- **Rc&lt;T>**: A reference-counted smart pointer for shared ownership.
- **RefCell&lt;T>**: Allows for interior mutability, breaking Rust’s default borrowing rules.

---

### 10. **Foreign Function Interface (FFI)**
Rust's type system includes support for calling functions written in other languages, such as C. This is done using 
`extern` blocks and ensures safe interoperation.

### Summary
The Rust type system is comprehensive and designed to ensure safety, performance, and concurrency. Its key features, 
such as ownership, borrowing, lifetimes, traits, and generics, make Rust both expressive and reliable for a wide range 
of applications, from system-level programming to high-level software development.                    
                  </pre>
                </details>
                <t-b>
                  ChatGPT Prompt: show how to implement a Rust type that holds a Vec&lt;T&gt; and supports indexing and iteration.
                </t-b>
                <details>
                  <summary class="darkItem">Implement Rust type</summary>
                <pre>
To implement a Rust type that holds a `Vec&lt;T>` and supports indexing and iteration, you can use 
the `Deref`, `Index`, and `IntoIterator` traits. Here’s how you can do it:

### Implementation Example

```rust
use std::ops::{Deref, Index};
use std::slice::Iter;

// Define a custom struct that holds a Vec&lt;T>
struct MyCollection&lt;T> {
    items: Vec&lt;T>,
}

// Implement Deref for MyCollection to easily access the Vec<T>
impl&lt;T> Deref for MyCollection&lt;T> {
    type Target = Vec&lt;T>;

    fn deref(&self) -> &Self::Target {
        &self.items
    }
}

// Implement Index for MyCollection to support indexing
impl&lt;T> Index&lt;usize> for MyCollection&lt;T> {
    type Output = T;

    fn index(&self, index: usize) -> &Self::Output {
        &self.items[index]
    }
}

// Implement IntoIterator for MyCollection to support iteration
impl&lt;T> IntoIterator for MyCollection&lt;T> {
    type Item = T;
    type IntoIter = std::vec::IntoIter&lt;T>;

    fn into_iter(self) -> Self::IntoIter {
        self.items.into_iter()
    }
}

// Implement a method to get an iterator over references
impl&lt;T> MyCollection&lt;T> {
    fn iter(&self) -> Iter&lt;T> {
        self.items.iter()
    }
}

// Example usage
fn main() {
    let my_collection = MyCollection {
        items: vec![1, 2, 3, 4, 5],
    };

    // Indexing
    println!("Item at index 2: {}", my_collection[2]);

    // Iteration by value
    for item in my_collection {
        println!("Item: {}", item);
    }

    // Re-create MyCollection for iteration by reference
    let my_collection = MyCollection {
        items: vec![10, 20, 30, 40, 50],
    };

    // Iteration by reference
    for item in my_collection.iter() {
        println!("Item by reference: {}", item);
    }
}
```

### Explanation
1. **Struct Definition**:
   - `MyCollection&lt;T>` is a generic struct that wraps a `Vec&lt;T>`.

2. **Deref Trait**:
   - Implementing the `Deref` trait allows you to treat `MyCollection&lt;T>` as if it were a `Vec&lt;T>`. 
     This simplifies accessing the internal vector.

3. **Index Trait**:
   - The `Index` trait allows for indexing into `MyCollection` using the `[]` syntax. It makes 
     `my_collection[2]` work just like it does for a `Vec&lt;T>`.

4. **IntoIterator Trait**:
   - Implementing `IntoIterator` allows the struct to be used in a `for` loop, consuming the 
     collection and iterating over the items by value.
   
5. **Custom Iterator Method**:
   - `iter()` returns an iterator over references to the items in `Vec&lt;T>`. This allows iteration 
      without consuming the collection.

### Usage
- **Indexing**: `my_collection[2]` accesses the third element in the vector.
- **Iteration by Value**: The `for item in my_collection` loop consumes the collection, iterating 
  over each element.
- **Iteration by Reference**: `my_collection.iter()` provides a way to iterate over the collection 
  without consuming it.

This design provides convenient ways to access and traverse the data stored in `MyCollection<T>`.                  
                </pre>
                </details>
              </td>
            </tr>
            <tr id="type-refs">
              <td>
                <t-b style="font-size:1.15em; color:maroon;">
                  AI assistents, like ChatGPT, can provide targeted supplementary references.
                </t-b>
                <hr />
                <t-b>
                  ChatGPT Prompt: list references for previous type implementation
                </t-b>
                <details>
                  <summary class="darkItem">References for creating types</summary>
                  <pre>
Here are some useful references that explain the concepts used in implementing a custom Rust type that 
holds a `Vec&lt;T>` and supports indexing and iteration:

### 1. **Rust Standard Library Documentation**
- **Vec**: Learn about the `Vec` type, its methods, and how it works.
  - [Vec Documentation](https://doc.rust-lang.org/std/vec/struct.Vec.html)
- **Deref Trait**: Understand how the `Deref` trait works and why it’s useful for accessing the internal 
  data of a custom type.
  - [Deref Documentation](https://doc.rust-lang.org/std/ops/trait.Deref.html)
- **Index Trait**: Learn about implementing the `Index` trait to enable indexing with the `[]` syntax.
  - [Index Documentation](https://doc.rust-lang.org/std/ops/trait.Index.html)
- **IntoIterator Trait**: Understand how to make your custom type iterable in a `for` loop.
  - [IntoIterator Documentation](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)
- **slice::Iter**: Documentation on the iterator returned by `Vec::iter()`, which is used for iterating 
  over references.
  - [slice::Iter Documentation](https://doc.rust-lang.org/std/slice/struct.Iter.html)

### 2. **The Rust Programming Language (The Book)**
- **Chapter 15: Smart Pointers**: Covers the `Deref` trait in detail and explains how it can be used for 
  types like `Box&lt;T>`.
  - [The Rust Book: Smart Pointers](https://doc.rust-lang.org/book/ch15-02-deref.html)
- **Chapter 8: Common Collections**: Discusses `Vec` and other collection types.
  - [The Rust Book: Common Collections](https://doc.rust-lang.org/book/ch08-01-vectors.html)
- **Chapter 13: Iterators and Closures**: Provides an in-depth explanation of how iterators work in Rust.
  - [The Rust Book: Iterators](https://doc.rust-lang.org/book/ch13-02-iterators.html)

### 3. **Rust By Example**
- **Deref and Index Traits**: Examples of how to implement the `Deref` and `Index` traits for custom types.
  - [Rust By Example: Deref](https://doc.rust-lang.org/rust-by-example/trait/deref.html)
  - [Rust By Example: Index](https://doc.rust-lang.org/rust-by-example/trait/index.html)
- **Iterators**: Explains how to implement custom iterators for structs.
  - [Rust By Example: Iterators](https://doc.rust-lang.org/rust-by-example/trait/iter.html)

### 4. **Rust API Guidelines**
- **C-ITER: Iterators**: Guidelines on implementing iterators for your custom types.
  - [Rust API Guidelines: Iterators]
    (https://rust-lang.github.io/api-guidelines/interoperability.html#c-iter-iterators)

### 5. **Rust Playground**
- **Rust Playground**: A web-based environment where you can experiment with the implementation and test 
  your code.
  - [Rust Playground](https://play.rust-lang.org/)

These references provide detailed information and examples on how to implement and use traits like `Deref`, 
`Index`, and `IntoIterator` effectively in Rust. They will help deepen your understanding and refine your 
implementations.                    
                  </pre>
                </details>
              </td>
            </tr>
            <tr id="inter-mut">
              <td>
                <t-b style="font-size:1.15em; color:maroon;">
                  Questions like the one below can help a developer become more adept with the Rust programming language.
                </t-b>
                <hr />
                <t-b>
                  ChatGPT Prompt: Explain Rust's interior mutability
                </t-b>
                <details>
                  <summary class="darkItem">Interior Mutability</summary>
                  <pre>
**Interior Mutability** in Rust is a design pattern that allows you to mutate data even 
when there are immutable references to that data. It’s a way of working around Rust’s 
default rule that you can’t change data through an immutable reference. Rust enforces 
these rules to ensure thread and memory safety, but there are situations where safe mutation 
of data is needed even through an immutable reference. 

### How Interior Mutability Works
Interior mutability is achieved through special types provided by the standard library, 
such as:
- `RefCell<T>`
- `Mutex<T>`
- `RwLock<T>`
- `Atomic*` types
- `UnsafeCell<T>` (the foundation of interior mutability)

The most common type for interior mutability is `RefCell<T>`. It allows mutable borrowing at 
runtime, even when the `RefCell<T>` itself is not mutable.

### Key Concepts
1. **Borrowing Rules Relaxation**:
   - Rust normally enforces strict borrowing rules: you can have either one mutable reference 
     or multiple immutable references to a piece of data, but not both.
   - `RefCell<T>` allows you to relax these rules for runtime-checked borrowing. Instead of 
     enforcing borrow rules at compile time, `RefCell` checks these rules at runtime.

2. **Runtime Checks**:
   - With `RefCell<T>`, Rust checks borrowing rules dynamically. If you try to borrow mutably 
     when there’s already a mutable or immutable borrow, it will panic at runtime.
   - This is different from compile-time checks, where the violation of borrowing rules results 
     in a compile-time error.

### Example with `RefCell<T>`

```rust
use std::cell::RefCell;

struct MyStruct {
    data: RefCell<i32>,
}

fn main() {
    let my_struct = MyStruct { data: RefCell::new(5) };

    // Borrow the data immutably
    let value = my_struct.data.borrow();
    println!("Value: {}", *value); // Output: Value: 5
    // value goes out of scope here

    // Mutably borrow the data
    let mut value_mut = my_struct.data.borrow_mut();
    *value_mut += 1;
    println!("Mutated Value: {}", *value_mut); // Output: Mutated Value: 6
    // value_mut goes out of scope here
}
```

### Interior Mutability Patterns

1. **RefCell<T>**:
   - `RefCell<T>` is used when you need to mutate data but only have an immutable reference 
     to it.
   - It provides two methods: `borrow()` for immutable borrowing and `borrow_mut()` for 
     mutable borrowing.
   - These methods enforce Rust’s borrowing rules at runtime and will panic if the rules 
     are violated.

2. **Mutex<T> and RwLock<T>**:
   - These types provide thread-safe interior mutability for use in concurrent scenarios.
   - `Mutex<T>` allows you to safely mutate data across threads but only one thread can 
     lock the data for mutation at a time.
   - `RwLock<T>` provides more granular control, allowing multiple readers or one writer.

3. **UnsafeCell<T>**:
   - `UnsafeCell<T>` is the lowest-level type for interior mutability and is the building 
     block for other interior mutability types.
   - It is marked as `unsafe` and is usually used when implementing custom interior mutability 
     patterns.

### Why Use Interior Mutability?
- **Cell and RefCell** are useful for cases where the ownership and mutability rules are too 
  strict to fit a design pattern you’re working with but where mutation is still necessary.
- It’s often used in scenarios involving:
  - Caching mechanisms
  - Single-threaded contexts where mutation needs to be controlled at runtime
  - Graph structures where nodes may have cyclic references
  
### Trade-offs and Considerations
1. **Performance Overhead**:
   - `RefCell` introduces runtime checks, which can have a slight performance cost compared 
     to compile-time checks.
2. **Runtime Panics**:
   - Violating borrowing rules with `RefCell` will cause your program to panic at runtime, 
     so you need to be careful.
3. **Single-threaded Use**:
   - `RefCell<T>` is not thread-safe and should only be used in single-threaded contexts. For 
     multithreaded scenarios, use types like `Mutex<T>`.

### Summary
- Interior mutability is a powerful concept in Rust that allows you to modify data even when 
  references to it are immutable, by using types like `RefCell<T>`.
- It bypasses compile-time borrowing checks and enforces them at runtime.
- Use interior mutability when you need more flexibility than Rust’s strict ownership and borrowing 
  rules typically allow, but be mindful of the trade-offs, especially potential runtime panics.                    
                  </pre>
                </details>
              </td>
            </tr>
            <tr id="impl-trait">
              <td>
                <t-b style="font-size:1.15em; color:maroon;">
                  ChatGPT AI assistant can help by explaining advanced concepts.
                </t-b>
                <hr />
                <t-b>
                  ChatGPT Prompt: Explain the difference between returning an instance of a generic type bounded by
                  Trait MyTrait and returning impl MyTrait.
                </t-b>
                <details>
                  <summary class="darkItem">Return instance of generic type vs impl Trait</summary>
                  <pre>
The difference between returning an instance of a generic type bounded by a trait and 
returning `impl MyTrait` lies in how flexibility and type inference are handled in Rust.

### 1. **Returning a Generic Type Bounded by a Trait**
When you use generics bounded by a trait, you define the function like this:

```rust
fn example&lt;T: MyTrait>(value: T) -> T {
    // do something
    value
}
```

- **Flexibility**: This approach is more flexible. The caller can specify the concrete type 
  they want, as long as it implements `MyTrait`. The function is generic and can return any 
  type that implements the `MyTrait` trait.
- **Monomorphization**: At compile time, the Rust compiler generates different versions of the
  function for each type `T` used. This can increase the binary size if many different types 
  are used but can also provide optimized code for each specific type.

### 2. **Returning `impl MyTrait`**
When you use `impl MyTrait`, you define the function like this:

```rust
fn example() -> impl MyTrait {
    // return a specific type that implements MyTrait
}
```

- **Simplifies the API**: This approach simplifies the API for the caller. The caller does not 
  need to know or specify the exact type being returned, just that it implements `MyTrait`.
- **Type Opaqueness**: The exact type returned is hidden from the caller. The function decides 
  the concrete type internally, and the caller only knows that it implements `MyTrait`. This 
  can be useful for abstraction, hiding implementation details, or when you don’t want to expose 
  the underlying type.
- **Single Concrete Type**: The function must always return the same concrete type. You cannot 
  dynamically decide to return different types that implement `MyTrait`. All control over the 
  returned type remains with the function.

### **Key Differences**
1. **Type Flexibility**: 
   - Generics allow for multiple types to be returned (as long as they satisfy the trait bounds).
   - `impl MyTrait` always returns the same concrete type.

2. **Ease of Use**:
   - Generics may require more type annotations from the caller.
   - `impl MyTrait` simplifies the interface but limits flexibility.

3. **Use Cases**:
   - Use generics when you need flexibility and want to allow the caller to specify different 
     concrete types.
   - Use `impl MyTrait` when you want to hide the implementation details or simplify the function's 
     return type for the caller.

### **Example Comparison**
```rust
// Using generics
fn get_generic_item&lt;T: MyTrait>(item: T) -> T {
    item
}

// Using `impl MyTrait`
fn get_item() -> impl MyTrait {
    // Return a specific type, e.g., MyStruct, which implements MyTrait
    MyStruct {}
}
```

- **get_generic_item** can return any type `T` that implements `MyTrait`, depending on what the 
  caller provides.
- **get_item** always returns `MyStruct` or whatever concrete type is defined internally.

### Summary
- Use **generic types bounded by a trait** for flexibility and when multiple concrete types need 
  to be supported.
- Use **`impl MyTrait`** for abstraction, simplicity, and when only one concrete type needs to be 
  returned, while hiding the exact type from the caller.                    
                  </pre>
                </details>
              </td>
            </tr>
            <tr id="impl-refs">
              <td>
                <t-b style="font-size:1.15em; color:maroon;">
                  You can get more information from references supplied by ChatGPT.
                </t-b>
                <hr />
                <t-b>
                  ChatGPT Prompt: suggest references for functions that return impl objects
                </t-b>
                <details>
                  <summary class="darkItem">References for returning impl objects</summary>
                  <pre>
Here are some recommended references for understanding functions returning `impl Trait` in Rust:

1. **The Rust Programming Language (The Book) - Chapter on Traits**:
   - The official Rust book has a section on `impl Trait` that explains the concept in detail, 
     including use cases for returning `impl Trait` in functions.
   - [The Rust Book: Traits](https://doc.rust-lang.org/book/ch10-02-traits.html)

2. **Rust By Example - `impl Trait`**:
   - This resource provides concise, example-driven explanations of how and when to use `impl Trait`.
   - [Rust By Example: `impl Trait`](https://doc.rust-lang.org/rust-by-example/fn/impl_trait.html)

3. **Rust Language Reference - `impl Trait`**:
   - The Rust Language Reference gives an in-depth, formal explanation of `impl Trait` syntax and 
     semantics.
   - [Rust Reference: `impl Trait`](https://doc.rust-lang.org/reference/types/impl-trait.html)

4. **Rust Blog Posts and RFCs**:
   - **Blog Post**: "Returning Traits in Rust: `impl Trait`" - Offers a practical guide on when to use 
     `impl Trait` and the benefits of doing so.
   - **RFC 1522**: Discusses the introduction of `impl Trait` in more detail, useful for understanding 
     the design decisions behind it.
   - [RFC 1522: `impl Trait`]
     (https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md)

5. **Crust of Rust - YouTube Series by Jon Gjengset**:
   - Jon Gjengset’s videos are an excellent way to learn advanced Rust concepts. He has an episode 
     specifically on traits and `impl Trait`.
   - [Crust of Rust - Traits and Generics](https://www.youtube.com/c/JonGjengset)

6. **Stack Overflow and Rust Users Forum**:
   - These are great platforms to see practical examples and discuss nuances with the Rust community.
   - [Stack Overflow: `impl Trait`](https://stackoverflow.com/questions/tagged/rust)
   - [Rust Users Forum](https://users.rust-lang.org/)

These references should provide a comprehensive understanding of functions that return `impl Trait` in 
Rust, complete with examples and practical use cases.                    
                  </pre>
                </details>
                <div style="height:0.5em;"></div>
              </td>
            </tr>
          </table>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="learning">2.0 - Learning a Programming Language</h3>
        <t-b>
          Combining an <a target="_blank" href="https://doc.rust-lang.org/stable/book/">introductory book</a>, an online
          <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021">code editor/translator</a>, 
          and <a target="_blank" href="https://openai.com/chatgpt/overview/">ChatGPT</a> can be a very effective way to begin learning
          a new language like Rust.
        </t-b>
        <t-b>
          <ul>
            <li>
              Read a chapter
            </li>
            <li>
              Run its examples online and edit them and rerun to see the changes 
            </li>
            <li>
              Prompt ChatGPT to provide information about any topic that isn't clear
            </li>
            <li>
              Ask ChatGPT to suggest variations on the code you are writing 
              <div class="inset">
                You can copy small pieces of code to the clipboard, write a prompt request
                and paste code below the prompt (hold shift key and press enter to get a new line).
              </div>
              This often produces interesting results
            </li>
          </ul>
        </t-b>
        <t-b>
          ChatGPT explains how to use ChatGPT to learn Rust:
        </t-b>
        <table style="width:60em;">
          <tr>
            <td>
              <t-b style="font-size:1.15em; color:maroon;">
                Use ChatGPT to learn how to use a programming language
              </t-b>
              <hr />
              <t-b>
                ChatGPT Prompt: how to best use ChatGPT to learn Rust
              </t-b>
              <details>
                <summary class="darkItem">Using ChatGPT to learn Rust</summary>
                <pre>
To make the best use of ChatGPT while learning Rust, consider the following strategies:

### 1. **Ask for Clarifications and Explanations**
- Use ChatGPT to clarify difficult concepts, like **ownership**, **borrowing**, **lifetimes**, 
  and **traits**. You can request simple or more in-depth explanations as needed.
- Ask for examples to understand concepts better. For instance, if you’re learning about 
  **pattern matching**, request practical examples.

### 2. **Code Examples and Snippets**
- Request code snippets for concepts you’re learning. For example, “Show me how to implement 
  an iterator in Rust” or “Give me an example of how to use `match` with enums.”
- You can also ask for the code to be explained step by step, which will help you understand 
  the logic and syntax.

### 3. **Debugging Assistance**
- If you’re stuck with an error, describe the error message and share your code. ChatGPT can help 
  you identify issues and suggest fixes.
- You can ask for advice on best practices and how to refactor your code for better readability 
  or efficiency.

### 4. **Learning Projects and Challenges**
- Request simple project ideas to practice your skills, like building a **simple calculator** or 
  a **basic web scraper** using Rust.
- You can also ask for guidance on how to structure a project, write a specific function, or design 
  an API in Rust.

### 5. **Understanding the Standard Library**
- Ask for explanations and examples of how to use specific parts of the Rust standard library, like 
  **`Vec<T>`**, **`HashMap<K, V>`**, or **`Result<T, E>`**.
- Inquire about when and why to use certain data structures or standard library features.

### 6. **Practice with Rust Tools**
- Request information on how to use tools like **Cargo** (Rust’s package manager) or **Rustfmt** for 
  code formatting.
- You can also ask for tips on using **Clippy** to improve your code and learn idiomatic Rust.

### 7. **Review and Understand Rust Documentation**
- ChatGPT can guide you through the official Rust documentation and help explain terms and code examples 
  you don’t understand.
- Ask for summaries of chapters from **The Rust Programming Language** book or key takeaways from 
  **Rust By Example**.

### 8. **Testing Your Knowledge**
- Quiz yourself by asking ChatGPT to create Rust-related questions or challenges for you to solve.
- You can also write code and then ask ChatGPT to review or critique it.

### 9. **Rust Programming Exercises**
- Request practice exercises based on your current knowledge level. For example, “Give me beginner-friendly 
  exercises for practicing ownership and borrowing.”
- You can gradually move on to more complex topics like **concurrency**, **asynchronous programming**, or 
  **smart pointers**.

### 10. **Deep Dive into Advanced Concepts**
- Once you’re more comfortable, ask for explanations and examples of advanced concepts like **lifetimes in structs**, 
  **async/await**, **FFI (Foreign Function Interface)**, or **writing macros in Rust**.

**Remember**: Learning a language like Rust takes time, so be patient and use ChatGPT as a companion to guide you 
and provide support when needed. Happy coding!                
                </pre>
              </details>
            </td>
          </tr>
        </table>
        <div style="height:0.75em;"></div>
        <h3 id="adv-learning">3.0 - Mastering more advanced concepts</h3>
        <t-b>
          The Examples in Table 1 show that this same process works well for more
          advanced topics.
        </t-b>
        <t-b>
          After five years of writing Rust code I still find this to be a productive way
          of looking for lightly documented syntax or dig into ideas that I haven&apos;t explored before.
        </t-b>
        <t-b>
          ChatGPT was first released to the public on November 30, 2022.  So it was not available when I first starting
          learning Rust in 2019, but had it been I think
          that process would have been 
          more productive.
        </t-b>
        <div style="height:0.75em;"></div>
        <h3 id="cgpt-refs">4.0 - References</h3>
        <t-b>
          <h3>Table 2 - Annotated References</h3>
        </t-b>
        <table style="table-layout: fixed; width:60em;">
          <tr>
            <th class="darkItem" style="width:8em; border:2px solid var(--dark);">Link</th>
            <th class="darkItem" style="width:35em; border:2px solid var(--dark);">Comments</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://openai.com/chatgpt/overview/">getting started</a>
            </td>
            <td>
              If you click on start now button you will be able to try ChatGPT basic model. You can download an app for your phone,
              but using ChatGPT in a browser works well for me.
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://openai.com/chatgpt/pricing/">subscribing</a>
            </td>
            <td>
              You can use ChatGPT for free, getting access to a basic model with chat only functionality. If you subscribe
              the current rate is $20/month. That gives you access to more capable models, voice interaction, and creation 
              of images.
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://chatgpt.com/gpts">Custom gpts</a>
            </td>
            <td>
              Custom gpts for writing, coding, creating diagrams, ..., many from other sites that use ChatGPT.
              <div style="height: 0.5em;"></div>
            </td>
          </tr>
        </table>
        <div style="height:4em;"></div>
        <a id="bottom"></a>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <sec-elem style="width:0.0em">&nbsp;</sec-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#cgpt-refs">ChatGPT refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#adv-learning">learning advd matl</a></menu-elem>
        <menu-elem class="secElem"><a href="#learning">Basic learning</a></menu-elem>
        <menu-elem class="secElem"><a href="#impl-refs">impl trait refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#impl-trait">impl trait</a></menu-elem>
        <menu-elem class="secElem"><a href="#inter-mut">interior mutability</a></menu-elem>
        <menu-elem class="secElem"><a href="#type-refs">Type References</a></menu-elem>
        <menu-elem class="secElem"><a href="#typesys">Rust type system</a></menu-elem>
        <menu-elem class="secElem"><a href="#vsc-plugin">vsc plugin</a></menu-elem>
        <menu-elem class="secElem"><a href="#regex">reg expressions</a></menu-elem>
        <menu-elem class="secElem"><a href="#ex-script">execute ps-script</a></menu-elem>
        <menu-elem class="secElem"><a href="#ips-script">improved ps-script</a></menu-elem>
        <menu-elem class="secElem"><a href="#ps-script">ps-script</a></menu-elem>
        <menu-elem class="secElem"><a href="#examples">Examples</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
        <div class='darkItem popupHeader' style="padding:0.25em 2.0em;" onclick="this.parentElement.style.display='none'">Sections</div>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:2.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:1em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn + ": ";
  </script>
</body>
</html>