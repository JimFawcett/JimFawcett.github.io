<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppModels.htm
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Syracuse University
  -->
  <title>C++ Models</title>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 0.5fr;
      grid-column-gap: 0em;
      padding: 0px;
    }

    .item1 {
      grid-column: 1;
      padding: 0px;
    }

    .item2 {
      grid-column: 2;
      padding: 0px;
    }

    .border {
      border: 1px solid black;
      padding-bottom: 10px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>
  <a id="Next" href="CppStory_Survey.html">N</a>
  <a id="Prev" href="CppStory_Prologue.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #1 - C++ Models</h1>
      <h3 id="subtitle">Structure, compilation, exectution, memory storage, classes, templates</h3>
    </hgroup>
  </header>

  <toc-b id="toc">
    <div style="display:flex; flex-direction:row">
      <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
      <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
      <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
    </div>
    <up-b id="chaps" onmouseout="storyMenu.chaps()">
      <a href="CppStory_Prologue.html">Prologue</a><br />
      <a href="CppStory_Models.html">Models</a><br />
      <a href="CppStory_Survey.html">Survey</a><br />
      <a href="CppStory_Data.html">Data</a><br />
      <a href="CppStory_Operations.html">Operations</a><br />
      <a href="CppStory_Classes.html">Classes</a><br />
      <a href="CppStory_ClassRelationships.html">ClassRel</a><br />
      <a href="CppStory_Templates.html">Templates</a><br />
      <a href="CppStory_TemplateMetaprog.html">TMP</a><br />
      <a href="CppStory_Libraries.html">Libraries</a><br />
      <a href="CppStory_LibraryStreams.html">Streams Libraries</a><br />
      <a href="CppStory_LibrarySTL.html">STL Libraries</a><br />
      <a href="CppStory_Interesting.html">Interesting</a>
    </up-b>
    <rt-b id="sects">
      <a href="#top">Top</a>, <a href="#compil">Compile</a>, <a href="#execute">Execute</a>, 
      <a href="#memory">Memory</a>, <a href="#class">Class</a>, <a href="#objmodel">ObjModel</a>, 
      <a href="#templ">Templates</a>, 
      <a href="#epilog">Epilogue</a>, <a href="#refs">Refs</a>
    </rt-b>
  </toc-b>

  <hr class="spread" />
  <indent-blocks class="bb-55">
    <t-b>
      Like many modern languages, C++ is a large and ambitious language. The purpose of this chapter is
      to help you develop effective mental models for important features of the language. We do this with
      diagrams and associated text, and occasionally small code fragments.
    </t-b>
    <t-b>
      You will find details, with a lot more code, in succeeding chapters where we focus on data, 
      operations, classes, and templates.
    </t-b>
    <a id="struct"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.1</num-item1><num-item4>Code Structure:</num-item4>
    </num-cont>
    <indent-blocks>
      <t-b>
        C++ developers structure code with <span class="notices">packages</span> which contain
        <span class="notices">files</span>, which in turn, contain <span class="notices">classes</span>
        and <span class="notices">functions</span>. 
      </t-b>
      <t-b>
        <span class="notice">Package</span> boundaries are not enforced by the C++
        language nor by the platform operating system.  They are an abstraction that represents a unit
        of documentation, and are expected to take on a single responsibility. So they are defined by
        the C++ developer.  It is common practice for each C++ package to contain a single .cpp
        implementation file and usually a single .h header file of the same name, e.g., MyPkg.h and
        MyPkg.cpp.  To that a developer may choose to add an interface file, IMyPkg.h.
      </t-b>
      <t-b>
        Packages for components with no parents may only have a single .cpp file, and we sometimes
        elect to make an interface file, IPkg.h, a separate package with just that one file.  We do
        that when more than one other package has a class that implements the interface.
      </t-b>
      <t-b>
        <span class="notice">Files</span> are an operating system construct.  Code files are expected, by the C++ build environment,
        to obey naming conventions, based on extensions like .h, .hpp, and .cpp that define their
        contents. Files may contain zero or more classes and zero or more unbound functions.  C++ does
        not enforce one class per file, but language convention dictates only a few closely related
        classes per file, very often only one.
      </t-b>
      <t-b>
        <span class="notice">Classes</span> are a C++ language construct (also used by many other languages) 
        that define units of managed data. <span class="notice">Functions</span> and 
        <span class="notice">class methods</span> are units of computation. Classes are expected to
        have a single responsibility and each of their methods contributes to one specific part of
        that responsibility.
      </t-b>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Code Structure Details</summary>
          <div style="width:calc(100vw - 6rem);">
            <photosizer-block src="Pictures/CppModel_CodeFiles.jpg" width="700" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 1. C++ File Inclusion Model
              </span>
            </photosizer-block>
          </div>
          <t-b>
            Each C++ implementation file, one with the extension .cpp, usually includes several header
            files, ones with .h extension, and C++ libraries, like <c-s>&lt;iostream&gt;</c-s> with no extension. 
            Figure 1. below shows
            Executive.cpp including an interface header file, IComponent_A.h, and Component_B.h header
            file.
          </t-b>
          <t-b>
            When a C++ project is built, a single compiler source file is created by the compiler preprocessor
            from a single .cpp file and all of the header files it includes.  That is compiled and if no
            errors are encountered, it generates an object file, .obj, or library, .lib. If 
            there are any more .cpp files in the project, the process is repeated until all .cpp files have
            been compiled.
          </t-b>
          <t-b>
            When the Files of Figure 1. are compiled there are three passes by the compiler for each of
            the three .cpp files, generating three .obj or lib files, which are then linked together to
            form an execution image, Executive.exe.
          </t-b>
          <t-b class="clear" style="width:calc(100vw - 6rem);">
            <!--<defn-outerBlock>-->
            <photosizer-block src="Pictures/CppModel_CodePkgs.jpg" width="400" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 2. Package Diagram
              </span>
            </photosizer-block>
          </t-b>
          <t-b>
            In Figure 2., we show a package structure that contains the files from Figure 1. The Executive
            package makes calls to functions it both Component_A and Component_B.  Also, Component_B makes
            a call on Component_A.
          </t-b>
          <t-b>
            Because of these calling relationships, the Executive needs type information about both
            components and Component_B needs type information about Component_A. That type information
            comes from including headers in each .cpp file.
          </t-b>
          <t-b>
            Component_A provides an interface, IComponent_A.h, which describes the calling signatures
            of all its public methods, but does not include any implementation detail.  It servers as
            a contract for services that Component_A exports. If it also supplies an object factory,
            callers, like Executive and Component_B, have no dependencies on Component_A&apos;s
            implementation, and changes to that component will not affect the using code from
            compiling correctly, as long as the interface and object factory signature did not change.
          </t-b>
          <t-b class="clear" style="width:calc(100vw - 6rem);">
            <photosizer-block src="Pictures/CppModel_CodeClasses.jpg" width="400" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 3. C++ Class Diagram
              </span>
            </photosizer-block>
            <!--</defn-outerBlock>-->
          </t-b>
          <t-b>
            Looking inward, we see in Figure 3. the classes that each package contains. The Executive package
            has a single class, Executive. Component_A has two classes, the interface IComponent_A<sup>1</sup>
            and class Component_A. Finally, Component_B contains class Component_B and a subordinate class 
            Helper.
          </t-b>
          <t-b>
            The Executive composes Component_B and aggregates IComponent_A. Component_A inherits from its
            interface IComponent_A. Component_B composes its helper class an uses the IComponent_A interface.
            Note that Executive and Component_B both actually bind to an instance of Component_A, but they
            have to use the contract provided by IComponent_A.  That&apos;s why we show then linking to the
            interface.
          </t-b>
          <t-b>
            It is common, though not essential, that one of the classes in a package has the same name
            as the package. Usually, a package name comes from the name of the project that controls its
            build process.
          </t-b>
          <t-b>
            Since Component_B was not configured with an interface, Executive depends on its implementation
            details. It is likely that Executive and Component_B were designed together, to be used as a unit,
            separated into two classes to make understanding and testing easier.
          </t-b>
          <hr class="spreadup" />
          <div class="footnote">
            <ol class="tight">
              <li>
                Interfaces in C++ are usually implemented with structs rather than classes.  Classes and
                structs are identical except that structs by default have public members while classes
                by default have private members.
              </li>
            </ol>
          </div>
        </details>
      </t-b>
      The next section describes how a collection of packages are built into a library or executable
      file.
    </indent-blocks>
    <div class="clear"></div>
    <a id="compil"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.2</num-item1><num-item4>Compilation Model:</num-item4>
    </num-cont>
    <indent-blocks>
      <t-b>
        The C++ tool-chain consists of a preprocessor, compiler, and linker. Each .cpp file and its
        included .h header files form a translation unit.  The build system handles one translation 
        unit at a time and does not carry over information from one translation to the next.  It is 
        the job of the linker to bind various translations into an executable or library.
      </t-b>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Compilation Model Details</summary>
          <div style="width:calc(100vw - 6rem);">
            <photosizer-block src="Pictures/CompilationModel.JPG" width="600" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 1. C++ Compilation Model
              </span>
            </photosizer-block>
          </div>
          <t-b>
            C++ compiles each *.cpp file independently, and does not save type information when compiling more than one.
            Each *.cpp file and all of its included *.h files are called a translation unit. 
          </t-b>
          <t-b>
            The C++ language is designed
            to support one-pass compilation.  That means that an entity: function, struct, or class must be defined before
            its first use in compiler scan order. This is called the definition first rule:
          </t-b>
          <defn-block class="indent" style="width:25rem;">
            <defn-head>Definition First Rule:</defn-head>
            <defn-body>
              Instances of structs or classes can be declared only after the struct or class has been declared.
              The compiler can&apos;t lay out code for the instance until it knows how much stack space it will
              occupy. That is determined by the struct or class declaration.
            </defn-body>
          </defn-block>
          <t-b>
            The operation of a C++ Compiler is shown in Figure 1.  Its first action is to build an intermediate source
            code file with a preprocessor by replacing each #include statement in source code with the entire code of
            the included file.  Included files are really included in that source text.
            The preprocessor also expands any macros or uses them to set compiler directives, e.g., for #pragma once.
            <spacer-15></spacer-15>
            The Compiler then consumes the intermediate source file and either compiles to an object file (*.obj), static
            library (*.lib), or dynamic link library (*.dll), or, if there are compilation errors, it simply emits error
            messages.
            <spacer-15></spacer-15>
            The results of these compilation output files are processed by a Linker.  When program code makes calls or transfers
            to code in the same compilation unit, the compiler assigns addresses based on the code it has laid out.  However,
            if the code makes calls into another compilation unit, then the compiler doesn&apos;t have an address, and so makes
            an entry in a table of unresolved addresses.
            <spacer-15></spacer-15>
            The job of the Linker is to resolve these addresses.  It can do that, because it does not execute until all of the
            compilation units that target a specific execution image are compiled, so it has all the addresses it needs and
            proceeds to resolve the unknowns.
            <spacer-15></spacer-15>
            That results in a runnable execution image.  However, that is not the end of the story.  The build process may
            have defined dynamic link libraries which get loaded during execution.  It is the job of the Loader to start
            the execution image, and bind, at run-time, any dlls that the program needs.
          </t-b>
        </details>
      </t-b>
      <t-b>
        When the linker has successfully completed creating an executable, the executable can be started
        using 
        services of the operating system loader. The loader loads the executable image into memory and
        loads any dynamic-link libraries on which the executable may depend.  In that case it binds the 
        executable&apos;s calls to an appropriate entry in the library.
      </t-b>
    </indent-blocks>
    <div class="clear"></div>
    <a id="execute"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.3</num-item1><num-item4>Program Execution Model:</num-item4>
    </num-cont>
    <indent-blocks>
      <t-b>
        C++ source code compiles to native code that is loaded into memory, is initialized, and
        begins to directly execute machine language instructions. You can view the program&apos;s assembled
        code by choosing an option to generate a file containing assembler output.
      </t-b>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Program Execution</summary>
          <div style="width:calc(100vw - 6rem);">
            <photosizer-block src="Pictures/ProgramModel.JPG" width="500" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 2. C++ Program Model
              </span>
            </photosizer-block>
          </div>
          <t-b>
            When execution of a C++ program begins, initialization code generated by the compiler runs, then the thread of
            execution enters main, with any arguments defined on the command line.  Main entry creates a stack frame
            - a block of allocated stack memory - that holds input arguments, any local data defined by main, and the
            return value, used to indicate success or failure to the operating system.
            <spacer-15></spacer-15>
            Should main call a function, another stack frame is allocated for that function, and if that function calls
            another, it too allocates a stack frame.  Stack frames are allocated, as scratch-pad memory, for every scope
            entered by the thread of execution.  When the thread leaves that scope the allocated memory becomes invalid.
            The next time a stack frame needs allocation, the invalid memory is likely to be part of that allocation.
            <spacer-15></spacer-15>
            Heap memory can be allocated by a program&apos;s code with a call to new, and deallocated with a call to delete.
            Malloc and Free serve the same purpose in a C language program.
            <spacer-15></spacer-15>
            Input and output operations defined by a C++ program are handled with streams - iostreams cin and cout for the screen and console
            and fstreams ifstream and ofstream for files. Error and logging are handled by cerr and clog.  All of these stream
            objects are constructed as global objects by the initialization code that runs before main is entered, and are available
            anywhere in the program code.
            <spacer-15></spacer-15>
            The handles stdin, stdout, stderr, and stdlog are used by C programs.  They are references to the program&apos;s
            input and output channels, attached to screen and console.  The program can define other handles for channels to
            files defined by the program or discovered in the file system.
          </t-b>
        </details>
      </t-b>
      <t-b>
        The C++ programming language gives developers freedom to choose where in memory fundamental data
        and user defined objects reside.  The consequences of those choices determine lifetimes of the data
        and objects. This is addressed in the next section.
      </t-b>
    </indent-blocks>
    <div class="clear"></div>
    <a id="memory"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.4</num-item1><num-item4>Memory Model:</num-item4>
    </num-cont>
    <indent-blocks>
      <t-b>
        A C++ program runs in an environment with tiered memory: static memory allocated by the compiler
        holds code and global data. Stack memory is allocated by the developer&apos;s use of scopes, and
        heap memory is allocated to the process when it starts and heap storage of program artifacts is
        managed by the language implemented memory manager, part of the C++ infrastructure.
      </t-b>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Memory Model</summary>
          <div style="width:calc(100vw - 6rem);">
            <photosizer-block src="Pictures/MemoryModel.jpg" width="500" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 3. C++ Memory Model
              </span>
            </photosizer-block>
          </div>
          <t-b>
            Figure 3. shows details of the C++ Memory Model.  There are three types of memory: static, stack, and heap,
            each with their own lifetime models.
            <spacer-15></spacer-15>
            Anything in static memory is defined, and has coherent values, for the lifetime of the program.  That
            includes all program code, global data, and static local data. Static local data is defined inside functions and qualified by the
            keyword static.  Local static data is initialized on the first entry to the function where defined, but does not
            get re-initialized on subsequent entries, so static data can save information that persists between function calls.
            <spacer-15></spacer-15>
            Stack memory holds information defined by each program scope, e.g., a block of code surrounded by braces
            &quot;&#123;&quot; and &quot;&#125;&quot;.  The life time of a stack allocation begins when the thread of
            execution enters the scope, and ends when it leaves the scope. Then the allocation becomes invalid, the memory
            is returned to the memory manager for reuse, and may be allocated for the next scope.
            The call stack you see in a debugger running C++ code is just the set of stack allocations shown in Figure&nbsp;2. and 
            Figure&nbsp;3..
            <spacer-15></spacer-15>
            Heap memory is provided to a running program by the operating system.  A default heap is created when a C++
            program begins execution.  The program code allocates heap space by using calls to operator new and deallocates
            with a call to delete.  So the life time of a heap object starts with it&apos;s allocation with new, and ends
            with deallocation with delete.
          </t-b>
        </details>
      </t-b>
      <t-b>
        Most classes manage data - their state - by using the static qualifier to place data in static memory,
        creating scopes in stack memory defined by brace pairs, <c-s>{</c-s> and <c-s>}</c-s>, and 
        making heap allocations with the keywords <c-s>new</c-s> and <c-s>delete</c-s>.
      </t-b>
    </indent-blocks>
    <div class="clear"></div>
    <a id="class"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.5</num-item1><num-item4>Classes:</num-item4>
    </num-cont>
    <t-b>
      Classes and class relationships are the building blocks for object-oriented design.  The results
      are a collection of objects - instances of classes - that cooperate to conduct operations
      required of their program. We structure designs using:
      inheritance, composition, aggregation, using, and friend class relationships.
    </t-b>
    <indent-blocks>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Class Structure:</summary>
          <div style="width:calc(100vw - 12rem);">
            <photosizer-block src="Pictures/ClassLayout.jpg" width="500" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 3. C++ Memory Model
              </span>
            </photosizer-block>
          </div>
          <t-b>
            A class is like a &quot;cookie cutter&quot;.  It stamps out a section of memory in the stackframe
            of its local scope, and initializes that memory with data required to create a valid object.
            Each time it&apos;s used to declare an instance, another piece of memory is allocated and
            initialized.
          </t-b>
          <t-b>
            Each class has a set of methods - functions associated with that specific class - providing
            operations on its allocated data when invoked. Each class has code that is stored
            in static memory, and potentially many instances holding data usually stored in the stackframe of the function
            where it is declared.
          </t-b>
          <t-b style="margin-bottom:0px;">
            The example below models a point in some space, perhaps physical space-time, so it would have
            four coordinates: x, y, z, t.
          </t-b>
          <defn-code style="font-size:0.9rem; padding-top:0px;">
  class Point {
  public:
    Point(const std::string& name = "none");
    std::string& name();
    double& operator[](size_t i);
    double operator[](size_t i) const;
    size_t size() const;
  private:
    std::string name_;
    std::vector&lt;double&gt; coordinates_;
  };
          </defn-code>
          <t-b>
            When an instance method is invoked, <c-s>p1.name(param); p1&epsilon;Point</c-s>, the address of <c-s>p1</c-s> is sent to the
            code for class <c-s>Point</c-s> to use when <c-s>Point::name</c-s> modifies <c-s>p1</c-s>&apos;s data.  That address is identified
            by the reserved word &quot;<c-s>this</c-s>&quot;.  You may occasionally see references to <c-s>this</c-s> in
            methods of the class.  Most use is implicit, but occasionally it must be used explicitly, as in
            assignment operators that return <c-s>*this</c-s>.
          </t-b>
          <t-b>
            C++ classes define special methods: constructors, assignment operators, and destructors.  Constructor
            method names are all the name of the class. Assignment operators use the <c-s>operator=</c-s> name and
            destructor names are the class name prepended with a <c-s>~</c-s> character.
          </t-b>
        </details>
      </t-b>
      <t-b>
        C++ is a strictly typed language.  Every data artifact is required to have a type, either fundamental -
        defined by the language - or user-defined.  Templates allow a component to define a function or
        class in terms of one or more unspecified parameters. Those are compiled, checking syntax for all
        those parts that don&apos;t depend on the unspecified parameters.
      </t-b>
      <t-b>
        So type checking for those unspecified parts is deferred until application code that defines the parameters
        is compiled. This design is very useful, allowing construction of libraries that can support
        operations on many different types of data.
      </t-b>
    </indent-blocks>
    <div class="clear"></div>
    <a id="objmodel"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.6</num-item1><num-item4>Object Model:</num-item4>
    </num-cont>
    <t-b>
      The C++ object model is concerned with managment of object resources and the kinds of operations
      that are supported for instances of its type.  Look closely at the memory layout and value type
      discussions.
    </t-b>
    <indent-blocks>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Object Model Details</summary>
          <t-b>
            All C++ objects support construction and destruction semantics. When an object is declared
            in some scope its constructor ensures that its state is initialized with no support needed
            from the using code except to provide parameters, if needed, to the constructor.
          </t-b>
          <num-cont>
            <num-item1>1.6.1</num-item1><num-item4>Scope-based Resource Management:</num-item4>
          </num-cont>
          <t-b>
            When the thread of execution leaves the scope where an object has been constructed its
            destructor will be invoked, releasing object resources deterministically, with no support
            needed from its using code.  This inherent resource management is often referred to as
            Resource Acquisition Is Initialization (RAII).
          </t-b>
          <defn-block class="indent" style="width:35rem;">
            <defn-head>Scope-based Resource Management a.k.a. RAII:</defn-head>
            <defn-body>
              The C++ language guarantees that, when the thread of execution leaves a scope, all the
              objects created within that scope will be destroyed by calling their destructors, releasing
              any resources that have allocated to each object.
            </defn-body>
          </defn-block>
          <num-cont>
            <num-item1>1.6.2</num-item1><num-item4>Memory Layout:</num-item4>
          </num-cont>
          <t-b>
            The C++ object model is also concerned with how compound objects are layed out in memory. Structs
            and Classes support five relationships that bind objects together to build composite objects:
            inheritance, composition, aggregation, using, and friend-ship.
          </t-b>
          <div style="width:calc(100vw - 12rem);">
            <photosizer-block src="Pictures/ObjectRelationships.JPG" width="500" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 4. C++ Composite Object Model
              </span>
            </photosizer-block>
          </div>
          <t-b>
            The class diagram shown at the top of Figure 4 illustrates relationships between six entities:
            <ol class="tight">
              <li>
                D, a composite object which inherits a base class B and uses an object, U, created by
                some other entity.
              </li>
              <li>
                B, the base class, composes an instance of class C.
              </li>
              <li>
                C, the composed class.
              </li>
              <li>
                U, the used class.
              </li>
              <li>
                friend, an entity: struct or class or method, or function, that is granted, by D,
                access to its private data.
              </li>
              <li>
                Client, an entity that aggregates an instance of D.  That means that Client created
                its instance of D sometime during its lifetime.
              </li>
            </ol>
          </t-b>
          <t-b>
            The object diagram, at the bottom of Figure 4., illustrates the layout of each of these
            entities in memory. That&apos;s shown in two dimensions for clarity, but the layout is 
            actually a one-dimensional region of memory.
          </t-b>
          <t-b>
            When B is constructed its composed member C is built within the memory footprint of B.
            That means that the C instance is constructed as part of the construction of B.
          </t-b>
          <t-b>
            Similarly, an instance of D contains, within its memory footprint, an instance of B.  Again,
            that requires B to be constructed as part of the construction process for D.
          </t-b>
          <t-b>
            Instances of U, friend, and client are not owned by D and their memory layout is outside
            that of the compound instance of D.  That means that their construction processes are
            independent of that of D. Of course, if client creates an instance of D it must be 
            constructed before D.
          </t-b>
          <num-cont>
            <num-item1>1.6.3</num-item1><num-item4>Value Types:</num-item4>
          </num-cont>
          <t-b>
            C++ has been designed, from the ground up, to support value types, that is, types whose
            <span class="notice">instances</span> can be assigned and copied.
          </t-b>
          <defn-block class="indent" style="width:35rem;">
            <defn-head>Value Types:</defn-head>
            <defn-body>
              <t-b>
                Instances of value types can be copied and assigned. When a value type is copied, the
                destination instance is constructed and acquires the same state values as the source 
                of the copy, but
                remains an independent instance.  Should one of the instances have its state modified
                that does not affect the other.
              </t-b>
              <t-b>
                Assignment is a similar operation. The only difference is that the destination object
                already exists; the assignment gave it the same state values as the source of the
                assignment.
              </t-b>
            </defn-body>
          </defn-block>
          <t-b>
            C++ supports value types by allowing a class or struct designer to provide a copy
            constructor and copy assignment operator overload members to manage the change of state
          </t-b>
          <t-b>
            If a class has base classes (if any) and data members with correct copy and assignment 
            semantics, then the compiler will generate correct copy operations by memberwise copy
            construction and copy assignment for both the object and its bases.
          </t-b>
          <t-b>
            If that is not the case, then the designer supplies the constructor and operator overload
            to handle the transfer of state correctly.
          </t-b>
        </details>
        <t-b>
          This is the most important of the C++ models. If you understand this, most of the rest of
          the language makes sense.
        </t-b>
      </t-b>
    </indent-blocks>
    <div class="clear"></div>

    <a id="templ"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.6</num-item1><num-item4>Templates:</num-item4>
    </num-cont>
    <indent-blocks>
      <t-b>
        A template is a code generator that creates type specific artifacts from parameterized patterns.
        Function templates generate concrete functions and class templates generate concrete classes when
        supplied, in application code, with types.
      </t-b>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Templates</summary>
          <!--<div style="width:calc(100vw - 6rem);">
          </div>-->
          <t-b>
            Templates generate functions and classes when an application instantiates them with
            specific template parameters. The class template shown below generates
            a point class for each type, <c-s>T</c-s> specified by using
            code. The using code instantiates it with two parameter types, <c-s>int</c-s> and <c-s>double</c-s>, 
            so the template generates two classes, one for each type.
          </t-b>
          <t-b style="width:calc(100vw - 6rem);">
            <photosizer-block src="Pictures/TemplateLayout.jpg" width="600" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
            display: inline-block;
            font-weight: bold;
            font-family: 'Comic Sans MS, Tahoma';
            background-color: #ddd;
            width: 100%;
            padding: 5px 0px;
          ">
                Figure 3. Template Code Generation
              </span>
            </photosizer-block>
          </t-b>
          <t-b style="margin-bottom:0px;">
            The example, below, models a point in some space, so it might have
            three coordinates: x, y, z, e.g., coordinates_[0], coordinates_[1], coordinates_[2].  
          </t-b>
          <t-b>
            The diagram in Figure 3. assumes that <c-s>Point&lt;T&gt;</c-s> has been instantiated 
            for <c-s>int</c-s> and for <c-s>double</c-s>.
          </t-b>
          <defn-code style="font-size:0.9rem; padding-top:0px;">
  template&lt;typename T&gt;
  class Point {
  public:
    Point(const std::string& name = "none");
    std::string& name();
    T& operator[](size_t i);
    T operator[](size_t i) const;
    size_t size() const;
  private:
    std::string name_;
    std::vector&lt;T&gt; coordinates_;
  };
          </defn-code>
          <t-b>
            Template parameterization
            allows the designer to structure coordinates to fit an application. If the point described a location
            in a flowing fluid, the coordiates might be the location and flow rate components for each axis.
            <indent-block class="pad10">
              <c-s>T --> std::pair&lt;double, double&gt;</c-s>
            </indent-block>
            So, coordinates_ would have size 3 with entries for <c-s>{ x, flow_x }</c-s>, 
            <c-s>{ y, flow_y }</c-s>, <c-s>{ z, flow_z }</c-s>
          </t-b>
          <div class="clear"></div>
          <t-b style="width:calc(100vw - 6rem);">
            <photosizer-block src="Pictures/TemplateModel.jpg" width="300" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS, Tahoma';
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
                Figure 4. Specializing Generic Template
              </span>
            </photosizer-block>
          </t-b>
          <t-b>
            Should using code instantiate a template for additional
            parameter types, that would generate another class for each one.
            Fortunately, that is done by the compiler.  Developers only need to write one template
            class and perhaps one or two special cases.
          </t-b>
          <t-b>
            A class template can be specialized or a function template overloaded to handle special cases.
            It is not uncommon for a template design to work well for several application types, but fail 
            to operate as desired for special cases.
          </t-b>
          <t-b>
            Specialization is possible because templates generate code when an application, using the template
            for specified types, is compiled. When we specialize a class template, we define not only the
            generic class, but also a type specific class for the special case.  The language guarantees that,
            if a specialization matches a specified type, the specialization will be compiled.  If the type
            doesn&apos;t match any specialization (there can be more than one) then the generic template
            will be compiled using that type.
          </t-b>
          <t-b>
            The same process happens for function templates, except that the special cases are overloads of
            the template function and overload resolution is used instead of template type deduction.
          </t-b>
          <t-b>
            We will discuss class template specialization and function template overloading in Chapter #7.
          </t-b>
        </details>
      </t-b>
      This concludes our discussion of C++ models.  You will find details on each of them in succeeding chapters.
    </indent-blocks>
    <div class="clear"></div>
    <a id="epilog"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.6</num-item1><num-item4>Epilogue:</num-item4>
    </num-cont>
    <t-b>
      This chapter has explored important models used to help you understand how to develope C++ code.
      The succeeding chapters turn these models into concrete designs and code. 
    </t-b>
    <t-b>
      Chapter #2 surveys
      the language and provides many code examples to help you get started. Later chapters look in detail
      at classes, class relationships, and templates. 
    </t-b>
    <t-b>
      Finally, there are two chapters that discuss C++ standard libraries.  There will be more libraries 
      covered before too long.
    </t-b>
    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.7</num-item1><num-item4>References:</num-item4>
    </num-cont>
    <t-b class="indent">
      <a href="https://en.cppreference.com/w/cpp/keyword">C++ keywords - cppreference.com</a><br />
      <a href="https://en.cppreference.com/w/cpp/language/basic_concepts">Basic Concepts - cppreference.com</a><br />
      <a href="https://isocpp.org/faq">Frequently Asked Questions - isocpp.org</a><br />
      <a href="Resources/SurvivalGuide.pdf">C++ Survival Guide</a><br />
      <a href="DesignNote-CvsCpp.html">Comparison of C++ with C</a>
    </t-b>
  </indent-blocks>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

<!--  <script>createSizer("Pictures/CompilationModel.JPG", "Figure 1. C++ Compilation Model", 400, "fig1")</script>-->
  <!--<script>createSizer("Pictures/ProgramModel.JPG", "Figure 2. C++ Program Model", 400, "fig2")</script>-->
  <!--<script>createSizer("Pictures/MemoryModel.jpg", "Figure 3. C++ Memory Model", 400, "fig3")</script>-->
  <spacer-25 class="clear"></spacer-25>
  <info-bar></info-bar>
</body>
</html>