<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppModels.htm
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Syracuse University
  -->
  <title>C++ Models</title>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 0.5fr;
      grid-column-gap: 0em;
      padding: 0px;
    }

    .item1 {
      grid-column: 1;
      padding: 0px;
    }

    .item2 {
      grid-column: 2;
      padding: 0px;
    }

    .border {
      border: 1px solid black;
      padding-bottom: 10px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>
  <a id="Next" href="CppStory_Survey.html">N</a>
  <a id="Prev" href="CppStory_Prologue.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 1 - C++ Models</h1>
      <h3 id="subtitle">Compilation, exectution, memory storage, classes, templates</h3>
    </hgroup>
  </header>

  <toc-b id="toc">
    <div style="display:flex; flex-direction:row">
      <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
      <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
      <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
    </div>
    <up-b id="chaps" onmouseout="storyMenu.chaps()">
      <a href="CppStory_Prologue.html">Prologue</a><br />
      <a href="CppStory_Models.html">Models</a><br />
      <a href="CppStory_Survey.html">Survey</a><br />
      <a href="CppStory_Data.html">Data</a><br />
      <a href="CppStory_Operations.html">Operations</a><br />
      <a href="CppStory_Classes.html">Classes</a><br />
      <a href="CppStory_ClassRelationships.html">ClassRel</a><br />
      <a href="CppStory_Templates.html">Templates</a><br />
      <a href="CppStory_TemplateMetaprog.html">TMP</a><br />
      <a href="CppStory_Libraries.html">Libraries</a><br />
      <a href="CppStory_LibraryStreams.html">Streams Libraries</a><br />
      <a href="CppStory_LibrarySTL.html">STL Libraries</a><br />
      <a href="CppStory_Interesting.html">Interesting</a>
    </up-b>
    <rt-b id="sects">
      <a href="#top">Top</a>, <a href="#compil">Compile</a>, <a href="#execute">Execute</a>, 
      <a href="#memory">Memory</a>, <a href="#Class">Class</a>, <a href="#templ">Templates</a>, 
      <a href="#epilog">Epilogue</a>, <a href="#refs">Refs</a>
    </rt-b>
  </toc-b>

  <hr class="spread" />
  <indent-blocks class="bb-55">
    <a id="compil"></a>
    <h3>Compilation Model</h3>
    <indent-blocks>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Compilation Model</summary>
          <div style="width:calc(100vw - 6rem);">
            <photosizer-block src="Pictures/CompilationModel.JPG" width="600" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 1. C++ Compilation Model
              </span>
            </photosizer-block>
          </div>
          <t-b>
            C++ compiles each *.cpp file independently, and does not save type information when compiling more than one.
            Each *.cpp file and all of its included *.h files are called a compilation unit.
            <spacer-15></spacer-15>
            The operation of a C++ Compiler is shown in Figure 1.  Its first action is to build an intermediate source
            code file with a preprocessor by replacing each #include statement in source code with the entire code of
            the included file.  Included files are really included in that source text.
            The preprocessor also expands any macros or uses them to set compiler directives, e.g., for #pragma once.
            <spacer-15></spacer-15>
            The Compiler then consumes the intermediate source file and either compiles to an object file (*.obj), static
            library (*.lib), or dynamic link library (*.dll), or, if there are compilation errors, it simply emits error
            messages.
            <spacer-15></spacer-15>
            The results of these compilation output files are processed by a Linker.  When program code makes calls or transfers
            to code in the same compilation unit, the compiler assigns addresses based on the code it has laid out.  However,
            if the code makes calls into another compilation unit, then the compiler doesn&apos;t have an address, and so makes
            an entry in a table of unresolved addresses.
            <spacer-15></spacer-15>
            The job of the Linker is to resolve these addresses.  It can do that, because it does not execute until all of the
            compilation units that target a specific execution image are compiled, so it has all the addresses it needs and
            proceeds to resolve the unknowns.
            <spacer-15></spacer-15>
            That results in a runnable execution image.  However, that is not the end of the story.  The build process may
            have defined dynamic link libraries which get loaded during execution.  It is the job of the Loader to start
            the execution image, and bind, at run-time, any dlls that the program needs.
          </t-b>
        </details>
      </t-b>
    </indent-blocks>
    <a id="execute"></a>
    <h3>Program Execution Model:</h3>
    <indent-blocks>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Program Execution</summary>
          <div style="width:calc(100vw - 6rem);">
            <photosizer-block src="Pictures/ProgramModel.JPG" width="500" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 2. C++ Program Model
              </span>
            </photosizer-block>
          </div>
          <t-b>
            When execution of a C++ program begins, initialization code generated by the compiler runs, then the thread of
            execution enters main, with any arguments defined on the command line.  Main entry creates a stack frame
            - a block of allocated stack memory - that holds input arguments, any local data defined by main, and the
            return value, used to indicate success or failure to the operating system.
            <spacer-15></spacer-15>
            Should main call a function, another stack frame is allocated for that function, and if that function calls
            another, it too allocates a stack frame.  Stack frames are allocated, as scratch-pad memory, for every scope
            entered by the thread of execution.  When the thread leaves that scope the allocated memory becomes invalid.
            The next time a stack frame needs allocation, the invalid memory is likely to be part of that allocation.
            <spacer-15></spacer-15>
            Heap memory can be allocated by a program&apos;s code with a call to new, and deallocated with a call to delete.
            Malloc and Free serve the same purpose in a C language program.
            <spacer-15></spacer-15>
            Input and output operations defined by a C++ program are handled with streams - iostreams cin and cout for the screen and console
            and fstreams ifstream and ofstream for files. Error and logging are handled by cerr and clog.  All of these stream
            objects are constructed as global objects by the initialization code that runs before main is entered, and are available
            anywhere in the program code.
            <spacer-15></spacer-15>
            The handles stdin, stdout, stderr, and stdlog are used by C programs.  They are references to the program&apos;s
            input and output channels, attached to screen and console.  The program can define other handles for channels to
            files defined by the program or discovered in the file system.
          </t-b>
        </details>
      </t-b>
    </indent-blocks>
    <a id="memory"></a>
    <h3>Memory Model:</h3>
    <indent-blocks>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Memory Model</summary>
          <div style="width:calc(100vw - 6rem);">
            <photosizer-block src="Pictures/MemoryModel.jpg" width="500" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 3. C++ Memory Model
              </span>
            </photosizer-block>
          </div>
          <t-b>
            Figure 3. shows details of the C++ Memory Model.  There are three types of memory: static, stack, and heap,
            each with their own lifetime models.
            <spacer-15></spacer-15>
            Anything in static memory is defined, and has coherent values, for the lifetime of the program.  That
            includes all program code, global data, and static local data. Static local data is defined inside functions and qualified by the
            keyword static.  Local static data is initialized on the first entry to the function where defined, but does not
            get re-initialized on subsequent entries, so static data can save information that persists between function calls.
            <spacer-15></spacer-15>
            Stack memory holds information defined by each program scope, e.g., a block of code surrounded by braces
            &quot;&#123;&quot; and &quot;&#125;&quot;.  The life time of a stack allocation begins when the thread of
            execution enters the scope, and ends when it leaves the scope. Then the allocation becomes invalid, the memory
            is returned to the memory manager for reuse, and may be allocated for the next scope.
            The call stack you see in a debugger running C++ code is just the set of stack allocations shown in Figure&nbsp;2. and 
            Figure&nbsp;3..
            <spacer-15></spacer-15>
            Heap memory is provided to a running program by the operating system.  A default heap is created when a C++
            program begins execution.  The program code allocates heap space by using calls to operator new and deallocates
            with a call to delete.  So the life time of a heap object starts with it&apos;s allocation with new, and ends
            with deallocation with delete.
          </t-b>
        </details>
      </t-b>
    </indent-blocks>
    <a id="class"></a>
    <h3>Class Model:</h3>
    <t-b>
      Classes and class relationships are the building blocks for object-oriented design.  The results
      are a collection of objects - instances of classes - that cooperate to conduct operations
      required of their program. We structure the designs using:
      inheritance, composition, aggregation, using, and friend class relationships.
    </t-b>
    <indent-blocks>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Class Structure:</summary>
          <div style="width:calc(100vw - 12rem);">
            <photosizer-block src="Pictures/ClassLayout.jpg" width="500" class="photoSizerBlock right" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 3. C++ Memory Model
              </span>
            </photosizer-block>
          </div>
          <t-b>
            A class is like a &quot;cookie cutter&quot;.  It stamps out a section of memory in the stackframe
            of its local scope, and initializes that memory with data required to create a valid object.
            Each time it&apos;s used to declare an instance, another piece of memory is allocated and
            initialized.
          </t-b>
          <t-b>
            Each class has a set of methods - functions associated with that specific class - providing
            operations on its allocated data when invoked. Each has code that is stored
            in static memory, and potentially many instances holding data usually stored in the stackframe of the function
            where it is declared.
          </t-b>
          <t-b style="margin-bottom:0px;">
            The example below models a point in some space, perhaps physical space-time, so it would have
            four coordinates: x, y, z, t.
          </t-b>
          <defn-code style="font-size:0.9rem; padding-top:0px;">
  class X {
  public:
    X(const std::string& name = "none", size_t N = 3);
    std::string& name();
    double& operator[](size_t i);
    double operator[](size_t i) const;
    size_t size() const;
  private:
    std::string name_;
    std::vector&lt;double&gt; coordinates_;
  };
          </defn-code>
          <t-b>
            When an instance method is invoked, <c-s>x.fun(param); x&epsilon;X</c-s>, the address of <c-s>x</c-s> is sent to the
            code for class <c-s>X</c-s> to use if <c-s>fun</c-s> modifies <c-s>x</c-s>&apos;s data.  That address is identified
            by the reserved word &quot;<c-s>this</c-s>&quot;.  You may occasionally see references to <c-s>this</c-s> in
            methods of the class.  Most use is implicit, but occasionally it must be used explicitly, as in
            assignment operators that return <c-s>*this</c-s>.
          </t-b>
          <t-b>
            C++ classes define special methods: constructors, assignment operators, and destructors.  Constructor
            method names are all the name of the class. Assignment operators use the <c-s>operator=</c-s> name and
            destructor names are the class name prepended with a <c-s>~</c-s> character.
          </t-b>
        </details>
      </t-b>
    </indent-blocks>
    <div class="clear"></div>
    <a id="templ"></a>
    <h3>Templates:</h3>
    <indent-blocks>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Templates</summary>
          <!--<div style="width:calc(100vw - 6rem);">
          </div>-->
          <t-b>
            Templates generate functions and classes when an application instantiates them with
            specific template parameters. The function template shown in the middle panel generates
            a max function for each set of types, <c-s>T1</c-s> and <c-s>T2</c-s> specified by using
            code. The using code instantiates it with four sets of parameter types, so the template
            generates four functions, one for each set.
          </t-b>
          <t-b>
            Should the using code instantiate for additional
            sets of parameters, that would generate another function for each set.
            Fortunately, that is done by the compiler.  Developers only need to write one template
            function and perhaps one or two overloads for special cases, as done below.
          </t-b>
          <defn-outerBlock>
            <photosizer-block src="Pictures/TemplateModel.jpg" width="400" class="photoSizerBlock" style="margin-top:0;">
              <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS, Tahoma';
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
                Figure 3. Template Code Generation
              </span>
            </photosizer-block>
            <defn-block>
              <defn-head>Function Template Code</defn-head>
              <defn-code>
template&lt;typename T1, typename T2&gt;
auto max(T1 t1, T2 t2) {
  displayDemo("--- using generic template ---");
  return t1 &gt; t2 ? t1 : t2;
}

/*-- template function overload --*/

using pChar = const char*;
auto max(pChar s1, pChar s2) {
  displayDemo(
    "--- using overload for const char* ---"
  );
  return ((strcmp(s1, s2) &gt; 0) ? s1 : s2);
}
              </defn-code>
              <defn-head class="defnBorderTop">Using Code</defn-head>
              <defn-code>
--- using generic template ---
max(4,2) returns 4
--- using generic template ---
max(3.5, 2L) returns 3.5
--- using generic template ---
max(3.5, 4L) returns 4
--- using overload for const char* ---
max("aardvark", "zebra") returns zebra
--- using generic template ---
max(std::string("a string"), "b string")
  returns "b string"
class std::basic_string&lt;
  char,struct std::char_traits&lt;char&gt;, 
  class std::allocator&lt;char&gt; 
&gt;
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Class Template Code Demo</defn-head>
              <defn-code>
  template&lt;typename T&gt;
  class Demo {
  public:
    void value(T t);
    T value();
  private:
    T t_;
  };

  template&lt;typename T&gt;
  void Demo&lt;T&gt;::value(T t) {
    t_ = t;
  }

  template&lt;typename T&gt;
  T Demo&lt;T&gt;::value() {
    return t_;
  }
}
              </defn-code>
              <defn-head class="defnBorderTop">Using Code</defn-head>
              <defn-code>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include "../Display/Display.h"
#include "Demo.h"

int main() {

  displayTitle(
    "Demonstrating Template Syntax"
  );

  Demo&lt;std::string&gt; sd;
  sd.value("hello world");
  std::cout &lt;&lt; "\n  " 
            &lt;&lt; sd.value();
  putline(2);
}
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </t-b>
    </indent-blocks>
    <hr />
    <a id="epilog"></a>
    <h3>Epilogue:</h3>
    <a id="refs"></a>
    <hr />
    <h3>References:</h3>
  </indent-blocks>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

<!--  <script>createSizer("Pictures/CompilationModel.JPG", "Figure 1. C++ Compilation Model", 400, "fig1")</script>-->
  <!--<script>createSizer("Pictures/ProgramModel.JPG", "Figure 2. C++ Program Model", 400, "fig2")</script>-->
  <!--<script>createSizer("Pictures/MemoryModel.jpg", "Figure 3. C++ Memory Model", 400, "fig3")</script>-->
  <spacer-25 class="clear"></spacer-25>
  <info-bar></info-bar>
</body>
</html>