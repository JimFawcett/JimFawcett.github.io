<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_Survey.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Survey</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }

    .pad10-15 {
      padding: 10px 15px;
    }

    .codeStyle {
      overflow:hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    .labelStyle {
      font-family: sans-serif;
      /*font-weight:bold;*/
      font-size: 1.0em;
    }

    .normal {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    summary {
      width: max-content;
    }

      summary ~ div {
        width: max-content;
        max-width: 95%;
        position: relative;
        left: 29px;
        top: 1px;
        background-color: #eee;
      }

      summary ~ indent-block {
        width: max-content;
        max-width: 95%;
        position: relative;
        left: 4px;
        top: 1px;
        padding-left: 20px;
        padding-right: 20px;
        background-color: #eee;
      }

      photosizer-block {
        position: relative;
        z-index:2;
        background-color:white;
      }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #1&nbsp;-&nbsp;C++ Survey</h1>
      <h3 id="subtitle">data, operations, classes, templates, libraries</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <indent-block>
    <h3>Survey</h3>
    <indent-block>
      This chapter provides a quick look at programming facilities provided by C++ and its libraries.
      You will find a lot more details, with examples, on these topics in subsequent chapters.
      <ul class="tight pad10">
        <li><a href="https://en.cppreference.com/w/cpp/language/basic_concepts">Basic concepts</a></li>
        <li><a href="https://en.cppreference.com/w/cpp/keyword">Key words</a></li>
        <li><a href="CppModels.html">Models for C++ programs: building, execution, and memory storage</a></li>
      </ul>
      <hr class="spread" />
      <h4>Data Types:</h4>
      <indent-block>
        The C++ programming language provides fundamental types, built into the language,
        additional types provided by the C++ standard libraries, and user-defined types that
        can be designed to provide the same behaviors as fundamental types.
        <spacer-15></spacer-15>
        Fundamental types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="codeStyle lightItem">void, bool, nullptr_t, integral, char, and floating types</span>
            </summary>
            <div class="pad10 border">
            <ul class="tight">
              <li><span class="codeStyle">void</span> - only type with no values</li>
              <li><span class="codeStyle">bool</span> - values true and false</li>
              <li><span class="codeStyle">std::nullptr_t</span> - type of the nullptr literal</li>
              <li>
                integral types:
                <indent-block class="pad10 codeStyle">
                  int <span class="normal">with qualifiers:</span> short, long, long long, unsigned, const, volatile<br />
                  std::size_t, std::size_type
                </indent-block>
              </li>
              <li>
                character types:
                <indent-block class="pad10 codeStyle">
                  char, wchar_t <span class="normal">with qualifiers:</span> signed, unsigned<br />
                  <span class="normal">unicode characters:</span> char16_t, char32_t, char8_t (C++20)
                </indent-block>
              </li>
              <li>
                floating point types:
                <indent-block class="pad10 codeStyle">
                  float, double <span class="normal">with qualifiers:</span> long, long long, const, volatile
                </indent-block>
              </li>
              <li>
                arrays, pointers, and references:
                <indent-block class="pad10 codeStyle">
                  array &nbsp;&nbsp;&nbsp;&nbsp;--> T t[N], N <span class="normal">is a compile-time constant</span><br />
                  pointer &nbsp;&nbsp;--> U* pU = &u; &nbsp;&amp; <span class="normal">on the right side => address</span><br />
                  reference --> V&amp; v2 = v1; &nbsp;&amp <span class="normal">on left side => C++ reference</span>
                </indent-block>
              </li>
            </ul>
            <indent-block class="pad10">
              References:
              <indent-block>
                <a href="https://en.cppreference.com/w/cpp/language/types">cppreference.com/types</a>
              </indent-block>
            </indent-block>
            </div>
          </details>
        </indent-block>
        C++ standard libraries provide a large set of pre-defined types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">
                STL sequential and associative containers, container adapters
              </span>
            </summary>
            <indent-block class="pad10 border">
              sequential containers - linear sequence of elements:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>string, array, vector, deque</td>
                    <td class="normal">contiguous memory storage, can be indexed</td>
                  </tr>
                  <tr>
                    <td>forward_list, list</td>
                    <td class="normal">nodes allocated on heap, cannot be indexed</td>
                  </tr>
                </table>
              </indent-block>
              associative containers - key based storage on heap:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>set, multiset, unordered_set, unordered_multiset</td>
                    <td class="normal">key only storage using balanced binary tree or hash table</td>
                  </tr>
                  <tr>
                    <td>map, multimap, unordered_map, unordered_multimap</td>
                    <td class="normal">key-value storage using balanced binary tree or hash table</td>
                  </tr>
                </table>
              </indent-block>
              container adapters:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>queue, stack</td>
                    <td class="normal">sequential containers accessible only from end(s)</td>
                  </tr>
                  <tr>
                    <td>priority_queue</td>
                    <td class="normal">constant time lookup of largest element, logarithmic insertion and extraction</td>
                  </tr>
                </table>
              </indent-block>
              <indent-blocks class="pad10">
                References:
                <indent-block>
                  <a href="https://en.cppreference.com/w/cpp/container">cppreference.com/container</a><br />
                  <a href="STL-Containers.html">STL-Containers.html</a>
                </indent-block>
                <spacer-15></spacer-15>
              </indent-blocks>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                Special containers, streams, and other types
              </span>
            </summary>
            <indent-block class="pad10 border">
              special containers:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>pair</td>
                    <td class="normal">contains two elements which may have distinct types</td>
                  </tr>
                  <tr>
                    <td>tuple</td>
                    <td class="normal">contains finite number of elements with distinct types</td>
                  </tr>
                  <tr>
                    <td>initializer_list</td>
                    <td class="normal">
                      contains sequence of elements, all of the same type
                      normally filled with initialization list, e.g., { 1, 2, 3, ... }
                    </td>
                  </tr>
                  <tr>
                    <td>any</td>
                    <td class="normal">holds value of any type, provides std::any_cast for retrieval</td>
                  </tr>
                  <tr>
                    <td>optional</td>
                    <td class="normal">used to return values or signal failure to return</td>
                  </tr>
                  <tr>
                    <td>variant</td>
                    <td class="normal">similar to any, but only holds values from a specified set of types</td>
                  </tr>
                </table>
              </indent-block>
              stream types:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>istream</td>
                    <td class="normal">
                      sends sequence of values of fundamental types to console using insertion operator&lt;&lt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ostream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from keyboard using extraction operator&gt;&gt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ifstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached file using extraction operator&lt;&lt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ofstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached file using extraction operator&gt;&gt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>istringstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached in-memory string using extraction operator&lt;&lot;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ostringstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached in-memory string using extraction operator&gt;&gt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                </table>
              </indent-block>
              other types:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>unique_ptr&lt;T&gt;</td>
                    <td class="normal">
                      Construction allocates instance t &epsilon; T, destruction deallocates t.  Assignment moves ownership.
                    </td>
                  </tr>
                  <tr>
                    <td>shared_ptr&lt;T&gt;</td>
                    <td class="normal">
                      Reference counted smart pointer, assignment adds counted reference.
                    </td>
                  </tr>
                  <tr>
                    <td>exception</td>
                    <td class="normal">
                      When code error occurs exception instance is &quot;thrown&quot;, then handled by catch clause associated
                      with enclosing try block.
                    </td>
                  </tr>
                  <tr>
                    <td>chrono</td>
                    <td class="normal">
                      Class for managing time durations and dates.
                    </td>
                  </tr>
                </table>
              </indent-block>
              <indent-blocks class="pad10">
                References:
                <indent-block>
                  <a href="https://en.cppreference.com/w/cpp/header">cppreference.com/header</a>
                </indent-block>
                <spacer-15></spacer-15>
              </indent-blocks>
            </indent-block>
          </details>
        </indent-block>
        User defined types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">enum, struct, and class</span>
            </summary>
            <indent-block class="pad10 border">
              scoped enum:
              <indent-block class="pad10 codeStyle">
                enum class Color { red, green, blue };<br />
                Color r = Color::red;
              </indent-block>
              struct:
              <indent-block class="pad10 codeStyle">
                struct S { int i; double d; };<br />
                S s { 2, 3.1415927 };
              </indent-block>
              class:
              <indent-block class="pad10 codeStyle">
                class X {<br />
                public:<br />
                &nbsp;&nbsp;void set(const std::string&amp; s);<br />
                &nbsp;&nbsp;std::string get();<br />
                private:<br />
                &nbsp;&nbsp;std::string str;<br />
                };
              </indent-block>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">type alias</span>
            </summary>
            <indent-block class="pad10 border">
              alias - c++11:
              <indent-block class="pad10 codeStyle">
                using [aliasName] = [typeName];
              </indent-block>
              alias - C++98:
              <indent-block class="pad10 codeStyle">
                typedef [typeName] [aliasName];
              </indent-block>
            </indent-block>
          </details>
        </indent-block>
        Type testing:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">compile-time and run-time testing</span>
            </summary>
            <indent-block class="pad10 border">
              compile-time type tests:
              <indent-block class="pad10 codeStyle">
                <a href="https://en.cppreference.com/w/cpp/header/type_traits">std::type_traits</a>
                <span class="normal">, user-defined</span> type-traits;
              </indent-block>
              run-time type tests:
              <indent-block class="pad10 codeStyle">
                <a href="https://en.cppreference.com/w/cpp/types/type_info">std::type_info</a>
              </indent-block>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
        </indent-block>
        We will cover many of these in Chapter 2 - Data.
        <spacer-15></spacer-15>
      </indent-block>
      <hr class="spread" />
      <h4>Operations:</h4>
      <indent-block>
        C++ provides unary and binary operations for the fundamental types.  It also provides
        operator functions that may be overloaded for user defined types.
        Some of the most used <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">operators</a>
        are illustrated here for both fundamental and user-defined types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">
                dereference and address of:&nbsp;&nbsp;
                <span class="codeStyle">* &amp;</span>
              </span>
            </summary>
            <indent-block class="pad10 border codeStyle">
              struct X { Y y; ... }; X x1; Y y;<br />
              X* pX = &amp;x1;
              <span class="normal">sets pointer</span>
              pX &#949; X*
              <span class="normal">to address of instance</span> x1 &#949; X<br />
              X x2 = *pX;
              <span class="normal">instance</span> x2 &#949; X
              <span class="normal">gets copy of contents of </span>x1
              <span class="normal">pointed to by</span> pX
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                member access operations:&nbsp;&nbsp;
                <span class="codeStyle">. -></span>
              </span>
            </summary>
            <indent-block class="pad10 border codeStyle">
              struct X { int y; ... }; X x{ 2, ... }; X* pX = &amp;x;<br />
              x.y, pX->y <span class="normal">both refer to value of</span>
              y<span class="normal">, e.g., </span> 2<span class="normal">, contained in struct</span> X
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                pre increment and decrement:&nbsp;&nbsp;
                <span class="codeStyle">++i --i</span>
              </span>
            </summary>
            <indent-block class="pad10 border codeStyle">
              int i{ 0 }; ++i; --i;<br />
              ++i <span class="normal">increments</span>
              i <span class="normal">and returns value</span> 1<br />
              --i <span class="normal">decrements</span>
              i <span class="normal">and returns value</span> 0
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                post increment and decrement:&nbsp;&nbsp;
                <span class="codeStyle">i++ i--</span>
              </span>
            </summary>
            <indent-block class="pad10 border codeStyle">
              int i{ 0 }; i++; i--;<br />
              i++ <span class="normal">increments value to</span> 1
              <span class="normal">and returns prior value</span> 0<br />
              i-- <span class="normal">decrements value to</span> 0
              <span class="normal">and returns prior value</span> 1<br />
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                logical operators:&nbsp;&nbsp;
                <span class="codeStyle">== != &lt; &lt;= &gt;= &gt; &amp;&amp; || !</span>
              </span>
            </summary>
            <indent-block class="pad10 border codeStyle">
              Here, we illustrate how a user defined type could implement<br />
              two of these logical operations:
              <spacer-15></spacer-15>
              struct X {<br />
              &nbsp;&nbsp;int i; double d;<br />
              &nbsp;&nbsp;bool operator==(const X&amp; x) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;return i == x.i && d == x.d;<br />
              &nbsp;&nbsp;}<br />
              &nbsp;&nbsp;bool operator!=(const X&amp; x) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;return i != x.i || d != x.d;<br />
              &nbsp;&nbsp;}<br />
              };
              <spacer-15></spacer-15>
              X x1{ 1, 1.5 }, x2{ 1, 1.5 }; x3{ 2, -0.5 }<br />
              x1 == x2; x1 != x3;
              <spacer-15></spacer-15>
              <span class="normal">Both statements above are true.</span>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                index operator:&nbsp;&nbsp;
                <span class="codeStyle">a[]</span>
              </span>
            </summary>
            <indent-block class="pad10 border codeStyle">
              double a[] { 1.0, 1.5, 2.0 };
              <spacer-15></spacer-15>
              a[1] == 1.5 <span class="normal">has value</span> true
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                arithmetic operations:&nbsp;&nbsp;
                <span class="codeStyle">+ - * /</span>
              </span>
            </summary>
            <indent-block class="pad10 border codeStyle">
              int x1{ 2 }; int x2{ 4 };<br />
              x1 + x2 == 6;
              x1 - x2 == -2;
              x1 * x2 == 8;
              x2 / x1 == 2;<br />
              <span class="normal">All of the boolean expressions above are true</span>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                function call operator:&nbsp;&nbsp;
                <span class="codeStyle">f()</span>
              </span>
            </summary>
            <indent-block class="pad10 border codeStyle">
              void f(const std::string& str)<br />
              {<br />
              &nbsp;&nbsp;std::cout << "\n  " << str;<br />
              }
              <spacer-15></spacer-15>
              f("hello Syracuse"); <span class="normal">displays message on console</span>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                method call operator:&nbsp;&nbsp;
                <span class="codeStyle">operator()</span>
              </span>
            </summary>
            <indent-block class="pad10 border codeStyle">
              class X {<br />
              &nbsp;&nbsp;void operator()(const std::string&amp; s) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;std::cout << "\n  " << s;<br />
              &nbsp;&nbsp;}<br />
              };
              <spacer-15></spacer-15>
              X x;<br />
              x("hello");<br />
              x.operator()("hello");
              <spacer-15></spacer-15>
              <span class="normal">
                The last two statements are equivalent.
                <spacer-15></spacer-15>
                We call X a functor because an
                instance can be invoked like a function, as above.
              </span>
            </indent-block>
          </details>
        </indent-block>
        Users can define invocable functions and methods (functions bound to a specific class), as illustrated
        above.
        <spacer-15></spacer-15>
        <a href="https://en.cppreference.com/w/cpp/language/lambda">Lambdas</a> are locally defined
        callable objects that are useful for starting threads and using STL algorithms.
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">
                Lambda:&nbsp;&nbsp;
                <span class="codeStyle">[](/* args here */) { /* code block here */ };</span>
              </span>
            </summary>
            <indent-block class="pad10 border codeStyle">
              auto makeTitle = [](const std::string&amp; title) {<br />
              &nbsp;&nbsp;std::cout << "\n  " << title;<br />
              &nbsp;&nbsp;std::cout << "\n " << std::string(title.size() + 2, '-');<br />
              };
              <spacer-15></spacer-15>
              makeTitle("demonstrate lambda");
              <spacer-15></spacer-15>
              <span class="normal">emits:</span>
              <spacer-15></spacer-15>
              &nbsp;&nbsp;demonstrate lambda<br />
              &nbsp;--------------------
              <spacer-15></spacer-15>
            </indent-block>
          </details>
        </indent-block>
      </indent-block>
      <hr class="spread" />
      <h4>Classes and class relationships:</h4>
      <indent-block>
        C++ classes and structs are identical except that struct members are public by default and
        class members are private by default.  With either, we choose to make some members public with
        a &quot;public:&quot; declaration and others private with &quot;private:&quot;.
        <spacer-15></spacer-15>
        By convention, we use structs to aggregate data, much like std::tuple.  We also use them to
        define code interfaces, as described in Chapter&nbsp;4.
        We use classes to implement some abstraction defined by its public members.  If a class is well
        designed, only its methods have direct access to data it manages.  That allows a class to make
        strong guarantees about the validity of its data.
        <spacer-15></spacer-15>
        Object Oriented Design consists of using classes and class relationships to structure program 
        activities.  Basic classes can be quite simple, defining only methods for managing and accessing
        class state, as discussed here.  The language, however, provides additional design facilities for supporting 
        value or reference type behavior.  We will address those details in Chapter 4.
        <indent-block class="pad10">
          <details>
            <summary><span class="labelStyle lightItem">basic class</span></summary>
            <div class="pad10-15 border codeStyle" style="left:23px;">
              <div class="normal">
                Class Person holds personal data for each instance. These &quot;stats&quot; contain
                name, occupation, and age,
                held in a <span class="codeStyle">std::tuple</span>.
                <spacer-15></spacer-15>
                Instances of the Person class can be copied and assigned because its only data member,
                personStats is a std::tuple.
                The std::tuple and its elements all have correct copy, assignment, and destruction semantics.
                <spacer-15></spacer-15>
                Compiler generated methods for copying, assignment, and destruction do those operations
                on each of a class&apos;s base classes and composed member data items.  In this case, those
                generated operations simply use the std::tuple&apos;s copy, assignment, and destruction operations.
              </div>
              <hidephotosizer-block src="Pictures/PersonCodeLayout.JPG" width="400" class="photoSizerBlock right">
                <span style="font-family:'Comic Sans MS, Tahoma';">
                  <br />
                  Fig 1. Person Class code layout
                </span>
              </hidephotosizer-block>
              <pre class="codeStyle">
class Person {
public:
  using Name = std::string;
  using Occupation = std::string;
  using Age = int;
  using Stats = std::tuple&lt;Name, Occupation, Age&gt;;

  Person(const Stats& sts);
  Stats stats() const;
  void stats(const Stats& sts);
  bool isValid();
  Name name() const;
  Occupation occupation() const;
  void occupation(const Occupation&amp; occup);
  Age age() const;
  void age(const Age&amp; ag);

private:
  Stats personStats;
};
</pre>
              <spacer-15></spacer-15>
              <div class="normal">
                Note that Person defines four type aliases with names that make the class&apos;s code
                readable,
                easer to test, and easer to use.
                <spacer-15></spacer-15>
                It provides getter and setter methods for attributes
                occupation and age that should be changeable, and only a getter for the name attribute
                which should not.
                <spacer-15></spacer-15>
                References:
                <indent-block class="pad10">
                  <a href="CppStoryRepo.html">CppStory Repository</a>
                </indent-block>
              </div>
              <spacer-15></spacer-15>
            </div>
          </details>
        </indent-block>
        There are five relationships between C++ classes: inheritance, composition, aggregation, using, and friendship.
        The first four of these are supported by most object oriented languages.
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">class relationships</summary>
            <div class="pad10-15 codeStyle" style="max-width:95%;">

            </div>
          </details>
        </indent-block>
      </indent-block>
      <hr class="spread" />
      <h4>Templates and specialization</h4>
      <indent-block>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">template functions</summary>
            <div class="pad10-15 codeStyle" style="max-width:95%;">

            </div>
          </details>
        </indent-block>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">overloading template functions</summary>
            <div class="pad10-15 codeStyle" style="max-width:95%;">

            </div>
          </details>
        </indent-block>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">template classes</summary>
            <div class="pad10-15 codeStyle" style="max-width:95%;">

            </div>
          </details>
        </indent-block>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">template class specialization</summary>
            <div class="pad10-15 codeStyle" style="max-width:95%;">

            </div>
          </details>
        </indent-block>
      </indent-block>
      <hr class="spread" />
      <h4>Libraries</h4>
      <indent-block>
          <indent-block class="pad10">
            <details>
              <summary class="labelStyle lightItem">standard C++ libraries</summary>
              <div class="pad10-15 codeStyle" style="max-width:95%;">

              </div>
            </details>
          </indent-block>
        </indent-block>
        <indent-block>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">custom libraries</summary>
            <div class="pad10-15 codeStyle" style="max-width:95%;">

            </div>
          </details>
        </indent-block>
      </indent-block>
    </indent-block>
  </indent-block>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>