<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_Survey.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Survey</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
    .pad10-15 {
      padding:10px 15px;
    }
    .codeStyle {
      font-family:Consolas, monospace;
      font-weight:bold;
      font-size:1.0em;
    }
    .labelStyle {
      font-family: sans-serif;
      /*font-weight:bold;*/
      font-size:1.0em;
    }
    .normal {
      font-weight:normal;
      font-size:1.0em;
      font-family:Tahoma;
    }
    summary {
      width:max-content;
    }
    summary ~ div {
      width:max-content;
      background-color:#eee;
    }
    summary ~ indent-block {
      width:max-content;
      padding-left:20px;
      padding-right:20px;
      background-color:#eee;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #1&nbsp;-&nbsp;C++ Survey</h1>
      <h3 id="subtitle">data, operations, classes, templates, libraries</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <indent-block>
    <h3>Survey</h3>
    <indent-block>
      This chapter provides a quick look at programming facilities provided by C++ and its libraries.
      You will find a lot more details, with examples, on these topics in subsequent chapters.
      <ul class="tight pad10">
        <li><a href="https://en.cppreference.com/w/cpp/language/basic_concepts">Basic concepts</a></li>
        <li><a href="https://en.cppreference.com/w/cpp/keyword">Key words</a></li>
        <li><a href="CppModels.html">Models for C++ programs: building, execution, and memory storage</a></li>
      </ul>
      <hr class="spread" />
      <h4>Data Types:</h4>
      <indent-block>
        The C++ programming language provides fundamental types, built into the language,
        additional types provided by the C++ standard libraries, and user-defined types that
        can be designed to provide the same behaviors as fundamental types.
        <spacer-15></spacer-15>
        Fundamental types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="codeStyle lightItem">void, bool, nullptr_t, integral, char, and floating types</span>
            </summary>
            <div style="padding-bottom:10px; margin-left:25px;">
              <ul class="tight">
                <li><span class="codeStyle">void</span> - only type with no values</li>
                <li><span class="codeStyle">bool</span> - values true and false</li>
                <li><span class="codeStyle">std::nullptr_t</span> - type of the nullptr literal</li>
                <li>
                  integral types:
                  <indent-block class="pad10 codeStyle">
                    int <span class="normal">with qualifiers:</span> short, long, long long, unsigned, const, volatile<br />
                    std::size_t, std::size_type
                  </indent-block>
                </li>
                <li>
                  character types:
                  <indent-block class="pad10 codeStyle">
                    char, wchar_t <span class="normal">with qualifiers:</span> signed, unsigned<br />
                    <span class="normal">unicode characters:</span> char16_t, char32_t, char8_t (C++20)
                  </indent-block>
                </li>
                <li>
                  floating point types:
                  <indent-block class="pad10 codeStyle">
                    float, double <span class="normal">with qualifiers:</span> long, long long, const, volatile
                  </indent-block>
                </li>
                <li>
                  arrays, pointers, and references:
                  <indent-block class="pad10 codeStyle">
                    array &nbsp;&nbsp;&nbsp;&nbsp;--> T t[N], N <span class="normal">is a compile-time constant</span><br />
                    pointer &nbsp;&nbsp;--> U* pU = &u; &nbsp;&amp; <span class="normal">on the right side => address</span><br />
                    reference --> V&amp; v2 = v1; &nbsp;&amp <span class="normal">on left side => C++ reference</span>
                  </indent-block>
                </li>
              </ul>
              <indent-block class="pad10">
                References:
                <indent-block>
                  <a href="https://en.cppreference.com/w/cpp/language/types">cppreference.com/types</a>
                </indent-block>
              </indent-block>
            </div>
          </details>
        </indent-block>
        C++ standard libraries provide a large set of pre-defined types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">
                STL sequential and associative containers, container adapters
              </span>
            </summary>
            <indent-block class="pad10">
              sequential containers:
              <indent-block class="pad10 codeStyle">
                string, array, vector, deque, forward_list, list<br />
              </indent-block>
              associative containers:
              <indent-block class="pad10 codeStyle">
                set, map, multiset, multimap, unordered_set, unordered_map,
                unordered_multiset, unordered_multimap<br />
              </indent-block>
              container adapters:
              <indent-block class="pad10 codeStyle">
                queue, priority_queue, stack
              </indent-block>
              <indent-blocks class="pad10">
                References:
                <indent-block>
                  <a href="https://en.cppreference.com/w/cpp/container">cppreference.com/container</a><br />
                  <a href="STL-Containers.html">STL-Containers.html</a>
                </indent-block>
                <spacer-15></spacer-15>
              </indent-blocks>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                Special containers, streams, and other types
              </span>
            </summary>
            <indent-block class="pad10">
              special containers:
              <indent-block class="pad10 codeStyle">
                pair, tuple, initializer_list, any, optional, variant,
              </indent-block>
              stream types:
              <indent-block class="pad10 codeStyle">
                istream, ostream, ifstream, ofstream, istringstream, ostringstream,
              </indent-block>
              other types:
              <indent-block class="pad10 codeStyle">
                exception, chrono <span class="normal">(dates and times)</span>, unique_ptr, shared_ptr
              </indent-block>
              <indent-blocks class="pad10">
                References:
                <indent-block>
                  <a href="https://en.cppreference.com/w/cpp/header">cppreference.com/header</a>
                </indent-block>
                <spacer-15></spacer-15>
              </indent-blocks>
            </indent-block>
          </details>
        </indent-block>
        User defined types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">enum, struct, and class</span>
            </summary>
            <indent-block class="pad10">
              scoped enum:
              <indent-block class="pad10 codeStyle">
                enum class Color { red, green, blue };<br />
                Color r = Color::red;
              </indent-block>
              struct:
              <indent-block class="pad10 codeStyle">
                struct S { int i; double d; };<br />
                S s { 2, 3.1415927 };
              </indent-block>
              class:
              <indent-block class="pad10 codeStyle">
                class X {<br />
                public:<br />
                &nbsp;&nbsp;void set(const std::string&amp; s);<br />
                &nbsp;&nbsp;std::string get();<br />
                private:<br />
                &nbsp;&nbsp;std::string str;<br />
                };
              </indent-block>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">type alias</span>
            </summary>
            <indent-block class="pad10">
              alias - c++11:
              <indent-block class="pad10 codeStyle">
                using [aliasName] = [typeName];
              </indent-block>
              alias - C++98:
              <indent-block class="pad10 codeStyle">
                typedef [typeName] [aliasName];
              </indent-block>
            </indent-block>
          </details>
        </indent-block>
        Type testing:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">compile-time and run-time testing</span>
            </summary>
            <indent-block class="pad10">
              compile-time type tests:
              <indent-block class="pad10 codeStyle">
                <a href="https://en.cppreference.com/w/cpp/header/type_traits">std::type_traits</a>
                <span class="normal">, user-defined</span> type-traits;
              </indent-block>
              run-time type tests:
              <indent-block class="pad10 codeStyle">
                <a href="https://en.cppreference.com/w/cpp/types/type_info">std::type_info</a>
              </indent-block>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
        </indent-block>
        We will cover many of these in Chapter 2 - Data.
        <spacer-15></spacer-15>
      </indent-block>
      <hr class="spread" />
      <h4>Operations:</h4>
      <indent-block>
        C++ provides unary and binary operations for the fundamental types.  It also provides
        operator functions that may be overloaded for user defined types.
        <spacer-15></spacer-15>
        Some of the most used <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">operators</a>
        are illustrated here for both fundamental and user-defined types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">
                dereference and address of:&nbsp;&nbsp;
                <span class="codeStyle">* &amp;</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              struct X { Y y; ... }; X x1; Y y;<br />
              X* pX = &amp;x1;
              <span class="normal">sets pointer</span>
              pX &#949; X*
              <span class="normal">to address of instance</span> x1 &#949; X<br />
              X x2 = *pX;
              <span class="normal">instance</span> x2 &#949; X
              <span class="normal">gets copy of contents of </span>x1
              <span class="normal">pointed to by</span> pX
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                member access operations:&nbsp;&nbsp;
                <span class="codeStyle">. -></span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              struct X { int y; ... }; X x{ 2, ... }; X* pX = &amp;x;<br />
              x.y, pX->y <span class="normal">both refer to value of</span>
              y<span class="normal">, e.g., </span> 2<span class="normal">, contained in struct</span> X
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                pre increment and decrement:&nbsp;&nbsp;
                <span class="codeStyle">++i --i</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              int i{ 0 }; ++i; --i;<br />
              ++i <span class="normal">increments</span>
              i <span class="normal">and returns value</span> 1<br />
              --i <span class="normal">decrements</span>
              i <span class="normal">and returns value</span> 0
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                post increment and decrement:&nbsp;&nbsp;
                <span class="codeStyle">i++ i--</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              int i{ 0 }; i++; i--;<br />
              i++ <span class="normal">increments value to</span> 1
              <span class="normal">and returns prior value</span> 0<br />
              i-- <span class="normal">decrements value to</span> 0
              <span class="normal">and returns prior value</span> 1<br />
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                logical operators:&nbsp;&nbsp;
                <span class="codeStyle">== != &lt; &lt;= &gt;= &gt; &amp;&amp; || !</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              Here, we illustrate how a user defined type could implement<br />
              two of these logical operations:
              <spacer-15></spacer-15>
              struct X {<br />
              &nbsp;&nbsp;int i; double d;<br />
              &nbsp;&nbsp;bool operator==(const X&amp; x) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;return i == x.i && d == x.d;<br />
              &nbsp;&nbsp;}<br />
              &nbsp;&nbsp;bool operator!=(const X&amp; x) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;return i != x.i || d != x.d;<br />
              &nbsp;&nbsp;}<br />
              };
              <spacer-15></spacer-15>
              X x1{ 1, 1.5 }, x2{ 1, 1.5 }; x3{ 2, -0.5 }<br />
              x1 == x2; x1 != x3;
              <spacer-15></spacer-15>
              <span class="normal">Both statements above are true.</span>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                index operator:&nbsp;&nbsp;
                <span class="codeStyle">a[]</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              double a[] { 1.0, 1.5, 2.0 };
              <spacer-15></spacer-15>
              a[1] == 1.5 <span class="normal">has value</span> true
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                arithmetic operations:&nbsp;&nbsp;
                <span class="codeStyle">+ - * /</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              int x1{ 2 }; int x2{ 4 };<br />
              x1 + x2 == 6;
              x1 - x2 == -2;
              x1 * x2 == 8;
              x2 / x1 == 2;<br />
              <span class="normal">All of the boolean expressions above are true</span>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                function call operator:&nbsp;&nbsp;
                <span class="codeStyle">f()</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              void f(const std::string& str)<br />
              {<br />
              &nbsp;&nbsp;std::cout << "\n  " << str;<br />
              }
              <spacer-15></spacer-15>
              f("hello Syracuse"); <span class="normal">displays message on console</span>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                method call operator:&nbsp;&nbsp;
                <span class="codeStyle">operator()</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              class X {<br />
              &nbsp;&nbsp;void operator()(const std::string&amp; s) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;std::cout << "\n  " << s;<br />
              &nbsp;&nbsp;}<br />
              };
              <spacer-15></spacer-15>
              X x;<br />
              x("hello");<br />
              x.operator()("hello");
              <spacer-15></spacer-15>
              <span class="normal">
                The last two statements are equivalent.
                <spacer-15></spacer-15>
                We call X a functor because an
                instance can be invoked like a function, as above.
              </span>
            </indent-block>
          </details>
        </indent-block>
        Users can define invocable functions and methods (functions bound to a specific class), as illustrated
        above.
        <spacer-15></spacer-15>
        <a href="https://en.cppreference.com/w/cpp/language/lambda">Lambdas</a> are locally defined
        callable objects that are useful for starting threads and using STL algorithms.
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">
                Lambda:&nbsp;&nbsp;
                <span class="codeStyle">[](/* args here */) { /* code block here */ };</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              auto makeTitle = [](const std::string&amp; title) {<br />
              &nbsp;&nbsp;std::cout << "\n  " << title;<br />
              &nbsp;&nbsp;std::cout << "\n " << std::string(title.size() + 2, '-');<br />
              };
              <spacer-15></spacer-15>
              makeTitle("demonstrate lambda");
              <spacer-15></spacer-15>
              <span class="normal">emits:</span>
              <spacer-15></spacer-15>
              &nbsp;&nbsp;demonstrate lambda<br />
              &nbsp;--------------------
              <spacer-15></spacer-15>
            </indent-block>
          </details>
        </indent-block>
      </indent-block>
      <hr class="spread" />
      <h4>Classes and class relationships:</h4>
      <indent-block>
        C++ classes and structs are identical except that struct members are public by default and
        class members are private by default.  With either, we choose to make some members public with
        a &quot;public:&quot; declaration and others private with &quot;private:&quot;.
        <spacer-15></spacer-15>
        By convention, we use structs to aggregate data, much like std::tuple.  We also use them to
        define code interfaces, as described in Chapter&nbsp;4.
        We use classes to implement some abstraction defined by its public members.  If a class is well
        designed, only its methods have direct access to data it manages.  That allows a class to make
        strong guarantees about the validity of its data.
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">basic class</summary>
            <div class="pad10-15 codeStyle" style="max-width:90%;">
              <div class="normal">
                Class Person holds personal data for each instance. These &quot;stats&quot; contain
                name, occupation, and age,
                held in a <span class="codeStyle">std::tuple</span>.
                <spacer-15></spacer-15>
                Instances of the Person class can be copied and assigned because its only data member,
                personStats is a std::tuple.<br />
                The std::tuple and its elements all have correct copy, assignment, and destruction semantics.
                <spacer-15></spacer-15>
                Compiler generated methods for copying, assignment, and destruction do those operations
                on each of a class&apos;s base classes and composed member data items.  In this case, those
                generated operations simply use the std::tuple&apos;s copy, assignment, and destruction operations.
              </div>
              <photosizer-block src="Pictures/PersonCodeLayout.JPG" width="400" class="photoSizerBlock right">
                <span style="font-family:'Comic Sans MS, Tahoma';">
                  <br />
                  Fig 1. Person Class code layout
                </span>
              </photosizer-block>
              <pre class="codeStyle">
class Person {
public:
  using Name = std::string;
  using Occupation = std::string;
  using Age = int;
  using Stats = std::tuple&lt;Name, Occupation, Age&gt;;

  Person(const Stats& sts);
  Stats stats() const;
  void stats(const Stats& sts);
  bool isValid();
  Name name() const;
  Occupation occupation() const;
  void occupation(const Occupation&amp; occup);
  Age age() const;
  void age(const Age&amp; ag);

private:
  Stats personStats;
};
</pre>
              <spacer-15></spacer-15>
              Note that Person defines four type aliases with names that make the class&apos;s code
              readable,
              easer to test, and easer to use.  
              <spacer-15></spacer-15>
              It provides getter and setter methods for attributes
              occupation and age that should be changeable, and only a getter for the name attribute
              which should not.
              <spacer-15></spacer-15>
            </div>
          </details>
        </indent-block>
      </indent-block>
      <hr class="spread" />
      <h4>Templates and specialization</h4>
      <hr class="spread" />
      <h4>Libraries</h4>
    </indent-block>
  </indent-block>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>