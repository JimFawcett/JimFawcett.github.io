<!DOCTYPE html>
<html>
<!--
  CppStory_Survey.html
-->
<head>
  <title>C++ Story Survey</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeBlue.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesCppStory.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }


    .gray {
      background-color: #ddd;
    }

    .spread {
      margin: 1em;
    }

    .tightSpread {
      margin: 0.5em;
    }
    #github #pagetitle {
      background-color: #002147;
      color: #fafaff;
    }

    #github #title {
      background-color: #002147;
      color: #fafaff;
    }

    #github #subtitle {
      background-color: #002147;
      color: #fafaff;
    }

    #github a.repoLink {
      background-color: #002147;
      color: #fafaff;
    }

    #github a.repoLink:link {
      background-color: #002147;
      color: #fafaff;
    }
    #github c-s {
      font-size:small;
    }
    #github defn-code {
      font-size:small;
    }
    #github .codeStyle {
      font-family:Consolas;
      font-size:small;
      font-weight:bold;
    }
    #github h3 {
      margin-top: 1.0em;
      margin-bottom: 1.0em;
    }
    #github h4 {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }
    #github .normal {
      font-weight:normal;
      font-size:small;
    }
    #github .spreadup {
      margin-top:1em;
    }
  </style>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="CppStory_Data.html">Next</a>
  <a id="Prev" href="CppStory_Models.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="modified">10/17/2022</div>
      <div id="page">C++ Story Survey</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <header>
          <a class="repoLink" href="https://github.com/JimFawcett/CppStory">CppStory</a>
          <hgroup id="pagetitle">
            <h1 id="title">Chapter #2&nbsp;-&nbsp;C++ Survey</h1>
            <h3 class="indent" id="subtitle">data, operations, classes, templates, libraries</h3>
          </hgroup>
        </header>

        <!--<toc-b id="toc">
          <div style="display:flex; flex-direction:row">
            <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Chaps</a>&nbsp;
            <a href="Javascript:;" onclick="storyMenu.sects()" style="color:#fefefa;">Sects</a>&nbsp;
            <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">close</a>&nbsp;
          </div>
          <up-b id="chaps" onmouseout="storyMenu.chaps()">
            <a href="CppStory_Prologue.html">Prologue</a><br />
            <a href="CppStory_Models.html">Models</a><br />
            <a href="CppStory_Survey.html">Survey</a><br />
            <a href="CppStory_Data.html">Data</a><br />
            <a href="CppStory_Operations.html">Operations</a><br />
            <a href="CppStory_Classes.html">Classes</a><br />
            <a href="CppStory_ClassRelationships.html">ClassRel</a><br />
            <a href="CppStory_Templates.html">Templates</a><br />
            <a href="CppStory_TemplateMetaprog.html">TMP</a><br />
            <a href="CppStory_Libraries.html">Libraries</a><br />
            <a href="CppStory_LibraryStreams.html">Streams Libraries</a><br />
            <a href="CppStory_LibrarySTL.html">STL Libraries</a><br />
            <a href="CppStory_Interesting.html">Interesting</a>
          </up-b>
          <rt-b id="sects">
            <a href="#top">Top</a>, <a href="#Data">Data</a>, <a href="#Ops">Operations</a>,
            <a href="#Class">Classes</a>, <a href="#Templ">Templates</a>,
            <a href="#Lib">Libraries</a>, <a href="#epilog">Epilogue</a>,
            <a href="#exer">Exercises</a>, <a href="#refs">References</a>,
          </rt-b>
        </toc-b>-->

        <div>
          <h3 id="prologue">2.0  Survey Prologue</h3>
          <indent-blocks>
            <t-b>
              This chapter provides a quick look at programming facilities provided by C++ and its libraries.
              You will find a lot more details, with examples, on these topics in subsequent chapters.
            </t-b>
            <i-b>
              <ul class="tight pad10">
                <li><a href="https://en.cppreference.com/w/cpp/language/basic_concepts">Basic concepts</a></li>
                <li><a href="https://en.cppreference.com/w/cpp/keyword">Key words</a></li>
              </ul>
            </i-b>
            <t-b>
              It is challenging to discuss details of a programming language without using terms and ideas that
              haven&apos;t yet been introduced.  The intent of this chapter is to give you most of the basic ideas so that
              in later chapters, when we use a language construct or idea that hasn&apos;t yet been discussed fully,
              you will be able to follow the discussion, and have some confidence that details of the idea
              will be presented eventually.
            </t-b>
            <h3 id="data">2.1  Data Types</h3>
            <indent-blocks>
              <t-b>
                The C++ programming language provides fundamental types, built into the language,
                additional types provided by the C++ standard libraries, and supports building user-defined types. Those
                can be designed to provide essentially the same behaviors as fundamental types.
              </t-b>
              Fundamental types:
              <indent-block class="pad10">
                <details>
                  <summary class="darkItem labelStyle noWrap" style="font-family:Consolas; font-size:1.075em;">
                    void, bool, nullptr_t, integral, char, and floating types
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block class="pad10 defnBorder">
                    <ul class="tight">
                      <li><span class="codeStyle">void</span> - only type with no values</li>
                      <li><span class="codeStyle">bool</span> - values true and false</li>
                      <li><span class="codeStyle">std::nullptr_t</span> - type of the nullptr literal</li>
                      <li>
                        integral types:
                        <indent-block class="pad10 codeStyle">
                          int <span class="normal">with qualifiers:</span> short, long, long long, unsigned, const, volatile<br />
                          std::size_t, std::size_type
                        </indent-block>
                      </li>
                      <li>
                        character types:
                        <indent-block class="pad10 codeStyle">
                          char, wchar_t <span class="normal">with qualifiers:</span> signed, unsigned, const, volatile<br />
                          <span class="normal">unicode characters:</span> char16_t, char32_t, char8_t (C++20)
                          <t-s>, with qualifiers: const, volatile</t-s>
                        </indent-block>
                      </li>
                      <li>
                        floating point types:
                        <indent-block class="pad10 codeStyle">
                          float, double <span class="normal">with qualifiers:</span> long (double only), const, volatile
                        </indent-block>
                      </li>
                    </ul>
                    <indent-block class="pad10">
                      References:
                      <indent-block>
                        <a href="https://en.cppreference.com/w/cpp/language/types">cppreference.com/types</a>
                      </indent-block>
                    </indent-block>
                    <spacer-10></spacer-10>
                    <defn-head class="defnBorder" style="border-left:none; border-right:none;">Examples:</defn-head>
                    <defn-code class="noBorder" style="font-size:small;">
void demoFundamentalTypes() {

  showTitle("Demo fundamental types");

  int i{ 3 };
  char c{ 'z' };
  double d{ 3.1415927 };
  bool b{ true };

  std::cout << "\n  value of integer i   = " << i;
  std::cout << "\n  value of character c = " << c;
  std::cout << "\n  value of double d    = " << d;
  std::cout << "\n  value of bool b      = " << b;
  std::cout << "\n  value of nullptr     = " << nullptr;
  std::cout << "\n  numerical value of nullptr = " << static_cast&lt;size_t*&gt;(nullptr);
  std::cout << "\n";
}

Demo fundamental types
------------------------
value of integer i   = 3
value of character c = z
value of double d    = 3.14159
value of bool b      = 1
value of nullptr     = nullptr
numerical value of nullptr = 00000000
                    </defn-code>
                  </defn-block>
                </details>
              </indent-block>
              <s-halfEm></s-halfEm>
              Arrays and pointers:
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">
                    arrays
                  </summary>
                  <spacer-10></spacer-10>
                  <div>
                    <defn-block>
                      <defn-body>
                        An array is a fixed size sequence of continguous elements, all of the same type.
                        <spacer-10></spacer-10>
                        T&nbsp;arr[N];&nbsp;&nbsp;<t-s>[ declaration of array </t-s>arr <t-s>]</t-s>
                        <spacer-10></spacer-10>
                        T&nbsp;t&nbsp;=&nbsp;arr[1];
                        <spacer-10></spacer-10>
                        <div class="normal">
                          <c-s>T</c-s> is any default constructable C++ type,
                          <c-s>N</c-s> is a compile-time constant.<br />
                          <c-s>t</c-s> contains the value of the second element
                          of the <c-s>arr</c-s> array
                        </div>
                        <spacer-10></spacer-10>
                      </defn-body>
                      <defn-head class="defnBorderTop">
                        Example:
                      </defn-head>
                      <defn-code style="font-size:small;">
const char* args[] = { "one", "two", "three" };
size_t sizeOfArgsArray = 3;
std::cout << "\n  displaying args[]";
std::cout << "\n  ";
for (size_t i = 0; i < sizeOfArgsArray; ++i) {
  std::cout << args[i] << " ";
}
                      </defn-code>
                      <defn-head class="defnBorderTop">
                        Output
                      </defn-head>
                      <defn-code style="font-size:small;">
displaying args[]
one two three
                      </defn-code>
                    </defn-block>
                  </div>
                </details>
                <t-b>
                </t-b>
                <details>
                  <summary class="labelStyle darkItem">
                    pointers
                  </summary>
                  <spacer-10></spacer-10>
                  <div>
                    <defn-outerBlock>
                      <defn-block>
                        <defn-body>
                          <div style="max-width:30em;">
                            A pointer is a reference to the memory location of a variable, to which it is bound.
                            <div style="padding:0.25em 1em;">
                              <c-s>
                                X x;<br />
                                X*&nbsp;pX&nbsp;=&nbsp;&amp;x;&nbsp;&nbsp;<t-s>[</t-s>&amp;<t-s>&nbsp;on&nbsp;right&nbsp;of&nbsp;assignment&nbsp;is&nbsp;an&nbsp;address]</t-s>
                              </c-s>
                            </div>
                            <c-s>pX</c-s> is a pointer variable containing the address of <c-s>x</c-s>
                            <spacer-10></spacer-10>
                            <c-s>++pX</c-s> increments address stored in pX by <c-s>sizeof(X)</c-s>
                            <spacer-10></spacer-10>
                            Retrieve value referenced by <c-s>pX</c-s> using dereference operator, <c-s>*pX</c-s>, which returns
                            the value of <c-s>x</c-s>.
                          </div>
                        </defn-body>
                      </defn-block>
                      <defn-block>
                        <hidephotosizer-block src="Pictures/PointerImage1.JPG" width="300" class="photoSizerBlock right" style="margin-top:0;">
                          <span style="font-family:'Comic Sans MS, Tahoma';">
                            Fig 1. Pointer to x &epsilon; X
                          </span>
                        </hidephotosizer-block>
                      </defn-block>
                    </defn-outerBlock>
                  </div>
                </details>
                <t-b>
                  Pointers are often used to manage data stored on the C++ native heap:
                </t-b>
                <t-b>
                  <defn-block>
                    <defn-head>Manually allocating storage on heap</defn-head>
                    <defn-code style="font-size:small;">
double* pDbl = new double[2] {1.5, -4.3};
std::cout << "\n  1st element on heap = " << *pDbl;
std::cout << "\n  2nd element on heap = " << *(pDbl + 1) << std::endl;
delete[] pDbl;
// allocator has to remember array size and remember to delete when
// array is no longer needed.
                    </defn-code>
                  </defn-block>
                  <t-b>
                    We rarely write code like this outside a class that carefully manages allocation
                    and deallocation.  We will hear a lot more about this in subsequent chapters.
                    One safe way to manage heap storage is with standard smart pointers, <c-s>std::unique_ptr</c-s>
                    and <c-s>std::shared_ptr</c-s>.
                  </t-b>
                  <defn-block>
                    <defn-head>Using std::unique_ptr</defn-head>
                    <defn-code style="font-size:small;">
/*-- std::unique_ptr to scalar uses pointer syntax --*/

displayDemo("--- creating double on heap with unique_ptr ---");
auto ptr0 = std::unique_ptr&lt;double&gt;(new double{ -1.5 });
std::cout << "\n  element on heap = " << *ptr0 << std::endl;
ptr0.release();

/*-- std::unique_ptr to array uses array syntax --*/

displayDemo("--- creating small array of doubles on heap with unique_ptr ---");
auto ptr1 = std::unique_ptr&lt;double[]&gt;(new double[2]{ -1.5, 3.2 });
std::cout << "\n  1st element on heap = " << ptr1[0];
std::cout << "\n  2nd element on heap = " << ptr1[1] << std::endl;
ptr1.release();

/*-- see references at end of chapter for unique_ptr --*/
                    </defn-code>
                  </defn-block>
                </t-b>
                <t-b>
                  This is safer than manual allocation.  The heap allocation will always be returned.
                  If we didn&apos;t call <c-s>release()</c-s> the allocation would be returned when the
                  unique_ptr went out of scope.
                </t-b>
                <!--<t-b>
      It is usually preferable to use a <c-s>std::vector</c-s> instead of smart pointers.
    </t-b>-->
                <s-5px></s-5px>
                <details>
                  <summary class="darkItem labelStyle">
                    Example:&nbsp;&nbsp;Reading command line arguments
                  </summary>
                  <t-b>
                    In this example, of arrays and pointers, command line arguments are displayed on
                    the console using
                    main&apos;s argv[] array, then again using equivalent pointers.
                  </t-b>
                  <defn-outerBlock>
                    <defn-block>
                      <defn-head>Example Code</defn-head>
                      <defn-code style="font-size:small;">
int main(int argc, char* argv[]) {

  std::cout << "\n  displaying command line arguments using array";
  std::cout << "\n  ";
  for (int i = 0; i < argc; ++i) {
    std::cout << argv[i] << " ";
    if ((i + 1) % 2)
    std::cout << "\n  ";
  }
  std::cout << "\n  ";

  std::cout << "\n  displaying command line arguments using pointer";
  std::cout << "\n  ";
  char** ptr = argv;
  for (int i = 0; i < argc; ++i) {
    std::cout << *(ptr++) << " ";
    if ((i + 1) % 2)
    std::cout << "\n  ";
  }
  std::cout << "\n\n  ";
}
                      </defn-code>
                    </defn-block>
                    <defn-block>
                      <defn-head>Output</defn-head>
                      <defn-code style="font-size:small;">
// displaying command line arguments using array

chapter1-survey.exe
/P ..
/p *.h;*.cpp
/R ^template
/H

displaying command line arguments using pointer
chapter1-survey.exe
/P ..
/p *.h;*.cpp
/R ^template
/H
                      </defn-code>
                    </defn-block>
                  </defn-outerBlock>
                </details>
              </indent-block>
              <t-b>
                C++ references are used to pass function arguments by reference:
              </t-b>
              <indent-block>
                <details>
                  <summary class="labelStyle darkItem">
                    C++ references
                  </summary>
                  <t-b style="max-width:40em;">
                    <defn-block>
                      <defn-body>
                        <c-s>X&amp; xr = x;</c-s>&nbsp;&nbsp;[ declaration of reference <c-s>xr</c-s> bound to <c-s>x</c-s> ]
                        <t-b>
                          Unlike pointers, C++ reference types cannot be reset.  The instance referred to, <c-s>x</c-s>,
                          is always defined in the reference declaration and cannot be changed.
                          The value of <c-s>xr</c-s> is always the value of <c-s>x</c-s>, which can be changed.
                        </t-b>
                        <t-b>
                          It is useful to think of a reference as another name for the referenced instance.
                        </t-b>
                        <t-b>
                          References are most often used to pass arguments to a function by reference.
                        </t-b>
                        <t-b>
                          Passing an argument to a function by value, <c-s>f(T t)</c-s>, copies the argument&apos;s value to the function&apos;s
                          stack frame.
                        </t-b>
                        <t-b>
                          Passing a parameter by reference, <c-s>f(T&amp; t)</c-s>,
                          simply creates a small reference in the function&apos;s stack frame, bound to the parameter in the caller&apos;s
                          scope, instead of copying what could be a much larger object.
                        </t-b>
                      </defn-body>
                    </defn-block>
                  </t-b>
                </details>
              </indent-block>
              <s-halfEm></s-halfEm>
              <t-b>
                C++ standard libraries provide a large set of pre-defined types:
              </t-b>
              <indent-block>
                <details>
                  <summary class="labelStyle darkItem">
                    STL sequential and associative containers, container adapters
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-head class="noBorderBottom">
                      sequential containers - linear sequence of elements:
                    </defn-head>
                    <defn-body>
                      <i-b>
                        <table>
                          <tr>
                            <td><c-s>string, array, vector, deque</c-s></td>
                            <td>contiguous memory storage, can be indexed</td>
                          </tr>
                          <tr>
                            <td>forward_list, list</td>
                            <td class="normal">nodes allocated on heap, cannot be indexed</td>
                          </tr>
                        </table>
                      </i-b>
                    </defn-body>
                    <defn-head class="noBorderBottom">
                      associative containers - key based storage on heap:
                    </defn-head>
                    <defn-body>
                      <i-b>
                        <table>
                          <tr>
                            <td><c-s>set, multiset, unordered_set, unordered_multiset</c-s></td>
                            <td>key only storage using balanced binary tree or hash table</td>
                          </tr>
                          <tr>
                            <td><c-s>map, multimap, unordered_map, unordered_multimap</c-s></td>
                            <td>key-value storage using balanced binary tree or hash table</td>
                          </tr>
                        </table>
                      </i-b>
                    </defn-body>
                    <defn-head class="noBorderBottom">
                      container adapters:
                    </defn-head>
                    <defn-body>
                      <i-b>
                        <table>
                          <tr>
                            <td><c-s>queue, stack</c-s></td>
                            <td>sequential containers accessible only from end(s)</td>
                          </tr>
                          <tr>
                            <td><c-s>priority_queue</c-s></td>
                            <td>constant time lookup of largest element, logarithmic insertion and extraction</td>
                          </tr>
                        </table>
                      </i-b>
                    </defn-body>
                    <defn-head class="noBorderBottom">
                      References:
                    </defn-head>
                    <defn-body>
                      <i-b>
                        <a href="https://en.cppreference.com/w/cpp/container">cppreference.com/container</a><br />
                        <a href="STL-Containers.html">STL-Containers.html</a>
                      </i-b>
                      <s-1em></s-1em>
                    </defn-body>
                  </defn-block>
                </details>
                <div style="height:0.25em;"></div>
                <details>
                  <summary class="labelStyle darkItem">
                    Example: Sum elements in container using std::vector and std::for_each
                  </summary>
                  <indent-blocks>
                    <t-b style="max-width:50em;">
                      Example using <c-s>std::vector&lt;int&gt;</c-s> and <c-s>for_each</c-s> algorithm.  We
                      will use lambdas in this example, so you may wish to first peek at the lambda discussion at
                      the end of the Operations section.
                    </t-b>
                    <defn-outerBlock>
                      <defn-block>
                        <defn-head>Example Code</defn-head>
                        <defn-code>
std::vector&lt;int&gt; test{ 1, 2, 3, 4, 5 };
std::string prefix = "\n  ";
auto show = [&](auto element) {  // peek at lambda, below
  std::cout << prefix << element;
  prefix = ", ";
};
std::for_each(test.begin(), test.end(), show);

int sum = 0;
auto sumer = [&sum](auto element) { sum += element; };
std::for_each(test.begin(), test.end(), sumer);
std::cout << "\n  sum = " << sum;
                        </defn-code>
                      </defn-block>
                      <defn-block>
                        <defn-head>Output</defn-head>
                        <defn-code>
1, 2, 3, 4, 5
sum = 15
                        </defn-code>
                      </defn-block>
                    </defn-outerBlock>
                  </indent-blocks>
                </details>
                <div style="height:0.25em;"></div>
                <details>
                  <summary class="labelStyle darkItem">
                    Special containers, streams, and other types
                  </summary>
                  <spacer-10></spacer-10>
                  <t-b class="pad10-15 defnBorder">
                    <span class="notice">special containers:</span>
                    <indent-block class="pad10 codeStyle">
                      <table width="100%">
                        <tr>
                          <td>pair</td>
                          <td class="normal">contains two elements which may have distinct types</td>
                        </tr>
                        <tr>
                          <td>tuple</td>
                          <td class="normal">contains finite number of elements with distinct types</td>
                        </tr>
                        <tr>
                          <td>initializer_list</td>
                          <td class="normal">
                            contains sequence of elements, all of the same type
                            normally filled with initialization list, e.g., { 1, 2, 3, ... }
                          </td>
                        </tr>
                        <tr>
                          <td>any</td>
                          <td class="normal">holds value of any type, provides std::any_cast for retrieval</td>
                        </tr>
                        <tr>
                          <td>optional</td>
                          <td class="normal">used to return values or signal failure to return</td>
                        </tr>
                        <tr>
                          <td>variant</td>
                          <td class="normal">similar to any, but only holds values from a specified set of types</td>
                        </tr>
                      </table>
                    </indent-block>
                    <span class="notice">stream types:</span>
                    <indent-block class="pad10 codeStyle">
                      <table>
                        <tr>
                          <td>istream</td>
                          <td class="normal">
                            sends sequence of values of fundamental types to console using insertion operator&lt;&lt;,
                            which may be overloaded for user-defined types.
                          </td>
                        </tr>
                        <tr>
                          <td>ostream</td>
                          <td class="normal">
                            retrieves sequence of values of fundamental types from keyboard using extraction operator&gt;&gt;,
                            which may be overloaded for user-defined types.
                          </td>
                        </tr>
                        <tr>
                          <td>ifstream</td>
                          <td class="normal">
                            retrieves sequence of values of fundamental types from attached file using extraction operator&lt;&lt;,
                            which may be overloaded for user-defined types.
                          </td>
                        </tr>
                        <tr>
                          <td>ofstream</td>
                          <td class="normal">
                            retrieves sequence of values of fundamental types from attached file using extraction operator&gt;&gt;,
                            which may be overloaded for user-defined types.
                          </td>
                        </tr>
                        <tr>
                          <td>istringstream</td>
                          <td class="normal">
                            retrieves sequence of values of fundamental types from attached in-memory string using extraction operator&lt;&lot;,
                            which may be overloaded for user-defined types.
                          </td>
                        </tr>
                        <tr>
                          <td>ostringstream</td>
                          <td class="normal">
                            retrieves sequence of values of fundamental types from attached in-memory string using extraction operator&gt;&gt;,
                            which may be overloaded for user-defined types.
                          </td>
                        </tr>
                      </table>
                    </indent-block>
                    <span class="notice">other types:</span>
                    <indent-block class="pad10 codeStyle">
                      <table>
                        <tr>
                          <td>unique_ptr&lt;T&gt;</td>
                          <td class="normal">
                            Construction allocates instance t &epsilon; T, destruction deallocates t.  Assignment moves ownership.
                          </td>
                        </tr>
                        <tr>
                          <td>shared_ptr&lt;T&gt;</td>
                          <td class="normal">
                            Reference counted smart pointer, assignment adds counted reference.
                          </td>
                        </tr>
                        <tr>
                          <td>exception</td>
                          <td class="normal">
                            When code error occurs exception instance is &quot;thrown&quot;, then handled by catch clause associated
                            with enclosing try block.
                          </td>
                        </tr>
                        <tr>
                          <td>chrono</td>
                          <td class="normal">
                            Class for managing time durations and dates.
                          </td>
                        </tr>
                      </table>
                    </indent-block>
                    <indent-blocks class="pad10">
                      <span class="notice">References:</span>
                      <indent-block>
                        <a href="https://en.cppreference.com/w/cpp/header">cppreference.com/header</a>
                      </indent-block>
                      <spacer-15></spacer-15>
                    </indent-blocks>
                  </t-b>
                </details>
                <div style="height:0.25em;"></div>
                <details>
                  <summary class="labelStyle darkItem">
                    Example: Write file using file stream and std::optional
                  </summary>
                  <t-b style="max-width:50em;">
                    std::optional&lt;T&gt; is designed to return a value computed in a function
                    if available.  If computation fails (a file open for example)
                    it returns nullptr.
                  </t-b>
                  <defn-block>
                    <defn-code>
std::ofstream ofstrm;

/*--- attempt to open file for writing ---*/

auto fout = [&ofstrm](const std::string& filename) {
  ofstrm.open(filename, std::ios::out);
  std::optional<std::ofstream*> opt = &ofstrm;
  if (!ofstrm.good())
    opt = nullptr;
  return opt;
};
/*--- attempt to write file ---*/

auto opto = fout("testWrite.txt");
if (opto.has_value()) {
  std::string test("\n  this is a test\n");
  auto foptr = opto.value();
  *foptr << test;
  foptr->close();
}
                    </defn-code>
                  </defn-block>
                </details>
              </indent-block>
              <div style="height:0.75em;"></div>
              In the details dropdown, below, you will find a summary of the sizes of many common types.
              <div style="height:0.25em;"></div>
              <indent-block>
                <details>
                  <summary class="labelStyle darkItem">Type instance sizes</summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-head>
                      <span class="notice">Value Sizes</span>
                    </defn-head>
                    <defn-code>
-- limits --
bits in byte =       CHAR_BIT = 8
min value of char =  CHAR_MIN = -128
max value of char =  CHAR_MAX = 127
min value of int =    INT_MIN = -2147483648
max value of int =    INT_MAX = 2147483647
min value of float =  FLT_MIN = 1.17549e-38
max value of float =  FLT_MAX = 3.40282e+38
min value of double = DBL_MIN = 2.22507e-308
max value of double = DBL_MAX = 1.79769e+308

-- integral types --
4 = size of std::nullptr_t
1 = size of enum std::byte
1 = size of bool
1 = size of char
1 = size of signed char
1 = size of unsigned char
2 = size of char16_t
4 = size of char32_t
2 = size of short
4 = size of int
4 = size of unsigned int
4 = size of long
4 = size of unsigned long
8 = size of __int64 <==> long long int
8 = size of unsigned __int64 <==> unsigned long long int
4 = size of unsigned int <==> size_t
---------------------------------
demonstrate integer roll-over:
i = UINT_MAX : 4294967295
i + 1 = 0
---------------------------------

-- character types --
1 = size of char
1 = size of unsigned char
2 = size of wchar_t
2 = size of char16_t
4 = size of char32_t

-- float types --
4 = size of float
8 = size of double
8 = size of long double

-- pointers and references --
4 = size of double *
8 = size of double, note: is double&
8 = size of double <==> sizeof(double&)

pDouble:   00EFFCCC --> 15727820
++pDouble: 00EFFCD4 --> 15727828

-- arrays --
16 = size of int const [4]

-- std::strings --
28 = size of class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::alloc...,
is std::string{}
28 = size of class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::alloc...,
is std::string{ "a std::string" }

-- structs --
1 = size of struct `void __cdecl demoCompoundTypes(void)'::`2'::Empty,
is struct {}
24 = size of struct `void __cdecl demoCompoundTypes(void)'::`2'::Struct,
is struct { 1, 1.5, "a literal string" }

-- function pointers --
executing testFun1(const std::string&)
4 = size of void (__cdecl*)(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,...
executing testFun2()
4 = size of class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::alloc...

-- vector&lt;double&gt; --
16 = size of class std::vector&lt;double,class std::allocator&lt;double&gt; &gt;,
is std::vector&lt;double&gt;{}
16 = size of class std::vector&lt;double,class std::allocator&lt;double&gt; &gt;,
is std::vector&lt;double&gt;{ -0.5, 0, 0.5, 1.0, 1.5 }

-- vector&lt;double&gt;::iterator --
12 = size of class std::_Vector_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_type...,
is vector&lt;double&gt;::iterator

-- unordered_map&lt;std::string, int&gt; --
40 = size of class std::unordered_map&lt;class std::basic_string&lt;char,struct std::char_trai...,
is std::unordered_map&lt;std::string, int&gt;{}
40 = size of class std::unordered_map&lt;class std::basic_string&lt;char,struct std::char_trai...,
is std::unordered_map&lt;std::string, int&gt;{ {"one", 1}, ... }

-- unordered_map&lt;std::string,int&gt;::iterator --
12 = size of class std::_List_iterator&lt;class std::_List_val&lt;struct std::_List_simple_typ...,
is std::unordered_map&lt;std::string, int&gt;::iterator

-- display vector contents in rows of N --
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
17

-- miscellaneous types --
1 = size of enum std::byte
4 = size of unsigned int, is size_type
48 = size of class std::tuple&lt;int,double,class std::basic_string&lt;char,struct std::char_t...
4 = size of class std::unique_ptr&lt;double,struct std::default_delete&lt;double&gt; &gt;
8 = size of class std::shared_ptr&lt;double&gt;
8 = size of class XwithDouble &lt;==&gt; instance of class with double member
4 = size of class XwithRef    &lt;==&gt; instance of class with double& member
8 = size of class XwithDouble &lt;==&gt; class with double member
4 = size of class XwithRef    &lt;==&gt; class with double& member
4 = size of std::nullptr_t
80 = size of class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt;    &lt;==&gt; std::cout
80 = size of class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt;    &lt;==&gt; std::ostream
The meaning of life is 42
4 = size of class &lt;lambda_cb1c8eb6ab7293ad79a4f9e6fdc0cd2e&gt;

28 = size of class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::alloc...
4 = size of char const *
content of a std::string
string size = 25
allocation size = 31
                    </defn-code>
                  </defn-block>
                </details>
              </indent-block>
              <div style="height:0.25em;"></div>
              <h4 id="userdeft">2.1.1  User Defined Types</h4>
              User defined types: <span class="notice">enums, structs, classes, and type aliases</span>
              <indent-block class="pad10">
                <t-b>An enum is a sequence of named integral values. Enums are often used as case selectors in switch statements.</t-b>
                <details>
                  <summary class="labelStyle darkItem">
                    scoped enum: enum class E { ... };
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-code>
enum class Color { red, green, blue };
Color color;
---
if(color == Color::red) {
  doRedThing();
}
---
                    </defn-code>
                  </defn-block>
                </details>
                <spacer-15></spacer-15>
                <t-b>
                  Structs are just like classes except that struct members are public by default, where class members are by default private.
                  Often we use structs as in implementation detail holding a collection of values with heterogeneous types.
                </t-b>
                <details>
                  <summary class="labelStyle darkItem">
                    struct S { ... };
                  </summary>
                  <div style="height:0.25em;"></div>
                  <defn-block>
                    <defn-code>
struct S {
  int i; double d;
};
S s { 2, 3.1415927 };
int j = s.i;
double e = s.d;
                    </defn-code>
                  </defn-block>
                </details>
                <t-b>
                  Usually, classes build program abstractions.  That is, a class represents some domain entity like
                  an order or product.  They are also used to build implementation abstractions like blocking queues and thread pools.
                  You will hear more about blocking queues and thread pools later in this story.
                </t-b>
                <details>
                  <summary class="labelStyle darkItem">
                    class C { ... };
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-code>
class X {
  public:
  void set(const std::string&amp; s);
  std::string get();
  private:
  std::string str;
};
                    </defn-code>
                  </defn-block>
                </details>
                <t-b>
                  A type alias simply provides another name for an existing type.  Surprisingly they are very useful for making code
                  readable. We might provide a type alias, fileName, for the std::string type. That helps readers of the code understand
                  that values for this string are the names of files.  We can use filename any place that the language accepts a std::string,
                  e.g., as a function parameter type.
                </t-b>
                <details>
                  <summary class="labelStyle darkItem">
                    type alias: using AliasName = Sometype;
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block style="max-width:40em;">
                    <defn-body>
                      Aliases are designed to provide application specific domain names for standard types
                      and to provide short names for template types with many template parameters.
                    </defn-body>
                    <defn-body class="pad10" style="border-top:2px solid darkred;">
                      alias - c++11:  <c-s>using VecStr = std::vector&lt;std::string&gt;;</c-s>
                      <spacer-15></spacer-15>
                      alias - C++98:  <c-s>typedef std::vector&lt;std::string&gt; VecStr;</c-s>
                    </defn-body>
                  </defn-block>
                </details>
              </indent-block>
              <indent-block>
                <t-b class="mtz">
                  The ability to test types at compile time allows us to build very flexible template functions and methods. You will hear
                  much more about that below, and especially in Chapter #7 - Templates.
                  <!--<spacer-15></spacer-15>-->
                  Run-time type testing is less often used, but allows us to display the name of the type of some variable and test whether
                  two instances have the same type.
                </t-b>
                <details>
                  <summary class="labelStyle darkItem">
                    Testing types at compile-time and run-time
                  </summary>
                  <defn-block style="max-width:52em;">
                    <defn-body>
                      Compile-time tests use template meta programming.  That will be discussed in
                      detail in Chapter 8. This is here because you will see it used before we get
                      to those details.
                    </defn-body>
                    <defn-body class="defnBorderTop">
                      <span class="notice">compile-time type tests:</span>&nbsp;&nbsp;
                      <a href="https://en.cppreference.com/w/cpp/header/type_traits"><c-s>std::type_traits</c-s></a>
                      <div style="height:0.5em;"></div>
                      <c-s>
                        template&lt;typename T&gt;<br />
                        void display(const T&amp; t) {<br />
                        &nbsp;&nbsp;if constexpr (std::is_fundamental&lt;T&gt;::value) {<br />
                        &nbsp;&nbsp;// do display operations consistent with fundamental types<br />
                        &nbsp;&nbsp;// std::is_fundamental&lt;T&gt; is a std::type-trait<br />
                        }
                      </c-s>
                      <div style="height:0.25em;"></div>
                      <span class="normal">We can also create user-defined </span>type-traits,
                      as discussed in Chapter #8 - Template Metaprogramming.
                      <spacer-10></spacer-10>
                    </defn-body>
                    <defn-body class="defnBorderTop">
                      <spacer-10></spacer-10>
                      <span>
                        <span class="notice">run-time type tests:</span>&nbsp;&nbsp;
                        <a href="https://en.cppreference.com/w/cpp/types/type_info"><c-s>std::type_info</c-s></a>
                      </span>
                      <div class="pad10" style="width:max-content;">
                        <c-s>
                          if(typeid(x1) == typeid(x2)) {<br />
                          &nbsp;&nbsp;// do something knowing that x1 and x2 have the same types<br />
                          &nbsp;&nbsp;// the typeid operator returns a type_info instance. that&apos;s what we are comparing.<br />
                          }
                        </c-s>
                        <div style="height:0.25em;"></div>
                      </div>
                    </defn-body>
                    <defn-body class="defnBorderTop">
                      <span>
                        In the next chapter we will use <c-s>std::type_info</c-s> to display information about
                        types in several examples.
                      </span>
                    </defn-body>
                  </defn-block>
                </details>
              </indent-block>
              <div style="height:0.25em;"></div>
              <h4 id="defdecl">2.1.2  Definitions and Declarations</h4>
              <indent-block class="pad10">
                A type declaration associates a variable name with a type.
                <spacer-10></spacer-10>
                <details>
                  <summary class="labelStyle darkItem">type declaration</summary>
                  <defn-block style="max-width:50em;">
                    <defn-body>
                      A type declaration defines a name associated with a specified type, e.g., a set
                      of operations supported for the named entity, but defines no storage unless it
                      is also a definition.  If not, that must
                      be done later, but before the entity is used.
                    </defn-body>
                    <defn-body class="defnBorderTop">
                      <xt-b>
                        <c-s>extern int x;</c-s>
                        <indent-block class="pad10">
                          The entity x supports all of the operations for ints, but no storage is defined
                          by this statement.
                        </indent-block>
                        <c-s>void f(int i);</c-s>
                        <indent-block class="pad10">
                          Declares f to be a function, to be defined later, accepting a single integer
                          argument and returning nothing.
                        </indent-block>
                        <c-s>class X;</c-s>
                        <indent-block class="pad10">
                          Declares X to be a class to be defined later. X is said to be an incomplete type and
                          the statement is a forward declaration of X.
                        </indent-block>
                        <c-s>class Y { /* operations elided */ };</c-s>
                        <indent-block class="pad10">
                          We often say that class Y is defined by the statement above, but technically it is a
                          declaration, because this statement defines the size required for instances of Y
                          but no storage is allocated.
                        </indent-block>
                      </xt-b>
                    </defn-body>
                  </defn-block>
                </details>
                <div style="height:0.25em;"></div>
                A type definition is a declaration that also allocates, and may initialize, storage for a variable.
                <details>
                  <summary class="labelStyle darkItem">type definition</summary>
                  <spacer-10></spacer-10>
                  <defn-block style="max-width:50em;">
                    <defn-body>
                      A type definition allocates storage for a declared entity of a specified type.
                      The designer can specify the location of that storage, e.g., in static, stack, or
                      heap memory.
                    </defn-body>
                    <defn-body class="defnBorderTop">
                      <c-s>int x; int y{ 2 };</c-s>
                      <indent-block class="pad10">
                        The variable <c-s>x</c-s> is declared and storage is allocated
                        in the local stack frame, and filled with a default value;
                        <spacer-10></spacer-10>
                        The variable <c-s>y</c-s> is declared and storage is allocated in the local stack
                        frame and initialized with the value <c-s>2</c-s>.
                        <spacer-10></spacer-10>
                        <div style="border:1px solid darkred;">
                          Life-time of this storage extends from the point of declaration until the thread
                          of execution leaves the current scope.
                        </div>
                      </indent-block>
                    </defn-body>
                    <defn-body style="border-top:none;">
                      <spacer-10></spacer-10>
                      <c-s>void f(int i) { std::cout << "\n  " << argument has value << i; }</c-s>
                      <indent-block class="pad10">
                        The code within the <c-s>{</c-s> and <c-s>}</c-s> scope delimiters is compiled and allocated
                        to static memory adjacent to other code from the surrounding program.
                        <spacer-10></spacer-10>
                        <div style="border:1px solid darkred;">
                          Life-time of this allocation is the life time of the program after the program&apos;s
                          process has been created until the process begins termination.
                        </div>
                      </indent-block>
                    </defn-body>
                    <defn-body style="border-top:none;">
                      <spacer-10></spacer-10>
                      <c-s>X x; Y y(...);</c-s>
                      <indent-block class="pad10">
                        Reserves storage for <c-s>x &epsilon; X</c-s> in the stackframe for its local scope
                        and initializes that storage with a default value.
                        <spacer-10></spacer-10>
                        Reserves storage in the local stackframe for <c-s>y &epsilon; Y</c-s> and
                        initializes the storage using a Y constructor function that accepts the type(s)
                        specified by the ... elipsis, above.
                        <spacer-10></spacer-10>
                        <div style="border:1px solid darkred;">
                          Life-time of this storage extends from the point of declaration until the thread
                          of execution leaves the current scope.
                        </div>
                      </indent-block>
                    </defn-body>
                    <defn-body style="border-top:none;">
                      <spacer-10></spacer-10>
                      <c-s>static T t;</c-s> where <c-s>T</c-s> is some fundamental or user-defined type
                      <indent-block class="pad10">
                        Allocates storage for variable <c-s>t</c-s> in static memory, adjacent to other code for
                        the program.
                        <spacer-10></spacer-10>
                        <div style="border:1px solid darkred;">
                          Life-time of the memory
                          reservation for <c-s>t</c-s> extends from first use to the end of program
                          execution.
                        </div>
                      </indent-block>
                    </defn-body>
                    <defn-body style="border-top:none;">
                      <spacer-10></spacer-10>
                      <c-s>X* pX = new X;</c-s>
                      <indent-block class="pad10">
                        Allocates storage for the pointer <c-s>pX</c-s> in the local stack frame, and
                        allocates storage in the native heap for an un-named instance of <c-s>X</c-s>.  The storage
                        for <c-s>pX</c-s> is initialized with the heap address of the <c-s>X</c-s> instance, and
                        the storage of the instance of <c-s>X</c-s> is initialized by <c-s>X</c-s>&apos;s default constructor.
                        <spacer-10></spacer-10>
                        <div style="border:1px solid darkred;">
                          Life-time for this storage extends from the time the new operator is invoked
                          until <c-s>delete</c-s> operator is called on <c-s>pX</c-s>.
                        </div>
                      </indent-block>
                    </defn-body>
                  </defn-block>
                </details>
              </indent-block>
              <div class="indent">
                We will provide examples of, and cover many details about, C++ data types in Chapter #3 - Data.
              </div>
            </indent-blocks>
            <h3 id="ops">2.2 Operations</h3>
            <indent-blocks>
              <t-b class="mtz mbz">
                C++ programs consist of an ordered sequence of
                <a href="https://en.cppreference.com/w/cpp/language/statements">statements</a> where a statement is
                an <a href="https://en.cppreference.com/w/cpp/language/expressions">expression</a> followed
                by a semicolon&nbsp;&quot;<c-s>;</c-s>&quot;.
                Expressions may be declarative, operational, iterative, selection, and try-block expression types, and may be
                combinations of these. Declarative statements are compile-time artifacts, disappearing after
                compilation.  All the others generate code that executes at run-time.
              </t-b>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">
                    program scopes
                  </summary>
                  <div>
                    <defn-block style="max-width:50em;">
                      <defn-body>
                        C++ programs are partitioned by scopes, e.g., sequences of statements enclosed within braces
                        <span style="white-space:nowrap;">&quot;<c-s>{</c-s> &quot; and &quot;<c-s>}</c-s>&quot;.</span>
                      </defn-body>
                      <defn-body class="defnBorderTop">
                        <spacer-10></spacer-10>
                        There are several types of scopes:
                        <ul class="tightList indent">
                          <li>
                            <c-s>namespace N { ... }</c-s>
                          </li>
                          <li>
                            <c-s>class C { ... };</c-s>
                          </li>
                          <li>
                            <c-s>struct S { ... }</c-s>
                          </li>
                          <li>
                            <c-s>enum class E { ... }</c-s>
                          </li>
                          <li>
                            <c-s>void f(int i) { ... }</c-s>
                          </li>
                          <li>
                            <c-s>try { ... } catch(execption&amp; ex) { ... }</c-s>
                          </li>
                          <li>
                            <c-s>for(startExpression; endExpression; incrementExpression) { ... }</c-s>
                          </li>
                          <li>
                            <c-s>for(T t : container) { ... }&nbsp;&nbsp;T</c-s> may be replaced by <c-s>auto</c-s>
                          </li>
                          <li>
                            <c-s>while(predicate) { ... }</c-s>
                          </li>
                          <li>
                            <c-s>do { ... } while(predicate);</c-s>
                          </li>
                          <li>
                            <c-s>if(predicate) { ... } else { ... }</c-s>
                          </li>
                        </ul>
                        <spacer-5></spacer-5>
                        The first four are compile-time artifacts that define names, allowed operations,
                        and accessibility.  They disappear after compilation.
                        <spacer-10></spacer-10>
                        The rest are compile-time and run-time constructs that affect execution and
                        execution flow. Any entity declared within these scopes has a life-time that
                        starts at the point of declaration and ends when the thread of execution leaves the scope.
                        <spacer-10></spacer-10>
                        We will discuss all of these run-time operations in this section, below.
                        <spacer-10></spacer-10>
                      </defn-body>
                    </defn-block>
                  </div>
                </details>
              </indent-block>
              <t-b class="mtz mbz">
                C++ provides unary and binary <a href="https://en.cppreference.com/w/cpp/language/expressions">operations</a>
                for the fundamental types.  It also provides operator functions that may be overloaded for
                user-defined types.
                Some of the most used operations and
                <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">operators</a>
                are illustrated here for both fundamental and user-defined types:
              </t-b>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">
                    dereference and address of:&nbsp;&nbsp;
                    <span class="codeStyle">* &amp;</span>
                  </summary>
                  <defn-outerblock>
                    <defn-block style="max-width:50em;">
                      <defn-body>
                        <div>
                          <c-s>
                            struct X { Y y; ... }; X x1; Y y;
                            <div style="height:0.25em;"></div>
                            X* pX = &amp;x1;
                            <div style="height:0.25em;"></div>
                            <span class="normal">sets pointer</span>
                            pX &#949; X*
                            <span class="normal">to address of instance</span> x1 &#949; X
                            <div style="height:0.25em;"></div>
                            X x2 = *pX;
                            <div style="height:0.25em;"></div>
                            <span class="normal">instance</span> x2 &#949; X
                            <span class="normal">gets copy of contents of </span>x1
                            <span class="normal">pointed to by</span> pX 
                            <span class="normal">by dereferencing pointer, </span>
                            pX <span class="normal">and copying value to</span> x2
                          </c-s>
                        </div>
                      </defn-body>
                    </defn-block>
                    <defn-block>
                      <defn-body>
                        <photosizer-block src="Pictures/PointerImage.JPG" width="300" class="photoSizerBlock right" style="margin-top:0;">
                          <span style="font-family:'Comic Sans MS';">
                            Fig 2. Pointer to x &epsilon; X
                          </span>
                        </photosizer-block>
                      </defn-body>
                    </defn-block>
                  </defn-outerblock>
                </details>
                <spacer-15></spacer-15>
                <details>
                  <summary class="labelStyle darkItem">
                    member access operations:&nbsp;&nbsp;
                    <span class="codeStyle">. -></span>
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block style="max-width:50em;">
                    <defn-body>
                      <c-s>
                        struct X { int y; ... };
                        <div style="height:0.25em;"></div>
                        X x{ 2, ... }; X* pX = &amp;x;
                        <div style="height:0.25em;"></div>
                        x.y, pX->y <span class="normal">both refer to value of</span>
                        y<span class="normal">, e.g., </span> 2<span class="normal">, contained in struct</span> X&nbsp;&nbsp;
                      </c-s>
                    </defn-body>
                  </defn-block>
                </details>
                <spacer-15></spacer-15>
                <details>
                  <summary class="labelStyle darkItem">
                    pre increment and decrement:&nbsp;&nbsp;
                    <span class="codeStyle">++i --i</span>
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-body class="codeStyle pad10">
                      int i{ 0 }; ++i; --i;<br />
                      ++i <span class="normal">increments</span>
                      i <span class="normal">and returns value</span> 1<br />
                      --i <span class="normal">decrements</span>
                      i <span class="normal">and returns value</span> 0&nbsp;&nbsp;
                    </defn-body>
                  </defn-block>
                </details>
                <spacer-15></spacer-15>
                <details>
                  <summary class="labelStyle darkItem">
                    post increment and decrement:&nbsp;&nbsp;
                    <span class="codeStyle">i++ i--</span>
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-body class="codeStyle pad10">
                      int i{ 0 }; i++; i--;<br />
                      i++ <span class="normal">increments value to</span> 1
                      <span class="normal">and returns prior value</span> 0<br />
                      i-- <span class="normal">decrements value to</span> 0
                      <span class="normal">and returns prior value</span> 1&nbsp;&nbsp;
                    </defn-body>
                  </defn-block>
                </details>
                <spacer-15></spacer-15>
                <details>
                  <summary class="labelStyle darkItem">
                    logical operators:&nbsp;&nbsp;
                    <span class="codeStyle">== != &lt; &lt;= &gt;= &gt; &amp;&amp; || !</span>
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-body class="codeStyle pad10">
                      Here, we illustrate how a user defined type could implement<br />
                      two of these logical operations:
                      <spacer-15></spacer-15>
                      struct X {<br />
                      &nbsp;&nbsp;int i; double d;<br />
                      &nbsp;&nbsp;bool operator==(const X&amp; x) {<br />
                      &nbsp;&nbsp;&nbsp;&nbsp;return i == x.i && d == x.d;<br />
                      &nbsp;&nbsp;}<br />
                      &nbsp;&nbsp;bool operator!=(const X&amp; x) {<br />
                      &nbsp;&nbsp;&nbsp;&nbsp;return i != x.i || d != x.d;<br />
                      &nbsp;&nbsp;}<br />
                      };
                      <div style="height:0.25em;"></div>
                      X x1{ 1, 1.5 }, x2{ 1, 1.5 }; x3{ 2, -0.5 }<br />
                      x1 == x2; x1 != x3;
                      <div style="height:0.25em;"></div>
                      <span class="normal">Both statements above are true.</span>
                    </defn-body>
                  </defn-block>
                </details>
                <spacer-15></spacer-15>
                <details>
                  <summary class="labelStyle darkItem">
                    index operator:&nbsp;&nbsp;
                    <span class="codeStyle">a[]</span>
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-body class="pad10 codeStyle">
                      double a[] { 1.0, 1.5, 2.0 };
                      <spacer-15></spacer-15>
                      a[1] == 1.5 <span class="normal">has value</span> true
                    </defn-body>
                  </defn-block>
                </details>
                <spacer-15></spacer-15>
                <details>
                  <summary class="labelStyle darkItem">
                    arithmetic operations:&nbsp;&nbsp;
                    <span class="codeStyle">+ - * /</span>
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-body class="pad10 codeStyle">
                      int x1{ 2 }; int x2{ 4 };
                      <div style="height:0.25em;"></div>
                      x1 + x2 == 6;
                      x1 - x2 == -2;
                      x1 * x2 == 8;
                      x2 / x1 == 2;&nbsp;&nbsp;
                      <div style="height:0.25em;"></div>
                      <span class="normal">All of the boolean expressions above are true</span>;
                    </defn-body>
                  </defn-block>
                </details>
                <spacer-15></spacer-15>
                <details>
                  <summary class="labelStyle darkItem">
                    loops:&nbsp;&nbsp;for, while, do
                  </summary>
                  <defn-block class="t-b mtz mbz" style="max-width:50em;">
                    <defn-body class="pad10 codeStyle">
                      <div style="height:1em;"></div>
                      for(int i=0; i&lt;Max; ++i) {
                      <div class="normal indent">
                        Any, or all, of the three loop conditions may be omitted, provided
                        that omitted conditions are defined.  If no termination condition is provided,
                        the loop requires a conditional break statement to terminate.
                        <div style="height:0.25em;"></div>
                        Loop operations elided
                      </div>
                      }
                      <hr class="tightSpread" />
                      for(auto item : collection) {
                      <div class="normal indent">
                        Collection must provide an iterator and methods begin() and end()
                        which return iterators referring to the first element and one past
                        the last of its elements.
                        <div style="height:0.25em;"></div>
                        Loop operations elided
                      </div>
                      }
                      <hr class="tightSpread" />
                      while(predicate) {
                      <div class=" normal indent">
                        <div style="height:0.25em;"></div>
                        Loop operations will not be executed if predicate is false on entry.
                        <div style="height:0.25em;"></div>
                        Loop will continue until operations in scope of the loop
                        make its predicate false.
                        <div style="height:0.25em;"></div>
                        Loop operations elided
                      </div>
                      }
                      <hr class="tightSpread" />
                      do {
                      <div class="normal indent">
                        Ensures that loop operations are executed at least once.
                        <div style="height:0.25em;"></div>
                        Loop will continue until operations in scope of the loop
                        make its predicate false.
                        <div style="height:0.25em;"></div>
                        Loop operations elided
                      </div>
                      <div style="height:0.25em;"></div>
                      } while(predicate);
                      <div style="height:1em;"></div>
                    </defn-body>
                  </defn-block>
                </details>
                <spacer-15></spacer-15>
                <details>
                  <summary class="labelStyle darkItem">
                    selection:&nbsp;&nbsp;if-else, ternary operator, switch
                  </summary>
                  <t-b class="mtz mbz">
                    <defn-block style="max-width:50em;">
                      <defn-body class="pad10 codeStyle">
                        <div style="height:1.25em;"></div>
                        if(predicate) {
                        <div class="normal indent">
                          Operations to execute when predicate is true go here.
                        </div>
                        }<br />
                        else {
                        <div class="normal indent">
                          Operations to execute when predicate is false go here.
                          This else clause is optional.
                        </div>
                        }
                        <hr class="tightSpread">
                        <div class="normal">
                          The ternary operator:
                          <indent-block class="pad10">
                            <c-s>predicate ? e1 : e2</c-s>
                          </indent-block>
                          returns the value of expression <c-s>e1</c-s> if <c-s>predicate</c-s>
                          evaluates to <c-s>true</c-s>, otherwise it returns the value of expression
                          <c-s>e2</c-s>.
                        </div>
                        <hr class="tightSpread">
                        <div class="normal">
                          The switch operation enables execution of code specific to some specified case.
                          <div style="height:0.25em;"></div>
                          switch selectors, <c-s>iSelect</c-s>, and switch cases, <c-s>iSelect1, iSelect2, ...</c-s>
                          belong to a list, IS, of integral selectors, e.g., distinct integers or values of an enumeration:
                          <c-s>iSelect, iSelect1, iSelect2, ... &epsilon; IS</c-s>
                        </div>
                        <div style="height:0.75em;"></div>
                        switch(iSelect) {
                        <div class="indent">
                          case iSelect1:
                          <div class="normal indent">
                            Operations for <c-s>iSelect1</c-s> case go here.
                          </div>
                          &nbsp;&nbsp;break;<br />
                          case iSelect2:
                          <div class="normal indent">
                            Operations for <c-s>iSelect2</c-s> case go here.
                          </div>
                          &nbsp;&nbsp;break;<br />
                          &nbsp;&nbsp;----<br />
                          default:
                          <div class="normal indent">
                            Operations when <c-s>iSelect</c-s> does not match any declared
                            <c-s>iSelect[n]</c-s> case go here.
                          </div>
                        </div>
                        &nbsp;&nbsp;break;<br />
                        }
                        <div style="height:1.25em;"></div>
                      </defn-body>
                    </defn-block>
                  </t-b>
                </details>
                <spacer-15></spacer-15>
                <details>
                  <summary class="labelStyle darkItem">
                    function call operator:&nbsp;&nbsp;
                    <span class="codeStyle">f()</span>
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-body class="pad10 codeStyle">
                      void f(const std::string& str)<br />
                      {<br />
                      &nbsp;&nbsp;std::cout << "\n  " << str;<br />
                      }
                      <div style="height:0.25em;"></div>
                      f("hello Syracuse"); <span class="normal">displays message on console&nbsp;&nbsp;</span>
                    </defn-body>
                  </defn-block>
                </details>
                <spacer-15></spacer-15>
                <details>
                  <summary class="labelStyle darkItem">
                    method call operator:&nbsp;&nbsp;
                    <span class="codeStyle">operator()</span>
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block style="max-width:50em;">
                    <defn-body class="pad10 codeStyle">
                      class X {<br />
                      &nbsp;&nbsp;void operator()(const std::string&amp; s) {<br />
                      &nbsp;&nbsp;&nbsp;&nbsp;std::cout << "\n  " << s;<br />
                      &nbsp;&nbsp;}<br />
                      };
                      <div style="height:0.25em;"></div>
                      X x;<br />
                      x("hello");<br />
                      x.operator()("hello");
                      <div style="height:0.25em;"></div>
                      <span class="normal">
                        The last two statements are equivalent.
                        <spacer-15></spacer-15>
                        We call X a functor because an
                        instance can be invoked like a function, as above.&nbsp;&nbsp;
                      </span>
                    </defn-body>
                  </defn-block>
                </details>
              </indent-block>
              <t-b class="mtz mbz">
                Users can define invocable functions at namespace scope, including the global namespace,
                but cannot define functions in function scope, e.g., no inner functions.
                Users define methods (functions bound to a specific class) in class scope.
                <spacer-15></spacer-15>
                <a href="https://en.cppreference.com/w/cpp/language/lambda">Lambdas</a> are locally defined
                callable objects that are useful for starting threads and using STL algorithms.
              </t-b>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">
                    Lambda:&nbsp;&nbsp;
                    <span class="codeStyle">[/* capture */](/* args */) { /* code block */ };</span>
                  </summary>
                  <spacer-10></spacer-10>
                  <div>
                    <defn-block style="max-width:50em;">
                      <defn-code>
char ul = '-';
auto makeTitle = [ul](const std::string&amp; title) {
  std::cout << "\n  " << title;
  std::cout << "\n " << std::string(title.size() + 2, ul);
};

makeTitle("demonstrate lambda");

<span class="normal">emits:</span>

 demonstrate lambda
--------------------
                      </defn-code>
                      <defn-body class="codeStyle">
                        [ul] <t-s>in the second code line, captures the value of local variable</t-s> ul <t-s>
                          from the local scope
                          and uses it for an underline character, below the title message. The title is passed in
                          as a parameter when lambda,
                        </t-s>makeTitle<t-s>, is invoked.</t-s>
                        <div style="height:1em;"></div>
                      </defn-body>
                    </defn-block>
                  </div>
                </details>
              </indent-block>
              <t-b class="mtz mbz">
                Lambdas may be defined in namespace, function, and method scopes, and so, can serve the role
                of inner functions.  They are useful for much more, as we will see in Chapter #4 - Operations.
              </t-b>
            </indent-blocks>
            <h3 id="classes">2.3  Classes and Class Relationships</h3>
            <indent-blocks>
              <t-b class="mbz">
                C++ classes and structs are identical except that struct members are public by default and
                class members are private by default.  With either, we choose to make some members public with
                a &quot;public:&quot; declaration and others private with &quot;private:&quot;.
              </t-b>
              <spacer-15></spacer-15>
              <t-b class="mtz mbz">
                By convention, we use structs to aggregate data, much like std::tuple.  We also use them to
                define code interfaces, as described in Chapter&nbsp;4.
                We use classes to implement some abstraction defined by its public members.  If a class is well
                designed, only its methods have direct access to data it manages.  That allows a class to make
                strong guarantees about the validity of its data.
              </t-b>
              <spacer-15></spacer-15>
              <t-b class="mbz mtz">
                Object Oriented Design consists of using classes and class relationships to structure program
                activities.  Basic classes can be quite simple, defining only methods for managing and accessing
                class state, as discussed here.  The language, however, provides additional design facilities for supporting
                value or reference type behavior.  We will address those details in Chapter #5 - Classes.
              </t-b>
              <spacer-10></spacer-10>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">basic class</summary>
                  <defn-outerblock>
                    <defn-block style="max-width:50em;">
                      <defn-body class="pad10 autoX">
                        <div class="normal">
                          Class Person declares personal data contained by each instance. These &quot;stats&quot; contain
                          name, occupation, and age,
                          held in a <c-s>std::tuple</c-s>.
                          <div style="height:0.25em;"></div>
                          Instances of the Person class can be copied and assigned because its only data member,
                          personStats is a std::tuple.
                          The std::tuple and its elements all have correct copy, assignment, and destruction semantics.
                          <div style="height:0.25em;"></div>
                          Compiler generated methods for copying, assignment, and destruction do those operations
                          on each of a class&apos;s base classes and composed member data items.  In this case, those
                          generated operations simply use the std::tuple&apos;s copy, assignment, and destruction operations.
                        </div>
                        <div style="height:1em;"></div>
                        <pre class="codeStyle">
class Person {
public:
  using Name = std::string;
  using Occupation = std::string;
  using Age = int;
  using Stats = std::tuple&lt;Name, Occupation, Age&gt;;

  Person();
  Person(const Stats& sts);
  Stats stats() const;
  void stats(const Stats& sts);
  bool isValid();
  Name name() const;
  Occupation occupation() const;
  void occupation(const Occupation&amp; occup);
  Age age() const;
  void age(const Age&amp; ag);

private:
  Stats personStats;
};
                          </pre>
                        <div style="height:0.5em;"></div>
                        <div class="normal">
                          Note that Person defines four type aliases with names that make the class&apos;s code
                          readable,
                          easer to test, and easer to use.
                          <div style="0.25em;"></div>
                          It provides getter and setter methods for attributes
                          occupation and age that should be changeable, and only a getter for the name attribute
                          which should not.
                          <div style="height:0.25em;"></div>
                          References:
                          <indent-block class="pad10">
                            <a href="CppStoryRepo.html">CppStory Repository</a>
                          </indent-block>
                        </div>
                        <div style="height:0.25em;"></div>
                      </defn-body>
                    </defn-block>
                    <defn-block>
                      <div class="pad10-15" style="padding-right:25px;">
                        <photosizer-block src="Pictures/PersonCodeLayout.JPG" width="300" class="photoSizerBlock right">
                          <span style="font-family:'Comic Sans MS', Tahoma;">
                            Fig 1. Person Class code layout
                          </span>
                        </photosizer-block>
                      </div>
                    </defn-block>
                  </defn-outerblock>
                </details>
              </indent-block>
              <spacer-10></spacer-10>
              <t-b class="mbz mtz">
                If you look back at the Person class, in basic class - the previous details, you will see two things that might seem peculiar.
                There are two functions with the same name, Person, and they have no return values.
                C++ classes define constructors for building initialized instances of the class.
                The language recognizes constructors as any function with the same name as the class and no return values.
              </t-b>
              <spacer-15></spacer-15>
              <t-b class="mbz mtz">
                The fact that constructors return no values - not even void - is specified by the language.
                In order to handle two or more functions with the same name, C++ defined function overloading.
              </t-b>
              <spacer-10></spacer-10>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">
                    function overloading
                  </summary>
                  <div>
                    <defn-block style="max-width:50em;">
                      <defn-body class="normal">
                        Function overloading is the definition of two or more functions with the same name
                        but different sequences of argument types<sup>1</sup>.
                        <div class="pad10">
                          Consider the two Person constructors, from the previous &quot;basic class&quot; details:
                        </div>
                        <div class="indent">
                          <c-s>
                            &nbsp;&nbsp;Person();<br />
                            &nbsp;&nbsp;Person(const Stats&amp; sts);<br />
                          </c-s>
                        </div>
                        <div style="height:0.5em;"></div>
                        The second has an sts argument, used to initialize an internal data member.
                        The first has no argument, so the internal data member has a default initialization.
                        <div style="height:0.25em;"></div>
                        C++ classes need the ability to initialize instances in different ways, like this, and since
                        the class&apos;s constructors all have the same name, the compiler has to distinguish
                        between them in some way.
                        <div style="height:0.25em;"></div>
                        It does that by treating a function name concatenated with the types of its arguments<sup>2</sup>
                        as the compiler&apos;s name for that function.  This process of making qualified names
                        is called name-mangling.  That is what enables function overloading.
                        <div style="height:0.25em;"></div>
                        Function overloading is used in most class declarations, but a designer is free to use
                        overloading for other purposes as well.
                        <hr class="spreadup" />
                        <ol class="footnote">
                          <li>
                            Return types play no role in function overloading.
                          </li>
                          <li>
                            Actually, the name consists of a tokenized sequence that identifies the function name
                            and argument types in a compact format.
                          </li>
                        </ol>
                      </defn-body>
                    </defn-block>
                  </div>
                </details>
              </indent-block>
              <spacer-10></spacer-10>
              <indent-block>
                <details>
                  <summary class="labelStyle darkItem">
                    function overloading example
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-body class="pad10">
                      <pre><c-s>  /*---- find first and last elements of collection, may throw ----*/

using PD = std::pair&lt;double, double&gt;

PD firstAndLast(double dArr[], size_t N) {
  if (N &lt; 1)
    throw std::exception("no contents in array");
  return PD{ dArr[0], dArr[N - 1] };
}

using PI = std::pair&lt;int, int&gt;

PI firstAndLast(const std::vector&lt;int&gt;& vecInt) {
  if (vecInt.size() &lt; 1)
    throw std::exception("no contents in vector");
  return PI{ vecInt[0], vecInt[vecInt.size() - 1] };
}

/*---- find first and last elements of collection, using <span class="notice">optional</span> ----*/

std::optional&lt;PD&gt; firstAndLastOpt(double dArr[], size_t N) {
  std::optional&lt;PD&gt; opt;
  if(N &gt; 0)
    opt = std::pair{ dArr[0], dArr[N - 1] };
  return opt;
}

std::optional&lt;PI&gt; firstAndLastOpt(const std::vector&lt;int&gt;&amp; vecInt) {
  std::optional&lt;PI&gt; opt;
  if (vecInt.size() &gt; 0)
    opt = std::pair{ vecInt[0], vecInt[vecInt.size() - 1] };
  return opt;
}

/*---- demonstrate first and last ----*/

int main() {

  std::cout &lt;&lt; "\n  Demonstrating Function Overloading";
  std::cout &lt;&lt; "\n ====================================\n";

  double dArr[]{ 1.5, -0.5, 3.0 };
  std::vector&lt;int&gt; vecInt{ 1,2,3,4,5 };

  try {
    auto [firstd1, lastd1] = firstAndLast(dArr, 3);
    std::cout &lt;&lt; "\n  first = " &lt;&lt; firstd1 &lt;&lt; ", last = " &lt;&lt; lastd1;

    auto [firsti1, lasti1] = firstAndLast(vecInt);
    std::cout &lt;&lt; "\n  first = " &lt;&lt; firsti1 &lt;&lt; ", last = " &lt;&lt; lasti1;
  }
  catch (std::exception & ex) {
    std::cout &lt;&lt; "\n  " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }

  std::optional&lt;PD&gt; optd = firstAndLastOpt(dArr, 3);
  if (optd.has_value()) {
    auto [firstd2, lastd2] = optd.value();
    std::cout &lt;&lt; "\n  first = " &lt;&lt; firstd2 &lt;&lt; ", last = " &lt;&lt; lastd2;
  }
  else {
    std::cout &lt;&lt; "\n  array query failed";
  }

  std::optional&gt;PI&lt; opti = firstAndLastOpt(vecInt);
  if (opti.has_value()) {
    auto [firsti2, lasti2] = opti.value();
    std::cout &lt;&lt; "\n  first = " &lt;&lt; firsti2 &lt;&lt; ", last = " &lt;&lt; lasti2;
  }
  else {
    std::cout &lt;&lt; "\n  vector query failed";
  }
  
  std::cout &lt;&lt; "\n\n";
}</c-s></pre>
                    </defn-body>
                  </defn-block>
                </details>
              </indent-block>
              <div style="height:0.5em;"></div>
              <t-b class="mbz mtz">
                There are five relationships between C++ classes: inheritance, composition, aggregation, using, and friendship.
                The first four of these are supported by most object oriented languages.
              </t-b>
              <spacer-10></spacer-10>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">
                    class relationships
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block class="t-b mbz mtz">
                    <defn-body>
                      The five relationships between C++ classes are:
                      <ol>
                        <li style="padding:0px; margin-top:0.25em; margin-bottom:0.25em;">
                          <strong>Inheritance:</strong> a specialization of a base class by another derived class.
                        </li>
                        <li style="padding:0px; margin-top:0.25em; margin-bottom:0.25em;">
                          <strong>Composition:</strong> a permanent relationship between the composer
                          and composed.
                        </li>
                        <li style="padding:0px; margin-top:0.25em; margin-bottom:0.25em;">
                          <strong>Aggregation:</strong> a temporary relationship between the aggregator and aggregated.
                        </li>
                        <li style="padding:0px; margin-top:0.25em; margin-bottom:0.25em;">
                          <strong>Using:</strong> a non-owning relationship.  The used is made available to the user
                          by passing as a reference argument in a class method.
                        </li>
                        <li style="padding:0px; margin-top:0.25em; margin-bottom:0.25em;">
                          <strong>Friendship:</strong> a relationship granted by a class to one specific friend that allows
                          the friend access to the class&apos;s private members.  Friendship weakens encapsulation and
                          so is used only when necessary, e.g., rarely.
                        </li>
                      </ol>
                    </defn-body>
                    <defn-head class="defnBorderTop">Person Class Example</defn-head>
                    <defn-body>
                      <photosizer-block src="Pictures/PersonClassHierarchy.JPG" width="400" class="photoSizerBlock right">
                        <span style="font-family:'Comic Sans MS', Tahoma;">
                          <br />
                          Fig 1. Person Class Hierarchy
                        </span>
                      </photosizer-block>
                      The <c-s>Person</c-s> class, from the previous example, has been expanded into a class hierarchy representing software
                      development roles that a person might assume.  A class hierarchy like this
                      could be used to build a Project Management Tool that tracked progress on a
                      project and the contributions of individual team members.
                      <div style="height:0.5em;"></div>
                      There are several types of classes in this hierarchy:
                      <ul class="tight">
                        <li>Interfaces: <c-s>IPerson</c-s> and <c-s>ISW-Eng</c-s></li>
                        <li>An abstract class: <c-s>SW-Eng</c-s></li>
                        <li>
                          Concrete classes: <c-s>
                            Person, Dev, TeamLead, ProjMgr,
                            Project, Baseline, Documents,
                          </c-s> and <c-s>Budget</c-s>
                        </li>
                      </ul>
                      <div style="height:0.5em;"></div>
                      Interfaces, <c-s>IPerson</c-s> and <c-s>ISW-Eng</c-s>, support decoupling the hierarchy from its users, so that changes
                      to any of these classes don&apos;t require clients to change, as long as the
                      interface doesn&apos;t change.
                      <div style="height:0.5em;"></div>
                      The abstract class <c-s>SW-Eng</c-s> provides shared code and types for all its derived classes.
                      <div style="height:0.5em;"></div>
                      The concrete classes <c-s>Dev, TeamLead,</c-s> and <c-s>ProjMgr</c-s>, represent roles that a Software Engineer
                      may assume while working on the project.  The <c-s>Person</c-s> class is the key abstraction.  All of the
                      other parts serve to endow a person with one or more roles, e.g., developer, team lead, or project
                      manager.
                      <div style="height:0.5em;"></div>
                      All of the relationships between these classes are based on <strong class="notice">inheritance</strong>.
                      <div style="height:0.5em;"></div>
                      The <c-s>ProjMgr</c-s> class <strong class="notice">aggregates</strong> a <c-s>Project</c-s> instance, allowing a manager to move to another
                      project when the current project completes.
                      <div style="height:0.5em;"></div>
                      The <c-s>Project</c-s> class <strong class="notice">composes</strong> a <c-s>Budget</c-s> since that is an integral part of the project.  It
                      <strong class="notice">aggregates</strong> <c-s>Documents</c-s> and code <c-s>Baseline</c-s>,
                      as these don&apos;t exist at the beginning of the project.
                      <div style="height:0.5em;"></div>
                      Developers and Team Leads <strong class="notice">use</strong> the <c-s>Baseline</c-s> by contributing additions,
                      but they don&apos;t have an ownership relationship - only the Project Manager can authorise
                      deletions and creation of major new parts.
                      <div style="height:0.5em;"></div>
                    </defn-body>
                  </defn-block>
                </details>
              </indent-block>
              <spacer-10></spacer-10>
              <t-b class="mbz mtz">
                Inheritance supports sharing base class code with all of its derived classes.  While this is useful,
                inheritance&apos;s most important feature is support for substituting derived class pointers and references wherever
                a function accepts a base class pointer or reference.
              </t-b>
              <spacer-10></spacer-10>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">
                    function overriding
                  </summary>
                  <spacer-10></spacer-10>
                  <div>
                    <defn-block style="max-width:50em;">
                      <defn-body>
                        Suppose that, in the <c-s>SW-Eng</c-s> abstract class, from the previous &quot;class relationships&quot;
                        details, we&apos;ve defined a <c-s>virtual void doWork()</c-s> method.
                        <div style="height:0.25em;"></div>
                        One might expect that <c-s>Dev</c-s>s, <c-s>TeamLead</c-s>s, and <c-s>PrjMgr</c-s>s would each
                        have their own work behaviors, and so, each should have its own definition for what <c-s>doWork</c-s>
                        means.  Virtual function overriding allows us to specify those different behaviors.
                        <div style="height:0.25em;"></div>
                        Virtual function overriding is the process of, in each derived class, providing a definition for the function
                        execution of that function based on the type of the derived class, e.g., <c-s>Dev</c-s>, <c-s>TeamLead</c-s>,
                        or <c-s>PrjMgr</c-s>.  The virtual functions in each derived
                        class must have the same signature, e.g., <c-s>void doWork()</c-s>, and this redefinition only applys to
                        functions that are qualified as <c-s>virtual</c-s> in the base class.
                        <s-halfEm></s-halfEm>
                      </defn-body>
                    </defn-block>
                  </div>
                </details>
              </indent-block>
              <spacer-10></spacer-10>
              <indent-block>
                <details>
                  <summary class="labelStyle darkItem">
                    function overriding example
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-outerBlock>
                    <defn-block>
                      <defn-head>Example Code</defn-head>
                      <defn-code>
/*--- abstract base class ---*/

class SWDev {
  public:
  using WorkItems = std::vector&lt;std::string&gt;;

  SWDev(const std::string& name) : name_(name) {}
  virtual ~SWDev() {}
  virtual void doWork() = 0;
  void getCoffee();
  void name(const std::string& nm);
  std::string name();
  protected:
  std::string name_ = "anonymous";
  static WorkItems workItem;
};

/*--- shared data ---*/

inline SWDev::WorkItems SWDev::workItem = {
  "process email",
  "pull requests for today's work",
  "work off bugs",
  "add new features",
  "write up developer evaluations",
  "write up project stories",
  "schedule agile meeting",
  "discuss requirements with customer",
  "go golfing with customer"
};

inline auto show = [](const std::string& task) {
  std::cout &lt;&lt; "\n  " &lt;&lt; task;
};

/*--- non-virtual functions, don't override ---*/

inline void SWDev::name(const std::string& name) {
  name_ = name;
}

inline std::string SWDev::name() {
  return name_;
}

inline void SWDev::getCoffee() {
  std::cout &lt;&lt;
  "\n  get coffee from cafeteria, chat";
}

/*--- derived classes override virtual do work ---*/

class Dev : public SWDev {
  public:
  Dev(const std::string& name) : SWDev(name) {}
  virtual void doWork() override {
    show("\n  Dev: " + name());
    getCoffee();
    show(workItem[0]);
    show(workItem[1]);
    show(workItem[2]);
    show(workItem[3]);
  }
};

class TeamLead : public SWDev {
  public:
  TeamLead(const std::string& name) : SWDev(name) {}
  virtual void doWork() override {
    show("\n  TeamLead: " + name());
    getCoffee();
    show(workItem[0]);
    show(workItem[5]);
    show(workItem[6]);
    show(workItem[1]);
    show(workItem[2]);
    show(workItem[3]);
  }
};

class ProjMgr : public SWDev {
  public:
  ProjMgr(const std::string& name) : SWDev(name) {}
  virtual void doWork() override {
    show("\n  Project Mgr: " + name());
    getCoffee();
    show(workItem[0]);
    show(workItem[4]);
    show(workItem[7]);
    show(workItem[8]);
  }
};
                      </defn-code>
                    </defn-block>
                    <defn-block>
                      <defn-head>Using Code</defn-head>
                      <defn-code>
#include "Overriding.h"

int main() {

  std::cout &lt;&lt; "\n  Demonstrating Overriding";
  std::cout &lt;&lt; "\n ==========================\n";

  /* form project team */
  ProjMgr Frank("Frank");

  TeamLead Ashok("Ashok");
  Dev Joe("Joe");
  Dev Charley("Charley");
  Dev Sue("Sue");

  TeamLead Ming("Ming");
  Dev Barbara("Barbara");
  Dev Samir("Samir");

  std::vector&lt;SWDev*&gt; ProjectTeam{
    &Frank,
    &Ashok, &Joe, &Charly, &Sue,
    &Ming, &Barbara, &Samir
  };

  /* get to work */

  show("Monday, starting work");
  for (auto swDev : ProjectTeam) {
  swDev-&gt;doWork();
}
show("\n  That's all Folks\n\n");
                      </defn-code>
                      <defn-head class="defnBorderTop">Output</defn-head>
                      <defn-code>
 Demonstrating Overriding
==========================

Monday, starting work

Project Mgr: Frank
get coffee from cafeteria, chat
process email
write up developer evaluations
discuss requirements with customer
go golfing with customer

TeamLead: Ashok
get coffee from cafeteria, chat
process email
write up project stories
schedule agile meeting
pull requests for today's work
work off bugs
add new features

Dev: Joe
get coffee from cafeteria, chat
process email
pull requests for today's work
work off bugs
add new features

Dev: Charley
get coffee from cafeteria, chat
process email
pull requests for today's work
work off bugs
add new features

Dev: Sue
get coffee from cafeteria, chat
process email
pull requests for today's work
work off bugs
add new features

TeamLead: Ming
get coffee from cafeteria, chat
process email
write up project stories
schedule agile meeting
pull requests for today's work
work off bugs
add new features

Dev: Barbara
get coffee from cafeteria, chat
process email
pull requests for today's work
work off bugs
add new features

Dev: Samir
get coffee from cafeteria, chat
process email
pull requests for today's work
work off bugs
add new features

That's all Folks
                      </defn-code>
                    </defn-block>
                  </defn-outerBlock>
                </details>
              </indent-block>
              <spacer-15></spacer-15>
              <div style="padding:0.5em 0em;">
                We will discuss the details of techniques used in this example in Chapter 5.
              </div>
              <spacer-10></spacer-10>
              <t-b class="mtz">
                Most C++ projects use classes extensively.  Usually almost all of the code is devoted to implementing
                classes and using class instances.  We will look at, and dissect, examples in Chapter 5.
              </t-b>
            </indent-blocks>
            <a id="Templates"></a>
            <h3 id="templates">2.4  Templates and Specialization</h3>
            <t-b class="mbz">
              C++ templates provide a way of defining library functions and classes that depend
              on some unspecified type or types.  STL containers like <c-s>std::vector&lt;T&gt;</c-s>
              are examples.
            </t-b>
            <spacer-15></spacer-15>
            <t-b class="mbz mtz">
              Template functions and classes need to be instantiated by using applications
              with specific type(s) before they can be used, e.g., <c-s>std::vector&lt;std::string&gt;</c-s>.
            </t-b>
            <indent-blocks>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">
                    template functions
                  </summary>
                  <spacer-10></spacer-10>
                  <div>
                    <defn-block style="max-width:50em;">
                      <defn-body class="pad10">
                        The template function <c-s>max&lt;T, T&gt;</c-s> accepts two arguments of the same
                        type and returns an instance of that type with the value of the larger of the
                        arguments.
                        <indent-block class="pad10">
                          <c-s>
                            template &lt;typename T&gt;<br />
                            T max(T t1, T t2) {<br />
                            &nbsp;&nbsp;&nbsp;&nbsp;return t1 &gt; t2 ? t1 : t2;<br />
                            }
                          </c-s>
                        </indent-block>
                        This function, when instantiated with a specific type, will compile successfully
                        provided that T has defined <c-s>operator&gt;(T&amp; t)</c-s>. Otherwise, compilation
                        fails.
                        <div style="height:0.5em;"></div>
                        There is another subtle problem with <c-s>max&lt;T, T&gt;</c-s>.  It works correctly
                        for fundamental types and instances of classes like <c-s>std::string</c-s>.
                        However, if we make the following invocation:
                        <div style="height:0.5em;"></div>
                        <indent-block class="pad10">
                          <c-s>const char* pStr = max&lt;&quot;aardvark&quot;, &quot;zebra&quot;&gt;;</c-s>
                        </indent-block>
                        <spacer-10></spacer-10>
                        the function compiles, but we may not get a result we expect.
                        <c-s>max&lt;const char*, const char*&gt;</c-s> returns the larger of
                        its two arguments, which, in this case are pointers, so we will get a pointer to whichever
                        string is stored in the higher memory location, having nothing to do with lexicographic
                        ordering of its arguments.
                        <div style="height:0.5em;"></div>
                        We see how to fix it by overloading <c-s>max&lt;T, T&gt;</c-s> for
                        that specific case, below.
                        <div style="height:0.5em;"></div>
                      </defn-body>
                    </defn-block>
                  </div>
                </details>
                <div style="height:0.5em;"></div>
                <details>
                  <summary class="labelStyle darkItem">
                    overloading template functions
                  </summary>
                  <div>
                    <defn-block style="max-width:50em;">
                      <defn-body class="pad10">
                        Here&apos;s the original <c-s>max&lt;T, T&gt;</c-s> declaration:
                        <defn-block class="pad10-15 noBorder indent">
                          <c-s>
                            template &lt;typename T&gt;<br />
                            T max(T t1, T t2) {<br />
                            &nbsp;&nbsp;&nbsp;&nbsp;return t1 &gt; t2 ? t1 : t2;<br />
                            }
                          </c-s>
                        </defn-block>
                        and here is a function overload declaration for the case of <c-s>const char*</c-s>:
                        <defn-block class="pad10-15 noBorder indent">
                          <c-s>
                            using pStr = const char*;<br />
                            template &lt;&gt;<br />
                            pStr max(pStr s1, pStr s2) {<br />
                            &nbsp;&nbsp;&nbsp;&nbsp;return ((strcmp(s1,s2)>0) ? S1 : s2);<br />
                            }
                          </c-s>
                        </defn-block>
                        <spacer-10></spacer-10>
                        The C++ language guarantees that the most specific function overload will be
                        applied to compile a function.  In the case of <c-s>const char*</c-s>, <c-s>pStr</c-s> is more specific
                        than the template type <c-s>T</c-s>, so the second version will be compiled
                        and the result will return the string with largest lexicographic order because
                        that is what the C function <c-s>strcmp</c-s> returns.
                        <div style="height:0.5em;"></div>
                        This overloading guarantee is very important.  It means that we can define a
                        generic template for a class and then supply specific overloads for any types
                        that are problematic.
                        <div style="height:0.5em;"></div>
                        This isn&apos;t a perfect solution, because there may be an open-ended set of
                        types that cause problems, but if we encounter more problematic types, we can
                        provide additional overloads.
                        <div style="height:0.5em;"></div>
                      </defn-body>
                    </defn-block>
                  </div>
                </details>
              </indent-block>
              <indent-block>
                <details>
                  <summary class="labelStyle darkItem">
                    template classes
                  </summary>
                  <div>
                    <defn-block style="max-width:50em;">
                      <defn-body class="pad10">
                        C++ classes can be declared as templates too.  Here&apos;s an example:
                        <div style="height:0.5em;"></div>
                        <c-s>
                          template &lt;typename T&gt;<br />
                          class stack {<br />
                          public:<br />
                          &nbsp;&nbsp;&nbsp;&nbsp;void push(T t);<br />
                          &nbsp;&nbsp;&nbsp;&nbsp;T pop();<br />
                          &nbsp;&nbsp;&nbsp;&nbsp;T top();<br />
                          &nbsp;&nbsp;&nbsp;&nbsp;std::size_type size();<br />
                          private:<br />
                          &nbsp;&nbsp;&nbsp;&nbsp;// data members elided<br />
                          };
                          <div style="height:0.5em;"></div>
                          template &lt;typename T&gt;<br />
                          void stack&lt;T&gt;::push(T t) {<br />
                          &nbsp;&nbsp;&nbsp;&nbsp;// details elided<br />
                          }
                          <div style="height:0.5em;"></div>
                          // other member function definitions elided
                        </c-s>
                        <div style="height:0.5em;"></div>
                        With this template declaration we can define:
                        <div style="height:0.5em;"></div>
                        <c-s>
                          stack&lt;int&gt; intStk;<br />
                          stack&lt;std::pair&lt;std::string, int&gt;&gt; prStk;<br />
                          stack&lt;Widget&gt; WdgStk;<br />
                        </c-s>
                        <div style="height:0.5em;"></div>
                        Without templates we would have to declare a <c-s>stack</c-s> class for each of these
                        types.  With templates the compiler does all that extra work for us.
                        <div style="height:0.5em;"></div>
                        For each instantiation, the compiler generates a class for that type.  Syntactically,
                        each of the above declarations defines a distinct class.  That is,
                        <c-s>stack&lt;int&gt;</c-s> is not the same type as
                        <c-s>stack&lt;std::pair&lt;std::string, int&gt;&gt; prStk;</c-s>
                        <div style="height:0.5em;"></div>
                      </defn-body>
                    </defn-block>
                  </div>
                </details>
              </indent-block>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">
                    template class specialization
                  </summary>
                  <spacer-10></spacer-10>
                  <div style="max-width:50em;">
                    <defn-block style="max-width:50em;">
                      <defn-body class="pad10">
                        Suppose that, for the user-defined type <c-s>Widget</c-s>, some <c-s>stack&lt;T&gt;</c-s>
                        methods fail to compile or process a <c-s>Widget</c-s> incorrectly.
                        That could happen if the stack provides copy and assignment operations, but
                        <c-s>Widget</c-s> instances are not copyable or assignable, or those operations
                        are incorrect for <c-s>Widget</c-s> due to an incomplete design<sup>1</sup>.
                        <div style="height:0.5em;"></div>
                        For that, we can use template
                        specialization to fix that problem, in much the same way as we did by overloading
                        <c-s>max&lt;T, T&gt;</c-s> in the discussion of overloading template functions.
                        For the <c-s>Widget</c-s> specialization we would declare the
                        <c-s>stack&lt;Widget&gt;</c-s> copy and assignment operations as deleted
                        with <c-s>=delete</c-s> postfix qualifiers.
                        <div style="height:0.5em;"></div>
                        The generic class is defined as:
                        <div style="height:0.5em;"></div>
                        <div class="pad10 indent">
                          <c-s>
                            template &lt;typename T&gt;<br />
                            class stack {<br />
                            public:<br />
                            &nbsp;&nbsp;stack();<br />
                            &nbsp;&nbsp;stack(const stack&lt;T&gt;&amp; stk);<br />
                            &nbsp;&nbsp;stack&lt;T&gt;&amp; operator=(const stack&lt;T&gt;&amp; stk);<br />
                            &nbsp;&nbsp;void push(T t);<br />
                            &nbsp;&nbsp;T pop();<br />
                            &nbsp;&nbsp;T top();<br />
                            &nbsp;&nbsp;std::size_type size();<br />
                            private:<br />
                            &nbsp;&nbsp;// data members elided<br />
                            };
                            <div style="height:0.5em;"></div>
                            template &lt;typename T&gt;<br />
                            void stack&lt;T&gt;::push(T t) {<br />
                            &nbsp;&nbsp;// details elided<br />
                            }
                            <div style="height:0.5em;"></div>
                            // other member function definitions elided
                          </c-s>
                          <div style="height:0.5em;"></div>
                          <c-s>
                            stack&lt;Widget&gt; WdgStk;
                          </c-s>
                          // fails to compile or exhibits incorrect operation.
                        </div>
                        <div style="height:0.5em;"></div>
                        So, we define a <c-s>stack</c-s> class specialization for <c-s>Widgets</c-s>
                        like this:
                        <div style="height:0.5em;"></div>
                        <div class="pad10 indent">
                          <c-s>
                            template &lt;&gt;<br />
                            class stack&lt;Widget&gt; {<br />
                            public:<br />
                            &nbsp;&nbsp;stack();<br />
                            &nbsp;&nbsp;stack(const stack&lt;T&gt;&amp; stk) = delete;<br />
                            &nbsp;&nbsp;stack&lt;T&gt;&amp; operator=(const stack&lt;T&gt;&amp; stk) = delete;<br />
                            &nbsp;&nbsp;void push(Widget w);<br />
                            &nbsp;&nbsp;Widget pop();<br />
                            &nbsp;&nbsp;Widget top();<br />
                            &nbsp;&nbsp;std::size_type size();<br />
                            private:<br />
                            &nbsp;&nbsp;// elided data members may be different from the generic class<br />
                            };
                            <div style="height:0.5em;"></div>
                            template &lt;typename T&gt;<br />
                            void stack&lt;T&gt;::push(T t) {<br />
                            &nbsp;&nbsp;// elided details may be different from the generic class<br />
                            }
                            <div style="height:0.5em;"></div>
                            // other member function definitions elided
                          </c-s>
                          <div style="height:0.5em;"></div>
                          <c-s class="pad10">
                            stack&lt;Widget&gt; WdgStk;
                          </c-s>
                          <div style="height:0.5em;"></div>
                          // now compiles if we don&apos;t try to copy or assign instances<br />
                          // and exhibits correct operation
                        </div>
                        <div style="height:0.5em;"></div>
                        The C++ language guarantees that a specialization will be compiled instead of the
                        generic class whenever the class is instantiated with a specialized type, like
                        <c-s>Widget</c-s>
                        <hr class="spreadup" />
                        <ol style="font-size:0.9em;">
                          <li>
                            We will discuss, in Chapter 5., how incomplete designs happen and how to ensure your designs
                            are complete.
                          </li>
                        </ol>
                        <div style="height:0.5em;"></div>
                      </defn-body>
                    </defn-block>
                  </div>
                </details>
              </indent-block>
            </indent-blocks>
            <a id="Lib"></a>
            <h3 id="libs">2.5  Libraries</h3>
            <t-b class="mbz">
              The C++ standard libraries collection is very large, perhaps overwhelming.
              Many of us are quite familiar with a small subset, and browse through the
              rest when we need some functionality that could be there.
            </t-b>
            <spacer-15></spacer-15>
            <indent-blocks>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">
                    standard C++ libraries
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block class="t-b mbz mtz">
                    <defn-body>
                      I&apos;ve enumerated here a lot of the libraries and some of their contents in order
                      to support your browsing process.
                    </defn-body>
                    <defn-body class="defnBorderTop">
                      This material was drawn from resources provided by
                      <a href="https://en.cppreference.com/w/cpp">cppreference.com</a>.<br />
                      Only the organization has been changed (slightly) and a few of the more
                      obscure libraries omitted.  I&apos;ve annotated the material and emphasized
                      those libraries I use frequently.  You will see most of them in examples
                      throughout this story.
                    </defn-body>
                    <defn-body class="defnBorderTop">
                      Here are some categories:
                      <ol class="indent">
                        <li>
                          Language Support libraries
                          <ul class="tight">
                            <li>
                              <span class="notice">&lt;initializer_list&gt;</span> - supports uniform initialization for user-defined types,
                              examples in Chapter #3 - Data.
                            </li>
                            <li>
                              <span class="notice">&lt;type_traits&gt;</span> - used for template metadata programming, examples in Chapter 3.
                            </li>
                            <li>&lt;limits&gt; - Numeric limits</li>
                            <li>&lt;cstdlib&gt; - Managing OS Processes and Signals</li>
                          </ul>
                        </li>
                        <li>
                          General Utilities libraries
                          <ul class="tight">
                            <li><span class="notice">&lt;memory&gt;</span> - Smart pointers and allocators, examples in Chapter 4</li>
                            <li>&lt;chrono&gt; - Time durations, times, and dates</li>
                            <li>
                              Function objects and qualilfiers:
                              <indent-block>
                                <div>
                                  <span class="notice">&lt;functional&gt;</span> - function, mem_fn, bind, invoke, ref
                                </div>
                                <div>
                                  <span class="notice">&lt;utility&gt;</span> - move, forward, pair, tuple, examples in Chapters 4 and 5
                                </div>
                                <span class="notice">&lt;tuple&gt;</span> - examples in Chapters 2 and 3
                              </indent-block>
                            </li>
                            <li>&lt;charconv&gt; - to_chars, from_chars, chars_format</li>
                            <li><span class="notice">&lt;optional&gt;</span> - return instance or empty</li>
                            <li><span class="notice">&lt;any&gt;</span> - holds instance of almost any type, example in Chapter 3</li>
                            <li>&lt;variant&gt; - holds instances of any specified set of types</li>
                          </ul>
                        </li>
                        <li>
                          <span class="notice">&lt;string&gt;</span> - std::basic_string --> std::string, std::wstring
                        </li>
                        <li>
                          Containers libraries:
                          <indent-block>
                            &lt;array&gt;, &lt;deque&gt;, &lt;list&gt;, &lt;map&gt;,
                            &lt;multimap&gt; &lt;multiset&gt;
                            &lt;queue&gt;,
                            &lt;set&gt;, &lt;singleList&gt;, &lt;stack&gt;, <span class="notice">&lt;string&gt;</span>,
                            <span class="notice">&lt;unordered_map&gt;</span>,
                            &lt;unordered_multimap&gt;, &lt;unordered_multiset&gt;,
                            &lt;unordered_set&gt;, <span class="notice">&lt;vector&gt;</span>
                          </indent-block>
                        </li>
                        <li>
                          &lt;algorithm&gt; - Algorithms library
                          <spacer-10></spacer-10>
                          <indent-block>
                            Non-modifying sequence operations:
                            <div class="indent">
                              all_of, any_of, none_of, for_each, for_each_n, count, count_if,
                              mismatch, find, find_if, find_if_not, find_end, find_first_of,
                              adjacent_find, search, search_n
                            </div>
                            Modifying sequence operations:
                            <div class="indent">
                              copy, copy_if, copy_n, copy_backward,
                              move, move_backward, fill, fill_n, transform, generate, generate_n,
                              remove, remove_if, remove_copy, remove_copy_if, replace, replace_if,
                              replace_copy, replace_copy_if, swap, swap_ranges, iter_swap,
                              reverse, reverse_copy, rotate, shift_left, shift_right,
                              random_shuffle, shuffle, sample, unique, unique_copy
                            </div>
                            Partitioning operations:
                            <div class="indent">
                              is_partitioned, partition, partition_copy, stable_partition, partition_point
                            </div>
                            Sorting operations:
                            <div class="indent">
                              is_sorted, is_sorted_until, sort, partial_sort, stable_sort, nth_element
                            </div>
                            Binary search on sorted ranges:
                            <div class="indent">
                              lower_bound, upper_bound, binary_search, equal_range
                            </div>
                            Other operations on sorted ranges:
                            <div class="indent">
                              merge, inplace_merge
                            </div>
                            Set operations on sorted ranges:
                            <div class="indent">
                              includes, set_differences, set_intersection, set_symmetric_distance, set_union
                            </div>
                            Heap operations:
                            <div class="indent">
                              is_heap, is_heap_until, make_heap, push_heap, pop_heap, sort_heap
                            </div>
                            Min/Max operations:
                            <div class="indent">
                              max, max_element, min, min_element, minmax, minmax_element, clamp
                            </div>
                            Comparison operations:
                            <div class="indent">
                              equal, lexicographical_compare, lexicographical_compare_three_way
                            </div>
                            Permutation operations:
                            <div class="indent">
                              is_permutation, next_permutation, prev_permutation
                            </div>
                            Numeric operations:
                            <div class="indent">
                              iota, accumulate, inner_product, adjacent_difference, partial_sum,
                              reduce, exclusive_scan, inclusive_scan, transform_reduce,
                              transform_exclusive_scan, transform_inclusive_scan
                            </div>
                          </indent-block>
                        </li>
                        <li>
                          Numerics libraries
                          <ul class="tight">
                            <li>
                              &lt;cstdlib&gt;, &lt;cmath&gt; - Common math functions
                            </li>
                            <li>&lt;cmath&gt; - Special math functions</li>
                            <li>&lt;numeric&gt;, &lt;cmath&gt; - Numeric algorithms</li>
                            <li>&lt;random&gt;, &lt;cstdlib&gt; - Pseudo-random number generators</li>
                            <li>&lt;cfenv&gt; - Floating-point environment</li>
                            <li>&lt;complex&gt; - Complex numbers, operations</li>
                          </ul>
                        </li>
                        <li>
                          Input/Output libraries:
                          <ul class="tightList">
                            <li>
                              Terminal I/O:
                              <div class="indent">
                                <span class="notice">
                                  &lt;ios&gt;, &lt;streambuf&gt;, &lt;ostream&gt;, &lt;istream&gt;,
                                  &lt;iostream&gt;
                                </span>
                              </div>
                            </li>
                            <li>
                              File I/O:
                              <div class="indent">
                                <span class="notice">&lt;fstream&gt;</span>
                              </div>
                            </li>
                            <li>
                              String I/O:
                              <div class="indent">
                                <span class="notice">&lt;sstream&gt;</span>
                              </div>
                            </li>
                            <li>
                              Synchronized I/O:
                              <div class="indent">
                                &lt;syncstream&gt;
                              </div>
                            </li>
                            <li>
                              I/O manipulators:
                              <div class="indent">
                                <scan class="notice">&lt;iomanip&gt;</scan>
                              </div>
                            </li>
                          </ul>
                        </li>
                        <li>
                          <span class="notice">&lt;regex&gt;</span> - Regular Expressions library
                        </li>
                        <li>
                          Thread Support libraries:
                          <div>
                            C++17:
                            <div class="indent">
                              <span class="notice">
                                &lt;thread&gt;, &lt;mutex&gt;, &lt;shared_mutex&gt;,
                                &lt;condition_variable&gt;, &lt;future&gt;, &lt;atomic&gt;
                              </span>
                            </div>
                            C++20:
                            <div class="indent">
                              &lt;semiphore&gt;, &lt;latch&gt;, &lt;stop_token&gt;

                            </div>
                          </div>
                        </li>
                        <li>
                          <span class="notice">&lt;filesystem&gt;</span> - Filesystem library
                        </li>
                        <li>
                          Error Handling libraries:
                          <div class="indent">
                            <span class="notice">&lt;exception&gt;</span>, &lt;stdexcept&gt;, &lt;cerrno&gt;, &lt;cassert&gt;
                            &lt;system_error&gt;
                          </div>
                        </li>
                        <li>
                          Other libraries
                          <ul class="tight">
                            <li>Localizations</li>
                            <li>Iterators</li>
                            <li>Concepts (C++20)</li>
                            <li>Named Requirements (C++20)</li>
                            <li>Ranges (C++20)</li>
                          </ul>
                        </li>
                      </ol>
                    </defn-body>
                  </defn-block>
                </details>
              </indent-block>
            </indent-blocks>
            <indent-blocks>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem bb-full">
                    Example:&nbsp;&nbsp;Display container contents using std::vector, std::for_each, and lambda
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block>
                    <defn-body class="pad10">
                      Here&apos;s an example using the STL vector container and for_each algorithm with lambda fold:
                      <div style="width:max-content;">
                        <pre><c-s>  std::vector&lt;int&gt; test{ 
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 
  };  
  
  size_t N = 4;
  
  auto fold = [N](auto t) {
    static size_t count = UINT_MAX - 1;
    if (++count > N) {
      count = 1;
      std::cout << "\n  ";
    }
    std::cout << t << " ";
  };

  std::for_each(test.begin(), test.end(), fold);
        </c-s>
</pre>
                        with output:<pre><c-s>  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16  
  17</c-s></pre>
                      </div>
                    </defn-body>
                  </defn-block>
                </details>
              </indent-block>
            </indent-blocks>
            <spacer-15></spacer-15>
            <t-b class="mtz">
              The standard library collection is very large, but still there are a few surprising
              omissions. Until C++17 there was no filesystem library and there still is no support
              for:
            </t-b>
            <ul style="margin-top:10px; margin-bottom:10px;">
              <li style="padding-bottom:2px;">Network programming and inter-process communication</li>
              <li style="padding-bottom:2px;">Processing XML or JSON data formats</li>
              <li>Building Graphical User Interfaces</li>
            </ul>
            <t-b class="mbz">
              However, building these is not too difficult using platform APIs and/or third party libraries, especially
              the extensive <a href="https://Boost.org">Boost</a> library.
            </t-b>
            <spacer-10></spacer-10>
            <indent-blocks>
              <indent-block class="pad10">
                <details>
                  <summary class="labelStyle darkItem">
                    custom libraries
                  </summary>
                  <spacer-10></spacer-10>
                  <defn-block style="max-width:50em;">
                    <defn-body class="pad10">
                      Libraries, written entirely in C++, using platform APIs as necessary,
                      that fill in some omissions from the standard C++ library.
                      <table class="lightItem" style="margin:20px 30px;">
                        <tr>
                          <th class="darkItem">Library</th>
                          <th class="darkItem">Description</th>
                        </tr>
                        <tr>
                          <td>FileSystem</td>
                          <td>
                            Provides interfaces used by many of the applications in code repositories
                            in this site.  It was developed using Windows and Linux platform APIs.
                            I plan to turn this into a wrapper for the std::filesystem which provides
                            a different set of interfaces, incompatible with the existing applications.
                            <spacer-10></spacer-10>
                            <a href="FileSystem.html">FileSystem.html</a>
                          </td>
                        </tr>
                        <tr>
                          <td>XmlDocument</td>
                          <td>
                            A fairly complete processing library for reading, parsing, building,
                            and writing XML to and from strings and files.
                            <spacer-10></spacer-10>
                            <a href="XmlDocument.html">XmlDocument.html</a>
                          </td>
                        </tr>
                        <tr>
                          <td>CppCommWithFileXfer</td>
                          <td>
                            Supports asynchronous message-passing communication between multiple
                            endpoints, using the Sockets library, below.
                            <spacer-10></spacer-10>
                            <a href="CppCommWithFileXfer.html">CppCommWithFileXfer.html</a>
                          </td>
                        </tr>
                        <tr>
                          <td>Sockets</td>
                          <td>
                            A sockets class hierarchy that handles IP4 and IP6 protocols
                            for stream-based sockets.  The library has versions for both Windows
                            and Linux.
                            <spacer-10></spacer-10>
                            <a href="Sockets.html">Sockets.html</a>
                          </td>
                        </tr>
                        <tr>
                          <td>CppParser</td>
                          <td>
                            A rule based parser suitable for analyzing C, C++, C#, and Java.
                            <spacer-10></spacer-10>
                            <a href="BlogParser.html">Parsing Blog</a>,
                            <a href="CppParser.html">CppParser Repository</a>,
                            <a href="CppLexicalScanner.html">CppLexicalScanner.html</a>
                          </td>
                        </tr>
                      </table>
                      <spacer-15></spacer-15>
                    </defn-body>
                  </defn-block>
                </details>
              </indent-block>
            </indent-blocks>
          </indent-blocks>
          <spacer-15></spacer-15>
          This completes our survey of the C++ programming language.  We will be expanding on each
          of these topics:
          <indent-block class="pad10">
            <span class="notice">Data, Operations, Classes, Templates, and Libraries</span>
          </indent-block>
          in the following chapters of this story, with lots of discussion and code examples,
          and a few videos here and there.

          <h3 id="epilogue">2.6  Survey Epilogue</h3>
          <t-b>
            This chapter has presented most of the ideas in this story about the C++ programming language.
            We&apos;ve left out a lot of details, but those will come in the following chapters.
          </t-b>
          <t-b>
            This simple view of the language is all you need to build useful C++ programs. If you encounter requirements
            that can&apos;t be implemented with them then look into the following chapters.
          </t-b>
          <h3 id="exercises">2.7  Programming Exercises</h3>
          <indent-blocks>
            <div style="width:80%">
              <ol>
                <li>
                  Write code that saves an array of strings where the size of the array is specified at
                  run-time. Show how to access stored items and how to deallocate the storage.
                </li>
                <li>
                  Write a lambda that accepts a std::string message and displays it on the console with a second
                  line composed of &apos;-&apos; characters.
                  <hr />
                  If the lambda prepends the message with a newline, indents it two spaces, and makes the underline
                  string two characters longer, with a one character indent, the result creates a nice title.
                  Can you create the lambda so it also accepts an underline character which defaults to &apos;-&apos;?
                </li>
                <li>
                  Develop a class that accepts an initializer_list of strings when constructed and save the elements
                  of the list in a std::vector. Write a member function that adds an additional string to the list.
                  Demonstrate this class in a main() where you supply a list of your friends. Then add two additional
                  new friends.
                </li>
                <li>
                  Generalize the friends class to accept a list of std::tuples where the tuples provide a bit more
                  information about your friends.  Can you make this work for types other than std::tuple, perhaps
                  a struct with the same information.  The intent here is that, after the first change, you can use
                  more than one data type without changing your friends class.
                </li>
              </ol>
            </div>
          </indent-blocks>

          <h3 id="refs">2.8  References</h3>
          <indent-block>
            <a href="https://cppreference.com">cppreference.com</a><br />
            <a href="http://www.cplusplus.com/reference/">cplusplus.com/reference</a><br />
            <a href="https://docs.microsoft.com/en-us/cpp/cpp/c-cpp-language-and-standard-libraries?view=vs-2019">C/C++ language and standard libraries reference - MSDN</a><br />
            <!--<a href="https://doc.bccnsoft.com/docs/cppreference_en/index.html">cpp reference - bccnsoft.com</a><br />-->
            <a href="https://cpppatterns.com/">cpppatterns.com</a><br />
            <a href="https://www.fluentcpp.com/posts/">Posts on Fluent C++</a><br />
            <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms">C++ Idioms</a><br />
            <a href="https://www.youtube.com/playlist?list=PLs3KjaCtOwSZ2tbuV1hx8Xz-rFZTan2J1">C++ weekly videos</a><br />
            <a href="https://riptutorial.com/cplusplus">riptutorial - documentation provided by StackOverFlow</a><br />
            <a href="https://www.mycplus.com/category/tutorials/cplusplus-programming-tutorials/">mycplus.com tutorials</a><br />
            <a href="https://github.com/boostcon/cppnow_presentations_2018">cppnow 2018</a><br />
            <a href="https://www.youtube.com/watch?v=I52uPJSoAT4">Declarative Style in C++</a><br />
          </indent-block>

        </div>
        <spacer-25></spacer-25>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <sec-elem style="width:0.0em">&nbsp;</sec-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#exercises">exercises</a></menu-elem>
        <menu-elem class="secElem"><a href="#epilogue">epilogue</a></menu-elem>
        <menu-elem class="secElem"><a href="#libs">libs</a></menu-elem>
        <menu-elem class="secElem"><a href="#templates">templates</a></menu-elem>
        <menu-elem class="secElem"><a href="#classes">classes</a></menu-elem>
        <menu-elem class="secElem"><a href="#ops">operations</a></menu-elem>
        <menu-elem class="secElem"><a href="#defdecl">defdecl</a></menu-elem>
        <menu-elem class="secElem"><a href="#userdef">userdef</a></menu-elem>
        <menu-elem class="secElem"><a href="#data">data types</a></menu-elem>
        <menu-elem class="secElem"><a href="#prologue">prologue</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <!--<menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.decrZoomScreen()">Zout</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.normZoomScreen()">Zdef</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.incrZoomScreen()">Zin</menu-elem>-->
    </frame-footer>
  </page-frame>
</body>
</html>