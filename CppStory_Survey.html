<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_Survey.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Survey</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    #github .pad10-15 {
      padding: 10px 15px;
    }

    #github .codeStyle {
      overflow:hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github .labelStyle {
      font-family: sans-serif;
      /*font-weight:bold;*/
      font-size: 1.0em;
    }

    #github .normal {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github summary {
      padding: 3px 0px 5px 0px;
      font-weight:bold;
      width: max-content;
    }

      #github summary ~ div {
        width: max-content;
        max-width: 95%;
      }

      #github summary ~ indent-block {
        width: max-content;
        max-width: 95%;
        padding-left: 20px;
        padding-right: 20px;
        /*background-color: #eee;*/
      }

      #github photosizer-block {
        position: relative;
        z-index:2;
        background-color:white;
      }

      #github comment-block {
        width:max-content;
        max-width: 95%;
        padding:10px 15px;
        background-color:#eee;
        font-weight: normal;
        font-size: 1.0em;
        font-family: Tahoma;
      }
      #github c-s {
        overflow:hidden;
        font-family: Consolas, monospace;
        font-weight: bold;
        font-size: 1.0em;
      }
      #github t-s {
        font-weight: normal;
        font-size: 1.0em;
        font-family: Tahoma;
      }

      #github .notice {
        font-size:1.1em;
        font-weight:bolder;
        font-style:italic;
        font-family:Consolas, sans-serif;
        border:none;
        color:darkred;
      }
      #github background-block {
        display:block;
        background-color:#ddd;
        max-width:90%;
        width:max-content;
        padding:10px 15px;
      }
      #github .background-block {
        display:block;
        background-color:#ddd;
        max-width:90%;
        width:max-content;
        padding:10px 15px;
      }
      #github .footnote {
        font-size:0.85em;
      }
      #github ol.footnote li {
        padding-bottom:0px;
      }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Data.html">N</a>
  <a id="Prev" href="CppStory_Prologue.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #1&nbsp;-&nbsp;C++ Survey</h1>
      <h3 id="subtitle">data, operations, classes, templates, libraries</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <indent-blocks>
    <h3>Survey</h3>
    <indent-blocks>
      This chapter provides a quick look at programming facilities provided by C++ and its libraries.
      You will find a lot more details, with examples, on these topics in subsequent chapters.<br />
      <ul class="tight pad10">
        <li><a href="https://en.cppreference.com/w/cpp/language/basic_concepts">Basic concepts</a></li>
        <li><a href="https://en.cppreference.com/w/cpp/keyword">Key words</a></li>
        <li><a href="CppModels.html">Models for C++ programs: building, execution, and memory storage</a></li>
      </ul>
      <hr class="spread" style="border:2px solid #999;" />
      <h4>Data Types:</h4>
      <indent-blocks>
        The C++ programming language provides fundamental types, built into the language,
        additional types provided by the C++ standard libraries, and supports user-defined types that
        can be designed to provide the same behaviors as fundamental types.
        <spacer-15></spacer-15>
        Fundamental types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="codeStyle lightItem">void, bool, nullptr_t, integral, char, and floating types</span>
            </summary>
            <div class="pad10 indent">
              <ul class="tight">
                <li><span class="codeStyle">void</span> - only type with no values</li>
                <li><span class="codeStyle">bool</span> - values true and false</li>
                <li><span class="codeStyle">std::nullptr_t</span> - type of the nullptr literal</li>
                <li>
                  integral types:
                  <indent-block class="pad10 codeStyle">
                    int <span class="normal">with qualifiers:</span> short, long, long long, unsigned, const, volatile<br />
                    std::size_t, std::size_type
                  </indent-block>
                </li>
                <li>
                  character types:
                  <indent-block class="pad10 codeStyle">
                    char, wchar_t <span class="normal">with qualifiers:</span> signed, unsigned<br />
                    <span class="normal">unicode characters:</span> char16_t, char32_t, char8_t (C++20)
                  </indent-block>
                </li>
                <li>
                  floating point types:
                  <indent-block class="pad10 codeStyle">
                    float, double <span class="normal">with qualifiers:</span> long, const, volatile
                  </indent-block>
                </li>
              </ul>
              <indent-block class="pad10">
                References:
                <indent-block>
                  <a href="https://en.cppreference.com/w/cpp/language/types">cppreference.com/types</a>
                </indent-block>
              </indent-block>
            </div>
          </details>
        </indent-block>
        Arrays, pointers, and references:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">arrays</span>
            </summary>
            <indent-block class="pad10 codeStyle">
              An array is a fixed size sequence of continguous elements, all of the same type.
              <spacer-10></spacer-10>
              T&nbsp;arr[N];&nbsp;&nbsp;<t-s>[ declaration of array </t-s>arr <t-s>]</t-s>
              <spacer-10></spacer-10>
              T&nbsp;t&nbsp;=&nbsp;arr[1];
              <spacer-10></spacer-10>
              <div class="normal">
                <c-s>T</c-s> is any default constructable C++ type,
                <c-s>N</c-s> is a compile-time constant.
                <c-s>t</c-s> contains the value of the second element
                of the <c-s>arr</c-s> array
              </div>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">pointers</span>
            </summary>
            <indent-block style="width:95%;">
              <hidephotosizer-block src="Pictures/PointerImage1.JPG" width="300" class="photoSizerBlock right" style="margin-top:0;">
                <span style="font-family:'Comic Sans MS, Tahoma';">
                  Fig 1. Pointer to x &epsilon; X
                </span>
              </hidephotosizer-block>
              <spacer-15></spacer-15>
              A pointer is a reference to the memory location of a variable, to which it is bound.
              <spacer-10></spacer-10>
              <c-s>
                X x;<br />
                X* pX = &amp;x;&nbsp;&nbsp;<t-s>[</t-s> &amp; <t-s>on right of assignment is an address ]</t-s>
              </c-s>
              <spacer-10></spacer-10>
              <c-s>pX</c-s> is a pointer variable containing the address of <c-s>x</c-s>
              <spacer-10></spacer-10>
              <c-s>++pX</c-s> increments address stored in pX by <c-s>sizeof(X)</c-s>
              <spacer-10></spacer-10>
              Retrieve the value referenced by pX using the dereference operator:
              <c-s>*pX</c-s> returns the value referenced by <c-s>pX</c-s>
            </indent-block>
            <div class="clear"></div>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                C++ references
              </span>
            </summary>
            <indent-block class="pad10" style="width:95%;">
              <c-s>X&amp; xr = x;</c-s>&nbsp;&nbsp;[ declaration of reference <c-s>xr</c-s> bound to <c-s>x</c-s> ]
              <spacer-10></spacer-10>
              Unlike pointers, C++ reference types cannot be reset.  The instance referred to, <c-s>x</c-s>,
              is always defined in the reference declaration and cannot be changed.
              The value of <c-s>xr</c-s> is always the value of <c-s>x</c-s>, which can be changed.
              <spacer-10></spacer-10>
              It is useful to think of a reference as another name for the referenced instance.
              <spacer-10></spacer-10>
              References are most often used to pass arguments to a function by reference.
              <spacer-10></spacer-10>
              Passing an argument to a function by value, <c-s>f(T t)</c-s>, copies the argument&apos;s value to the function&apos;s
              stack frame.
              <spacer-10></spacer-10>
              Passing a parameter by reference, <c-s>f(U&amp; u)</c-s>,
              simply creates a small reference in the function&apos;s stack frame, bound to the parameter in the caller&apos;s
              scope, instead of copying what could be a much larger object.
            </indent-block>
          </details>
        </indent-block>
        C++ standard libraries provide a large set of pre-defined types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">
                STL sequential and associative containers, container adapters
              </span>
            </summary>
            <indent-block class="pad10">
              sequential containers - linear sequence of elements:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>string, array, vector, deque</td>
                    <td class="normal">contiguous memory storage, can be indexed</td>
                  </tr>
                  <tr>
                    <td>forward_list, list</td>
                    <td class="normal">nodes allocated on heap, cannot be indexed</td>
                  </tr>
                </table>
              </indent-block>
              associative containers - key based storage on heap:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>set, multiset, unordered_set, unordered_multiset</td>
                    <td class="normal">key only storage using balanced binary tree or hash table</td>
                  </tr>
                  <tr>
                    <td>map, multimap, unordered_map, unordered_multimap</td>
                    <td class="normal">key-value storage using balanced binary tree or hash table</td>
                  </tr>
                </table>
              </indent-block>
              container adapters:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>queue, stack</td>
                    <td class="normal">sequential containers accessible only from end(s)</td>
                  </tr>
                  <tr>
                    <td>priority_queue</td>
                    <td class="normal">constant time lookup of largest element, logarithmic insertion and extraction</td>
                  </tr>
                </table>
              </indent-block>
              <indent-blocks class="pad10">
                References:
                <indent-block>
                  <a href="https://en.cppreference.com/w/cpp/container">cppreference.com/container</a><br />
                  <a href="STL-Containers.html">STL-Containers.html</a>
                </indent-block>
                <spacer-15></spacer-15>
              </indent-blocks>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                Special containers, streams, and other types
              </span>
            </summary>
            <indent-block class="pad10">
              special containers:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>pair</td>
                    <td class="normal">contains two elements which may have distinct types</td>
                  </tr>
                  <tr>
                    <td>tuple</td>
                    <td class="normal">contains finite number of elements with distinct types</td>
                  </tr>
                  <tr>
                    <td>initializer_list</td>
                    <td class="normal">
                      contains sequence of elements, all of the same type
                      normally filled with initialization list, e.g., { 1, 2, 3, ... }
                    </td>
                  </tr>
                  <tr>
                    <td>any</td>
                    <td class="normal">holds value of any type, provides std::any_cast for retrieval</td>
                  </tr>
                  <tr>
                    <td>optional</td>
                    <td class="normal">used to return values or signal failure to return</td>
                  </tr>
                  <tr>
                    <td>variant</td>
                    <td class="normal">similar to any, but only holds values from a specified set of types</td>
                  </tr>
                </table>
              </indent-block>
              stream types:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>istream</td>
                    <td class="normal">
                      sends sequence of values of fundamental types to console using insertion operator&lt;&lt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ostream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from keyboard using extraction operator&gt;&gt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ifstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached file using extraction operator&lt;&lt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ofstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached file using extraction operator&gt;&gt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>istringstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached in-memory string using extraction operator&lt;&lot;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ostringstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached in-memory string using extraction operator&gt;&gt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                </table>
              </indent-block>
              other types:
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>unique_ptr&lt;T&gt;</td>
                    <td class="normal">
                      Construction allocates instance t &epsilon; T, destruction deallocates t.  Assignment moves ownership.
                    </td>
                  </tr>
                  <tr>
                    <td>shared_ptr&lt;T&gt;</td>
                    <td class="normal">
                      Reference counted smart pointer, assignment adds counted reference.
                    </td>
                  </tr>
                  <tr>
                    <td>exception</td>
                    <td class="normal">
                      When code error occurs exception instance is &quot;thrown&quot;, then handled by catch clause associated
                      with enclosing try block.
                    </td>
                  </tr>
                  <tr>
                    <td>chrono</td>
                    <td class="normal">
                      Class for managing time durations and dates.
                    </td>
                  </tr>
                </table>
              </indent-block>
              <indent-blocks class="pad10">
                References:
                <indent-block>
                  <a href="https://en.cppreference.com/w/cpp/header">cppreference.com/header</a>
                </indent-block>
                <spacer-15></spacer-15>
              </indent-blocks>
            </indent-block>
          </details>
        </indent-block>
        User defined types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">enum, struct, and class</span>
            </summary>
            <indent-block class="pad10">
              scoped enum:
              <indent-block class="pad10 codeStyle">
                enum class Color { red, green, blue };<br />
                Color r = Color::red;
              </indent-block>
              struct:
              <indent-block class="pad10 codeStyle">
                struct S { int i; double d; };<br />
                S s { 2, 3.1415927 };
              </indent-block>
              class:
              <indent-block class="pad10 codeStyle">
                class X {<br />
                public:<br />
                &nbsp;&nbsp;void set(const std::string&amp; s);<br />
                &nbsp;&nbsp;std::string get();<br />
                private:<br />
                &nbsp;&nbsp;std::string str;<br />
                };
              </indent-block>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">type alias</span>
            </summary>
            <indent-block class="pad10">
              alias - c++11:
              <indent-block class="pad10 codeStyle">
                using [aliasName] = [typeName];
              </indent-block>
              alias - C++98:
              <indent-block class="pad10 codeStyle">
                typedef [typeName] [aliasName];
              </indent-block>
            </indent-block>
          </details>
        </indent-block>
        Type testing:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">compile-time and run-time testing</span>
            </summary>
            <indent-block class="pad10">
              compile-time type tests:
              <indent-block class="pad10 codeStyle">
                <a href="https://en.cppreference.com/w/cpp/header/type_traits">std::type_traits</a>
                <span class="normal">, user-defined</span> type-traits;
              </indent-block>
              run-time type tests:
              <indent-block class="pad10 codeStyle">
                <a href="https://en.cppreference.com/w/cpp/types/type_info">std::type_info</a>
              </indent-block>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
        </indent-block>
        Definitions and declarations:
        <indent-block class="pad10">
          <details>
            <summary><span class="labelStyle lightItem">type declaration</span></summary>
            <indent-block class="pad10">
              A type declaration defines a name associated with a specified type, e.g., a set
              of operations supported for the named entity, but defines no storage.  That must
              be done later, but before the entity is used.
              <spacer-10></spacer-10>
              <c-s>extern int x;</c-s>
              <indent-block class="pad10">
                The entity x supports all of the operations for ints, but no storage is defined
                by this statement.
              </indent-block>
              <c-s>void f(int i);</c-s>
              <indent-block class="pad10">
                Declares f to be a function, to be defined later, accepting a single integer
                argument and returning nothing.
              </indent-block>
              <c-s>class X;</c-s>
              <indent-block class="pad10">
                Declares X to be a class to be defined later. X is said to be an incomplete type and
                the statement is a forward declaration of X.
              </indent-block>
              <c-s>class Y { /* operations elided */ };</c-s>
              <indent-block class="pad10">
                We often say that class Y is defined by the statement above, but technically it is a
                declaration, because this statement defines the size required for instances of Y
                but no storage is allocated.
              </indent-block>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary><span class="labelStyle lightItem">type definition</span></summary>
            <indent-block class="pad10" style="width:100%;">
              A type definition allocates storage for a declared entity of a specified type.
              The designer can specify the location of that storage, e.g., in static, stack, or
              heap memory.
              <spacer-10></spacer-10>
              <c-s>int x; int y{ 2 };</c-s>
              <indent-block class="pad10">
                The variable <c-s>x</c-s> is declared and storage is allocated
                in the local stack frame, and filled with a default value;
                <spacer-10></spacer-10>
                The variable <c-s>y</c-s> is declared and storage is allocated in the local stack
                frame and initialized with the value <c-s>2</c-s>.
                <spacer-10></spacer-10>
                <background-block>
                  Life-time of this storage extends from the point of declaration until the thread
                  of execution leaves the current scope.
                </background-block>
              </indent-block>
              <c-s>void f(int i) { std::cout << "\n  " << argument has value << i; }</c-s>
              <indent-block class="pad10">
                The code within the <c-s>{</c-s> and <c-s>}</c-s> scope delimiters is compiled and allocated
                to static memory adjacent to other code from the surrounding program.
                <spacer-10></spacer-10>
                <background-block>
                  Life-time of this allocation is the life time of the program after the program&apos;s
                  process has been created until the process begins termination.
                </background-block>
              </indent-block>
              <c-s>X x; Y y(...);</c-s>
              <indent-block class="pad10">
                Reserves storage for <c-s>x &epsilon; X</c-s> in the stackframe for its local scope
                and initializes that storage with a default value.
                <spacer-10></spacer-10>
                Reserves storage in the local stackframe for <c-s>y &epsilon; Y</c-s> and
                initializes the storage using a Y constructor function that accepts the type(s)
                specified by the ... elipsis, above.
                <spacer-10></spacer-10>
                <background-block>
                  Life-time of this storage extends from the point of declaration until the thread
                  of execution leaves the current scope.
                </background-block>
              </indent-block>
              <c-s>static T t;</c-s> where <c-s>T</c-s> is some fundamental or user-defined type
              <indent-block class="pad10">
                Allocates storage for variable <c-s>t</c-s> in static memory, adjacent to other code for
                the program.
                <spacer-10></spacer-10>
                <background-block>
                  Life-time of the memory
                  reservation for <c-s>t</c-s> extends from first use to the end of program
                  execution.
                </background-block>
              </indent-block>
              <c-s>X* pX = new X;</c-s>
              <indent-block class="pad10">
                Allocates storage for the pointer <c-s>pX</c-s> in the local stack frame, and
                allocates storage in the native heap for an un-named instance of <c-s>X</c-s>.  The storage
                for <c-s>pX</c-s> is initialized with the heap address of the <c-s>X</c-s> instance, and
                the storage of the instance of <c-s>X</c-s> is initialized by <c-s>X</c-s>&apos;s default constructor.
                <spacer-10></spacer-10>
                <background-block>
                  Life-time for this storage extends from the time the new operator is invoked
                  until <c-s>delete</c-s> operator is called on <c-s>pX</c-s>.
                </background-block>
              </indent-block>
            </indent-block>
          </details>
        </indent-block>
        We will provide examples of, and cover many details about, C++ data types in Chapter 2 - Data.
        <spacer-15></spacer-15>
      </indent-blocks>
      <hr class="spread" style="border:2px solid #999;" />
      <h4>Operations:</h4>
      <indent-blocks>
        C++ programs consist of an ordered sequence of
        <a href="https://en.cppreference.com/w/cpp/language/statements">statments</a> where a statement is
        an <a href="https://en.cppreference.com/w/cpp/language/expressions">expression</a> followed
        by a semicolon &quot;<c-s>;</c-s>&quot;.
        Statements may be declarative, expression, iterative, selection, and try-block, and may be
        combinations of these. Declarative statements are compile-time artifacts, disappearing after
        compilation.  All the others generate code that executes at run-time.
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">program scopes</span>
            </summary>
            <indent-block class="pad10">
              C++ programs are partitioned by scopes, e.g., sequences of statements enclosed within braces
              <span style="white-space:nowrap;">&quot;<c-s>{</c-s> &quot; and &quot;<c-s>}</c-s>&quot;.</span>
              <spacer-10></spacer-10>
              There are several types of scopes:
              <ul class="tight pad10">
                <li>
                  <c-s>namespace N { ... }</c-s>
                </li>
                <li>
                  <c-s>class C { ... };</c-s>
                </li>
                <li>
                  <c-s>struct S { ... }</c-s>
                </li>
                <li>
                  <c-s>enum class E { ... }</c-s>
                </li>
                <li>
                  <c-s>void f(int i) { ... }</c-s>
                </li>
                <li>
                  <c-s>try { ... } catch(execption&amp; ex) { ... }</c-s>
                </li>
                <li>
                  <c-s>for(startExpression; endExpression; incrementExpression) { ... }</c-s>
                </li>
                <li>
                  <c-s>for(T t : container) { ... }&nbsp;&nbsp;T</c-s> may be replaced by <c-s>auto</c-s>
                </li>
                <li>
                  <c-s>while(predicate) { ... }</c-s>
                </li>
                <li>
                  <c-s>do { ... } while(predicate);</c-s>
                </li>
                <li>
                  <c-s>if(predicate) { ... } else { ... }</c-s>
                </li>
              </ul>
              The first four are compile-time artifacts that define names, allowed operations,
              and accessibility.  They disappear after compilation.
              <spacer-10></spacer-10>
              The rest are compile-time and run-time constructs that affect execution and
              execution flow. Any entity declared within these scopes has a life-time that
              starts at the point of declaration and ends when the thread of execution leaves the scope.
              <spacer-10></spacer-10>
              We will discuss all of these run-time operations in this section, below.
            </indent-block>
          </details>
        </indent-block>
        C++ provides unary and binary <a href="https://en.cppreference.com/w/cpp/language/expressions">operations</a>
        for the fundamental types.  It also provides operator functions that may be overloaded for
        user-defined types.
        Some of the most used operations and
        <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">operators</a>
        are illustrated here for both fundamental and user-defined types:
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">
                dereference and address of:&nbsp;&nbsp;
                <span class="codeStyle">* &amp;</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle" style="width:95%;">
              <hidephotosizer-block src="Pictures/PointerImage.JPG" width="300" class="photoSizerBlock right" style="margin-top:0;">
                <span style="font-family:'Comic Sans MS, Tahoma';">
                  Fig 2. Pointer to x &epsilon; X
                </span>
              </hidephotosizer-block>
              <spacer-15></spacer-15>
              struct X { Y y; ... }; X x1; Y y;
              <spacer-15></spacer-15>
              X* pX = &amp;x1;<br />
              <span class="normal">sets pointer</span>
              pX &#949; X*
              <span class="normal">to address of instance</span> x1 &#949; X
              <spacer-15></spacer-15>
              X x2 = *pX;<br />
              <span class="normal">instance</span> x2 &#949; X
              <span class="normal">gets copy of contents of </span>x1
              <span class="normal">pointed to by</span> pX<br />
              <span class="normal">by dereferencing pointer, </span>
              pX <span class="normal">and assigning value to</span> x2
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                member access operations:&nbsp;&nbsp;
                <span class="codeStyle">. -></span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              struct X { int y; ... };
              <spacer-10></spacer-10>
              X x{ 2, ... }; X* pX = &amp;x;
              <spacer-10></spacer-10>
              x.y, pX->y <span class="normal">both refer to value of</span>
              y<span class="normal">, e.g., </span> 2<span class="normal">, contained in struct</span> X
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                pre increment and decrement:&nbsp;&nbsp;
                <span class="codeStyle">++i --i</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              int i{ 0 }; ++i; --i;<br />
              ++i <span class="normal">increments</span>
              i <span class="normal">and returns value</span> 1<br />
              --i <span class="normal">decrements</span>
              i <span class="normal">and returns value</span> 0
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                post increment and decrement:&nbsp;&nbsp;
                <span class="codeStyle">i++ i--</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              int i{ 0 }; i++; i--;<br />
              i++ <span class="normal">increments value to</span> 1
              <span class="normal">and returns prior value</span> 0<br />
              i-- <span class="normal">decrements value to</span> 0
              <span class="normal">and returns prior value</span> 1<br />
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                logical operators:&nbsp;&nbsp;
                <span class="codeStyle">== != &lt; &lt;= &gt;= &gt; &amp;&amp; || !</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              Here, we illustrate how a user defined type could implement<br />
              two of these logical operations:
              <spacer-15></spacer-15>
              struct X {<br />
              &nbsp;&nbsp;int i; double d;<br />
              &nbsp;&nbsp;bool operator==(const X&amp; x) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;return i == x.i && d == x.d;<br />
              &nbsp;&nbsp;}<br />
              &nbsp;&nbsp;bool operator!=(const X&amp; x) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;return i != x.i || d != x.d;<br />
              &nbsp;&nbsp;}<br />
              };
              <spacer-15></spacer-15>
              X x1{ 1, 1.5 }, x2{ 1, 1.5 }; x3{ 2, -0.5 }<br />
              x1 == x2; x1 != x3;
              <spacer-15></spacer-15>
              <span class="normal">Both statements above are true.</span>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                index operator:&nbsp;&nbsp;
                <span class="codeStyle">a[]</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              double a[] { 1.0, 1.5, 2.0 };
              <spacer-15></spacer-15>
              a[1] == 1.5 <span class="normal">has value</span> true
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                arithmetic operations:&nbsp;&nbsp;
                <span class="codeStyle">+ - * /</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              int x1{ 2 }; int x2{ 4 };
              <spacer-10></spacer-10>
              x1 + x2 == 6;
              x1 - x2 == -2;
              x1 * x2 == 8;
              x2 / x1 == 2;
              <spacer-10></spacer-10>
              <span class="normal">All of the boolean expressions above are true</span>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                loops:&nbsp;&nbsp;for, while, do
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              <hr />
              <spacer-15></spacer-15>
              for(int i=0; i&lt;Max; ++i) {
              <comment-block>
                Any, or all, of the three loop conditions may be omitted, provided
                that omitted conditions are defined.  If no termination condition is provided,
                the loop requires a conditional break statement to terminate.
                <spacer-10></spacer-10>
                Loop operations elided
              </comment-block>
              }
              <hr class="spread" />
              for(auto item : collection) {
              <comment-block>
                Collection must provide an iterator and methods begin() and end()
                which return iterators referring to the first element and one past
                the last of its elements.
                <spacer-10></spacer-10>
                Loop operations elided
              </comment-block>
              }
              <hr class="spread" />
              while(predicate) {
              <comment-block>
                Loop operations will not be executed if predicate is false on entry.
                <spacer-10></spacer-10>
                Loop will continue until operations in scope of the loop
                make its predicate false.
                <spacer-10></spacer-10>
                Loop operations elided
              </comment-block>
              }
              <hr class="spread" />
              do {
              <comment-block>
                Ensures that loop operations are executed at least once.
                <spacer-10></spacer-10>
                Loop will continue until operations in scope of the loop
                make its predicate false.
                <spacer-10></spacer-10>
                Loop operations elided
              </comment-block>
              } while(predicate);
              <hr class="spread" />
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                selection:&nbsp;&nbsp;if-else, ternary operator, switch
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              <hr>
              <spacer-15></spacer-15>
              if(predicate) {
              <comment-block>
                Operations to execute when predicate is true go here.
              </comment-block>
              }<br />
              else {
              <comment-block>
                Operations to execute when predicate is false go here.
                This else clause is optional.
              </comment-block>
              }
              <hr class="spread">
              <div class="normal">
                The ternary operator:
                <indent-block class="pad10">
                  <c-s>predicate ? e1 : e2</c-s>
                </indent-block>
                returns the value of expression <c-s>e1</c-s> if <c-s>predicate</c-s>
                evaluates to <c-s>true</c-s>, otherwise it returns the value of expression
                <c-s>e2</c-s>.
              </div>
              <hr class="spread">
              <div class="normal">
                The switch operation enables execution of code specific to some specified case.
                <spacer-10></spacer-10>
                switch selectors, <c-s>iSelect</c-s>, and switch cases, <c-s>iSelect1, iSelect2, ...</c-s>
                belong to a list, IS, of integral selectors, e.g., distinct integers or values of an enumeration:
                <c-s>iSelect, iSelect1, iSelect2, ... &epsilon; IS</c-s>
              </div>
              <spacer-10></spacer-10>
              switch(iSelect) {<br />
              case iSelect1:
              <comment-block>
                Operations for iSelect1 case go here.
              </comment-block>
              &nbsp;&nbsp;break;<br />
              case iSelect2:
              <comment-block>
                Operations for iSelect2 case go here.
              </comment-block>
              &nbsp;&nbsp;break;<br />
              &nbsp;&nbsp;----<br />
              default:
              <comment-block>
                Operations when iSelect does not match any declared iSelect[n] case go here.
              </comment-block>
              &nbsp;&nbsp;break;<br />
              }
              <hr class="spread">
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                function call operator:&nbsp;&nbsp;
                <span class="codeStyle">f()</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              void f(const std::string& str)<br />
              {<br />
              &nbsp;&nbsp;std::cout << "\n  " << str;<br />
              }
              <spacer-15></spacer-15>
              f("hello Syracuse"); <span class="normal">displays message on console</span>
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">
                method call operator:&nbsp;&nbsp;
                <span class="codeStyle">operator()</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              class X {<br />
              &nbsp;&nbsp;void operator()(const std::string&amp; s) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;std::cout << "\n  " << s;<br />
              &nbsp;&nbsp;}<br />
              };
              <spacer-15></spacer-15>
              X x;<br />
              x("hello");<br />
              x.operator()("hello");
              <spacer-15></spacer-15>
              <span class="normal">
                The last two statements are equivalent.
                <spacer-15></spacer-15>
                We call X a functor because an
                instance can be invoked like a function, as above.
              </span>
            </indent-block>
          </details>
        </indent-block>
        Users can define invocable functions at namespace scope, including the global namespace,
        but cannot define functions in function scope, e.g., no inner functions.
        Users define methods (functions bound to a specific class) in class scope.
        <spacer-15></spacer-15>
        <a href="https://en.cppreference.com/w/cpp/language/lambda">Lambdas</a> are locally defined
        callable objects that are useful for starting threads and using STL algorithms.
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">
                Lambda:&nbsp;&nbsp;
                <span class="codeStyle">[/* capture here */](/* args here */) { /* code block here */ };</span>
              </span>
            </summary>
            <indent-block class="pad10 codeStyle">
              char ul = '-';<br />
              auto makeTitle = [ul](const std::string&amp; title) {<br />
              &nbsp;&nbsp;std::cout << "\n  " << title;<br />
              &nbsp;&nbsp;std::cout << "\n " << std::string(title.size() + 2, ul);<br />
              };
              <spacer-15></spacer-15>
              makeTitle("demonstrate lambda");
              <spacer-15></spacer-15>
              <span class="normal">emits:</span>
              <spacer-15></spacer-15>
              &nbsp;&nbsp;demonstrate lambda<br />
              &nbsp;--------------------
              <spacer-15></spacer-15>
              [ul] <t-s>captures the value of local variable</t-s> ul <t-s>from the local scope
              and uses it for an underline character, below the title message. The title is passed in
              as a parameter when lambda, </t-s>makeTitle<t-s>, is invoked.</t-s>
            </indent-block>
          </details>
        </indent-block>
        Lambdas maybe defined in namespace, function, and method scopes, and so, can serve the role
        of inner functions.  They are useful for much more, as we will see below and in Chapter 2.
      </indent-blocks>
      <hr class="spread" style="border:2px solid #999;" />
      <h4>Classes and class relationships:</h4>
      <indent-blocks>
        C++ classes and structs are identical except that struct members are public by default and
        class members are private by default.  With either, we choose to make some members public with
        a &quot;public:&quot; declaration and others private with &quot;private:&quot;.
        <spacer-15></spacer-15>
        By convention, we use structs to aggregate data, much like std::tuple.  We also use them to
        define code interfaces, as described in Chapter&nbsp;4.
        We use classes to implement some abstraction defined by its public members.  If a class is well
        designed, only its methods have direct access to data it manages.  That allows a class to make
        strong guarantees about the validity of its data.
        <spacer-15></spacer-15>
        Object Oriented Design consists of using classes and class relationships to structure program
        activities.  Basic classes can be quite simple, defining only methods for managing and accessing
        class state, as discussed here.  The language, however, provides additional design facilities for supporting
        value or reference type behavior.  We will address those details in Chapter 4.
        <spacer-10></spacer-10>
        <indent-block class="pad10">
          <details>
            <summary><span class="labelStyle lightItem">basic class</span></summary>
            <indent-block class="pad10" style="width:100%;">
              Class Person declares personal data contained by each instance. These &quot;stats&quot; contain
              name, occupation, and age,
              held in a <c-s>std::tuple</c-s>.
              <spacer-15></spacer-15>
              Instances of the Person class can be copied and assigned because its only data member,
              personStats is a std::tuple.
              The std::tuple and its elements all have correct copy, assignment, and destruction semantics.
              <spacer-15></spacer-15>
              Compiler generated methods for copying, assignment, and destruction do those operations
              on each of a class&apos;s base classes and composed member data items.  In this case, those
              generated operations simply use the std::tuple&apos;s copy, assignment, and destruction operations.
              <spacer-15></spacer-15>
              <hidephotosizer-block src="Pictures/PersonCodeLayout.JPG" width="300" class="photoSizerBlock right">
                <span style="font-family:'Comic Sans MS, Tahoma';">
                  <br />
                  Fig 1. Person Class code layout
                </span>
              </hidephotosizer-block>
              <pre class="codeStyle">
class Person {
public:
  using Name = std::string;
  using Occupation = std::string;
  using Age = int;
  using Stats = std::tuple&lt;Name, Occupation, Age&gt;;

  Person();
  Person(const Stats& sts);
  Stats stats() const;
  void stats(const Stats& sts);
  bool isValid();
  Name name() const;
  Occupation occupation() const;
  void occupation(const Occupation&amp; occup);
  Age age() const;
  void age(const Age&amp; ag);

private:
  Stats personStats;
};
</pre>
              <spacer-15></spacer-15>
              <div class="normal">
                Note that Person defines four type aliases with names that make the class&apos;s code
                readable,
                easer to test, and easer to use.
                <spacer-15></spacer-15>
                It provides getter and setter methods for attributes
                occupation and age that should be changeable, and only a getter for the name attribute
                which should not.
                <spacer-15></spacer-15>
                References:
                <indent-block class="pad10">
                  <a href="CppStoryRepo.html">CppStory Repository</a>
                </indent-block>
              </div>
              <spacer-15></spacer-15>
              <hr class="spread" />
            </indent-block>
          </details>
        </indent-block>
        <spacer-10></spacer-10>
        If you look back at the Person class, in basic class - the previous details, you will see two things that might seem peculiar.
        There are two functions with the same name, Person, and they have no return values.
        C++ classes define constructors for building initialized instances of the class.
        The language recognizes constructors as any function with the same name as the class and no return values.
        <spacer-15></spacer-15>
        The fact that constructors return no values - not even void - is specified by the language.
        In order to handle two or more functions with the same name, C++ defined function overloading.
        <spacer-10></spacer-10>
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">function overloading</span>
            </summary>
            <indent-block class="pad10" style="width:100%">
              Function overloading is the definition of two or more functions with the same name
              but different sequences of argument types<sup>1</sup>.
              <spacer-15></spacer-15>
              Consider the two Person constructors, from the previous &quot;basic class&quot; details:
              <spacer-10></spacer-10>
              <c-s>
                &nbsp;&nbsp;Person();<br />
                &nbsp;&nbsp;Person(const Stats&amp; sts);<br />
              </c-s>
              <spacer-10></spacer-10>
              The second has an sts argument, used to initialize an internal data member.
              The first has no argument, so the internal data member has a default initialization.
              <spacer-15></spacer-15>
              C++ classes need the ability to initialize instances in different ways, like this, and since
              the class&apos;s constructors all have the same name, the compiler has to distinguish
              between them in some way.  
              <spacer-15></spacer-15>
              It does that by treating a function name concatenated with the types of its arguments<sup>2</sup>
              as the compiler&apos;s name for that function.  This process of making qualified names
              is called name-mangling.  That is what enables function overloading.
              <spacer-15></spacer-15>
              Function overloading is used in most class declarations, but a designer is free to use
              overloading for other purposes as well.
              <hr class="spread" />
              <ol class="footnote">
                <li>
                  Return types play no role in function overloading.
                </li>
                <li>
                  Actually, the name consists of a tokenized sequence that identifies the function name
                  and argument types in a compact format.
                </li>
              </ol>
            </indent-block>
          </details>
        </indent-block>
        <spacer-10></spacer-10>
        There are five relationships between C++ classes: inheritance, composition, aggregation, using, and friendship.
        The first four of these are supported by most object oriented languages.
        <spacer-10></spacer-10>
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">class relationships</span>
            </summary>
            <div class="pad10-15" style="max-width:95%;">
              <!-- onclick toggle picture visibilitiy -->
              The five relationships between C++ classes are:
              <ol class="tight pad10">
                <li>
                  Inheritance: a specialization of a base class by another derived class.
                </li>
                <li>
                  Composition: a permanent relationship between the composer
                  and composed.
                </li>
                <li>
                  Aggregation: a temporary relationship between the aggregator and aggregated.
                </li>
                <li>
                  Using: a non-owning relationship.  The used is made available to the user
                  by passing as a reference argument in a class method.
                </li>
                <li>
                  Friendship: a relationship granted by a class to one specific friend that allows
                  the friend access to the class&apos;s private members.  Friendship weakens encapsulation and
                  so is used only when necessary, e.g., rarely.
                </li>
              </ol>
              <hidephotosizer-block src="Pictures/PersonClassHierarchy.JPG" width="400" class="photoSizerBlock right">
                <span style="font-family:'Comic Sans MS, Tahoma';">
                  <br />
                  Fig 1. Person Class Hierarchy
                </span>
              </hidephotosizer-block>
              The <c-s>Person</c-s> class, from the previous example, has been expanded into a class hierarchy representing software
              development roles that a person might assume.  A class hierarchy like this
              could be used to build a Project Management Tool that tracked progress on a
              project and the contributions of individual team members.
              <spacer-15></spacer-15>
              There are several types of classes in this hierarchy:
              <ul class="tight">
                <li>Interfaces: <c-s>IPerson</c-s> and <c-s>ISW-Eng</c-s></li>
                <li>An abstract class: <c-s>SW-Eng</c-s></li>
                <li>
                  Concrete classes: <c-s>
                    Person, Dev, TeamLead, ProjMgr,
                    Project, Baseline, Documents,
                  </c-s> and <c-s>Budget</c-s>
                </li>
              </ul>
              <spacer-15></spacer-15>
              Interfaces, <c-s>IPerson</c-s> and <c-s>ISW-Eng</c-s>, support decoupling the hierarchy from its users, so that changes
              to any of these classes don&apos;t require clients to change, as long as the
              interface doesn&apos;t change.
              <spacer-15></spacer-15>
              The abstract class <c-s>SW-Eng</c-s> provides shared code and types for all its derived classes.
              <spacer-15></spacer-15>
              The concrete classes <c-s>Dev, TeamLead,</c-s> and <c-s>ProjMgr</c-s>, represent roles that a Software Engineer
              may assume while working on the project.  The <c-s>Person</c-s> class is the key abstraction.  All of the
              other parts serve to endow a person with one or more roles, e.g., developer, team lead, or project
              manager.
              <spacer-15></spacer-15>
              All of the relationships between these classes are based on <strong class="notice">inheritance</strong>.
              <spacer-15></spacer-15>
              The <c-s>ProjMgr</c-s> class <strong class="notice">aggregates</strong> a <c-s>Project</c-s> instance, allowing a manager to move to another
              project when the current project completes.
              <spacer-15></spacer-15>
              The <c-s>Project</c-s> class <strong class="notice">composes</strong> a <c-s>Budget</c-s> since that is an integral part of the project.  It
              <strong class="notice">aggregates</strong> <c-s>Documents</c-s> and code <c-s>Baseline</c-s>,
              as these don&apos;t exist at the beginning of the project.
              <spacer-15></spacer-15>
              Developers and Team Leads <strong class="notice">use</strong> the <c-s>Baseline</c-s> by contributing additions,
              but they don&apos;t have an ownership relationship - only the Project Manager can authorise
              deletions and creation of major new parts.
            </div>
            <hr class="spread" />
          </details>
        </indent-block>
        <spacer-10></spacer-10>
        Inheritance supports sharing base class code with all of its derived classes.  While this is useful,
        inheritance&apos;s most important feature is support for substituting derived class pointers and references whereever
        a function accepts a base class pointer or reference.
        <spacer-10></spacer-10>
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">
                function overriding
              </span>
            </summary>
            <indent-block class="pad10" style="width:100%;">
              Suppose that, in the <c-s>SW-Eng</c-s> abstract class, from the previous &quot;class relationships&quot;
              details, we&apos;ve defined a <c-s>virtual void doWork()</c-s> method.
              <spacer-15></spacer-15>
              One might expect that <c-s>Dev</c-s>s, <c-s>TeamLead</c-s>s, and <c-s>PrjMgr</c-s>s would each
              have their own work behaviors, and so, each should have its own definition for what <c-s>doWork</c-s>
              means.  Virtual function overloading allows us to specify those different behaviors.
              <spacer-15></spacer-15>
              Virtual function overloading is the process of, in each derived class, providing a defintion for the function
              execution of that function based on the type of the derived class, e.g., <c-s>Dev</c-s>, <c-s>TeamLead</c-s>,
              or <c-s>PrjMgr</c-s>.  The virtual functions in each derived
              class must have the same signature, e.g., <c-s>void doWork()</c-s>, and this redefinition only applys to
              functions that are qualified as <c-s>virtual</c-s> in the base class.
            </indent-block>
          </details>
        </indent-block>
        <spacer-10></spacer-10>
        Most C++ projects use classes extensively.  Usually almost all of the code is devoted to implementing
        classes and using class instances.  We will look at, and dissect, examples in Chapter 4.
      </indent-blocks>
      <hr class="spread" style="border:2px solid #999;" />
      <h4>Templates and specialization</h4>
      C++ templates provide a way of defining library functions and classes that depend
      on some unspecified type or types.  STL containers like <c-s>std::vector&lt;T&gt;</c-s>
      are examples.
      <spacer-15></spacer-15>
      Template functions and classes need to be instantiated by using applications
      with specific type(s) before they can be used, e.g., <c-s>std::vector&lt;std::string&gt;</c-s>.
      <indent-blocks>
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">template functions</span>
            </summary>
            <indent-block class="pad10" style="max-width:95%;">
              The template function <c-s>max&lt;T, T&gt;</c-s> accepts two arguments of the same
              type and returns an instance of that type with the value of the larger of the
              arguments.
              <spacer-10></spacer-10>
              <c-s>
                template &lt;typename T&gt;<br />
                T max(const T&amp; t1, const T&amp; t2) {<br />
                &nbsp;&nbsp;return t1 &gt; t2 ? t1; t2;<br />
                }
              </c-s>
              <spacer-10></spacer-10>
              This function, when instantiated with a specific type, will compile successfully
              provided that T has defined <c-s>operator&gt;(T&amp; t)</c-s>. Otherwise, compilation
              fails.
              <spacer-10></spacer-10>
              There is another subtle problem with <c-s>max&lt;T, T&gt;</c-s>.  It works correctly
              for fundamental types and instances of classes like <c-s>std::string</c-s>.
              However, if we make the following invocation:
              <spacer-10></spacer-10>
              <indent-block class="pad10">
                <c-s>const char* pStr = max&lt;&quot;aardvark&quot;, &quot;zebra&quot;&gt;;</c-s>
              </indent-block>
              <spacer-10></spacer-10>
              the function compiles, but we may not get a result we expect.
              <c-s>max&lt;const char*, const char*&gt;</c-s> returns the larger of
              its two arguments, which, in this case are pointers, so we will get a pointer to whichever
              string is stored in the higher memory location, having nothing to do with lexicographic
              ordering of its arguments.
              <spacer-10></spacer-10>
              We see how to fix it by overloading <c-s>max&lt;T, T&gt;</c-s> for
              that specific case, below.
            </indent-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary>
              <span class="labelStyle lightItem">overloading template functions</span>
            </summary>
            <indent-block class="pad10" style="max-width:95%;">
              Here&apos;s the original <c-s>max&lt;T, T&gt;</c-s> declaration:
              <background-block class="pad10 indent">
                <c-s>
                  template &lt;typename T&gt;<br />
                  T max(const T&amp; t1, const T&amp; t2) {<br />
                  &nbsp;&nbsp;return t1 &gt; t2 ? t1; t2;<br />
                  }
                </c-s>
              </background-block>
              and here is a function overload declaration for the case of <c-s>const char*</c-s>:
              <background-block class="pad10 indent">
                <c-s>
                  using pStr = const char*;<br />
                  template &lt;&gt;<br />
                  pStr max(const pStr&amp; s1, const pStr&amp; s2) {<br />
                  &nbsp;&nbsp;return ((strcmp(s1,s2)>0) ? S1 : s2);<br />
                  }
                </c-s>
              </background-block>
              <spacer-10></spacer-10>
              The C++ language guarantees that the most specific function overload will be
              applied to compile a function.  In the case of <c-s>const char*</c-s>, <c-s>pStr</c-s> is more specific
              than the template type <c-s>T</c-s>, so the second version will be compiled
              and the result will return the string with largest lexicographic order because
              that is what the C function <c-s>strcmp</c-s> returns.
              <spacer-10></spacer-10>
              This overloading guarantee is very important.  It means that we can define a
              generic template for a class and then supply specific overloads for any types
              that are problematic.
              <spacer-10></spacer-10>
              This isn&apos;t a perfect solution, because there may be an open-ended set of
              types that cause problems, but if we encounter more problematic types, we can
              provide additional overloads.
            </indent-block>
          </details>
        </indent-block>
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">template classes</span>
            </summary>
            <indent-block class="pad10" style="max-width:95%;">
              C++ classes can be declared as templates too.  Here&apos;s an example:
              <spacer-10></spacer-10>
              <c-s>
                template &lt;typename T&gt;<br />
                class stack {<br />
                public:<br />
                &nbsp;&nbsp;void push(T t);<br />
                &nbsp;&nbsp;T pop();<br />
                &nbsp;&nbsp;T top();<br />
                &nbsp;&nbsp;std::size_type size();<br />
                private:<br />
                &nbsp;&nbsp;// data members elided<br />
                };
                <spacer-10></spacer-10>
                template &lt;typename T&gt;<br />
                void stack&lt;T&gt;::push(T t) {<br />
                &nbsp;&nbsp;// details elided<br />
                }
                <spacer-10></spacer-10>
                // other member function definitions elided
              </c-s>
              <spacer-15></spacer-15>
              With this template declaration we can define:
              <spacer-10></spacer-10>
              <c-s>
                stack&lt;int&gt; intStk;<br />
                stack&lt;std::pair&lt;std::string, int&gt;&gt; prStk;<br />
                stack&lt;Widget&gt; WdgStk;<br />
              </c-s>
              <spacer-10></spacer-10>
              Without templates we would have to declare a <c-s>stack</c-s> class for each of these
              types.  With templates the compiler does all that extra work for us.
              <spacer-10></spacer-10>
              For each instantiation, the compiler generates a class for that type.  Syntactically,
              each of the above declarations defines a distinct class.  That is,
              <c-s>stack&lt;int&gt;</c-s> is not the same type as
              <c-s>stack&lt;std::pair&lt;std::string, int&gt;&gt; prStk;</c-s>
            </indent-block>
          </details>
        </indent-block>
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">template class specialization</span>
            </summary>
            <indent-block class="pad10" style="max-width:95%;">
              Suppose that, for the user-defined type <c-s>Widget</c-s>, some <c-s>stack&lt;T&gt;</c-s>
              methods fail to compile or process a <c-s>Widget</c-s> incorrectly.
              That could happen if the stack provides copy and assignment operations, but
              <c-s>Widget</c-s> instances are not copyable or assignable, or those operations
              are incorrect for <c-s>Widget</c-s> due to an incomplete design<sup>1</sup>.
              <spacer-10></spacer-10>
              For that, we can use template
              specialization to fix that problem, in much the same way as we did by overloading
              <c-s>max&lt;T, T&gt;</c-s> in the discussion of overloading template functions.
              For the <c-s>Widget</c-s> specialization we would declare the
              <c-s>stack&lt;Widget&gt;</c-s> copy and assignment operations as deleted
              with <c-s>=delete</c-s> postfix qualifiers.
              <spacer-15></spacer-15>
              The generic class is defined as:
              <spacer-10></spacer-10>
              <background-block class="pad10 indent">
                <c-s>
                  template &lt;typename T&gt;<br />
                  class stack {<br />
                  public:<br />
                  &nbsp;&nbsp;stack();<br />
                  &nbsp;&nbsp;stack(const stack&lt;T&gt;&amp; stk);<br />
                  &nbsp;&nbsp;stack&lt;T&gt;&amp; operator=(const stack&lt;T&gt;&amp; stk);<br />
                  &nbsp;&nbsp;void push(T t);<br />
                  &nbsp;&nbsp;T pop();<br />
                  &nbsp;&nbsp;T top();<br />
                  &nbsp;&nbsp;std::size_type size();<br />
                  private:<br />
                  &nbsp;&nbsp;// data members elided<br />
                  };
                  <spacer-10></spacer-10>
                  template &lt;typename T&gt;<br />
                  void stack&lt;T&gt;::push(T t) {<br />
                  &nbsp;&nbsp;// details elided<br />
                  }
                  <spacer-10></spacer-10>
                  // other member function definitions elided
                </c-s>
                <spacer-15></spacer-15>
                <c-s>
                  stack&lt;Widget&gt; WdgStk;
                </c-s>
                // fails to compile or exhibits incorrect operation.
              </background-block>
              <spacer-15></spacer-15>
              So, we define a <c-s>stack</c-s> class specialization for <c-s>Widgets</c-s>
              like this:
              <spacer-10></spacer-10>
              <background-block class="pad10 indent">
                <c-s>
                  template &lt;&gt;<br />
                  class stack&lt;Widget&gt; {<br />
                  public:<br />
                  &nbsp;&nbsp;stack();<br />
                  &nbsp;&nbsp;stack(const stack&lt;T&gt;&amp; stk) = delete;<br />
                  &nbsp;&nbsp;stack&lt;T&gt;&amp; operator=(const stack&lt;T&gt;&amp; stk) = delete;<br />
                  &nbsp;&nbsp;void push(Widget w);<br />
                  &nbsp;&nbsp;Widget pop();<br />
                  &nbsp;&nbsp;Widget top();<br />
                  &nbsp;&nbsp;std::size_type size();<br />
                  private:<br />
                  &nbsp;&nbsp;// elided data members may be different from the generic class<br />
                  };
                  <spacer-10></spacer-10>
                  template &lt;typename T&gt;<br />
                  void stack&lt;T&gt;::push(T t) {<br />
                  &nbsp;&nbsp;// elided details may be different from the generic class<br />
                  }
                  <spacer-10></spacer-10>
                  // other member function definitions elided
                </c-s>
                <spacer-10></spacer-10>
                <c-s class="pad10">
                  stack&lt;Widget&gt; WdgStk;
                </c-s>
                <spacer-10></spacer-10>
                // now compiles if we don&apos;t try to copy or assign instances<br />
                // and exhibits correct operation
              </background-block>
              <spacer-15></spacer-15>
              The C++ language guarantees that a specialization will be compiled instead of the
              generic class whenever the class is instantiated with a specialized type, like
              <c-s>Widget</c-s>
              <hr class="spread" />
              <ol style="font-size:0.8em;">
                <li>
                  We will discuss, in Chapter 4., how incomplete designs happen and how to ensure your designs
                  are complete.
                </li>
              </ol>
            </indent-block>
          </details>
        </indent-block>
      </indent-blocks>
      <hr class="spread" style="border:2px solid #999;" />
      <h4>Libraries</h4>
      The C++ standard libraries collection is very large, perhaps overwhelming.
      Many of us are quite familiar with a small subset, and browse through the
      rest when we need some functionality that could be there.
      <spacer-15></spacer-15>
      <indent-blocks>
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">standard C++ libraries</span>
            </summary>
            <indent-block class="pad10" style="max-width:95%;">
              I&apos;ve enumerated a lot of the libraries and some of their contents in order
              to support your browsing process.
              <div style="border:2px solid darkred; width:max-content; max-width:95%; padding:10px; margin:15px 0px;">
                This material was drawn from resources provided by
                <a href="https://en.cppreference.com/w/cpp">cppreference.com</a>.<br />
                Only the organization has been changed (slightly) and a few of the more
                obscure libraries omitted.  I&apos;ve annotated the material and emphasized
                those libraries I use frequently.  You will see most of them in examples
                throughout this story.
              </div>
              Here are some categories:
              <ul>
                <li>
                  Language Support libraries
                  <ul class="tight">
                    <li>
                      <span class="notice">&lt;initializer_list&gt;</span> - supports uniform initialization for user-defined types,
                      examples in Chapter 2.
                    </li>
                    <li>
                      <span class="notice">&lt;type_traits&gt;</span> - used for template metadata programming, examples in Chapter 3.
                    </li>
                    <li>&lt;limits&gt; - Numeric limits</li>
                    <li>&lt;cstdlib&gt; - Managing OS Processes and Signals</li>
                  </ul>
                </li>
                <li>
                  General Utilities libraries
                  <ul class="tight">
                    <li><span class="notice">&lt;memory&gt;</span> - Smart pointers and allocators, examples in Chapter 4</li>
                    <li>&lt;chrono&gt; - Time durations, times, and dates</li>
                    <li>
                      Function objects and qualilfiers:
                      <indent-block>
                        <div>
                          <span class="notice">&lt;functional&gt;</span> - function, mem_fn, bind, invoke, ref
                        </div>
                        <div>
                          <span class="notice">&lt;utility&gt;</span> - move, forward, pair, tuple, examples in Chapters 2 and 3
                        </div>
                        <span class="notice">&lt;tuple&gt;</span> - examples in Chapters 1 and 2
                      </indent-block>
                    </li>
                    <li>&lt;charconv&gt; - to_chars, from_chars, chars_format</li>
                    <li><span class="notice">&lt;optional&gt;</span> - return instance or empty</li>
                    <li><span class="notice">&lt;any&gt;</span> - holds instance of almost any type, example in Chapter 4</li>
                    <li>&lt;variant&gt; - holds instances of any specified set of types</li>
                  </ul>
                </li>
                <li>
                  <span class="notice">&lt;string&gt;</span> - std::basic_string --> std::string, std::wstring
                </li>
                <li>
                  Containers libraries:
                  <indent-block>
                    &lt;array&gt;, &lt;deque&gt;, &lt;list&gt;, &lt;map&gt;,
                    &lt;multimap&gt; &lt;multiset&gt;
                    &lt;queue&gt;,
                    &lt;set&gt;, &lt;singleList&gt;, &lt;stack&gt;, <span class="notice">&lt;string&gt;</span>,
                    <span class="notice">&lt;unordered_map&gt;</span>,
                    &lt;unordered_multimap&gt;, &lt;unordered_multiset&gt;,
                    &lt;unordered_set&gt;, <span class="notice">&lt;vector&gt;</span>
                  </indent-block>
                </li>
                <li>
                  &lt;algorithm&gt; - Algorithms library
                  <spacer-10></spacer-10>
                  <indent-block>
                    Non-modifying sequence operations:
                    <background-block class="indent">
                      all_of, any_of, none_of, for_each, for_each_n, count, count_if,
                      mismatch, find, find_if, find_if_not, find_end, find_first_of,
                      adjacent_find, search, search_n
                    </background-block>
                    Modifying sequence operations:
                    <background-block class="indent">
                      copy, copy_if, copy_n, copy_backward,
                      move, move_backward, fill, fill_n, transform, generate, generate_n,
                      remove, remove_if, remove_copy, remove_copy_if, replace, replace_if,
                      replace_copy, replace_copy_if, swap, swap_ranges, iter_swap,
                      reverse, reverse_copy, rotate, shift_left, shift_right,
                      random_shuffle, shuffle, sample, unique, unique_copy
                    </background-block>
                    Partitioning operations:
                    <background-block class="indent">
                      is_partitioned, partition, partition_copy, stable_partition, partition_point
                    </background-block>
                    Sorting operations:
                    <background-block class="indent">
                      is_sorted, is_sorted_until, sort, partial_sort, stable_sort, nth_element
                    </background-block>
                    Binary search on sorted ranges:
                    <background-block class="indent">
                      lower_bound, upper_bound, binary_search, equal_range
                    </background-block>
                    Other operations on sorted ranges:
                    <background-block class="indent">
                      merge, inplace_merge
                    </background-block>
                    Set operations on sorted ranges:
                    <background-block class="indent">
                      includes, set_differences, set_intersection, set_symmetric_distance, set_union
                    </background-block>
                    Heap operations:
                    <background-block class="indent">
                      is_heap, is_heap_until, make_heap, push_heap, pop_heap, sort_heap
                    </background-block>
                    Min/Max operations:
                    <background-block class="indent">
                      max, max_element, min, min_element, minmax, minmax_element, clamp
                    </background-block>
                    Comparison operations:
                    <background-block class="indent">
                      equal, lexicographical_compare, lexicographical_compare_three_way
                    </background-block>
                    Permutation operations:
                    <background-block class="indent">
                      is_permutation, next_permutation, prev_permutation
                    </background-block>
                    Numeric operations:
                    <background-block class="indent">
                      iota, accumulate, inner_product, adjacent_difference, partial_sum,
                      reduce, exclusive_scan, inclusive_scan, transform_reduce,
                      transform_exclusive_scan, transform_inclusive_scan
                    </background-block>
                  </indent-block>
                </li>
                <li>
                  Numerics libraries
                  <ul class="tight">
                    <li>
                      &lt;cstdlib&gt;, &lt;cmath&gt; - Common math functions
                    </li>
                    <li>&lt;cmath&gt; - Special math functions</li>
                    <li>&lt;numeric&gt;, &lt;cmath&gt; - Numeric algorithms</li>
                    <li>&lt;random&gt;, &lt;cstdlib&gt; - Pseudo-random number generators</li>
                    <li>&lt;cfenv&gt; - Floating-point environment</li>
                    <li>&lt;complex&gt; - Complex numbers, operations</li>
                  </ul>
                </li>
                <li>
                  Input/Output libraries:
                  <ul class="tight">
                    <li>
                      Terminal I/O:
                      <background-block class="indent">
                        <span class="notice">
                          &lt;ios&gt;, &lt;streambuf&gt;, &lt;ostream&gt;, &lt;istream&gt;,
                          &lt;iostream&gt;
                        </span>
                      </background-block>
                    </li>
                    <li>
                      File I/O:
                      <background-block class="indent">
                        <span class="notice">&lt;fstream&gt;</span>
                      </background-block>
                    </li>
                    <li>
                      String I/O:
                      <background-block class="indent">
                        <span class="notice">&lt;sstream&gt;</span>
                      </background-block>
                    </li>
                    <li>
                      Synchronized I/O:
                      <background-block class="indent">
                        &lt;syncstream&gt;
                      </background-block>
                    </li>
                    <li>
                      I/O manipulators:
                      <background-block class="indent">
                        <scan class="notice">&lt;iomanip&gt;</scan>
                      </background-block>
                    </li>
                  </ul>
                </li>
                <li>
                  <span class="notice">&lt;regex&gt;</span> - Regular Expressions library
                </li>
                <li>
                  Thread Support libraries:
                  <div>
                    C++17:
                    <background-block class="indent">
                      <span class="notice">
                        &lt;thread&gt;, &lt;mutex&gt;, &lt;shared_mutex&gt;,
                        &lt;condition_variable&gt;, &lt;future&gt;, &lt;atomic&gt;
                      </span>
                    </background-block>
                    C++20:
                    <background-block class="indent">
                      &lt;semiphore&gt;, &lt;latch&gt;, &lt;stop_token&gt;

                    </background-block>
                  </div>
                </li>
                <li>
                  <span class="notice">&lt;filesystem&gt;</span> - Filesystem library
                </li>
                <li>
                  Error Handling libraries:
                  <background-block class="indent">
                    <span class="notice">&lt;exception&gt;</span>, &lt;stdexcept&gt;, &lt;cerrno&gt;, &lt;cassert&gt;
                    &lt;system_error&gt;
                  </background-block>
                </li>
                <li>
                  Other libraries
                  <ul class="tight">
                    <li>Localizations</li>
                    <li>Iterators</li>
                    <li>Concepts (C++20)</li>
                    <li>Named Requirements (C++20)</li>
                    <li>Ranges (C++20)</li>
                  </ul>
                </li>
              </ul>
            </indent-block>
          </details>
        </indent-block>
      </indent-blocks>
      <spacer-10></spacer-10>
      Here&apos;s an example using the STL vector container and for_each algorithm with lambda fold:
      <pre class="background-block"><c-s>  std::vector&lt;int&gt; test{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 };
  
  size_t N = 4;
  
  auto fold = [N](auto t) {
    static size_t count = 0;
    if (++count > N) {
      count = 1;
      std::cout << "\n  ";
    }
    std::cout << t << " ";
  };

  std::cout << "\n  ";
  std::for_each(test.begin(), test.end(), fold);
        </c-s>
</pre>
      with output:<pre class="background-block"><c-s>  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  17</c-s></pre>
      <spacer-15></spacer-15>
      The standard library collection is very large, but still there are a few surprising
      omissions. Until C++17 there was no filesystem library and there still is no support
      for:
      <ul style="margin-top:10px; margin-bottom:10px;">
        <li style="padding-bottom:2px;">Network programming and inter-process communication</li>
        <li style="padding-bottom:2px;">Processing XML or JSON data formats</li>
        <li>Building Graphical User Interfaces</li>
      </ul>
      However, building these is not too difficult using platform APIs and/or third party libraries, especially
      the extensive <a href="https://Boost.org">Boost</a> library.
      <spacer-10></spacer-10>
      <indent-blocks>
        <indent-block class="pad10">
          <details>
            <summary>
              <span class="labelStyle lightItem">custom libraries</span>
            </summary>
            <indent-block class="pad10" style="max-width:95%;">
              Libraries, written entirely in C++, using platform APIs as necessary,
              that fill in some omissions from the standard C++ library.
              <spacer-15></spacer-15>
              <table>
                <tr>
                  <th>Library</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>FileSystem</td>
                  <td>
                    Provides interfaces used by many of the applications in code repositories
                    in this site.  It was developed using Windows and Linux platform APIs.
                    I plan to turn this into a wrapper for the std::filesystem which provides
                    a different set of interfaces, incompatible with the existing applications.
                    <spacer-10></spacer-10>
                    <a href="FileSystem.html">FileSystem.html</a>
                  </td>
                </tr>
                <tr>
                  <td>XmlDocument</td>
                  <td>
                    A fairly complete processing library for reading, parsing, building,
                    and writing XML to and from strings and files.
                    <spacer-10></spacer-10>
                    <a href="XmlDocument.html">XmlDocument.html</a>
                  </td>
                </tr>
                <tr>
                  <td>CppCommWithFileXfer</td>
                  <td>
                    Supports asynchronous message-passing communication between multiple
                    endpoints, using the Sockets library, below.
                    <spacer-10></spacer-10>
                    <a href="CppCommWithFileXfer.html">CppCommWithFileXfer.html</a>
                  </td>
                </tr>
                <tr>
                  <td>Sockets</td>
                  <td>
                    A sockets class hierarchy that handles IP4 and IP6 protocols
                    for stream-based sockets.  The library has versions for both Windows
                    and Linux.
                    <spacer-10></spacer-10>
                    <a href="Sockets.html">Sockets.html</a>
                  </td>
                </tr>
                <tr>
                  <td>CppParser</td>
                  <td>
                    A rule based parser suitable for analyzing C, C++, C#, and Java.
                    <spacer-10></spacer-10>
                    <a href="BlogParser.html">Parsing Blog</a>,
                    <a href="CppParser.html">CppParser Repository</a>,
                    <a href="CppLexicalScanner.html">CppLexicalScanner.html</a>
                  </td>
                </tr>
              </table>
            </indent-block>
          </details>
        </indent-block>
      </indent-blocks>
    </indent-blocks>
    <spacer-15></spacer-15>
    This completes our survey of the C++ programming language.  We will be expanding on each
    of these topics: 
    <indent-block class="pad10">
      <span class="notice">Data, Operations, Classes, Templates, and Libraries</span>
    </indent-block>
    in the following chapters of this story, with lots of discussion and code examples,
    and a few videos here and there.
  </indent-blocks>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>