<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Survey.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Survey</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <script>
    //function closeTOC() {
    //  let toc = document.getElementById("toc");
    //  toc.style.display = "none";
    //}
  </script>
</head>
<body id="github" onload="initializeMenu()">
  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Data.html">N</a>
  <a id="Prev" href="CppStory_Prologue.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #1&nbsp;-&nbsp;C++ Survey</h1>
      <h3 id="subtitle">data, operations, classes, templates, libraries</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <bb-55 class="indent">
    <num-cont>
      <num-item1>1</num-item1><num-item2>.</num-item2><num-item3>0</num-item3><num-item4>Survey</num-item4>
    </num-cont>
    <toc-b id="toc">
    <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>
      <a href="#top">Top</a>, <a href="#Data">Data</a>, <a href="#Ops">Operations</a>, 
      <a href="#Class">Classes</a>, <a href="#Templ">Templates</a>, <a href="#Lib">Libraries</a>, 
      <a href="Javascript:;" onclick="closeTOC()" style="color:darkred;">Close</a>
    <up-b id="chaps" onmouseout="storyMenu.chaps()">
      <a href="CppStory_Prologue.html">Prologue</a><br />
      <a href="CppStory_Survey.html">Survey</a><br />
      <a href="CppStory_Data.html">Data</a><br />
      <a href="CppStory_Operations.html">Operations</a><br />
      <a href="CppStory_Classes.html">Classes</a><br />
      <a href="CppStory_ClassRelationships.html">ClassRel</a><br />
      <a href="CppStory_Templates.html">Templates</a><br />
      <a href="CppStory_TemplateMetaProg.html">TMP</a><br />
      <a href="CppStory_Libraries.html">Libraries</a><br />
      <a href="CppStory_Interesting.html">Interesting</a>
    </up-b>
    </toc-b>
    <!--<div id="toc" style="position:fixed; bottom:1.6rem; left:0.2rem; padding:3px 10px 5px 10px; background:#eee; border:3px solid darkred;">
      <a href="#top">Top</a>, <a href="#Data">Data</a>, <a href="#Ops">Operations</a>, 
      <a href="#Class">Classes</a>, <a href="#Templ">Templates</a>, <a href="#Lib">Libraries</a>, 
      <a href="Javascript:;" onclick="closeTOC()" style="color:darkred;">Close</a>
    </div>-->
    <indent-blocks>
      This chapter provides a quick look at programming facilities provided by C++ and its libraries.
      You will find a lot more details, with examples, on these topics in subsequent chapters.<br />
      <i-b>
        <ul class="tight pad10">
          <li><a href="https://en.cppreference.com/w/cpp/language/basic_concepts">Basic concepts</a></li>
          <li><a href="https://en.cppreference.com/w/cpp/keyword">Key words</a></li>
          <li><a href="CppModels.html">Models for C++ programs: building, execution, and memory storage</a></li>
          <li>
            <a href="CppStoryRepo.html">CppStoryRepo</a> contains many small but complete code examples used in the
            text of this Chapter.  You may wish to download and run the code while you are studying this Chapter.
          </li>
        </ul>
      </i-b>
      It is challenging to discuss details of a programming language without using terms and ideas that
      haven&apos;t yet been introduced.  The intent of this chapter is to give you most of the basic ideas so that
      in later chapters, when we use a language construct or idea that hasn&apos;t yet been discussed fully,
      you will be able to follow the discussion, and have some confidence that details of the idea
      will be presented eventually.
      <a id="Data"></a>
      <hr class="spread" />
      <num-cont><num-item1>1</num-item1><num-item2>.</num-item2><num-item3>1</num-item3><num-item4>Data Types:</num-item4></num-cont>
      <indent-blocks>
        The C++ programming language provides fundamental types, built into the language,
        additional types provided by the C++ standard libraries, and supports building user-defined types. Those
        can be designed to provide essentially the same behaviors as fundamental types.
        <spacer-15></spacer-15>
        Fundamental types:
        <indent-block class="pad10">
          <details>
            <summary class="lightItem labelStyle noWrap" style="font-family:Consolas; font-size:1.075rem;">
              void, bool, nullptr_t, integral, char, and floating types
            </summary>
            <spacer-10></spacer-10>
            <defn-block class="pad10 defnBorder">
              <ul class="tight">
                <li><span class="codeStyle">void</span> - only type with no values</li>
                <li><span class="codeStyle">bool</span> - values true and false</li>
                <li><span class="codeStyle">std::nullptr_t</span> - type of the nullptr literal</li>
                <li>
                  integral types:
                  <indent-block class="pad10 codeStyle">
                    int <span class="normal">with qualifiers:</span> short, long, long long, unsigned, const, volatile<br />
                    std::size_t, std::size_type
                  </indent-block>
                </li>
                <li>
                  character types:
                  <indent-block class="pad10 codeStyle">
                    char, wchar_t <span class="normal">with qualifiers:</span> signed, unsigned, const, volatile<br />
                    <span class="normal">unicode characters:</span> char16_t, char32_t, char8_t (C++20)
                    <t-s>, with qualifiers: const, volatile</t-s>
                  </indent-block>
                </li>
                <li>
                  floating point types:
                  <indent-block class="pad10 codeStyle">
                    float, double <span class="normal">with qualifiers:</span> long (double only), const, volatile
                  </indent-block>
                </li>
              </ul>
              <indent-block class="pad10">
                References:
                <indent-block>
                  <a href="https://en.cppreference.com/w/cpp/language/types">cppreference.com/types</a>
                </indent-block>
              </indent-block>
              <spacer-10></spacer-10>
              <defn-head class="defnBorder" style="border-left:none; border-right:none;">Examples:</defn-head>
              <defn-code class="noBorder">
void demoFundamentalTypes() {

  showTitle("Demo fundamental types");

  int i{ 3 };
  char c{ 'z' };
  double d{ 3.1415927 };
  bool b{ true };
  
  std::cout << "\n  value of integer i   = " << i;
  std::cout << "\n  value of character c = " << c;
  std::cout << "\n  value of double d    = " << d;
  std::cout << "\n  value of bool b      = " << b;
  std::cout << "\n  value of nullptr     = " << nullptr;
  std::cout << "\n  numerical value of nullptr = " << static_cast&lt;size_t*&gt;(nullptr);
  std::cout << "\n";
}

 Demo fundamental types
------------------------
value of integer i   = 3
value of character c = z
value of double d    = 3.14159
value of bool b      = 1
value of nullptr     = nullptr
numerical value of nullptr = 00000000
              </defn-code>
            </defn-block>
          </details>
        </indent-block>
        <s-halfEm></s-halfEm>
        Arrays and pointers:
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
              arrays
            </summary>
            <spacer-10></spacer-10>
            <div>
            <defn-block>
              <defn-body>
                An array is a fixed size sequence of continguous elements, all of the same type.
                <spacer-10></spacer-10>
                T&nbsp;arr[N];&nbsp;&nbsp;<t-s>[ declaration of array </t-s>arr <t-s>]</t-s>
                <spacer-10></spacer-10>
                T&nbsp;t&nbsp;=&nbsp;arr[1];
                <spacer-10></spacer-10>
                <div class="normal">
                  <c-s>T</c-s> is any default constructable C++ type,
                  <c-s>N</c-s> is a compile-time constant.<br />
                  <c-s>t</c-s> contains the value of the second element
                  of the <c-s>arr</c-s> array
                </div>
                <spacer-10></spacer-10>
              </defn-body>
              <defn-head class="defnBorderTop">
                Example:
              </defn-head>
              <defn-code>
const char* args[] = { "one", "two", "three" };
size_t sizeOfArgsArray = 3;
std::cout << "\n  displaying args[]";
std::cout << "\n  ";
for (size_t i = 0; i < sizeOfArgsArray; ++i) {
  std::cout << args[i] << " ";
}
              </defn-code>
              <defn-head class="defnBorderTop">
                Output
              </defn-head>
              <defn-code>
displaying args[]
one two three
              </defn-code>
            </defn-block>
            </div>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              pointers
            </summary>
            <spacer-10></spacer-10>
            <div>
            <defn-outerBlock>
              <defn-block>
                <defn-body>
                  <div style="max-width:30rem;">
                  A pointer is a reference to the memory location of a variable, to which it is bound.
                  <spacer-10></spacer-10>
                  <c-s>
                    X x;<br />
                    X*&nbsp;pX&nbsp;=&nbsp;&amp;x;&nbsp;&nbsp;<t-s>[</t-s>&amp;<t-s>&nbsp;on&nbsp;right&nbsp;of&nbsp;assignment&nbsp;is&nbsp;an&nbsp;address]</t-s>
                  </c-s>
                  <spacer-10></spacer-10>
                  <c-s>pX</c-s> is a pointer variable containing the address of <c-s>x</c-s>
                  <spacer-10></spacer-10>
                  <c-s>++pX</c-s> increments address stored in pX by <c-s>sizeof(X)</c-s>
                  <spacer-10></spacer-10>
                  Retrieve value referenced by <c-s>pX</c-s> using dereference operator, <c-s>*pX</c-s>, which returns
                  the value of <c-s>x</c-s>.
                  </div>
                </defn-body>
              </defn-block>
              <defn-block>
              <hidephotosizer-block src="Pictures/PointerImage1.JPG" width="300" class="photoSizerBlock right" style="margin-top:0;">
                <span style="font-family:'Comic Sans MS, Tahoma';">
                  Fig 1. Pointer to x &epsilon; X
                </span>
              </hidephotosizer-block>
              </defn-block>
            </defn-outerBlock>
            </div>
          </details>
          <spacer-10></spacer-10>
          <details>
            <summary class="darkItem labelStyle">
              Example:&nbsp;&nbsp;Reading command line arguments
            </summary>
            <t-b>
              In this example, of arrays and pointers, command line arguments are displayed on 
              the console using 
              main&apos;s argv[] array, then again using equivalent pointers.
            </t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Example Code</defn-head>
                <defn-code>
int main(int argc, char* argv[]) {

  std::cout << "\n  displaying command line arguments using array";
  std::cout << "\n  ";
  for (int i = 0; i < argc; ++i) {
    std::cout << argv[i] << " ";
    if ((i + 1) % 2)
      std::cout << "\n  ";
  }
  std::cout << "\n  ";

  std::cout << "\n  displaying command line arguments using pointer";  
  std::cout << "\n  ";
  char** ptr = argv;
  for (int i = 0; i < argc; ++i) {
    std::cout << *(ptr++) << " ";
    if ((i + 1) % 2)
      std::cout << "\n  ";
  }
  std::cout << "\n\n  ";
}
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output</defn-head>
                <defn-code>
// displaying command line arguments using array
  
chapter1-survey.exe
/P ..
/p *.h;*.cpp
/R ^template
/H

displaying command line arguments using pointer  
chapter1-survey.exe
/P ..
/p *.h;*.cpp
/R ^template
/H
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </details>
        </indent-block>
        <t-b>
          C++ references are used to pass function arguments by reference:
        </t-b>
        <indent-block>
          <details>
            <summary class="labelStyle lightItem">
              C++ references
            </summary>
            <t-b style="max-width:40rem;">
              <defn-block>
                <defn-body>
              <c-s>X&amp; xr = x;</c-s>&nbsp;&nbsp;[ declaration of reference <c-s>xr</c-s> bound to <c-s>x</c-s> ]
              <spacer-10></spacer-10>
              Unlike pointers, C++ reference types cannot be reset.  The instance referred to, <c-s>x</c-s>,
              is always defined in the reference declaration and cannot be changed.
              The value of <c-s>xr</c-s> is always the value of <c-s>x</c-s>, which can be changed.
              <spacer-10></spacer-10>
              It is useful to think of a reference as another name for the referenced instance.
              <spacer-10></spacer-10>
              References are most often used to pass arguments to a function by reference.
              <spacer-10></spacer-10>
              Passing an argument to a function by value, <c-s>f(T t)</c-s>, copies the argument&apos;s value to the function&apos;s
              stack frame.
              <spacer-10></spacer-10>
              Passing a parameter by reference, <c-s>f(T&amp; t)</c-s>,
              simply creates a small reference in the function&apos;s stack frame, bound to the parameter in the caller&apos;s
              scope, instead of copying what could be a much larger object.
                </defn-body>
              </defn-block>
            </t-b>
          </details>
        </indent-block>
        <s-halfEm></s-halfEm>
        <t-b>
          C++ standard libraries provide a large set of pre-defined types:
        </t-b>
        <indent-block>
          <details>
            <summary class="labelStyle lightItem">
              STL sequential and associative containers, container adapters
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
              <defn-head class="noBorderBottom">
                sequential containers - linear sequence of elements:
              </defn-head>
              <defn-body>
                <i-b>
                  <table>
                    <tr>
                      <td><c-s>string, array, vector, deque</c-s></td>
                      <td>contiguous memory storage, can be indexed</td>
                    </tr>
                    <tr>
                      <td>forward_list, list</td>
                      <td class="normal">nodes allocated on heap, cannot be indexed</td>
                    </tr>
                  </table>
                </i-b>
              </defn-body>
              <defn-head class="noBorderBottom">
                associative containers - key based storage on heap:
              </defn-head>
              <defn-body>
                <i-b>
                <table>
                  <tr>
                    <td><c-s>set, multiset, unordered_set, unordered_multiset</c-s></td>
                    <td>key only storage using balanced binary tree or hash table</td>
                  </tr>
                  <tr>
                    <td><c-s>map, multimap, unordered_map, unordered_multimap</c-s></td>
                    <td>key-value storage using balanced binary tree or hash table</td>
                  </tr>
                </table>
                </i-b>
              </defn-body>
              <defn-head class="noBorderBottom">
                container adapters:
              </defn-head>
              <defn-body>
                <i-b>
                <table>
                  <tr>
                    <td><c-s>queue, stack</c-s></td>
                    <td>sequential containers accessible only from end(s)</td>
                  </tr>
                  <tr>
                    <td><c-s>priority_queue</c-s></td>
                    <td>constant time lookup of largest element, logarithmic insertion and extraction</td>
                  </tr>
                </table>
                </i-b>
              </defn-body>
              <defn-head class="noBorderBottom">
                References:
              </defn-head>
              <defn-body>
                <i-b>
                  <a href="https://en.cppreference.com/w/cpp/container">cppreference.com/container</a><br />
                  <a href="STL-Containers.html">STL-Containers.html</a>
                </i-b>
                <s-1em></s-1em>
              </defn-body>
            </defn-block>
          </details>
          <spacer-10></spacer-10>
          <details>
            <summary class="labelStyle darkItem">
              Example: Sum elements in container using std::vector and std::for_each
            </summary>
            <indent-blocks>
              <t-b style="max-width:50rem;">
                Example using <c-s>std::vector&lt;int&gt;</c-s> and <c-s>for_each</c-s> algorithm.  We
                will use lambdas in this example, so you may wish to first peek at the lambda discussion at
                the end of the Operations section.
              </t-b>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>Example Code</defn-head>
                  <defn-code>
  std::vector<int> test{ 1, 2, 3, 4, 5 };
  std::string prefix = "\n  ";
  auto show = [&](auto element) {  // peek at lambda, below     
    std::cout << prefix << element;
    prefix = ", ";
  };
  std::for_each(test.begin(), test.end(), show);

  int sum = 0;
  auto sumer = [&sum](auto element) { sum += element; };  
  std::for_each(test.begin(), test.end(), sumer);
  std::cout << "\n  sum = " << sum;
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Output</defn-head>
                  <defn-code>
  1, 2, 3, 4, 5  
  sum = 15
                  </defn-code>
                </defn-block>
              </defn-outerBlock>
            </indent-blocks>
          </details>
          <spacer-10></spacer-10>
          <details>
            <summary class="labelStyle lightItem">
              Special containers, streams, and other types
            </summary>
            <spacer-10></spacer-10>
            <div class="pad10-15 defnBorder">
              <span class="notice">special containers:</span>
              <indent-block class="pad10 codeStyle">
                <table width="100%">
                  <tr>
                    <td>pair</td>
                    <td class="normal">contains two elements which may have distinct types</td>
                  </tr>
                  <tr>
                    <td>tuple</td>
                    <td class="normal">contains finite number of elements with distinct types</td>
                  </tr>
                  <tr>
                    <td>initializer_list</td>
                    <td class="normal">
                      contains sequence of elements, all of the same type
                      normally filled with initialization list, e.g., { 1, 2, 3, ... }
                    </td>
                  </tr>
                  <tr>
                    <td>any</td>
                    <td class="normal">holds value of any type, provides std::any_cast for retrieval</td>
                  </tr>
                  <tr>
                    <td>optional</td>
                    <td class="normal">used to return values or signal failure to return</td>
                  </tr>
                  <tr>
                    <td>variant</td>
                    <td class="normal">similar to any, but only holds values from a specified set of types</td>
                  </tr>
                </table>
              </indent-block>
              <span class="notice">stream types:</span>
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>istream</td>
                    <td class="normal">
                      sends sequence of values of fundamental types to console using insertion operator&lt;&lt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ostream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from keyboard using extraction operator&gt;&gt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ifstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached file using extraction operator&lt;&lt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ofstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached file using extraction operator&gt;&gt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>istringstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached in-memory string using extraction operator&lt;&lot;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                  <tr>
                    <td>ostringstream</td>
                    <td class="normal">
                      retrieves sequence of values of fundamental types from attached in-memory string using extraction operator&gt;&gt;,
                      which may be overloaded for user-defined types.
                    </td>
                  </tr>
                </table>
              </indent-block>
              <span class="notice">other types:</span>
              <indent-block class="pad10 codeStyle">
                <table>
                  <tr>
                    <td>unique_ptr&lt;T&gt;</td>
                    <td class="normal">
                      Construction allocates instance t &epsilon; T, destruction deallocates t.  Assignment moves ownership.
                    </td>
                  </tr>
                  <tr>
                    <td>shared_ptr&lt;T&gt;</td>
                    <td class="normal">
                      Reference counted smart pointer, assignment adds counted reference.
                    </td>
                  </tr>
                  <tr>
                    <td>exception</td>
                    <td class="normal">
                      When code error occurs exception instance is &quot;thrown&quot;, then handled by catch clause associated
                      with enclosing try block.
                    </td>
                  </tr>
                  <tr>
                    <td>chrono</td>
                    <td class="normal">
                      Class for managing time durations and dates.
                    </td>
                  </tr>
                </table>
              </indent-block>
              <indent-blocks class="pad10">
                <span class="notice">References:</span>
                <indent-block>
                  <a href="https://en.cppreference.com/w/cpp/header">cppreference.com/header</a>
                </indent-block>
                <spacer-15></spacer-15>
              </indent-blocks>
            </div>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle darkItem">
              Example: Write file using file stream and std::optional
            </summary>
            <t-b style="max-width:50rem;">
              std::optional&lt;T&gt; is designed to return a value computed in a function
              if available.  If computation fails (a file open for example)
              it returns nullptr.
            </t-b>
            <defn-block>
              <defn-code>
  std::ofstream ofstrm;

  /*--- attempt to open file for writing ---*/

  auto fout = [&ofstrm](const std::string& filename) {  
    ofstrm.open(filename, std::ios::out);
    std::optional<std::ofstream*> opt = &ofstrm;
    if (!ofstrm.good())
      opt = nullptr;
    return opt;
  };
  /*--- attempt to write file ---*/

  auto opto = fout("testWrite.txt");
  if (opto.has_value()) {
    std::string test("\n  this is a test\n");
    auto foptr = opto.value();
    *foptr << test;
    foptr->close();
  }
              </defn-code>
            </defn-block>
          </details>
        </indent-block>
        <spacer-15></spacer-15>
        In the details dropdown, below, you will find a summary of the sizes of many common types.
        <spacer-15></spacer-15>
        <indent-block>
          <details>
            <summary class="labelStyle lightItem">Type instance sizes</summary>
            <spacer-10></spacer-10>
            <defn-block>
              <defn-head>
                <span class="notice">Value Sizes</span>
              </defn-head>
              <defn-code>
  -- limits --
  bits in byte =       CHAR_BIT = 8
  min value of char =  CHAR_MIN = -128
  max value of char =  CHAR_MAX = 127
  min value of int =    INT_MIN = -2147483648
  max value of int =    INT_MAX = 2147483647
  min value of float =  FLT_MIN = 1.17549e-38
  max value of float =  FLT_MAX = 3.40282e+38
  min value of double = DBL_MIN = 2.22507e-308
  max value of double = DBL_MAX = 1.79769e+308

  -- integral types --
  4 = size of std::nullptr_t
  1 = size of enum std::byte
  1 = size of bool
  1 = size of char
  1 = size of signed char
  1 = size of unsigned char
  2 = size of char16_t
  4 = size of char32_t
  2 = size of short
  4 = size of int
  4 = size of unsigned int
  4 = size of long
  4 = size of unsigned long
  8 = size of __int64 <==> long long int
  8 = size of unsigned __int64 <==> unsigned long long int
  4 = size of unsigned int <==> size_t
 ---------------------------------
  demonstrate integer roll-over:
  i = UINT_MAX : 4294967295
  i + 1 = 0
 ---------------------------------

  -- character types --
  1 = size of char
  1 = size of unsigned char
  2 = size of wchar_t
  2 = size of char16_t
  4 = size of char32_t

  -- float types --
  4 = size of float
  8 = size of double
  8 = size of long double

  -- pointers and references --
  4 = size of double *
  8 = size of double, note: is double&
  8 = size of double <==> sizeof(double&)

  pDouble:   00EFFCCC --> 15727820
  ++pDouble: 00EFFCD4 --> 15727828

  -- arrays --
  16 = size of int const [4]

  -- std::strings --
  28 = size of class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::alloc...,
       is std::string{}
  28 = size of class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::alloc...,
       is std::string{ "a std::string" }

  -- structs --
  1 = size of struct `void __cdecl demoCompoundTypes(void)'::`2'::Empty,
      is struct {}
  24 = size of struct `void __cdecl demoCompoundTypes(void)'::`2'::Struct,
       is struct { 1, 1.5, "a literal string" }

  -- function pointers --
  executing testFun1(const std::string&)
  4 = size of void (__cdecl*)(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,...
  executing testFun2()
  4 = size of class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::alloc...

  -- vector&lt;double&gt; --
  16 = size of class std::vector&lt;double,class std::allocator&lt;double&gt; &gt;,
       is std::vector&lt;double&gt;{}
  16 = size of class std::vector&lt;double,class std::allocator&lt;double&gt; &gt;,
       is std::vector&lt;double&gt;{ -0.5, 0, 0.5, 1.0, 1.5 }

  -- vector&lt;double&gt;::iterator --
  12 = size of class std::_Vector_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_type...,
       is vector&lt;double&gt;::iterator

  -- unordered_map&lt;std::string, int&gt; --
  40 = size of class std::unordered_map&lt;class std::basic_string&lt;char,struct std::char_trai...,
       is std::unordered_map&lt;std::string, int&gt;{}
  40 = size of class std::unordered_map&lt;class std::basic_string&lt;char,struct std::char_trai...,
       is std::unordered_map&lt;std::string, int&gt;{ {"one", 1}, ... }

  -- unordered_map&lt;std::string,int&gt;::iterator --
  12 = size of class std::_List_iterator&lt;class std::_List_val&lt;struct std::_List_simple_typ...,
       is std::unordered_map&lt;std::string, int&gt;::iterator

  -- display vector contents in rows of N --
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  17

  -- miscellaneous types --
  1 = size of enum std::byte
  4 = size of unsigned int, is size_type
  48 = size of class std::tuple&lt;int,double,class std::basic_string&lt;char,struct std::char_t...
  4 = size of class std::unique_ptr&lt;double,struct std::default_delete&lt;double&gt; &gt;
  8 = size of class std::shared_ptr&lt;double&gt;
  8 = size of class XwithDouble &lt;==&gt; instance of class with double member
  4 = size of class XwithRef    &lt;==&gt; instance of class with double& member
  8 = size of class XwithDouble &lt;==&gt; class with double member
  4 = size of class XwithRef    &lt;==&gt; class with double& member
  4 = size of std::nullptr_t
  80 = size of class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt;    &lt;==&gt; std::cout
  80 = size of class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt;    &lt;==&gt; std::ostream
  The meaning of life is 42
  4 = size of class &lt;lambda_cb1c8eb6ab7293ad79a4f9e6fdc0cd2e&gt;

  28 = size of class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::alloc...
  4 = size of char const *
  content of a std::string
  string size = 25
  allocation size = 31
              </defn-code>
            </defn-block>
          </details>
        </indent-block>
        <spacer-15></spacer-15>
        User defined types: <span class="notice">enums, structs, classes, and type aliases</span>
        <indent-block class="pad10">
          An enum is a sequence of named integral values. Enums are often used as case selectors in switch statements.
          <spacer-10></spacer-10>
          <details>
            <summary class="labelStyle lightItem">
              scoped enum: enum class E { ... };
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
              <defn-code>
  enum class Color { red, green, blue };  
  Color color;
  ---
  if(color == Color::red) {
    doRedThing();
  }
  ---
              </defn-code>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          Structs are just like classes except that struct members are public by default, where class members are by default private.
          Often we use structs as in implementation detail holding a collection of values with heterogeneous types.
          <spacer-10></spacer-10>
          <details>
            <summary class="labelStyle lightItem">
              struct S { ... };
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
              <defn-code>
  struct S { 
     int i; double d; 
  };
  S s { 2, 3.1415927 };  
  int j = s.i;
  double e = s.d;
              </defn-code>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          Usually, classes build program abstractions.  That is, a class represents some domain entity like
          an order or product.  They are also used to build implementation abstractions like blocking queues and thread pools.
          You will hear more about blocking queues and thread pools later in this story.
          <spacer-10></spacer-10>
          <details>
            <summary class="labelStyle lightItem">
              class C { ... };
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
              <defn-code>
  class X {
  public:
    void set(const std::string&amp; s);
    std::string get();
  private:
    std::string str;
  };
              </defn-code>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          A type alias simply provides another name for an existing type.  Surprisingly they are very useful for making code
          readable. We might provide a type alias, fileName, for the std::string type. That helps readers of the code understand
          that values for this string are the names of files.  We can use filename any place that the language accepts a std::string,
          e.g., as a function parameter type.
          <spacer-10></spacer-10>
          <details>
            <summary class="labelStyle lightItem">
              type alias: using AliasName = Sometype;
            </summary>
            <spacer-10></spacer-10>
            <defn-block style="max-width:40rem;">
              <defn-body>
                Aliases are designed to provide application specific domain names for standard types
                and to provide short names for template types with many template parameters.
              </defn-body>
              <defn-body class="pad10" style="border-top:2px solid darkred;">
                alias - c++11:  <c-s>using VecStr = std::vector&lt;std::string&gt;;</c-s>
                <spacer-15></spacer-15>
                alias - C++98:  <c-s>typedef std::vector&lt;std::string&gt; VecStr;</c-s>
              </defn-body>
            </defn-block>
          </details>
        </indent-block>
        <indent-block class="pad10">
          The ability to test types at compile time allows us to build very flexible template functions and methods. You will hear
          much more about that below, and especially in Chapter #4 - Templates.
          <!--<spacer-15></spacer-15>-->
          Run-time type testing is less often used, but allows us to display the name of the type of some variable and test whether
          two instances have the same type.
          <spacer-10></spacer-10>
          <details>
            <summary class="labelStyle lightItem">
              compile-time and run-time testing
            </summary>
            <spacer-10></spacer-10>
            <defn-block style="max-width:52rem;">
              <defn-body>
                Compile-time tests use template meta programming.  That will be discussed in
                detail in Chapter 5. This is here because you will see it used before we get
                to those details.
              </defn-body>
              <defn-body class="defnBorderTop">
                <spacer-10></spacer-10>
                <span class="notice">compile-time type tests:</span>&nbsp;&nbsp;<a href="https://en.cppreference.com/w/cpp/header/type_traits"><c-s>std::type_traits</c-s></a></span>
                <spacer-10></spacer-10>
                <c-s>
                template&lt;typename T&gt;<br />
                void display(const T&amp; t) {<br />
                &nbsp;&nbsp;if constexpr (std::is_fundamental&lt;T&gt;::value) {<br />
                &nbsp;&nbsp;// do display operations consistent with fundamental types<br />
                &nbsp;&nbsp;// std::is_fundamental&lt;T&gt; is a std::type-trait<br />
                }
                </c-s>
                <spacer-10></spacer-10>
                <span class="normal">We can also create user-defined </span>type-traits,
                as discussed in Chapter #5.
                <spacer-10></spacer-10>
              </defn-body>
              <defn-body class="defnBorderTop">
                <spacer-10></spacer-10>
                <span><span class="notice">run-time type tests:</span>&nbsp;&nbsp;
                <a href="https://en.cppreference.com/w/cpp/types/type_info"><c-s>std::type_info</c-s></a></span>
                <indent-block class="pad10" style="width:max-content;">
                  <c-s>
                  if(typeid(x1) == typeid(x2)) {<br />
                  &nbsp;&nbsp;// do something knowing that x1 and x2 have the same types<br />
                  &nbsp;&nbsp;// the typeid operator returns a type_info instance. that&apos;s what we are comparing.<br />
                  }
                  </c-s>
                  <spacer-10></spacer-10>
                </indent-block>
              </defn-body>
              <defn-body class="defnBorderTop">
                <span>In the next chapter we will use <c-s>std::type_info</c-s> to display information about
                types in several examples.</span>
              </defn-body>
            </defn-block>
          </details>
        </indent-block>
        Definitions and declarations:
        <indent-block class="pad10">
          A type declaration associates a variable name with a type.
          <spacer-10></spacer-10>
          <details>
            <summary class="labelStyle lightItem">type declaration</summary>
            <spacer-10></spacer-10>
            <defn-block style="max-width:50rem;">
              <defn-body>
                A type declaration defines a name associated with a specified type, e.g., a set
                of operations supported for the named entity, but defines no storage unless it
                is also a definition.  If not, that must
                be done later, but before the entity is used.
              </defn-body>
              <defn-body class="defnBorderTop">
                <xt-b>
                  <c-s>extern int x;</c-s>
                  <indent-block class="pad10">
                    The entity x supports all of the operations for ints, but no storage is defined
                    by this statement.
                  </indent-block>
                  <c-s>void f(int i);</c-s>
                  <indent-block class="pad10">
                    Declares f to be a function, to be defined later, accepting a single integer
                    argument and returning nothing.
                  </indent-block>
                  <c-s>class X;</c-s>
                  <indent-block class="pad10">
                    Declares X to be a class to be defined later. X is said to be an incomplete type and
                    the statement is a forward declaration of X.
                  </indent-block>
                  <c-s>class Y { /* operations elided */ };</c-s>
                  <indent-block class="pad10">
                    We often say that class Y is defined by the statement above, but technically it is a
                    declaration, because this statement defines the size required for instances of Y
                    but no storage is allocated.
                  </indent-block>
                </xt-b>
              </defn-body>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          A type definition is a declaration that also allocates, and may initialize, storage for a variable.
          <spacer-10></spacer-10>
          <details>
            <summary class="labelStyle lightItem">type definition</summary>
            <spacer-10></spacer-10>
            <defn-block style="max-width:50rem;">
              <defn-body>
                A type definition allocates storage for a declared entity of a specified type.
                The designer can specify the location of that storage, e.g., in static, stack, or
                heap memory.
              </defn-body>
              <defn-body class="defnBorderTop">
                <c-s>int x; int y{ 2 };</c-s>
                <indent-block class="pad10">
                  The variable <c-s>x</c-s> is declared and storage is allocated
                  in the local stack frame, and filled with a default value;
                  <spacer-10></spacer-10>
                  The variable <c-s>y</c-s> is declared and storage is allocated in the local stack
                  frame and initialized with the value <c-s>2</c-s>.
                  <spacer-10></spacer-10>
                  <background-block style="border:1px solid darkred;">
                    Life-time of this storage extends from the point of declaration until the thread
                    of execution leaves the current scope.
                  </background-block>
                </indent-block>
              </defn-body>
              <defn-body style="border-top:none;">
                <spacer-10></spacer-10>
                <c-s>void f(int i) { std::cout << "\n  " << argument has value << i; }</c-s>
                <indent-block class="pad10">
                  The code within the <c-s>{</c-s> and <c-s>}</c-s> scope delimiters is compiled and allocated
                  to static memory adjacent to other code from the surrounding program.
                  <spacer-10></spacer-10>
                  <background-block style="border:1px solid darkred;">
                    Life-time of this allocation is the life time of the program after the program&apos;s
                    process has been created until the process begins termination.
                  </background-block>
                </indent-block>
              </defn-body>
              <defn-body style="border-top:none;">
                <spacer-10></spacer-10>
                <c-s>X x; Y y(...);</c-s>
                <indent-block class="pad10">
                  Reserves storage for <c-s>x &epsilon; X</c-s> in the stackframe for its local scope
                  and initializes that storage with a default value.
                  <spacer-10></spacer-10>
                  Reserves storage in the local stackframe for <c-s>y &epsilon; Y</c-s> and
                  initializes the storage using a Y constructor function that accepts the type(s)
                  specified by the ... elipsis, above.
                  <spacer-10></spacer-10>
                  <background-block style="border:1px solid darkred;">
                    Life-time of this storage extends from the point of declaration until the thread
                    of execution leaves the current scope.
                  </background-block style="border:1px solid darkred;">
                </indent-block>
              </defn-body>
              <defn-body style="border-top:none;">
                <spacer-10></spacer-10>
                <c-s>static T t;</c-s> where <c-s>T</c-s> is some fundamental or user-defined type
                <indent-block class="pad10">
                  Allocates storage for variable <c-s>t</c-s> in static memory, adjacent to other code for
                  the program.
                  <spacer-10></spacer-10>
                  <background-block style="border:1px solid darkred;">
                    Life-time of the memory
                    reservation for <c-s>t</c-s> extends from first use to the end of program
                    execution.
                  </background-block>
                </indent-block>
              </defn-body>
              <defn-body style="border-top:none;">
                <spacer-10></spacer-10>
                <c-s>X* pX = new X;</c-s>
                <indent-block class="pad10">
                  Allocates storage for the pointer <c-s>pX</c-s> in the local stack frame, and
                  allocates storage in the native heap for an un-named instance of <c-s>X</c-s>.  The storage
                  for <c-s>pX</c-s> is initialized with the heap address of the <c-s>X</c-s> instance, and
                  the storage of the instance of <c-s>X</c-s> is initialized by <c-s>X</c-s>&apos;s default constructor.
                  <spacer-10></spacer-10>
                  <background-block style="border:1px solid darkred;">
                    Life-time for this storage extends from the time the new operator is invoked
                    until <c-s>delete</c-s> operator is called on <c-s>pX</c-s>.
                  </background-block>
                </indent-block>
              </defn-body>
            </defn-block>
          </details>
        </indent-block>
        <spacer-10></spacer-10>
        We will provide examples of, and cover many details about, C++ data types in Chapter 2 - Data.
        <spacer-15></spacer-15>
      </indent-blocks>
      <a name="Ops"></a>
      <hr class="spread" />
      <num-cont>
        <num-item1>1</num-item1><num-item2>.</num-item2><num-item3>2</num-item3>
        <num-item4>Operations</num-item4>
      </num-cont>
      <indent-blocks>
        C++ programs consist of an ordered sequence of
        <a href="https://en.cppreference.com/w/cpp/language/statements">statements</a> where a statement is
        an <a href="https://en.cppreference.com/w/cpp/language/expressions">expression</a> followed
        by a semicolon &quot;<c-s>;</c-s>&quot;.
        Expressions may be declarative, operational, iterative, selection, and try-block expression types, and may be
        combinations of these. Declarative statements are compile-time artifacts, disappearing after
        compilation.  All the others generate code that executes at run-time.
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
              program scopes
            </summary>
            <spacer-10></spacer-10>
            <div style="max-width:40rem;">
            <defn-block>
              <defn-body>
                C++ programs are partitioned by scopes, e.g., sequences of statements enclosed within braces
                <span style="white-space:nowrap;">&quot;<c-s>{</c-s> &quot; and &quot;<c-s>}</c-s>&quot;.</span>
              </defn-body>
              <defn-body class="defnBorderTop">
                <spacer-10></spacer-10>
                There are several types of scopes:
                <ul class="tightList indent">
                  <li>
                    <c-s>namespace N { ... }</c-s>
                  </li>
                  <li>
                    <c-s>class C { ... };</c-s>
                  </li>
                  <li>
                    <c-s>struct S { ... }</c-s>
                  </li>
                  <li>
                    <c-s>enum class E { ... }</c-s>
                  </li>
                  <li>
                    <c-s>void f(int i) { ... }</c-s>
                  </li>
                  <li>
                    <c-s>try { ... } catch(execption&amp; ex) { ... }</c-s>
                  </li>
                  <li>
                    <c-s>for(startExpression; endExpression; incrementExpression) { ... }</c-s>
                  </li>
                  <li>
                    <c-s>for(T t : container) { ... }&nbsp;&nbsp;T</c-s> may be replaced by <c-s>auto</c-s>
                  </li>
                  <li>
                    <c-s>while(predicate) { ... }</c-s>
                  </li>
                  <li>
                    <c-s>do { ... } while(predicate);</c-s>
                  </li>
                  <li>
                    <c-s>if(predicate) { ... } else { ... }</c-s>
                  </li>
                </ul>
                <spacer-5></spacer-5>
                The first four are compile-time artifacts that define names, allowed operations,
                and accessibility.  They disappear after compilation.
                <spacer-10></spacer-10>
                The rest are compile-time and run-time constructs that affect execution and
                execution flow. Any entity declared within these scopes has a life-time that
                starts at the point of declaration and ends when the thread of execution leaves the scope.
                <spacer-10></spacer-10>
                We will discuss all of these run-time operations in this section, below.
                <spacer-10></spacer-10>
              </defn-body>
            </defn-block>
            </div>
          </details>
        </indent-block>
        C++ provides unary and binary <a href="https://en.cppreference.com/w/cpp/language/expressions">operations</a>
        for the fundamental types.  It also provides operator functions that may be overloaded for
        user-defined types.
        Some of the most used operations and
        <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">operators</a>
        are illustrated here for both fundamental and user-defined types:
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
                dereference and address of:&nbsp;&nbsp;
                <span class="codeStyle">* &amp;</span>
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
              <defn-body class="codeStyle dflex">
                <spacer-10></spacer-10>
              <div>
                struct X { Y y; ... }; X x1; Y y;
                <spacer-15></spacer-15>
                X* pX = &amp;x1;<br />
                <span class="normal">sets pointer</span>
                pX &#949; X*
                <span class="normal">to address of instance</span> x1 &#949; X
                <spacer-15></spacer-15>
                X x2 = *pX;<br />
                <span class="normal">instance</span> x2 &#949; X
                <span class="normal">gets copy of contents of </span>x1
                <span class="normal">pointed to by</span> pX<br />
                <span class="normal">by dereferencing pointer, </span>
                pX <span class="normal">and copying value to</span> x2
              </div>
              <hidephotosizer-block src="Pictures/PointerImage.JPG" width="300" class="photoSizerBlock right" style="margin-top:0;">
                <span style="font-family:'Comic Sans MS, Tahoma';">
                  Fig 2. Pointer to x &epsilon; X
                </span>
              </hidephotosizer-block>
              </defn-body>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              member access operations:&nbsp;&nbsp;
              <span class="codeStyle">. -></span>
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
              <defn-body class="codeStyle">
                <spacer-10></spacer-10>
                struct X { int y; ... };
                <spacer-10></spacer-10>
                X x{ 2, ... }; X* pX = &amp;x;
                <spacer-10></spacer-10>
                x.y, pX->y <span class="normal">both refer to value of</span>
                y<span class="normal">, e.g., </span> 2<span class="normal">, contained in struct</span> X&nbsp;&nbsp;
                <spacer-10></spacer-10>
              </defn-body>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              pre increment and decrement:&nbsp;&nbsp;
              <span class="codeStyle">++i --i</span>
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
              <defn-body class="codeStyle pad10">
                int i{ 0 }; ++i; --i;<br />
                ++i <span class="normal">increments</span>
                i <span class="normal">and returns value</span> 1<br />
                --i <span class="normal">decrements</span>
                i <span class="normal">and returns value</span> 0&nbsp;&nbsp;
              </defn-body>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              post increment and decrement:&nbsp;&nbsp;
              <span class="codeStyle">i++ i--</span>
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
            <defn-body class="codeStyle pad10">
              int i{ 0 }; i++; i--;<br />
              i++ <span class="normal">increments value to</span> 1
              <span class="normal">and returns prior value</span> 0<br />
              i-- <span class="normal">decrements value to</span> 0
              <span class="normal">and returns prior value</span> 1&nbsp;&nbsp;
            </defn-body>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              logical operators:&nbsp;&nbsp;
              <span class="codeStyle">== != &lt; &lt;= &gt;= &gt; &amp;&amp; || !</span>
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
            <defn-body class="codeStyle pad10">
              Here, we illustrate how a user defined type could implement<br />
              two of these logical operations:
              <spacer-15></spacer-15>
              struct X {<br />
              &nbsp;&nbsp;int i; double d;<br />
              &nbsp;&nbsp;bool operator==(const X&amp; x) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;return i == x.i && d == x.d;<br />
              &nbsp;&nbsp;}<br />
              &nbsp;&nbsp;bool operator!=(const X&amp; x) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;return i != x.i || d != x.d;<br />
              &nbsp;&nbsp;}<br />
              };
              <spacer-15></spacer-15>
              X x1{ 1, 1.5 }, x2{ 1, 1.5 }; x3{ 2, -0.5 }<br />
              x1 == x2; x1 != x3;
              <spacer-15></spacer-15>
              <span class="normal">Both statements above are true.</span>
            </defn-body>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              index operator:&nbsp;&nbsp;
              <span class="codeStyle">a[]</span>
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
            <defn-body class="pad10 codeStyle">
              double a[] { 1.0, 1.5, 2.0 };
              <spacer-15></spacer-15>
              a[1] == 1.5 <span class="normal">has value</span> true
            </defn-body>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              arithmetic operations:&nbsp;&nbsp;
              <span class="codeStyle">+ - * /</span>
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
            <defn-body class="pad10 codeStyle">
              int x1{ 2 }; int x2{ 4 };
              <spacer-10></spacer-10>
              x1 + x2 == 6;
              x1 - x2 == -2;
              x1 * x2 == 8;
              x2 / x1 == 2;&nbsp;&nbsp;
              <spacer-10></spacer-10>
              <span class="normal">All of the boolean expressions above are true</span>;
            </defn-body>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              loops:&nbsp;&nbsp;for, while, do
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
            <defn-body class="pad10 codeStyle">
              <spacer-15></spacer-15>
              for(int i=0; i&lt;Max; ++i) {
              <comment-block>
                Any, or all, of the three loop conditions may be omitted, provided
                that omitted conditions are defined.  If no termination condition is provided,
                the loop requires a conditional break statement to terminate.
                <spacer-10></spacer-10>
                Loop operations elided
              </comment-block>
              }
              <hr class="spread" />
              for(auto item : collection) {
              <comment-block>
                Collection must provide an iterator and methods begin() and end()
                which return iterators referring to the first element and one past
                the last of its elements.
                <spacer-10></spacer-10>
                Loop operations elided
              </comment-block>
              }
              <hr class="spread" />
              while(predicate) {
              <comment-block>
                Loop operations will not be executed if predicate is false on entry.
                <spacer-10></spacer-10>
                Loop will continue until operations in scope of the loop
                make its predicate false.
                <spacer-10></spacer-10>
                Loop operations elided
              </comment-block>
              }
              <hr class="spread" />
              do {
              <comment-block>
                Ensures that loop operations are executed at least once.
                <spacer-10></spacer-10>
                Loop will continue until operations in scope of the loop
                make its predicate false.
                <spacer-10></spacer-10>
                Loop operations elided
              </comment-block>
              } while(predicate);
            </defn-body>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              selection:&nbsp;&nbsp;if-else, ternary operator, switch
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
            <defn-body class="pad10 codeStyle">
              <spacer-15></spacer-15>
              if(predicate) {
              <comment-block>
                Operations to execute when predicate is true go here.
              </comment-block>
              }<br />
              else {
              <comment-block>
                Operations to execute when predicate is false go here.
                This else clause is optional.
              </comment-block>
              }
              <hr class="spread">
              <div class="normal">
                The ternary operator:
                <indent-block class="pad10">
                  <c-s>predicate ? e1 : e2</c-s>
                </indent-block>
                returns the value of expression <c-s>e1</c-s> if <c-s>predicate</c-s>
                evaluates to <c-s>true</c-s>, otherwise it returns the value of expression
                <c-s>e2</c-s>.
              </div>
              <hr class="spread">
              <div class="normal">
                The switch operation enables execution of code specific to some specified case.
                <spacer-10></spacer-10>
                switch selectors, <c-s>iSelect</c-s>, and switch cases, <c-s>iSelect1, iSelect2, ...</c-s>
                belong to a list, IS, of integral selectors, e.g., distinct integers or values of an enumeration:
                <c-s>iSelect, iSelect1, iSelect2, ... &epsilon; IS</c-s>
              </div>
              <spacer-10></spacer-10>
              switch(iSelect) {<br />
              case iSelect1:
              <comment-block>
                Operations for iSelect1 case go here.
              </comment-block>
              &nbsp;&nbsp;break;<br />
              case iSelect2:
              <comment-block>
                Operations for iSelect2 case go here.
              </comment-block>
              &nbsp;&nbsp;break;<br />
              &nbsp;&nbsp;----<br />
              default:
              <comment-block>
                Operations when iSelect does not match any declared iSelect[n] case go here.
              </comment-block>
              &nbsp;&nbsp;break;<br />
              }
            </defn-body>
            </defn-block>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              function call operator:&nbsp;&nbsp;
              <span class="codeStyle">f()</span>
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
              <defn-body class="pad10 codeStyle">
                void f(const std::string& str)<br />
                {<br />
                &nbsp;&nbsp;std::cout << "\n  " << str;<br />
                }
                <spacer-15></spacer-15>
                f("hello Syracuse"); <span class="normal">displays message on console&nbsp;&nbsp;</span>
              </defn-body>
            </defn-block>
           </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              method call operator:&nbsp;&nbsp;
              <span class="codeStyle">operator()</span>
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
            <defn-body class="pad10 codeStyle">
              class X {<br />
              &nbsp;&nbsp;void operator()(const std::string&amp; s) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;std::cout << "\n  " << s;<br />
              &nbsp;&nbsp;}<br />
              };
              <spacer-15></spacer-15>
              X x;<br />
              x("hello");<br />
              x.operator()("hello");
              <spacer-15></spacer-15>
              <span class="normal">
                The last two statements are equivalent.
                <spacer-15></spacer-15>
                We call X a functor because an
                instance can be invoked like a function, as above.&nbsp;&nbsp;
              </span>
            </defn-body>
            </defn-block>
          </details>
        </indent-block>
        Users can define invocable functions at namespace scope, including the global namespace,
        but cannot define functions in function scope, e.g., no inner functions.
        Users define methods (functions bound to a specific class) in class scope.
        <spacer-15></spacer-15>
        <a href="https://en.cppreference.com/w/cpp/language/lambda">Lambdas</a> are locally defined
        callable objects that are useful for starting threads and using STL algorithms.
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
              Lambda:&nbsp;&nbsp;
              <span class="codeStyle">[/* capture */](/* args */) { /* code block */ };</span>
            </summary>
            <spacer-10></spacer-10>
            <div style="max-width:40rem;">
              <defn-block>
                <defn-code>
  char ul = '-';
  auto makeTitle = [ul](const std::string&amp; title) {
    std::cout << "\n  " << title;
    std::cout << "\n " << std::string(title.size() + 2, ul);
  };

  makeTitle("demonstrate lambda");

  <span class="normal">emits:</span>

   demonstrate lambda
  --------------------
                  </defn-code>
                <defn-body>
  [ul] <t-s>captures the value of local variable</t-s> ul <t-s>from the local scope
  and uses it for an underline character, below the title message. The title is passed in
  as a parameter when lambda, </t-s>makeTitle<t-s>, is invoked.</t-s>
                </defn-body>
              </defn-block>
            </div>
          </details>
        </indent-block>
        Lambdas may be defined in namespace, function, and method scopes, and so, can serve the role
        of inner functions.  They are useful for much more, as we will see in Chapter 2.
      </indent-blocks>
      <a id="Class"></a>
      <hr class="spread" />
      <!--<h4>Classes and class relationships:</h4>-->
      <num-cont>
        <num-item1>1</num-item1><num-item2>.</num-item2><num-item3>3</num-item3>
        <num-item4>Classes and Class Relationships:</num-item4>
      </num-cont>
      <indent-blocks>
        C++ classes and structs are identical except that struct members are public by default and
        class members are private by default.  With either, we choose to make some members public with
        a &quot;public:&quot; declaration and others private with &quot;private:&quot;.
        <spacer-15></spacer-15>
        By convention, we use structs to aggregate data, much like std::tuple.  We also use them to
        define code interfaces, as described in Chapter&nbsp;4.
        We use classes to implement some abstraction defined by its public members.  If a class is well
        designed, only its methods have direct access to data it manages.  That allows a class to make
        strong guarantees about the validity of its data.
        <spacer-15></spacer-15>
        Object Oriented Design consists of using classes and class relationships to structure program
        activities.  Basic classes can be quite simple, defining only methods for managing and accessing
        class state, as discussed here.  The language, however, provides additional design facilities for supporting
        value or reference type behavior.  We will address those details in Chapter 4.
        <spacer-10></spacer-10>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">basic class</summary>
            <spacer-10></spacer-10>
            <defn-block>
            <defn-body class="pad10 autoX">
              <div class="pad10-15" style="padding-right:25px;">
              <hidephotosizer-block src="Pictures/PersonCodeLayout.JPG" width="300" class="photoSizerBlock right">
                <span style="font-family:'Comic Sans MS, Tahoma';">
                  Fig 1. Person Class code layout
                </span>
              </hidephotosizer-block>
              <div>
                Class Person declares personal data contained by each instance. These &quot;stats&quot; contain
                name, occupation, and age,
                held in a <c-s>std::tuple</c-s>.
                <spacer-15></spacer-15>
                Instances of the Person class can be copied and assigned because its only data member,
                personStats is a std::tuple.
                The std::tuple and its elements all have correct copy, assignment, and destruction semantics.
                <spacer-15></spacer-15>
                Compiler generated methods for copying, assignment, and destruction do those operations
                on each of a class&apos;s base classes and composed member data items.  In this case, those
                generated operations simply use the std::tuple&apos;s copy, assignment, and destruction operations.
              </div>
              <spacer-15></spacer-15>
              <pre class="codeStyle">
  class Person {
  public:
    using Name = std::string;
    using Occupation = std::string;
    using Age = int;
    using Stats = std::tuple&lt;Name, Occupation, Age&gt;;

    Person();
    Person(const Stats& sts);
    Stats stats() const;
    void stats(const Stats& sts);
    bool isValid();
    Name name() const;
    Occupation occupation() const;
    void occupation(const Occupation&amp; occup);
    Age age() const;
    void age(const Age&amp; ag);

  private:
    Stats personStats;
  };
</pre>
              <spacer-15></spacer-15>
              <div class="normal">
                Note that Person defines four type aliases with names that make the class&apos;s code
                readable,
                easer to test, and easer to use.
                <spacer-15></spacer-15>
                It provides getter and setter methods for attributes
                occupation and age that should be changeable, and only a getter for the name attribute
                which should not.
                <spacer-15></spacer-15>
                References:
                <indent-block class="pad10">
                  <a href="CppStoryRepo.html">CppStory Repository</a>
                </indent-block>
              </div>
              <spacer-15></spacer-15>
              <!--</div>
              <div class="background-block" style="min-width:350px;">-->
              </div>
            </defn-body>
            </defn-block>
          </details>
        </indent-block>
        <spacer-10></spacer-10>
        If you look back at the Person class, in basic class - the previous details, you will see two things that might seem peculiar.
        There are two functions with the same name, Person, and they have no return values.
        C++ classes define constructors for building initialized instances of the class.
        The language recognizes constructors as any function with the same name as the class and no return values.
        <spacer-15></spacer-15>
        The fact that constructors return no values - not even void - is specified by the language.
        In order to handle two or more functions with the same name, C++ defined function overloading.
        <spacer-10></spacer-10>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
              function overloading
            </summary>
            <spacer-10></spacer-10>
            <div style="max-width:50rem;">
            <defn-block>
            <defn-body class="pad10">
              Function overloading is the definition of two or more functions with the same name
              but different sequences of argument types<sup>1</sup>.
              <spacer-15></spacer-15>
              Consider the two Person constructors, from the previous &quot;basic class&quot; details:
              <spacer-10></spacer-10>
              <c-s>
                &nbsp;&nbsp;Person();<br />
                &nbsp;&nbsp;Person(const Stats&amp; sts);<br />
              </c-s>
              <spacer-10></spacer-10>
              The second has an sts argument, used to initialize an internal data member.
              The first has no argument, so the internal data member has a default initialization.
              <spacer-15></spacer-15>
              C++ classes need the ability to initialize instances in different ways, like this, and since
              the class&apos;s constructors all have the same name, the compiler has to distinguish
              between them in some way.  
              <spacer-15></spacer-15>
              It does that by treating a function name concatenated with the types of its arguments<sup>2</sup>
              as the compiler&apos;s name for that function.  This process of making qualified names
              is called name-mangling.  That is what enables function overloading.
              <spacer-15></spacer-15>
              Function overloading is used in most class declarations, but a designer is free to use
              overloading for other purposes as well.
              <hr class="spreadup" />
              <ol class="footnote">
                <li>
                  Return types play no role in function overloading.
                </li>
                <li>
                  Actually, the name consists of a tokenized sequence that identifies the function name
                  and argument types in a compact format.
                </li>
              </ol>
            </defn-body>
            </defn-block>
            </div>
          </details>
        </indent-block>
        <spacer-10></spacer-10>
        <indent-block>
          <details>
            <summary class="labelStyle darkItem">
              function overloading example
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
            <defn-body class="pad10">
              <pre><c-s>  /*---- find first and last elements of collection, may throw ----*/

using PD = std::pair&lt;double, double&gt;

PD firstAndLast(double dArr[], size_t N) {
  if (N &lt; 1)
    throw std::exception("no contents in array");
  return PD{ dArr[0], dArr[N - 1] };
}

using PI = std::pair&lt;int, int&gt;

PI firstAndLast(const std::vector&lt;int&gt;& vecInt) {
  if (vecInt.size() &lt; 1)
    throw std::exception("no contents in vector");
  return PI{ vecInt[0], vecInt[vecInt.size() - 1] };
}

/*---- find first and last elements of collection, using <span class="notice">optional</span> ----*/

std::optional&lt;PD&gt; firstAndLastOpt(double dArr[], size_t N) {
  std::optional&lt;PD&gt; opt;
  if(N &gt; 0)
    opt = std::pair{ dArr[0], dArr[N - 1] };
  return opt;
}

std::optional&lt;PI&gt; firstAndLastOpt(const std::vector&lt;int&gt;&amp; vecInt) {
  std::optional&lt;PI&gt; opt;
  if (vecInt.size() &gt; 0)
    opt = std::pair{ vecInt[0], vecInt[vecInt.size() - 1] };
  return opt;
}

/*---- demonstrate first and last ----*/

int main() {

  std::cout &lt;&lt; "\n  Demonstrating Function Overloading";
  std::cout &lt;&lt; "\n ====================================\n";

  double dArr[]{ 1.5, -0.5, 3.0 };
  std::vector&lt;int&gt; vecInt{ 1,2,3,4,5 };

  try {
    auto [firstd1, lastd1] = firstAndLast(dArr, 3);
    std::cout &lt;&lt; "\n  first = " &lt;&lt; firstd1 &lt;&lt; ", last = " &lt;&lt; lastd1;

    auto [firsti1, lasti1] = firstAndLast(vecInt);
    std::cout &lt;&lt; "\n  first = " &lt;&lt; firsti1 &lt;&lt; ", last = " &lt;&lt; lasti1;
  }
  catch (std::exception & ex) {
    std::cout &lt;&lt; "\n  " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }

  std::optional&lt;PD&gt; optd = firstAndLastOpt(dArr, 3);
  if (optd.has_value()) {
    auto [firstd2, lastd2] = optd.value();
    std::cout &lt;&lt; "\n  first = " &lt;&lt; firstd2 &lt;&lt; ", last = " &lt;&lt; lastd2;
  }
  else {
    std::cout &lt;&lt; "\n  array query failed";
  }

  std::optional&gt;PI&lt; opti = firstAndLastOpt(vecInt);
  if (opti.has_value()) {
    auto [firsti2, lasti2] = opti.value();
    std::cout &lt;&lt; "\n  first = " &lt;&lt; firsti2 &lt;&lt; ", last = " &lt;&lt; lasti2;
  }
  else {
    std::cout &lt;&lt; "\n  vector query failed";
  }
  
  std::cout &lt;&lt; "\n\n";
}</c-s></pre>
            </defn-body>
            </defn-block>
          </details>
        </indent-block>
        <spacer-15></spacer-15>
        There are five relationships between C++ classes: inheritance, composition, aggregation, using, and friendship.
        The first four of these are supported by most object oriented languages.
        <spacer-10></spacer-10>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
              class relationships
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
              <defn-body>
                The five relationships between C++ classes are:
                <ol>
                  <li style="padding:0px; margin-top:0.25em; margin-bottom:0.25em;">
                    <strong>Inheritance:</strong> a specialization of a base class by another derived class.
                  </li>
                  <li style="padding:0px; margin-top:0.25em; margin-bottom:0.25em;">
                    <strong>Composition:</strong> a permanent relationship between the composer
                    and composed.
                  </li>
                  <li style="padding:0px; margin-top:0.25em; margin-bottom:0.25em;">
                    <strong>Aggregation:</strong> a temporary relationship between the aggregator and aggregated.
                  </li>
                  <li style="padding:0px; margin-top:0.25em; margin-bottom:0.25em;">
                    <strong>Using:</strong> a non-owning relationship.  The used is made available to the user
                    by passing as a reference argument in a class method.
                  </li>
                  <li style="padding:0px; margin-top:0.25em; margin-bottom:0.25em;">
                    <strong>Friendship:</strong> a relationship granted by a class to one specific friend that allows
                    the friend access to the class&apos;s private members.  Friendship weakens encapsulation and
                    so is used only when necessary, e.g., rarely.
                  </li>
                </ol>
              </defn-body>
              <defn-head class="defnBorderTop">Person Class Example</defn-head>
              <defn-body>
                <hidephotosizer-block src="Pictures/PersonClassHierarchy.JPG" width="400" class="photoSizerBlock right">
                  <span style="font-family:'Comic Sans MS, Tahoma';">
                    <br />
                    Fig 1. Person Class Hierarchy
                  </span>
                </hidephotosizer-block>
                The <c-s>Person</c-s> class, from the previous example, has been expanded into a class hierarchy representing software
                development roles that a person might assume.  A class hierarchy like this
                could be used to build a Project Management Tool that tracked progress on a
                project and the contributions of individual team members.
                <spacer-15></spacer-15>
                There are several types of classes in this hierarchy:
                <ul class="tight">
                  <li>Interfaces: <c-s>IPerson</c-s> and <c-s>ISW-Eng</c-s></li>
                  <li>An abstract class: <c-s>SW-Eng</c-s></li>
                  <li>
                    Concrete classes: <c-s>
                      Person, Dev, TeamLead, ProjMgr,
                      Project, Baseline, Documents,
                    </c-s> and <c-s>Budget</c-s>
                  </li>
                </ul>
                <spacer-15></spacer-15>
                Interfaces, <c-s>IPerson</c-s> and <c-s>ISW-Eng</c-s>, support decoupling the hierarchy from its users, so that changes
                to any of these classes don&apos;t require clients to change, as long as the
                interface doesn&apos;t change.
                <spacer-15></spacer-15>
                The abstract class <c-s>SW-Eng</c-s> provides shared code and types for all its derived classes.
                <spacer-15></spacer-15>
                The concrete classes <c-s>Dev, TeamLead,</c-s> and <c-s>ProjMgr</c-s>, represent roles that a Software Engineer
                may assume while working on the project.  The <c-s>Person</c-s> class is the key abstraction.  All of the
                other parts serve to endow a person with one or more roles, e.g., developer, team lead, or project
                manager.
                <spacer-15></spacer-15>
                All of the relationships between these classes are based on <strong class="notice">inheritance</strong>.
                <spacer-15></spacer-15>
                The <c-s>ProjMgr</c-s> class <strong class="notice">aggregates</strong> a <c-s>Project</c-s> instance, allowing a manager to move to another
                project when the current project completes.
                <spacer-15></spacer-15>
                The <c-s>Project</c-s> class <strong class="notice">composes</strong> a <c-s>Budget</c-s> since that is an integral part of the project.  It
                <strong class="notice">aggregates</strong> <c-s>Documents</c-s> and code <c-s>Baseline</c-s>,
                as these don&apos;t exist at the beginning of the project.
                <spacer-15></spacer-15>
                Developers and Team Leads <strong class="notice">use</strong> the <c-s>Baseline</c-s> by contributing additions,
                but they don&apos;t have an ownership relationship - only the Project Manager can authorise
                deletions and creation of major new parts.
              </defn-body>
            </defn-block>
          </details>
        </indent-block>
        <spacer-10></spacer-10>
        Inheritance supports sharing base class code with all of its derived classes.  While this is useful,
        inheritance&apos;s most important feature is support for substituting derived class pointers and references wherever
        a function accepts a base class pointer or reference.
        <spacer-10></spacer-10>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
              function overriding
            </summary>
            <spacer-10></spacer-10>
            <div style="max-width:50rem;">
            <defn-block>
            <defn-body>
              Suppose that, in the <c-s>SW-Eng</c-s> abstract class, from the previous &quot;class relationships&quot;
              details, we&apos;ve defined a <c-s>virtual void doWork()</c-s> method.
              <spacer-15></spacer-15>
              One might expect that <c-s>Dev</c-s>s, <c-s>TeamLead</c-s>s, and <c-s>PrjMgr</c-s>s would each
              have their own work behaviors, and so, each should have its own definition for what <c-s>doWork</c-s>
              means.  Virtual function overriding allows us to specify those different behaviors.
              <spacer-15></spacer-15>
              Virtual function overriding is the process of, in each derived class, providing a definition for the function
              execution of that function based on the type of the derived class, e.g., <c-s>Dev</c-s>, <c-s>TeamLead</c-s>,
              or <c-s>PrjMgr</c-s>.  The virtual functions in each derived
              class must have the same signature, e.g., <c-s>void doWork()</c-s>, and this redefinition only applys to
              functions that are qualified as <c-s>virtual</c-s> in the base class.
              <s-halfEm></s-halfEm>
            </defn-body>
            </defn-block>
            </div>
          </details>
        </indent-block>
        <spacer-10></spacer-10>
        <indent-block>
          <details>
            <summary class="labelStyle darkItem">
              function overriding example
            </summary>
            <spacer-10></spacer-10>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Example Code</defn-head>
                <defn-code>
  /*--- abstract base class ---*/

  class SWDev {
  public:
    using WorkItems = std::vector&lt;std::string&gt;;

    SWDev(const std::string& name) : name_(name) {}
    virtual ~SWDev() {}
    virtual void doWork() = 0;
    void getCoffee();
    void name(const std::string& nm);
    std::string name();
  protected:
    std::string name_ = "anonymous";
    static WorkItems workItem;
  };

  /*--- shared data ---*/

  inline SWDev::WorkItems SWDev::workItem = {
    "process email",
    "pull requests for today's work",
    "work off bugs",
    "add new features",
    "write up developer evaluations",
    "write up project stories",
    "schedule agile meeting",
    "discuss requirements with customer",
    "go golfing with customer"
  };

  inline auto show = [](const std::string& task) {
    std::cout &lt;&lt; "\n  " &lt;&lt; task;
  };

  /*--- non-virtual functions, don't override ---*/

  inline void SWDev::name(const std::string& name) {
    name_ = name;
  }

  inline std::string SWDev::name() {
    return name_;
  }

  inline void SWDev::getCoffee() {
    std::cout &lt;&lt; 
      "\n  get coffee from cafeteria, chat";
  }

  /*--- derived classes override virtual do work ---*/

  class Dev : public SWDev {
  public:
    Dev(const std::string& name) : SWDev(name) {}
    virtual void doWork() override {
      show("\n  Dev: " + name());
      getCoffee();
      show(workItem[0]);
      show(workItem[1]);
      show(workItem[2]);
      show(workItem[3]);
    }
  };

  class TeamLead : public SWDev {
  public:
    TeamLead(const std::string& name) : SWDev(name) {}
    virtual void doWork() override {
      show("\n  TeamLead: " + name());
      getCoffee();
      show(workItem[0]);
      show(workItem[5]);
      show(workItem[6]);
      show(workItem[1]);
      show(workItem[2]);
      show(workItem[3]);
    }
  };

  class ProjMgr : public SWDev {
  public:
    ProjMgr(const std::string& name) : SWDev(name) {}
    virtual void doWork() override {
      show("\n  Project Mgr: " + name());
      getCoffee();
      show(workItem[0]);
      show(workItem[4]);
      show(workItem[7]);
      show(workItem[8]);
    }
  };
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Using Code</defn-head>
                <defn-code>
#include "Overriding.h"

int main() {

  std::cout &lt;&lt; "\n  Demonstrating Overriding";
  std::cout &lt;&lt; "\n ==========================\n";

  /* form project team */
  ProjMgr Frank("Frank");

  TeamLead Ashok("Ashok");
  Dev Joe("Joe");
  Dev Charley("Charley");
  Dev Sue("Sue");

  TeamLead Ming("Ming");
  Dev Barbara("Barbara");
  Dev Samir("Samir");

  std::vector&lt;SWDev*&gt; ProjectTeam{
    &Frank,
    &Ashok, &Joe, &Charly, &Sue,
    &Ming, &Barbara, &Samir
  };

  /* get to work */

  show("Monday, starting work");
  for (auto swDev : ProjectTeam) {
    swDev-&gt;doWork();
  }
  show("\n  That's all Folks\n\n");
                </defn-code>
                <defn-head class="defnBorderTop">Output</defn-head>
                <defn-code>
  Demonstrating Overriding
 ==========================

  Monday, starting work

  Project Mgr: Frank
  get coffee from cafeteria, chat
  process email
  write up developer evaluations
  discuss requirements with customer
  go golfing with customer

  TeamLead: Ashok
  get coffee from cafeteria, chat
  process email
  write up project stories
  schedule agile meeting
  pull requests for today's work
  work off bugs
  add new features

  Dev: Joe
  get coffee from cafeteria, chat
  process email
  pull requests for today's work
  work off bugs
  add new features

  Dev: Charley
  get coffee from cafeteria, chat
  process email
  pull requests for today's work
  work off bugs
  add new features

  Dev: Sue
  get coffee from cafeteria, chat
  process email
  pull requests for today's work
  work off bugs
  add new features

  TeamLead: Ming
  get coffee from cafeteria, chat
  process email
  write up project stories
  schedule agile meeting
  pull requests for today's work
  work off bugs
  add new features

  Dev: Barbara
  get coffee from cafeteria, chat
  process email
  pull requests for today's work
  work off bugs
  add new features

  Dev: Samir
  get coffee from cafeteria, chat
  process email
  pull requests for today's work
  work off bugs
  add new features

  That's all Folks
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </details>
        </indent-block>
        <spacer-15></spacer-15>
        <indent-block class="pad10">
          We will discuss the details of techniques used in this example in Chapter 4.
        </indent-block>
        <spacer-10></spacer-10>
        Most C++ projects use classes extensively.  Usually almost all of the code is devoted to implementing
        classes and using class instances.  We will look at, and dissect, examples in Chapter 4.
      </indent-blocks>
      <a id="Templ"></a>
      <hr class="spread" />
      <num-cont>
        <num-item1>1</num-item1><num-item2>.</num-item2><num-item3>4</num-item3>
        <num-item4>Templates and Specialization:</num-item4>
      </num-cont>
      C++ templates provide a way of defining library functions and classes that depend
      on some unspecified type or types.  STL containers like <c-s>std::vector&lt;T&gt;</c-s>
      are examples.
      <spacer-15></spacer-15>
      Template functions and classes need to be instantiated by using applications
      with specific type(s) before they can be used, e.g., <c-s>std::vector&lt;std::string&gt;</c-s>.
      <indent-blocks>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
              template functions
            </summary>
            <spacer-10></spacer-10>
            <div style="max-width:50rem;">
            <defn-block>
            <defn-body class="pad10">
              The template function <c-s>max&lt;T, T&gt;</c-s> accepts two arguments of the same
              type and returns an instance of that type with the value of the larger of the
              arguments.
              <spacer-10></spacer-10>
              <indent-block class="pad10">
              <c-s>
                template &lt;typename T&gt;<br />
                T max(T t1, T t2) {<br />
                &nbsp;&nbsp;return t1 &gt; t2 ? t1 : t2;<br />
                }
              </c-s>
              </indent-block>
              <spacer-10></spacer-10>
              This function, when instantiated with a specific type, will compile successfully
              provided that T has defined <c-s>operator&gt;(T&amp; t)</c-s>. Otherwise, compilation
              fails.
              <spacer-10></spacer-10>
              There is another subtle problem with <c-s>max&lt;T, T&gt;</c-s>.  It works correctly
              for fundamental types and instances of classes like <c-s>std::string</c-s>.
              However, if we make the following invocation:
              <spacer-10></spacer-10>
              <indent-block class="pad10">
                <c-s>const char* pStr = max&lt;&quot;aardvark&quot;, &quot;zebra&quot;&gt;;</c-s>
              </indent-block>
              <spacer-10></spacer-10>
              the function compiles, but we may not get a result we expect.
              <c-s>max&lt;const char*, const char*&gt;</c-s> returns the larger of
              its two arguments, which, in this case are pointers, so we will get a pointer to whichever
              string is stored in the higher memory location, having nothing to do with lexicographic
              ordering of its arguments.
              <spacer-10></spacer-10>
              We see how to fix it by overloading <c-s>max&lt;T, T&gt;</c-s> for
              that specific case, below.
            </defn-body>
            </defn-block>
            </div>
          </details>
          <spacer-15></spacer-15>
          <details>
            <summary class="labelStyle lightItem">
              overloading template functions
            </summary>
            <spacer-10></spacer-10>
            <div style="max-width:60rem;">
            <defn-block>
            <defn-body class="pad10">
              Here&apos;s the original <c-s>max&lt;T, T&gt;</c-s> declaration:
              <defn-block class="pad10-15 noBorder indent">
                <c-s>
                  template &lt;typename T&gt;<br />
                  T max(T t1, T t2) {<br />
                  &nbsp;&nbsp;return t1 &gt; t2 ? t1 : t2;<br />
                  }
                </c-s>
              </defn-block>
              and here is a function overload declaration for the case of <c-s>const char*</c-s>:
              <defn-block class="pad10-15 noBorder indent">
                <c-s>
                  using pStr = const char*;<br />
                  template &lt;&gt;<br />
                  pStr max(pStr s1, pStr s2) {<br />
                  &nbsp;&nbsp;return ((strcmp(s1,s2)>0) ? S1 : s2);<br />
                  }
                </c-s>
              </defn-block>
              <spacer-10></spacer-10>
              The C++ language guarantees that the most specific function overload will be
              applied to compile a function.  In the case of <c-s>const char*</c-s>, <c-s>pStr</c-s> is more specific
              than the template type <c-s>T</c-s>, so the second version will be compiled
              and the result will return the string with largest lexicographic order because
              that is what the C function <c-s>strcmp</c-s> returns.
              <spacer-10></spacer-10>
              This overloading guarantee is very important.  It means that we can define a
              generic template for a class and then supply specific overloads for any types
              that are problematic.
              <spacer-10></spacer-10>
              This isn&apos;t a perfect solution, because there may be an open-ended set of
              types that cause problems, but if we encounter more problematic types, we can
              provide additional overloads.
            </defn-body>
            </defn-block>
            </div>
          </details>
        </indent-block>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
              template classes
            </summary>
            <spacer-10></spacer-10>
            <div style="max-width:50rem;">
            <defn-block>
            <defn-body class="pad10">
              C++ classes can be declared as templates too.  Here&apos;s an example:
              <spacer-10></spacer-10>
              <c-s>
                template &lt;typename T&gt;<br />
                class stack {<br />
                public:<br />
                &nbsp;&nbsp;void push(T t);<br />
                &nbsp;&nbsp;T pop();<br />
                &nbsp;&nbsp;T top();<br />
                &nbsp;&nbsp;std::size_type size();<br />
                private:<br />
                &nbsp;&nbsp;// data members elided<br />
                };
                <spacer-10></spacer-10>
                template &lt;typename T&gt;<br />
                void stack&lt;T&gt;::push(T t) {<br />
                &nbsp;&nbsp;// details elided<br />
                }
                <spacer-10></spacer-10>
                // other member function definitions elided
              </c-s>
              <spacer-15></spacer-15>
              With this template declaration we can define:
              <spacer-10></spacer-10>
              <c-s>
                stack&lt;int&gt; intStk;<br />
                stack&lt;std::pair&lt;std::string, int&gt;&gt; prStk;<br />
                stack&lt;Widget&gt; WdgStk;<br />
              </c-s>
              <spacer-10></spacer-10>
              Without templates we would have to declare a <c-s>stack</c-s> class for each of these
              types.  With templates the compiler does all that extra work for us.
              <spacer-10></spacer-10>
              For each instantiation, the compiler generates a class for that type.  Syntactically,
              each of the above declarations defines a distinct class.  That is,
              <c-s>stack&lt;int&gt;</c-s> is not the same type as
              <c-s>stack&lt;std::pair&lt;std::string, int&gt;&gt; prStk;</c-s>
              <s-halfEm></s-halfEm>
            </defn-body>
            </defn-block>
            </div>
          </details>
        </indent-block>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
              template class specialization
            </summary>
            <spacer-10></spacer-10>
            <div style="max-width:50rem;">
            <defn-block>
            <defn-body class="pad10">
              Suppose that, for the user-defined type <c-s>Widget</c-s>, some <c-s>stack&lt;T&gt;</c-s>
              methods fail to compile or process a <c-s>Widget</c-s> incorrectly.
              That could happen if the stack provides copy and assignment operations, but
              <c-s>Widget</c-s> instances are not copyable or assignable, or those operations
              are incorrect for <c-s>Widget</c-s> due to an incomplete design<sup>1</sup>.
              <spacer-10></spacer-10>
              For that, we can use template
              specialization to fix that problem, in much the same way as we did by overloading
              <c-s>max&lt;T, T&gt;</c-s> in the discussion of overloading template functions.
              For the <c-s>Widget</c-s> specialization we would declare the
              <c-s>stack&lt;Widget&gt;</c-s> copy and assignment operations as deleted
              with <c-s>=delete</c-s> postfix qualifiers.
              <spacer-15></spacer-15>
              The generic class is defined as:
              <spacer-10></spacer-10>
              <div class="pad10 indent">
                <c-s>
                  template &lt;typename T&gt;<br />
                  class stack {<br />
                  public:<br />
                  &nbsp;&nbsp;stack();<br />
                  &nbsp;&nbsp;stack(const stack&lt;T&gt;&amp; stk);<br />
                  &nbsp;&nbsp;stack&lt;T&gt;&amp; operator=(const stack&lt;T&gt;&amp; stk);<br />
                  &nbsp;&nbsp;void push(T t);<br />
                  &nbsp;&nbsp;T pop();<br />
                  &nbsp;&nbsp;T top();<br />
                  &nbsp;&nbsp;std::size_type size();<br />
                  private:<br />
                  &nbsp;&nbsp;// data members elided<br />
                  };
                  <spacer-10></spacer-10>
                  template &lt;typename T&gt;<br />
                  void stack&lt;T&gt;::push(T t) {<br />
                  &nbsp;&nbsp;// details elided<br />
                  }
                  <spacer-10></spacer-10>
                  // other member function definitions elided
                </c-s>
                <spacer-15></spacer-15>
                <c-s>
                  stack&lt;Widget&gt; WdgStk;
                </c-s>
                // fails to compile or exhibits incorrect operation.
              </div>
              <spacer-15></spacer-15>
              So, we define a <c-s>stack</c-s> class specialization for <c-s>Widgets</c-s>
              like this:
              <spacer-10></spacer-10>
              <div class="pad10 indent">
                <c-s>
                  template &lt;&gt;<br />
                  class stack&lt;Widget&gt; {<br />
                  public:<br />
                  &nbsp;&nbsp;stack();<br />
                  &nbsp;&nbsp;stack(const stack&lt;T&gt;&amp; stk) = delete;<br />
                  &nbsp;&nbsp;stack&lt;T&gt;&amp; operator=(const stack&lt;T&gt;&amp; stk) = delete;<br />
                  &nbsp;&nbsp;void push(Widget w);<br />
                  &nbsp;&nbsp;Widget pop();<br />
                  &nbsp;&nbsp;Widget top();<br />
                  &nbsp;&nbsp;std::size_type size();<br />
                  private:<br />
                  &nbsp;&nbsp;// elided data members may be different from the generic class<br />
                  };
                  <spacer-10></spacer-10>
                  template &lt;typename T&gt;<br />
                  void stack&lt;T&gt;::push(T t) {<br />
                  &nbsp;&nbsp;// elided details may be different from the generic class<br />
                  }
                  <spacer-10></spacer-10>
                  // other member function definitions elided
                </c-s>
                <spacer-10></spacer-10>
                <c-s class="pad10">
                  stack&lt;Widget&gt; WdgStk;
                </c-s>
                <spacer-10></spacer-10>
                // now compiles if we don&apos;t try to copy or assign instances<br />
                // and exhibits correct operation
              </div>
              <spacer-15></spacer-15>
              The C++ language guarantees that a specialization will be compiled instead of the
              generic class whenever the class is instantiated with a specialized type, like
              <c-s>Widget</c-s>
              <hr class="spreadup" />
              <ol style="font-size:0.8em;">
                <li>
                  We will discuss, in Chapter 4., how incomplete designs happen and how to ensure your designs
                  are complete.
                </li>
              </ol>
            </defn-body>
            </defn-block>
            </div>
          </details>
        </indent-block>
      </indent-blocks>
      <a id="Lib"></a>
      <hr class="spread" />
      <!--<h4>Libraries</h4>-->
      <num-cont>
        <num-item1>1</num-item1><num-item2>.</num-item2><num-item3>5</num-item3>
        <num-item4>Libraries:</num-item4>
      </num-cont>
      The C++ standard libraries collection is very large, perhaps overwhelming.
      Many of us are quite familiar with a small subset, and browse through the
      rest when we need some functionality that could be there.
      <spacer-15></spacer-15>
      <indent-blocks>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
              standard C++ libraries
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
            <defn-body>
              I&apos;ve enumerated here a lot of the libraries and some of their contents in order
              to support your browsing process.
            </defn-body>
            <defn-body class="defnBorderTop">
              This material was drawn from resources provided by
              <a href="https://en.cppreference.com/w/cpp">cppreference.com</a>.<br />
              Only the organization has been changed (slightly) and a few of the more
              obscure libraries omitted.  I&apos;ve annotated the material and emphasized
              those libraries I use frequently.  You will see most of them in examples
              throughout this story.
            </defn-body>
            <defn-body class="defnBorderTop">
              Here are some categories:
              <ol class="indent">
                <li>
                  Language Support libraries
                  <ul class="tight">
                    <li>
                      <span class="notice">&lt;initializer_list&gt;</span> - supports uniform initialization for user-defined types,
                      examples in Chapter 2.
                    </li>
                    <li>
                      <span class="notice">&lt;type_traits&gt;</span> - used for template metadata programming, examples in Chapter 3.
                    </li>
                    <li>&lt;limits&gt; - Numeric limits</li>
                    <li>&lt;cstdlib&gt; - Managing OS Processes and Signals</li>
                  </ul>
                </li>
                <li>
                  General Utilities libraries
                  <ul class="tight">
                    <li><span class="notice">&lt;memory&gt;</span> - Smart pointers and allocators, examples in Chapter 4</li>
                    <li>&lt;chrono&gt; - Time durations, times, and dates</li>
                    <li>
                      Function objects and qualilfiers:
                      <indent-block>
                        <div>
                          <span class="notice">&lt;functional&gt;</span> - function, mem_fn, bind, invoke, ref
                        </div>
                        <div>
                          <span class="notice">&lt;utility&gt;</span> - move, forward, pair, tuple, examples in Chapters 2 and 3
                        </div>
                        <span class="notice">&lt;tuple&gt;</span> - examples in Chapters 1 and 2
                      </indent-block>
                    </li>
                    <li>&lt;charconv&gt; - to_chars, from_chars, chars_format</li>
                    <li><span class="notice">&lt;optional&gt;</span> - return instance or empty</li>
                    <li><span class="notice">&lt;any&gt;</span> - holds instance of almost any type, example in Chapter 4</li>
                    <li>&lt;variant&gt; - holds instances of any specified set of types</li>
                  </ul>
                </li>
                <li>
                  <span class="notice">&lt;string&gt;</span> - std::basic_string --> std::string, std::wstring
                </li>
                <li>
                  Containers libraries:
                  <indent-block>
                    &lt;array&gt;, &lt;deque&gt;, &lt;list&gt;, &lt;map&gt;,
                    &lt;multimap&gt; &lt;multiset&gt;
                    &lt;queue&gt;,
                    &lt;set&gt;, &lt;singleList&gt;, &lt;stack&gt;, <span class="notice">&lt;string&gt;</span>,
                    <span class="notice">&lt;unordered_map&gt;</span>,
                    &lt;unordered_multimap&gt;, &lt;unordered_multiset&gt;,
                    &lt;unordered_set&gt;, <span class="notice">&lt;vector&gt;</span>
                  </indent-block>
                </li>
                <li>
                  &lt;algorithm&gt; - Algorithms library
                  <spacer-10></spacer-10>
                  <indent-block>
                    Non-modifying sequence operations:
                    <background-block class="indent">
                      all_of, any_of, none_of, for_each, for_each_n, count, count_if,
                      mismatch, find, find_if, find_if_not, find_end, find_first_of,
                      adjacent_find, search, search_n
                    </background-block>
                    Modifying sequence operations:
                    <background-block class="indent">
                      copy, copy_if, copy_n, copy_backward,
                      move, move_backward, fill, fill_n, transform, generate, generate_n,
                      remove, remove_if, remove_copy, remove_copy_if, replace, replace_if,
                      replace_copy, replace_copy_if, swap, swap_ranges, iter_swap,
                      reverse, reverse_copy, rotate, shift_left, shift_right,
                      random_shuffle, shuffle, sample, unique, unique_copy
                    </background-block>
                    Partitioning operations:
                    <background-block class="indent">
                      is_partitioned, partition, partition_copy, stable_partition, partition_point
                    </background-block>
                    Sorting operations:
                    <background-block class="indent">
                      is_sorted, is_sorted_until, sort, partial_sort, stable_sort, nth_element
                    </background-block>
                    Binary search on sorted ranges:
                    <background-block class="indent">
                      lower_bound, upper_bound, binary_search, equal_range
                    </background-block>
                    Other operations on sorted ranges:
                    <background-block class="indent">
                      merge, inplace_merge
                    </background-block>
                    Set operations on sorted ranges:
                    <background-block class="indent">
                      includes, set_differences, set_intersection, set_symmetric_distance, set_union
                    </background-block>
                    Heap operations:
                    <background-block class="indent">
                      is_heap, is_heap_until, make_heap, push_heap, pop_heap, sort_heap
                    </background-block>
                    Min/Max operations:
                    <background-block class="indent">
                      max, max_element, min, min_element, minmax, minmax_element, clamp
                    </background-block>
                    Comparison operations:
                    <background-block class="indent">
                      equal, lexicographical_compare, lexicographical_compare_three_way
                    </background-block>
                    Permutation operations:
                    <background-block class="indent">
                      is_permutation, next_permutation, prev_permutation
                    </background-block>
                    Numeric operations:
                    <background-block class="indent">
                      iota, accumulate, inner_product, adjacent_difference, partial_sum,
                      reduce, exclusive_scan, inclusive_scan, transform_reduce,
                      transform_exclusive_scan, transform_inclusive_scan
                    </background-block>
                  </indent-block>
                </li>
                <li>
                  Numerics libraries
                  <ul class="tight">
                    <li>
                      &lt;cstdlib&gt;, &lt;cmath&gt; - Common math functions
                    </li>
                    <li>&lt;cmath&gt; - Special math functions</li>
                    <li>&lt;numeric&gt;, &lt;cmath&gt; - Numeric algorithms</li>
                    <li>&lt;random&gt;, &lt;cstdlib&gt; - Pseudo-random number generators</li>
                    <li>&lt;cfenv&gt; - Floating-point environment</li>
                    <li>&lt;complex&gt; - Complex numbers, operations</li>
                  </ul>
                </li>
                <li>
                  Input/Output libraries:
                  <ul class="tightList">
                    <li>
                      Terminal I/O:
                      <background-block class="indent">
                        <span class="notice">
                          &lt;ios&gt;, &lt;streambuf&gt;, &lt;ostream&gt;, &lt;istream&gt;,
                          &lt;iostream&gt;
                        </span>
                      </background-block>
                    </li>
                    <li>
                      File I/O:
                      <background-block class="indent">
                        <span class="notice">&lt;fstream&gt;</span>
                      </background-block>
                    </li>
                    <li>
                      String I/O:
                      <background-block class="indent">
                        <span class="notice">&lt;sstream&gt;</span>
                      </background-block>
                    </li>
                    <li>
                      Synchronized I/O:
                      <background-block class="indent">
                        &lt;syncstream&gt;
                      </background-block>
                    </li>
                    <li>
                      I/O manipulators:
                      <background-block class="indent">
                        <scan class="notice">&lt;iomanip&gt;</scan>
                      </background-block>
                    </li>
                  </ul>
                </li>
                <li>
                  <span class="notice">&lt;regex&gt;</span> - Regular Expressions library
                </li>
                <li>
                  Thread Support libraries:
                  <div>
                    C++17:
                    <background-block class="indent">
                      <span class="notice">
                        &lt;thread&gt;, &lt;mutex&gt;, &lt;shared_mutex&gt;,
                        &lt;condition_variable&gt;, &lt;future&gt;, &lt;atomic&gt;
                      </span>
                    </background-block>
                    C++20:
                    <background-block class="indent">
                      &lt;semiphore&gt;, &lt;latch&gt;, &lt;stop_token&gt;

                    </background-block>
                  </div>
                </li>
                <li>
                  <span class="notice">&lt;filesystem&gt;</span> - Filesystem library
                </li>
                <li>
                  Error Handling libraries:
                  <background-block class="indent">
                    <span class="notice">&lt;exception&gt;</span>, &lt;stdexcept&gt;, &lt;cerrno&gt;, &lt;cassert&gt;
                    &lt;system_error&gt;
                  </background-block>
                </li>
                <li>
                  Other libraries
                  <ul class="tight">
                    <li>Localizations</li>
                    <li>Iterators</li>
                    <li>Concepts (C++20)</li>
                    <li>Named Requirements (C++20)</li>
                    <li>Ranges (C++20)</li>
                  </ul>
                </li>
              </ol>
            </defn-body>
            </defn-block>
          </details>
        </indent-block>
      </indent-blocks>
      <indent-blocks>
      <indent-block class="pad10">
        <details>
          <summary class="labelStyle darkItem">
            Example:&nbsp;&nbsp;Display container contents using std::vector, std::for_each, and a lambda
          </summary>
          <spacer-10></spacer-10>
          <defn-block>
          <defn-body class="pad10">
      Here&apos;s an example using the STL vector container and for_each algorithm with lambda fold:
            <div style="width:max-content;">
      <pre><c-s>  std::vector&lt;int&gt; test{ 
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 
  };  
  
  size_t N = 4;
  
  auto fold = [N](auto t) {
    static size_t count = UINT_MAX - 1;
    if (++count > N) {
      count = 1;
      std::cout << "\n  ";
    }
    std::cout << t << " ";
  };

  std::for_each(test.begin(), test.end(), fold);
        </c-s>
</pre>
      with output:<pre><c-s>  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16  
  17</c-s></pre>
              </div>
          </defn-body>
          </defn-block>
        </details>
      </indent-block>
      </indent-blocks>
      <spacer-15></spacer-15>
      The standard library collection is very large, but still there are a few surprising
      omissions. Until C++17 there was no filesystem library and there still is no support
      for:
      <ul style="margin-top:10px; margin-bottom:10px;">
        <li style="padding-bottom:2px;">Network programming and inter-process communication</li>
        <li style="padding-bottom:2px;">Processing XML or JSON data formats</li>
        <li>Building Graphical User Interfaces</li>
      </ul>
      However, building these is not too difficult using platform APIs and/or third party libraries, especially
      the extensive <a href="https://Boost.org">Boost</a> library.
      <spacer-10></spacer-10>
      <indent-blocks>
        <indent-block class="pad10">
          <details>
            <summary class="labelStyle lightItem">
              custom libraries
            </summary>
            <spacer-10></spacer-10>
            <defn-block>
            <defn-body class="pad10">
              Libraries, written entirely in C++, using platform APIs as necessary,
              that fill in some omissions from the standard C++ library.
              <table class="lightItem" style="margin:20px 30px;">
                <tr>
                  <th class="darkItem">Library</th>
                  <th class="darkItem">Description</th>
                </tr>
                <tr>
                  <td>FileSystem</td>
                  <td>
                    Provides interfaces used by many of the applications in code repositories
                    in this site.  It was developed using Windows and Linux platform APIs.
                    I plan to turn this into a wrapper for the std::filesystem which provides
                    a different set of interfaces, incompatible with the existing applications.
                    <spacer-10></spacer-10>
                    <a href="FileSystem.html">FileSystem.html</a>
                  </td>
                </tr>
                <tr>
                  <td>XmlDocument</td>
                  <td>
                    A fairly complete processing library for reading, parsing, building,
                    and writing XML to and from strings and files.
                    <spacer-10></spacer-10>
                    <a href="XmlDocument.html">XmlDocument.html</a>
                  </td>
                </tr>
                <tr>
                  <td>CppCommWithFileXfer</td>
                  <td>
                    Supports asynchronous message-passing communication between multiple
                    endpoints, using the Sockets library, below.
                    <spacer-10></spacer-10>
                    <a href="CppCommWithFileXfer.html">CppCommWithFileXfer.html</a>
                  </td>
                </tr>
                <tr>
                  <td>Sockets</td>
                  <td>
                    A sockets class hierarchy that handles IP4 and IP6 protocols
                    for stream-based sockets.  The library has versions for both Windows
                    and Linux.
                    <spacer-10></spacer-10>
                    <a href="Sockets.html">Sockets.html</a>
                  </td>
                </tr>
                <tr>
                  <td>CppParser</td>
                  <td>
                    A rule based parser suitable for analyzing C, C++, C#, and Java.
                    <spacer-10></spacer-10>
                    <a href="BlogParser.html">Parsing Blog</a>,
                    <a href="CppParser.html">CppParser Repository</a>,
                    <a href="CppLexicalScanner.html">CppLexicalScanner.html</a>
                  </td>
                </tr>
              </table>
              <spacer-15></spacer-15>
           </defn-body>
            </defn-block>
          </details>
        </indent-block>
      </indent-blocks>
    </indent-blocks>
    <spacer-15></spacer-15>
    This completes our survey of the C++ programming language.  We will be expanding on each
    of these topics: 
    <indent-block class="pad10">
      <span class="notice">Data, Operations, Classes, Templates, and Libraries</span>
    </indent-block>
    in the following chapters of this story, with lots of discussion and code examples,
    and a few videos here and there.
    <hr class="spread" />
    <h3>References:</h3>
    <indent-block>
      <a href="https://cppreference.com">cppreference.com</a><br />
      <a href="https://cpppatterns.com/">cpppatterns.com</a><br />
      <a href="https://www.fluentcpp.com/posts/">Posts on Fluent C++</a><br />
      <a href="https://www.youtube.com/playlist?list=PLs3KjaCtOwSZ2tbuV1hx8Xz-rFZTan2J1">C++ weekly videos</a><br /> 
      <a href="https://riptutorial.com/cplusplus">riptutorial - documentation provided by StackOverFlow</a><br />
      <a href="https://www.mycplus.com/category/tutorials/cplusplus-programming-tutorials/">mycplus.com tutorials</a>
      <a href="https://github.com/boostcon/cppnow_presentations_2018">cppnow 2018</a><br />
      <a href="https://www.youtube.com/watch?v=I52uPJSoAT4">Declarative Style in C++</a><br />
    </indent-block>

  </bb-55>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>