<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_Operations.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Story-Operations</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    #github .pad10-15 {
      padding: 10px 15px;
    }

    #github .codeStyle {
      overflow: hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github .labelStyle {
      font-family: sans-serif;
      /*font-weight:bold;*/
      font-size: 1.0em;
    }

    #github .normal {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github summary {
      padding: 3px 0px 5px 0px;
      font-weight: bold;
      width: max-content;
    }

      #github summary ~ div {
        width: max-content;
        max-width: 95%;
      }

      #github summary ~ indent-block {
        width: max-content;
        max-width: 95%;
        padding-left: 20px;
        padding-right: 20px;
        /*background-color: #eee;*/
      }

    #github photosizer-block {
      position: relative;
      z-index: 2;
      background-color: white;
    }

    #github comment-block {
      width: max-content;
      max-width: 95%;
      padding: 10px 15px;
      background-color: #eee;
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github c-s {
      overflow: hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github t-s {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github .notice {
      font-size: 1.1em;
      font-weight: bolder;
      font-style: italic;
      font-family: Consolas, sans-serif;
      border: none;
      color: darkred;
    }

    #github background-block {
      display: block;
      background-color: #ddd;
      max-width: 90%;
      width: max-content;
      padding: 10px 15px;
    }

    #github .footnote {
      font-size: 0.85em;
    }

    #github ol.footnote li {
      padding-bottom: 0px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Classes.html">N</a>
  <a id="Prev" href="CppStory_Data.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #3 - C++ Operations</h1>
      <h3 id="subtitle">callable objects</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <indent-block>
    <h3>Operations:</h3>
    In this chapter we focus on ways that operations on data are implemented.
    <hr class="spreadup" />
    <h3>Type Coercions:</h3>
    The fundamental C++ types support coercions between selected types.
    <indent-block class="pad10">
      <defn-block>
        <defn-head>
          Type Coercion
        </defn-head>
        <defn-body class="pad10">
          Coercion is the conversion of the representation of a value in one type
          into the representation of the value in another type. For example when the
          statements below are executed: 
          <indent-block class="pad10">
            <c-s>
              int i{ 5 };<br />
              double d = i; 
            </c-s>
          </indent-block>
          the value of <c-s>i</c-s>, e.g., <c-s>5</c-s>, is converted to the corresponding double precision 
          representation with sign bit, exponent, and fractional part.
          <spacer-15></spacer-15>
          For the fundamental types, any time the conversion source has the same or smaller size than
          the destination, the conversion will succeed, silently.  These are called numeric promotions or widening.
          <spacer-15></spacer-15>
          If the conversion has source type larger than destination type the conversion may or may not
          succeed.  These are called numeric conversions or narrowing.
        </defn-body>
        <defn-example class="pad10">
          <t-s>Here are some examples of numeric promotions:</t-s>
          <indent-block class="pad10">
            long int li{ 5 };<br />
            int i = short int{ 2 };<br />
            long long int {2L}<br />
            double d{ 3.0F };
          </indent-block>
          <t-s>and here are examples of numeric conversions:</t-s>
          <indent-block class="pad10">
            int j = 2.5; &nbsp;&nbsp;// succeeds with warning, truncates <c-s>2.5</c-s> to <c-s>2</c-s><br />
            int j{ 2.5 };  &nbsp;// compile failure (see initialization section of Chapter 2)<br />
            float f = 1.5; // succeeds with warning
          </indent-block>
          <div class="pad10">
            The suffixes L and F denote long int and float.  Suffix LL denotes a long long int.
            If there are no suffixes an integral number has the type int and a floating point
            number has the type double.
          </div>
        </defn-example>
      </defn-block>
      <spacer-15></spacer-15>
      Coercions can be implemented for user-defined types using promotion constructors 
      and cast operators.  We will cover that below, and in detail in Chapter 4.
    </indent-block>
    <h3>Functions:</h3>
    Functions have a name, a sequence of zero or more arguments, and a return type or void return,
    wrapped around a block of code.
    <spacer-10></spacer-10>
    <indent-block class="background-block">
      <c-s>
        void putline(size_t n = 1) {<br />
        &nbsp;&nbsp;for(size_t i = 0; i &lt; n; ++i)<br />
        &nbsp;&nbsp;&nbsp;&nbsp;std::cout << "\n";<br />
        }
      </c-s>
    </indent-block>
    <spacer-10></spacer-10>
    They may have default arguments, as shown in this example, so calling <c-s>putline()</c-s>
    results in a single new line being pushed into the terminal stream.
    <spacer-15></spacer-15>
    functions can only be defined at namespace scope or class or struct scope.  They cannot be
    defined within function scope.  That means that C++ does not support inner functions.  When
    defined in class or struct scope they are said to be methods of the class or struct.
    <spacer-15></spacer-15>
    For the remainder of this story, we use the term method for any function defined in class
    or struct scope.  All functions defined at namespace scope will simply be referred to
    as functions.  If there is a possible ambiguity, we will use the qualifier global or unbound
    to indicate that they are not methods.  So, putline is a global function.
    The name of a function is just a pointer to its code. 
    <spacer-15></spacer-15>
    Each function should have a single responsibility and be small and simple enough to make
    it (relatively) easy to understand and test.  A good default size is 50 lines of code - that
    can fit on a single page, so we can quickly see all the parts.
    <spacer-15></spacer-15>
    One measure of complexity that I use is a count of all scopes within a function body.  
    That is simply 1 + the count of all the open braces &quot;{&quot; inside
    the body<sup>1</sup>, but does&apos;t count the complexity of functions that are called. Those we can
    think about some other time. I use a complexity measure, CM = 10 (scopes) as an upper limit for my own
    code, and try to make most functions have CM &lt;= 5.
    <hr class="spreadup" />
    <indent-blocks class="footnote">
      <ol>
        <li>
          This complexity measure is closely related to the McCabe Cyclomatic Complexity metric.
          That has been discredited in an often quoted article in the academic literature.
          However, I believe that research was flawed - the metric values were correlated with change
          metrics and found to be weakly correlated.  The authors concluded that Cyclomatic
          Complexity was therefore of little value.  However, they didn&apos;t account for the
          fact that developers are very reluctant to change complex code because it is so hard
          to accomplish without introducing new errors. I contend that this result demonstrates
          the usefulness of the metric.  In many years of developing code, I&apos;ve found it
          to be very useful. Functions that have high complexity, by this measure, are very hard
          to understand and test.
        </li>
      </ol>
    </indent-blocks>

    <h3>Function Pointers:</h3>
    Function pointers are used to:
    <spacer-10></spacer-10>
    <ul class="tight">
      <li>create callbacks</li>
      <li>pass processing to platform API functions</li>
      <li>
        modify the way library functions operate, e.g., qsort accepts a comparator function pointer
      </li>
      <li>pass processing to plug-in interfaces</li>
    </ul>
    <spacer-10></spacer-10>
    These kinds of applications can be built without using function pointers, but when using existing
    frameworks, it&apos;s likely that you may need them. 
    <spacer-15></spacer-15>
    Function pointers can bind to any function as long as its return type and parameter types
    match the function pointer declaration.  We show how that is done below, for both specific
    and generic function pointer declarations. The syntax is a bit complicated, so
    we&apos;ve shown several cases.
    <spacer-25></spacer-25>
    <indent-block>
      <defn-block>
        <defn-head class="pad10">
          Here&apos;s how you declare, define, and use specific function pointers:
        </defn-head>
        <defn-body>
    <pre><c-s><t-s>   For the function:</t-s>

     void putLine(size_t n = 1) {
        for (size_t i = 0; i < n; ++i)
        std::cout << "\n";
     }

  <t-s>Define a function pointer for that specific signature:</t-s>

     using FP1 = void(*)(size_t n);&nbsp;&nbsp;// function pointer type
     FP1 pl1 = putLine;
     pl1(1);  // push single newline to terminal

  <t-s>You can define a function pointer more directly using auto</t-s>
  
     auto& pl2 = putLine;
     pl2(2);  // push two newlines to the terminal

</c-s></pre>
      </defn-body>
      <defn-head class="pad10">
        And here&apos;s how you make them generic:
      </defn-head>
      <defn-body>
<pre><c-s>  <t-s>For the functions:</t-s>

     size_t size(const std::string& s) {
        return s.size();
     }
  
     template <typename T>
     void message(T t) {
        std::cout << t;
     }

  <t-s>Declare a generic function pointer type</t-s>
  
     template&lt;class Tr, Ta&gt;
     using FP2 = Tr(*)(Ta t);

  <t-s>and instantiate it for the second and third test functions:</t-s>

     FP2&lt;size_t, const std::string&&gt; pSz = size;
     size_t sz = pSz("a test string");

     FP2&lt;void, const std::string&&gt; msg1 = message;
     msg1("\n  a test message");

  You can also define function pointers in a generic way using auto   

     auto& msg2 = message&lt;const std::string&&gt;
     msg2("\n  another test message");

     auto& msg3 = message&lt;const char*&gt;
     msg3("\n  still another test message!");
   
     auto& pSz2 = size;
     msg2(
        "\n  size of \"another, somewhat longer, string\" = " + 
        std::to_string(sz)
     );
      </c-s></pre>
        </defn-body>
      </defn-block>
    </indent-block>
    <!--That can be demonstrated by 
    declaring function pointers and setting them equal to a function name, then invoking
    them.  That&apos;s illustrated in this example:
    <spacer-10></spacer-10>
    <indent-block>
      <details>
        <summary>
          <span class="labelStyle darkItem">
            function pointer example
          </span>
        </summary>
        <spacer-10></spacer-10>
    <indent-block class="background-block">
<pre><c-s>  // Functions.cpp

  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include "../Display/Display.h"

  /* test functions */

  void putLine(size_t n = 1) {
    for (size_t i = 0; i &lt; n; ++i)
      std::cout &lt;&lt; "\n";
  }

  size_t size(const std::string&amp; s) {
    return s.size();
  }

  template &lt;typename T&gt;
  void message(T t) {
    std::cout &lt;&lt; t;
  }

  /* defining function pointers */

  /* templates must be declared at namespace scope */

  /* #1 function pointer declaration - creates generic fun ptr type */

  template&lt;class Tr, class Ta&gt;
  using FP2 = Tr(*)(Ta t);

  void demoFunctionPointers() {

    displayDemo("--- demoFunctionPointers ---");
    putLine();

    /* #2 function pointer declaration - creates */
    /*    pointer to specific function signature */

    using FP1 = void(*)(size_t n);

    /* declaring function pointers with initialization */

    FP1 pl1 = putLine;
    FP2&lt;void, size_t&gt; pl2 = putLine;
    FP2&lt;size_t, const std::string&amp;&gt; pSz = size;
    FP2&lt;void, const std::string&amp;&gt; msg1 = message;
  
    /* can also define function pointers using auto */

    auto&amp; pl3 = putLine;
    auto&amp; msg2 = message&lt;const std::string&amp;&gt;;
    auto&amp; msg3 = message&lt;const char*&gt;;

    /* test code */

    message("\n ------------------------");
    msg1("\n  testing PL1");
    pl1(1);
    msg2("\n  testing PL2");
    pl2(1);
    size_t sz = pSz("this is a string");
    msg2("\n  size of \"this is a string\" = " + std::to_string(sz));
    msg3("\n --------------");
    message("\n  done with testing");
    message("\n ------------------------\n");
  }

  int main() {
    demoFunctionPointers();
    putline(2);
  }</c-s></pre>      </details>
    </indent-block>-->
    <h3>Methods:</h3>
    Functions bound to classes and structs are called methods.  Methods have access to all the
    member data of the class.  If a class inherits from one or more base classes, it inherits all 
    the methods and data members of its base classes, and has access to any of that qualified as 
    &quot;public: or protected:&quot; for methods and qualified as &quot;protected:&quot; for
    data. 
    <spacer-15></spacer-15>
    <div class="indent" style="display:flex;">
      <defn-block>
        <defn-head>
          Base class
        </defn-head>
        <defn-body>
          <pre>
<c-s>  class B {
  public:
    void name(const std::string&amp; aname) {
      name_ = aname;
    }
    std::string name() {
      return name_;
    }
  protected:
    std::string name_;
  };
</c-s></pre>
        </defn-body>
      </defn-block>
      <defn-block>
        <defn-head>
          Derived class
        </defn-head>
        <defn-body>
          <pre><c-s>  class D : public B {
  public:
    void occupation(const std::string&amp; occup) {
      occupation_ = occup;
    }
    std::string occupation() {
      return ocupation_;
    }
  private:
    std::string occupation_;
  };
</c-s></pre>
        </defn-body>
      </defn-block>
    </div>
    <spacer-25></spacer-25>
    The class D, in the block above, has public methods:
    <ul class="tight">
      <li>
        <c-s>void name(const std::string&amp; aname)</c-s>
      </li>
      <li>
        <c-s>std::string name()</c-s>
      </li>
      <li>
        <c-s>void occupation(const std::string&amp;; occup)</c-s>
      </li>
      <li>
        <c-s>std::string occupation()</c-s>
      </li>
    </ul>
    <spacer-15></spacer-15>
    The two name methods it inherited from B and those are accessible to clients. It implemented
    the two occupation methods and those are also accessible to clients.
    <spacer-15></spacer-15>
    The derived class D not only contains its occupation_ string, but it also contains the
    Base::name_ string, inside an image of B that is part of its memory footprint.  We will 
    demonstrate that in the next chapter3 classes.

    <h3>Method Pointers:</h3>
    Method pointers have the same uses as function pointers.  They have an advantage that
    they can use member data from the invoking instance.
    Method pointers can be bound to any method of the specified type provided that the
    function arguments and return value match the method pointer declaraton.
    <spacer-25></spacer-25>
    <indent-block>
      <defn-block>
        <defn-head class="pad10">
          Here&apos;s how you declare, define, and use specific method pointers:<br />
          -- all the cases are included because syntax is a bit complex --
        </defn-head>
        <defn-body>
    <pre><c-s><t-s>   Using classes B and D defined above:</t-s>

  /* accessing inherited overloaded methods name */

  using FP1 = void(D::B::*)(const std::string&);
  FP1 pNameSetter = &D::B::name;
  D d;
  (d.*pNameSetter)("Tom");

  using FP2 = std::string(D::B::*)();
  FP2 pNameGetter = &D::B::name;
  std::string name = (d.*pNameGetter)();
  std::cout << "\n  d1.name() --> " << name;

  /* accessing overloaded methods occupation in D */

  using FP3 = void(D::*)(const std::string&);
  FP3 pOccupSetter = &D::occupation;
  (d.*pOccupSetter)("derivatives analyst");

  using FP4 = std::string(D::*)();
  FP4 pOccupGetter = &D::occupation;
  std::string myJob = (d.*pOccupGetter)();
  std::cout << "\n  d1.Occupation() -- > " << myJob;

  /* std::invoke */

  <t-s>using</t-s> std::invoke with a method pointer:

  std::invoke(pNameSetter, d, "Darth Vader");
  std::string darth = std::invoke(pNameGetter, d);
  std::cout << "\n  his name is " << darth;

  /*-- alternate definitions --*/

  auto pOccuSetter2 = static_cast&lt;std::string(D::*)()&gt;(&D::occupation);
  auto pOccuGetter2 = static_cast&lt;void(D::*)(const std::string&)&gt;(&D::occupation);  

  std::string(D:: * pOccuGetter3)() = &D::occupation;
  void(D:: * pOccuSetter3)(const std::string&) = &D::occupation;

      </c-s></pre>
        </defn-body>
        <defn-head class="pad10">
          Here&apos;s the output:
        </defn-head>
        <defn-body>
          <pre><c-s>  d1.name() --> Tom
  d1.Occupation() -- > derivatives analyst
  his name is Darth Vader
</c-s></pre>
        </defn-body>
      </defn-block>
    </indent-block>
    <spacer-15></spacer-15>
    <h3>Functors:</h3>
    Functors are instances of classes that implement operator() so they can be invoked.
    In modern frameworks they often take the place of function pointers, e.g., used for
    callbacks and to inject processing into some other class&apos;s instance.
    <spacer-25></spacer-25>
    <indent-block>
      <defn-block>
        <defn-head class="pad10">
          Functors
        </defn-head>
        <defn-body>
            <pre><c-s>  class Functor {
  public:
    template<typename T>
    void operator()(T element) {
      ++count_;
      std::cout << "\n  " << element;
    }
    size_t count() {
      return count_;
    }
    void name(const std::string& nm) {
      name_ = nm;
    }
    std::string name() {
      return name_;
    }
  private:
    std::string name_;
    size_t count_ = 0;
  };
            </c-s></pre>
          </defn-body>
        <defn-head class="pad10">
          Using functor:
        </defn-head>
        <defn-body>
          <pre><c-s>  Functor fun;
  fun.name("counter");

  std::vector<std::string> numbers{ "one", "two", "three", "four", "five" };  

  /* std::for_each invokes fun on each element in numbers  */
  /* it then returns a copy of fun to be interrogated later */

  fun = std::for_each(numbers.begin(), numbers.end(), fun);

  std::cout << "\n  " << fun.name() << " processed " 
            << fun.count() << " elements";  
</c-s></pre>
        </defn-body>
        <defn-head class="pad10">
          Output:
        </defn-head>
        <defn-body>
          <pre><c-s>  one
  two
  three
  four
  five
  counter processed 5 elements
            </c-s></pre>
        </defn-body>
      </defn-block>
    </indent-block>
    <spacer-15></spacer-15>
    <h3>Lambdas:</h3>
    <h3>Callable Objects:</h3>
    <h3>Standard Invoke:</h3>
    <h3>Testing:</h3>
    <h3>STL Algorithms:</h3>
    <indent-blocks>
    </indent-blocks>
    <spacer-25></spacer-25>
    <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

    <info-bar></info-bar>
</body>
</html></html>