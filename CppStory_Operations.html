<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_Operations.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>C++ Story-Operations</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    #github .pad10-15 {
      padding: 10px 15px;
    }

    #github .codeStyle {
      overflow: hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github .labelStyle {
      font-family: sans-serif;
      /*font-weight:bold;*/
      font-size: 1.0em;
    }

    #github .normal {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github summary {
      padding: 3px 0px 5px 0px;
      font-weight: bold;
      width: max-content;
    }

      #github summary ~ div {
        width: max-content;
        max-width: 95%;
      }

      #github summary ~ indent-block {
        width: max-content;
        max-width: 95%;
        padding-left: 20px;
        padding-right: 20px;
        /*background-color: #eee;*/
      }

    #github photosizer-block {
      position: relative;
      z-index: 2;
      background-color: white;
    }

    #github comment-block {
      width: max-content;
      max-width: 95%;
      padding: 10px 15px;
      background-color: #eee;
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github c-s {
      overflow: hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github t-s {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github .notice {
      font-size: 1.1em;
      font-weight: bolder;
      font-style: italic;
      font-family: Consolas, sans-serif;
      border: none;
      color: darkred;
    }

    #github background-block {
      display: block;
      background-color: #ddd;
      max-width: 90%;
      width: max-content;
      padding: 10px 15px;
    }

    #github .footnote {
      font-size: 0.85em;
    }

    #github ol.footnote li {
      padding-bottom: 0px;
    }
    #github .container1 {
      display: grid;
      grid-template-columns: auto 18em 1fr;
      padding: 0.0em;
      margin: 0em 0.25em 1em 0.25em;
      /*border: 2px solid darkred;*/
    }

    #github .container2 {
      display: grid;
      grid-template-columns: auto 20em 1fr;
      padding: 0.0em;
      margin: 0em 0.25em 1em 0.25em;
      /*border: 2px solid darkred;*/
    }

    #github .container3 {
      display: grid;
      grid-template-columns: auto 1fr;
      padding: 0.0em;
      margin: 0em 0.25em 1em 0.25em;
      max-width:100%;
      /*border: 2px solid darkred;*/
    }

    #github .item1 {
      grid-column: 1;
      padding: 0.2em 1em;
      border: 2px solid darkred;
      border-bottom:none;
      overflow-x:auto;
    }

    #github .item2 {
      grid-column: 2;
      padding: 0.2em 1em;
      border: 2px solid darkred;
      border-left:none;
      border-bottom:none;
    }

    #github .item3 {
      grid-column: 3;
      padding: 0.2em 1em;
      border: 2px solid darkred;
      border-left:none;
      border-bottom:none;
    }

    #github .header {
      background-color:darkred;
      color:#fefefa;
    }

  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Classes.html">N</a>
  <a id="Prev" href="CppStory_Data.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #3 - C++ Operations</h1>
      <h3 id="subtitle">functions, methods, functors, lambdas, and callable objects</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <indent-blocks>
    <!--<h3>Operations:</h3>-->
    <num-cont>
      <num-item1>3.0</num-item1>
      <num-item4>Operations</num-item4>
    </num-cont>
    In this chapter we focus on ways that C++ data operations are implemented and tested.  The content applies to almost everything
    you implement with C++.  Getting familiar with these topics will make it easier to digest discussions of classes and templates
    in succeeding chapters.
    <hr class="spreadup" />
    <!--<h3>Type Coercions:</h3>-->
    <num-cont>
      <num-item1>3</num-item1><num-item2>.</num-item2><num-item3>1</num-item3>
      <num-item4>Type Coercions:</num-item4>
    </num-cont>
    The fundamental C++ types support coercions between selected types.
    <div class="pad10">
      <defn-block>
        <defn-head>
          Type Coercion
        </defn-head>
        <defn-body class="pad10">
          Coercion is the conversion of the representation of a value in one type
          into the representation of the value in another type. For example when the
          statements below are executed: 
          <indent-block class="pad10">
            <c-s>
              int i{ 5 };<br />
              double d = i; 
            </c-s>
          </indent-block>
          the value of <c-s>i</c-s>, e.g., <c-s>5</c-s>, is converted to the corresponding double precision 
          representation with sign bit, exponent, and fractional part.
          <spacer-15></spacer-15>
          For the fundamental types, any time the conversion source has the same or smaller size than
          the destination, the conversion will succeed, silently.  These are called numeric promotions or widening.
          <spacer-15></spacer-15>
          If the conversion has source type larger than destination type the conversion may or may not
          succeed.  These are called numeric conversions or narrowing.
        </defn-body>
        <defn-example class="pad10"><c-s>
          <t-s>Here are some examples of numeric promotions:</t-s>
          <indent-block class="pad10">
            long int li{ 5 };<br />
            int i = short int{ 2 };<br />
            long long int {2L}<br />
            double d{ 3.0F };
          </indent-block></c-s>
          <t-s>and here are examples of numeric conversions:</t-s><c-s>
          <indent-block class="pad10">
            int j = 2.5; &nbsp;&nbsp;// succeeds with warning, truncates <c-s>2.5</c-s> to <c-s>2</c-s><br />
            int j{ 2.5 };  &nbsp;// compile failure (see initialization section of Chapter 2)<br />
            float f = 1.5; // succeeds with warning
          </indent-block></c-s>
          <div class="pad10">
            The suffixes <c-s>L</c-s> and <c-s>F</c-s> denote <c-s>long int <t-s>and</t-s> float</c-s>.  
            Suffix <c-s>LL</c-s> denotes a <c-s>long long int</c-s>.
            If there are no suffixes an integral number has the type <c-s>int</c-s> and a floating point
            number has the type <c-s>double</c-s>.
          </div>
        </defn-example>
      </defn-block>
    </div>
    <spacer-15></spacer-15>
    Coercions can be implemented for user-defined types using promotion constructors 
    and cast operators.  We will cover that in detail in Chapter 4.
    <spacer-10></spacer-10>

    <hr class="spread" />
    <num-cont>
      <num-item1>3.2</num-item1><num-item4>Copy Contruction Operations</num-item4>
    </num-cont>
    Copy construction creates a new instance of some specified type and initializes with the state of an existing instance of the
    same type.  Here, we show copy construction syntax for double, a fundamental type, and struct.
    <spacer-15></spacer-15>
    <defn-block>
      <defn-head class="notice" style="border:2px solid darkred;">
        Copy construction:
      </defn-head>
      <defn-code>
  double d1 { 3.15149 };  
  double d2 { d1 };      // C++14 copy construction syntax - preferred
  double d2 = { d1 };    // alternate C++14 copy construction syntax - no assignment
  double d2 = d1;        // C++98 copy construction syntax - no assignment
  double d2(d1);         // C++98 copy construction syntax
      </defn-code>
      <defn-head style="border-top:none;">
        Copy construction of structs
      </defn-head>
      <defn-code style="border-top:2px solid darkred;">
  displayDemo("--- demo copy construct struct ---");
  struct S { int i; double d; char c; int iArr[3]; };
  S s1{ 1, 1.0 / 3.0, 'Q', { 1, 2, 3 } };
  S s2{ s1 };  // copy construction
  showStruct(s1, "src");
  showStruct(s2, "cpy");
      </defn-code>
      <defn-head style="border-top:none;">
        Output:
      </defn-head>
      <defn-code style="border-top:2px solid darkred;">
  src struct: { 1, 0.333333, Q, [ 1 2 3 ] }
  cpy struct: { 1, 0.333333, Q, [ 1 2 3 ] }
      </defn-code>
    </defn-block>
    <spacer-25></spacer-25>
    Note that for structs and classes, if no copy constructor is defined the compiler will generate one
    that does member-wise copy operations.  It is a pleasant suprise that works for arrays as well as the fundamental
    types illustrated.  I suspect that the compiler does a memcpy on the contiguous array memory to affect that copy.
    Compiler generated operations will be discussed in detail in Chapter #4 - classes.
    <hr class="spread" />
    <num-cont>
      <num-item1>3.3</num-item1><num-item4>Copy Assignment Operations</num-item4>
    </num-cont>
    Copy assignment copies the state from a source instance of some specified type to the state of an existing instance of the
    same type.  Here, we show copy assignment syntax for std::byte, a fundamental type, and struct.
    <spacer-15></spacer-15>
    <defn-block>
      <defn-head class="notice" style="border:2px solid darkred;">
        Copy assignment:
      </defn-head>
      <defn-code>
    std::byte b1{ 0xf };  // value of b1 is 0xf
    std::byte b2{ 0xe };  // value of b2 is 0xe
    b2 = b1;              // copy assignment - value of b2 is now 0xf
      </defn-code>
      <defn-head style="border-top:none;">
        Copy assignment of structs
      </defn-head>
      <defn-code style="border-top:2px solid darkred;">
  struct S { int i = 1; double d = 1.0 / 3.0; char c = 'Q'; int iArr[3]{ 1,2,3 }; } s1;
  S s2{ 2, 1.5, 'a', { 3, 2, 1 } };
  showStruct(s1, "s1");
  showStruct(s2, "s2");
  std::cout << "\n  after assignment s2 has values: ";
  s2 = s1;
  showStruct(s2, "s2");
      </defn-code>
      <defn-head style="border-top:none;">
        Output:
      </defn-head>
      <defn-code style="border-top:2px solid darkred;">
  s1 struct: { 1, 0.333333, Q, [ 1 2 3 ] }
  s2 struct: { 2, 1.5, a, [ 3 2 1 ] }
  after assignment s2 has values:
  s2 struct: { 1, 0.333333, Q, [ 1 2 3 ] }
      </defn-code>
    </defn-block>
    <spacer-25></spacer-25>
    Note that for structs and classes, if no copy assignment operator is defined the compiler will generate one
    that does member-wise copy assignment operations.  
    Compiler generated operations will be discussed in detail in Chapter #4 - classes.
    <!--<h3>Functions:</h3>-->
    <hr class="spread" />
    <num-cont>
      <num-item1>3.4</num-item1>
      <num-item4>Functions:</num-item4>
    </num-cont>
    Functions have a name, a sequence of zero or more arguments, and a return type or void return,
    wrapped around a block of code.
    <spacer-10></spacer-10>
    <defn-block class="indent defnBorders pad10-15">
      <c-s>
        void putline(size_t n = 1) {<br />
        &nbsp;&nbsp;for(size_t i = 0; i &lt; n; ++i)<br />
        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\n";<br />
        }
      </c-s>
    </defn-block>
    <spacer-10></spacer-10>
    They may have default arguments, as shown in this example, so calling <c-s>putline()</c-s>
    results in a single new line being pushed into the terminal stream.
    <spacer-15></spacer-15>
    Function arguments may be passed by value, as shown above, or by reference
    as shown in the code below.
    <spacer-10></spacer-10>
    <defn-block class="indent defnBorders pad10-15">
      <c-s>
        void show(const std::vector&lt;int&gt;&amp; vInt) {<br />
        &nbsp;&nbsp;for(int item : vInt)<br />
        &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; item &lt;&lt; " ";<br />
        }
      </c-s>
    </defn-block>
    <spacer-10></spacer-10>
    The &amp; before vInt indicates that the vector argument is passed by
    reference.  To avoid side effects, we pass reference arguments as const
    references.  On rare occasions we may choose to pass a non-const reference
    so the function may change the argument in the caller&apos;s scope, but this
    makes the code harder to understand, requiring the designer to understand
    what the function does to the passed arguments.  Furthermore, literals
    can only be passed by value or by const reference.
    <spacer-15></spacer-15>
    functions can only be defined at namespace scope or class or struct scope.  They cannot be
    defined within function scope.  That means that C++ does not support inner functions.  When
    defined in class or struct scope they are said to be methods of the class or struct.
    <spacer-15></spacer-15>
    For the remainder of this story, we use the term method for any function defined in class
    or struct scope.  All functions defined at namespace scope will simply be referred to
    as functions.  If there is a possible ambiguity, we will use the qualifier global or unbound
    to indicate that they are not methods.  So, putline is a global function.
    The name of a function is just a pointer to its code. 
    <spacer-15></spacer-15>
    Each function should have a single responsibility and be small and simple enough to make
    it (relatively) easy to understand and test.  A good default size is 50 lines of code - that
    can fit on a single page, so we can quickly see all the parts.
    <spacer-15></spacer-15>
    One measure of complexity that I use is a count of all scopes within a function body.  
    That is simply 1 + the count of all the open braces &quot;{&quot; inside
    the body<sup>1</sup>, but doesn&apos;t count the complexity of functions that are called. Those we can
    think about some other time. I use a complexity measure, CM = 10 (scopes) as an upper limit for my own
    code, and try to make most functions have CM &lt;= 5.
    <hr class="spreadup" />
    <indent-blocks class="footnote">
      <ol>
        <li>
          This complexity measure is closely related to the McCabe Cyclomatic Complexity metric.
          That has been discredited in an often quoted article in the academic literature.
          However, I believe that research was flawed - the metric values were correlated with change
          metrics and found to be weakly correlated.  The authors concluded that Cyclomatic
          Complexity was therefore of little value.  However, they didn&apos;t account for the
          fact that developers are very reluctant to change complex code because it is so hard
          to accomplish without introducing new errors. I contend that this result demonstrates
          the usefulness of the metric.  In many years of developing code, I&apos;ve found it
          to be very useful. Functions that have high complexity, by this measure, are very hard
          to understand and test.
        </li>
      </ol>
    </indent-blocks>

    <!--<h3>Function Pointers:</h3>-->
    <hr class="spread" />
    <num-cont>
      <num-item1>3.5</num-item1>
      <num-item4>Function Pointers:</num-item4>
    </num-cont>
    Function pointers are used to:
    <spacer-10></spacer-10>
    <ul class="tight">
      <li>create callbacks</li>
      <li>pass processing to platform API functions</li>
      <li>
        modify the way library functions operate, e.g., qsort accepts a comparator function pointer
      </li>
      <li>pass processing to plug-in interfaces</li>
    </ul>
    <spacer-10></spacer-10>
    These kinds of applications can be built without using function pointers, but when using existing
    frameworks, it&apos;s likely that you will need them, especially with platform APIs. 
    <spacer-15></spacer-15>
    Function pointers can bind to any function as long as its return type and parameter types
    match the function pointer declaration. 
    <defn-block>
      <defn-code class="noBorder pad10">  FP pL = putline;
  using FP = void(*)(size_t n); // function pointer type
  pL(1)  // push a newline to terminal - func ptrs don&apos;t honor default params</defn-code>
    </defn-block>
    We show more about how that is done in the syntax details, below, for both specific
    and generic function pointer declarations. It&apos;s a bit complicated, so
    we&apos;ve shown several cases.
    <spacer-15></spacer-15>

    <indent-block style="min-width:100%;">
      <details>
        <summary class="labelStyle lightItem">
          function pointer syntax
        </summary>
        <spacer-10></spacer-10>
      <defn-block style="min-width:60%;">
        <defn-head class="pad10">
          Here&apos;s how you declare, define, and use specific function pointers:
        </defn-head>
        <defn-body>
    <pre><c-s><t-s>   For the function:</t-s>

     void putLine(size_t n = 1) {
        for (size_t i = 0; i < n; ++i)
        std::cout << "\n";
     }

  <t-s>Define a function pointer for that specific signature:</t-s>

     using FP1 = void(*)(size_t n);&nbsp;&nbsp;// function pointer type
     FP1 pl1 = putLine;
     pl1(1);  // push single newline to terminal

  <t-s>You can define a function pointer more directly using auto</t-s>
  
     auto& pl2 = putLine;
     pl2(2);  // push two newlines to the terminal

</c-s></pre>
      </defn-body>
      <defn-head class="pad10" style="border-top:none;">
        And here&apos;s how you make them generic:
      </defn-head>
      <defn-body>
<pre><c-s>  <t-s>For the functions:</t-s>

     size_t size(const std::string& s) {
        return s.size();
     }
  
     template <typename T>
     void message(T t) {
        std::cout << t;
     }

  <t-s>Declare a generic function pointer type</t-s>
  
     template&lt;class Tr, Ta&gt;
     using FP2 = Tr(*)(Ta t);

  <t-s>and instantiate it for the second and third test functions:</t-s>

     FP2&lt;size_t, const std::string&&gt; pSz = size;
     size_t sz = pSz("a test string");

     FP2&lt;void, const std::string&&gt; msg1 = message;
     msg1("\n  a test message");

  You can also define function pointers in a generic way using auto   

     auto& msg2 = message&lt;const std::string&&gt;
     msg2("\n  another test message");

     auto& msg3 = message&lt;const char*&gt;
     msg3("\n  still another test message!");
   
     auto& pSz2 = size;
     msg2(
        "\n  size of \"another, somewhat longer, string\" = " + 
        std::to_string(sz)
     );
      </c-s></pre>
        </defn-body>
      </defn-block>
      </details>
    </indent-block>
    <spacer-15></spacer-15>
    Function pointers are used in the Windows and Linux APIs, in the C Language libraries,
    in Qt - a cross platform GUI framework, ...

    <!--<h3>Methods:</h3>-->
    <hr class="spread" />
    <num-cont>
      <num-item1>3.6</num-item1>
      <num-item4>Methods:</num-item4>
    </num-cont>
    Functions bound to classes and structs are called methods.  Methods have access to all the
    member data of the class.  If a class inherits from one or more base classes, it inherits all 
    the methods and data members of its base classes, and has access to any of that qualified as 
    &quot;public: or protected:&quot; for methods and qualified as &quot;protected:&quot; for
    data. 
    <spacer-15></spacer-15>
    <div class="" style="display:flex;">
      <defn-block style="min-width:40%;">
        <defn-head>
          Base class
        </defn-head>
        <defn-body>
          <pre>
<c-s>  class B {
  public:
    void name(const std::string&amp; aname) {
      name_ = aname;
    }
    std::string name() {
      return name_;
    }
  protected:
    std::string name_;
  };
</c-s></pre>
        </defn-body>
      </defn-block>
      <defn-block style="min-width:40%;">
        <defn-head style="border-left:none;">
          Derived class
        </defn-head>
        <defn-body style="border-left:none;">
          <pre><c-s>  class D : public B {
  public:
    void occupation(const std::string&amp; occup) {
      occupation_ = occup;
    }
    std::string occupation() {
      return ocupation_;
    }
  private:
    std::string occupation_;
  };
</c-s></pre>
        </defn-body>
      </defn-block>
    </div>
    <spacer-25></spacer-25>
    The class D, in the block above, has public methods:
    <ul class="tight">
      <li>
        <c-s>void name(const std::string&amp; aname)</c-s>
      </li>
      <li>
        <c-s>std::string name()</c-s>
      </li>
      <li>
        <c-s>void occupation(const std::string&amp;; occup)</c-s>
      </li>
      <li>
        <c-s>std::string occupation()</c-s>
      </li>
    </ul>
    <spacer-15></spacer-15>
    The two name methods it inherited from B and those are accessible to clients. It implemented
    the two occupation methods and those are also accessible to clients.
    <spacer-15></spacer-15>
    The derived class D not only contains its occupation_ string, but it also contains the
    Base::name_ string, inside an image of B that is part of its memory footprint.  We will 
    demonstrate that in the next chapter3 classes.

    <!--<h3>Method Pointers:</h3>-->
    <hr class="spread" />
    <num-cont>
      <num-item1>3.7</num-item1>
      <num-item4>Method Pointers:</num-item4>
    </num-cont>
    Method pointers have the same uses as function pointers.  They have an advantage that
    they can use member data from the invoking instance.
    Method pointers can be bound to any method of the specified type provided that the
    function arguments and return value match the method pointer declaraton.
    <spacer-15></spacer-15>
    <defn-block class="noBorder">
      <defn-code class="noBorder">  using FP1 = void(D::B::*)(const std::string&);
  FP1 pNameSetter = &D::B::name;  // binds to void B::name(const std::string&)
  D d;
  (d.*pNameSetter)("Tom");

  using FP2 = std::string(D::B::*)();
  FP2 pNameGetter = &D::B::name;  // binds to std::string B::name()
  std::string name = (d.*pNameGetter)();
  std::cout << "\n  d1.name() --> " << name;
      </defn-code>
    </defn-block>
    <spacer-15></spacer-15>
    Note that binding to the inherited name functions requires using the class specifier
    D::B instructing the compiler that it will find the code (to point to) in the base
    class definition.  When binding to the occupation names you will just use the D class
    specifier.  Look at the syntax details, below, to see all the details.
    <spacer-15></spacer-15>
    <indent-block>
      <details>
        <summary class="labelStyle lightItem">
          method pointer syntax
        </summary>
        <spacer-10></spacer-10>
      <defn-block style="min-width:60%;">
        <defn-head class="pad10">
          Here&apos;s how you declare, define, and use specific method pointers:<br />
          -- all the cases are included because syntax is a bit complex --
        </defn-head>
        <defn-body>
    <pre><c-s><t-s>   Using classes B and D defined above:</t-s>

  /* accessing inherited overloaded methods name */

  using FP1 = void(D::B::*)(const std::string&);
  FP1 pNameSetter = &D::B::name;
  D d;
  (d.*pNameSetter)("Tom");

  using FP2 = std::string(D::B::*)();
  FP2 pNameGetter = &D::B::name;
  std::string name = (d.*pNameGetter)();
  std::cout << "\n  d1.name() --> " << name;

  /* accessing overloaded methods occupation in D */

  using FP3 = void(D::*)(const std::string&);
  FP3 pOccupSetter = &D::occupation;
  (d.*pOccupSetter)("derivatives analyst");

  using FP4 = std::string(D::*)();
  FP4 pOccupGetter = &D::occupation;
  std::string myJob = (d.*pOccupGetter)();
  std::cout << "\n  d1.Occupation() -- > " << myJob;

  /* std::invoke */

  <t-s>using</t-s> std::invoke with a method pointer:

  std::invoke(pNameSetter, d, "Darth Vader");
  std::string darth = std::invoke(pNameGetter, d);
  std::cout << "\n  his name is " << darth;

  /*-- alternate definitions --*/

  auto pOccuSetter2 = static_cast&lt;std::string(D::*)()&gt;(&D::occupation);
  auto pOccuGetter2 = static_cast&lt;void(D::*)(const std::string&)&gt;(&D::occupation);  

  std::string(D:: * pOccuGetter3)() = &D::occupation;
  void(D:: * pOccuSetter3)(const std::string&) = &D::occupation;

      </c-s></pre>
        </defn-body>
        <defn-head class="pad10" style="border-top:none;">
          Here&apos;s the output:
        </defn-head>
        <defn-body>
          <pre><c-s>  d1.name() --> Tom
  d1.Occupation() -- > derivatives analyst
  his name is Darth Vader
</c-s></pre>
        </defn-body>
      </defn-block>
      </details>
    </indent-block>
    <spacer-15></spacer-15>
    Here&apos;s a plausible example application for method pointers: you have a set of events that
    require different processing for each event, but there are common parts of that processing
    and data needs to be shared between the handlers.
    <spacer-15></spacer-15>
    For this, we could create a class that provides methods to handle each event along with methods
    for shared processing and data members appropriate for the application. Now, an event
    dispatcher provides a map with items:
    <indent-block class="pad10">
      <c-s>{ eventId, [pointer to method for that id] }</c-s>.
    </indent-block>
    So event dispatching looks like this:
    <indent-block class="pad10">
      <c-s>dispatcher[eventId](event args)</c-s>.
    </indent-block>
    We will see an example in Chapter #4 - classes.
    
    <!--<h3>Functors:</h3>-->
    <hr class="spread" />
    <num-cont>
      <num-item1>3.8</num-item1>
      <num-item4>Functors:</num-item4>
    </num-cont>
    Functors are instances of classes that implement operator() so they can be invoked.
    In modern frameworks they often take the place of function pointers, e.g., used for
    callbacks and to inject processing into some other class&apos;s instance.
    <defn-block>
      <defn-code class="noBorder">
  class AFunctor {
  public:
    void operator()(const std::string&amp; s);
    // other members elided
  }
  private:
    // member data elided
  };

  AFunctor fun;
  fun("called like a function");
      </defn-code>
    </defn-block>
    <spacer-15></spacer-15>
    The Standard Template Library (STL) algorithms
    were designed to be used with functors to inject processing into library defined operations,
    like std::for_each.  Here&apos;s an example:
    <defn-block>
      <defn-code class="noBorder">
  struct display {
    template&lt;typename T&gt;
    void operator()(T t) {
      std::cout << t << " ";
    }
  };

  std::vector&lt;std::string&gt; coll{ "one", "two", "three", "four" };
  std::for_each(coll.begin(), coll.end(), display);
      </defn-code>
    </defn-block>
    <c-s>std::for_each</c-s> simply calls display on each of its elements.  Since we
    created the functor display as a template function, that will work for any collection
    type for which elements can be inserted into <c-s>std::cout</c-s>.
    <spacer-15></spacer-15>
    This example code fragment is expanded to show all the parts in the details below.
    <spacer-15></spacer-15>
    <indent-block>
      <details>
        <summary class="labelStyle lightItem">
          functor syntax details
        </summary>
        <spacer-10></spacer-10>
      <defn-block style="min-width:60%;">
        <defn-head class="pad10">
          <span class="notice">functors</span>
        </defn-head>
        <defn-body>
            <pre><c-s>  class Functor {
  public:
    template&lt;typename T&gt;
    void operator()(T element) {
      ++count_;
      std::cout << "\n  " << element;
    }
    size_t count() {
      return count_;
    }
    void name(const std::string& nm) {
      name_ = nm;
    }
    std::string name() {
      return name_;
    }
  private:
    std::string name_;
    size_t count_ = 0;
  };
            </c-s></pre>
          </defn-body>
        <defn-head class="pad10" style="border-top:none;">
          <span class="notice">Using functor:</span>
        </defn-head>
        <defn-body>
          <pre><c-s>  Functor fun;
  fun.name("counter");

  std::vector&lt;std::string&gt; numbers{ "one", "two", "three", "four", "five" };  

  /* std::for_each invokes fun on each element in numbers  */
  /* it then returns a copy of fun to be interrogated later */

  fun = std::for_each(numbers.begin(), numbers.end(), fun);

  std::cout &lt;&lt; "\n  " &lt;&lt; fun.name() &lt;&lt; " processed " 
            &lt;&lt; fun.count() &lt;&lt; " elements";  
</c-s></pre>
        </defn-body>
        <defn-head class="pad10" style="border-top:none;">
          <span class="notice">Output:</span>
        </defn-head>
        <defn-body>
          <pre><c-s>  one
  two
  three
  four
  five
  counter processed 5 elements
            </c-s></pre>
        </defn-body>
      </defn-block>
      </details>
    </indent-block>
    <spacer-15></spacer-15>
    Functors are widely used in C++ code. In addition to being employed as presented here, they 
    are the basis for implementing lambda constructs, introduced with C++11.

<!--    <h3>Lambdas:</h3>-->
    <hr class="spread" />
    <num-cont>
      <num-item1>3.9</num-item1>
      <num-item4>Lambdas:</num-item4>
    </num-cont>
    Lambdas are locally defined callable  objects that can capture state from their local
    scope.  That is often described as the lambda&apos;s closure.  They are widely used
    to inject processing into STL algorithms.  You&apos;ve already seen a couple of examples
    of that in Chapter #1.
    <spacer-15></spacer-15>
    <defn-block class="">
      <defn-head class="pad10" style="border-bottom:2px solid darkred;">
        <span class="notice">Lambda:</span> anonymous locally defined functor in abreviated syntax
      </defn-head>
      <defn-code>  
 <t-s>Lambda syntax example:</t-s>

 auto l1 = example() {
   std::string s1 = "this is a demonstration";
   
   auto lam = [s1](const std::string&amp; s2) {
     std::cout << "\n  " << s1 << " of " << s2;
   };
   return lam;
 };

 l1("lambda syntax");
 <t-s>displays message &quot;this is a demonstration of lambda sytax&quot;</t-s>
 <t-s>
   Here&apos;s what happened:
   1.  string <c-s>s1</c-s> was constructed in example scope, e.g., the lambda&apos;s closure
   2.  lambda <c-s>lam</c-s> was defined capturing <c-s>s1</c-s> by value
   3.  the lambda code sends a string to <c-s>std::cout</c-s> using the captured <c-s>s1</c-s> copy
       and a string, <c-s>s2</c-s>, passed by the using code as an invocation parameter
   4.  this created a lambda object, which will be executed later, and returned it to be copied to <c-s>l1</c-s>.
   5.  <c-s>l1</c-s> executes the lambda passing it <c-s>s2</c-s> = <c-s>&quot;lambda sytax&quot;</c-s>
 </t-s>
      </defn-code>
    </defn-block>
    <spacer-15></spacer-15>
    Lambdas are used with STL algorithms, for providing threads with their processing semantics,
    and used like stored scripts for handling message and event dispatching.
    <spacer-15></spacer-15>
    The details dropdown, below, defines capture and discusses syntax options for capture and return value.
    
    <spacer-15></spacer-15>
    <indent-block>
      <details>
        <summary class="labelStyle lightItem">
          Lambda Syntax:
        </summary>
        <spacer-10></spacer-10>
        <defn-block>
          <defn-head class="pad10">
            <span class="notice">Lambda Syntax</span> - closure is local scope where lambda is defined
          </defn-head>
          <defn-code style="border-top:2px solid darkred;">
 auto f = [capture specifier](argument list)[->optional return specification] {
   body with code to execute
 };

 <ts><span class="notice">Capture specifier:</span></ts>
 [] ==> no capture
 [=] ==> capture all variables in closure by value
 [&] ==> capture all variables in closure by reference
 [v1, &v2] ==> capture, from closure, variable v1 by value and v2 by reference

 <t-s><span class="notice">argument list</span> - same as function:</t-s>
 (T1 t1, T2 t2, ...) <t-s>supplied by the caller</t-s>

 <t-s><span class="notice">optional return specification:</span></t-s>
 Only needed if auto f can&apos;t deduce the return type.

 <t-s><span class="notice">body:</span></t-s>
 Same sytax as ordinary function, except that it may use captured variables as
 well as variables from the parameter list, if any.

 <t-s><span class="notice">Note:
 </span>You need to be very careful with capture by reference and with capture of pointers by value.
  If a lamda is passed out of its scope of definition, references and pointers will point to no longer 
  existing resources.
            
  It is a good idea to use only specific capture specifiers for each captured variable used by the
  the lambda code, like v1 and &amp;v2, above.  If you expect to return the lambda outside its scope
  of definition, you would only use captured values, like v1, avoiding captures by reference like &amp;v2.</t-s>
          </defn-code>
        </defn-block>
      </details>
    </indent-block>
    <spacer-15></spacer-15>
    I think you may be surprised how often you use lambdas once you get used to them.
    Lambdas help to organize code by keeping the definition of a set of operations close
    to the site where they are invoked.

<!--    <h3>Callable Objects:</h3>-->
    <hr class="spread" />
    <num-cont>
      <num-item1>3.10</num-item1>
      <num-item4>Callable Objects:</num-item4>
    </num-cont>
    Any entity that can be invoked, e.g., functions, function pointers, methods, method pointers,
    functors, and lambdas, are all referred to as callable objects.  The STL algorithms accept 
    any of the STL containers and most accept any callable object to act on elements of the
    container.
    C++ threads accept any callable object that returns void.
    <spacer-15></spacer-15>
    The function std::invoke(...) accepts, as its first argument, any callable object.
    If that is a method pointer, the next argument must be the address of an instance on which
    the method pointer acts.  Any remaining arguments - an arbitry finite number - are passed by
    value to the callable object.
    <spacer-15></spacer-15>
    <div class="autoX">
      <defn-block>
        <defn-head>
          <span class="notice">demo of std::invoke</span>
        </defn-head>
        <defn-code style="border-top:2px solid darkred;">
  std::invoke(f, "function via std::invoke", 1);
  std::invoke(pFun, "function pointer via std::invoke", 2);
  std::invoke(F(), "functor via std::invoke", 3);
  std::invoke(lam, "lambda via std::invoke", 4)
  std::invoke(pMethod, C(), "method pointer via std::invoke", 5);
        </defn-code>
      </defn-block>
    </div>
    <spacer-15></spacer-15>
    In this example, <c-s>f</c-s> is a function taking a constant string reference and an unsigned int.
    <c-s>pFun</c-s> is a function pointer to the same function.
    <c-s>F</c-s> is a functor and <c-s>F()</c-s> is a temporary instance of <c-s>F</c-s>.
    <c-s>lam</c-s> is a lambda.
    <c-s>C</c-s> is a class with a method to call
    and <c-s>C()</c-s> is an instance of <c-s>C</c-s>.  <c-s>pMethod</c-s> is a pointer to <c-s>C</c-s>&apos;s method.
    <spacer-15></spacer-15>
    A complete listing of this code is shown in the details below.
    <spacer-15></spacer-15>
    <details>
      <summary class="labelStyle darkItem">
        Complete Example
      </summary>
      <spacer-10></spacer-10>
      <div class="autoX" style="padding:0; width:100%;">
        <defn-block>
          <defn-head>
            <span class="notice">CallableObjects.cpp</span>
          </defn-head>
          <defn-code style="border-top:2px solid darkred; padding-right:50px;">
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;functional&gt;
  #include "../Display/Display.h"

  std::string suffix(size_t i) {
    std::string sfx;
    switch (i)
    {
    case 1:
      sfx = "st";
      break;
    case 2:
      sfx = "nd";
      break;
    case 3:
      sfx = "rd";
      break;
    default:
      sfx = "th";
      break;
    }
    return sfx;
  }

  void f(const std::string& type, size_t i) {
    std::cout &lt;&lt; "\n  " &lt;&lt; std::to_string(i) &lt;&lt; suffix(i) + " invocation, a " + type;
  }

  void(*pFun)(const std::string&, size_t) = f;

  class F {
  public:
    void operator()(const std::string& type, size_t i) {
      std::cout &lt;&lt; "\n  " &lt;&lt; std::to_string(i) &lt;&lt; suffix(i) + " invocation, a " + type;
    }
  };

  auto lam = [](const std::string& type, size_t i) {
    std::cout << "\n  " << std::to_string(i) << suffix(i) + " invocation, a " + type;
  };

  class C {
  public:
    void method(const std::string& type, size_t i) {
      std::cout &lt;&lt; "\n  " &lt;&lt; std::to_string(i) &lt;&lt; suffix(i) + " invocation, a " + type;
    }
  };

  using MPtr = void(C::*)(const std::string&, size_t);
  MPtr pMethod = &C::method;

  template&lt;typename T&gt;
  void doInvoke(T t, const std::string& type, size_t count) {
    t(type, count);
  }

  template&lt;typename U, typename V&gt;
  void doInvoke(U u, V v, const std::string& type, size_t count) {
    (u.*v)(type, count);
  }

  int main() {
    displayDemo("--- Callable Objects Demo ---");

    doInvoke(f, "function", 1);
    doInvoke(pFun, "function pointer", 2);
    doInvoke(F(), "functor", 3);
    doInvoke(lam, "lambda", 4);
    doInvoke(C(), pMethod, "method pointer", 4);
    putline();
    /* 
      std::invoke is more powerful than doInvoke as it takes an arbitry
      number of arguments.
      - the first may be a function, function pointer, or functor
        that take any number of arguments
      - the first may also be a method pointer.  That requires the second
        to be an instance of the class.  It accepts an arbitrary number
        of succeeding arguments.
      That is implemented with a variadic template.  Those will be discussed
      in Chapter #4 - Templates.
    */
    std::invoke(f, "function via std::invoke", 1);
    std::invoke(pFun, "function pointer via std::invoke", 2);
    std::invoke(F(), "functor via std::invoke", 3);
    std::invoke(lam, "lambda via std::invoke", 4)
    std::invoke(pMethod, C(), "method pointer via std::invoke", 5);
    std::cout &lt;&lt; "\n\n";
  }
          </defn-code>
          <defn-head>
            <span class="notice">Output</span>
          </defn-head>
          <defn-code style="border-top:2px solid darkred;">
  --- Callable Objects Demo ---
  1st invocation, a function
  2nd invocation, a function pointer
  3rd invocation, a functor
  4th invocation, a lambda
  5th invocation, a method pointer

  1st invocation, a function via std::invoke
  2nd invocation, a function pointer via std::invoke
  3rd invocation, a functor via std::invoke
  4th invocation, a lambda via std::invoke
  5th invocation, a method pointer via std::invoke
          </defn-code>
        </defn-block>
      </div>
    </details>
    <spacer-15></spacer-15>
    Callable objects are used in many of the standard C++ libraries.  Also, they are used frequently for
    event handling and message dispatching.  You will see examples of that in the next two chapters.

    <hr class="spread" />
    <num-cont>
      <num-item1>3.11</num-item1>
      <num-item4>Passing Function and Method Parameters:</num-item4>
    </num-cont>
    Function and method arguments can be passed in one of two ways: by value or by reference. And, there are two ways
    to pass by reference: using a C++ reference or by using a pointer.
    <spacer-15></spacer-15>
    When an argument is passed by value, it is copied onto the stackframe of the called function. For fundamental types
    that is appropriate and commonly used.  Since the function uses a copy of the parameter, any changes made in the
    scope of the function will not affect the caller&apos;s value.
    <indent-block class="pad10">
      <c-s>void fun(X x) { ... }</c-s>
    </indent-block>
    For large objects, however, the cost of making a copy is usually undesirable and pass by reference is used.
    <spacer-15></spacer-15>
    When an argument is passed by C++ reference, a reference is created in the function&apos;s stackframe, bound to the
    parameter instance in the caller&apos;s scope.
    <indent-block class="pad10">
      <c-s>void fun(X& x) { ... }</c-s>
    </indent-block>
    And, when an argument is passed by pointer reference, a copy of the pointer is copied into the function&apos;s
    stackframe, bound to the paramter instance.
    <indent-block class="pad10">
      <c-s>void fun(X* pX) { ... }</c-s>
    </indent-block>
    Pass by reference is normally implemented with C++ references, primarily because the syntax used in the 
    function body is simpler.

    Note that the size of a reference is the same as the size of a pointer, so both will avoid the performance 
    penalty of copying a large object.
    <num-cont>
      <num-item1>3.11.1</num-item1>
      <num-item4>Side effects:</num-item4>
    </num-cont>
    When an argument is passed by non-const reference to a function, the function may change the value in the
    caller&apos;s scope.  This is usually undesireable because it makes the caller&apos;s code harder to understand
    and test. For that reason we usually pass by const reference:
    <indent-block class="pad10">
      <c-s>void fun(const X& x) { ... }</c-s><br />
      &nbsp;&nbsp;&nbsp;&nbsp;or<br />
      <c-s>void fun(const X* pX) { ... }</c-s>
    </indent-block>
    There are design cases where we elect to pass by non-const reference to use the resulting side effects, but
    we should think carefully about this. There are, since C++14, simple ways to return multiple values from
    a function, e.g., with <c-s>std::tupl</c-s>s, so there are no longer many places we would elect to pass by
    non-const reference.

    <hr class="spread" />
    <num-cont>
      <num-item1>3.12</num-item1>
      <num-item4>Return Values:</num-item4>
    </num-cont>
    The type of a function or method return value has important concequences.  If we are returning the value
    of an instance declared within a function body we must not return that by reference.  As soon as the
    function call completes, all internally declared objects go out of scope, and are destroyed.  If we return
    a reference to one of them it will be invalid before the using code can do anything with it.
    <spacer-15></spacer-15>
    The value of a class data member from a method of that class may be returned by either value
    or reference, since the data member continues to exist after the method call completes. The choice depends
    on whether we intend the calling code to be able to modify the returned member datum.  For non-const strings
    the string indexer will return a reference to the indexed character.  For const strings an overload of the
    indexer will return the character by value.
    <num-cont>
      <num-item1>3.12.1</num-item1>
      <num-item4>Return Value Optimization:</num-item4>
    </num-cont>
    When a function or method returns by value an instance, defined internally, in order to initialize an instance of the
    same type during construction, the compiler will often build the internal instance at the site of the receiving instance.
    This is called Return Value Optimization (<span class="notice">RVO</span>). The example, below, demonstrates when RVO is
    enabled.
    <spacer-10></spacer-10>
    <details>
      <summary class="labelStyle lightItem">Example: Return Value Optimization</summary>
      <spacer-10></spacer-10>
      <div style="display:flex;" class="autoX">
      <defn-block>
        <defn-head><span class="notice">Return value optimization</span></defn-head>
        <defn-code style="border-top:2px solid darkred;">
  namespace Chap3 {

    class X {
    public:
      X() {
        std::cout << "\n  default construction of ";
        myCount_ = ++numObjs_;
        std::cout << "object #" << myCount_;
      }
      X(const X& x) {
        std::cout << "\n  copy construction of ";
        myCount_ = ++numObjs_;
        std::cout << "object #" << myCount_;
      }
      X(X&& x) noexcept {
        std::cout << "\n  move construction of ";
        myCount_ = ++numObjs_;
        std::cout << "object #" << myCount_;
      }
      X& operator=(const X& x) {
        std::cout << "\n  copy assignment of ";
        std::cout << "object #" << myCount_;
      }
      X& operator=(X&& x) noexcept {
        std::cout << "\n  move assignment of ";
        std::cout << "object #" << myCount_;
      }
      ~X() {
        std::cout << "\n  destruction of ";
        std::cout << "object #" << myCount_;
      }
      size_t id() {
        return myCount_;
      }
    private:
      static size_t numObjs_;
      size_t myCount_;
    };

    // static members must be defined outside class declaration
    size_t X::numObjs_ = 0;
  }
  void showIn(const std::string& funName) {
    std::cout << "\n  entered " << funName;
  }
  void showOut(const std::string& funName) {
    std::cout << "\n  returned from " << funName;
  }

  Chap3::X test1() {
    showIn("test1 - return with move");
    Chap3::X x1;
    return x1;
  }
  Chap3::X test2() {
    showIn("test2 - return with RVO");
    return Chap3::X();
  }
  Chap3::X test3() {
    showIn("test3 - return with copy");
    static Chap3::X x;
    return x;
  }
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head class="notice" style="border:2px solid darkred; border-left:none;">
          Using code:
        </defn-head>
        <defn-code style="border-top:2px solid darkred; border-top:none; border-left:none;">
  int main() {
    using namespace Chap3;
    X x1 = test1();
    showOut("test1");
    putline();
    X x2 = test2();
    showOut("test2");
    putline();
    X x3 = test3();
    showOut("test3");
    std::cout << "\n\n";
  }
        </defn-code>
        <defn-head class="notice" style="border:2px solid darkred; border-top:none; border-left:none;">
          Output:
        </defn-head>
        <defn-code style="border-left:none;">
  entered test1
  default construction of object #1
  move construction of object #2
  destruction of object #1
  returned from test1

  entered test2
  default construction of object #3
  returned from test2

  entered test3
  default construction of object #4
  copy construction of object #5
  returned from test3

  destruction of object #5
  destruction of object #3
  destruction of object #2
  destruction of object #4
        </defn-code>
      </defn-block>
      </div>
    </details>
    <spacer-15></spacer-15>
    So when does the compiler use RVO or move or copy to return value?
    <spacer-15></spacer-15>
    <div class="container3">
      <div class="item1 header">Return Action</div>
      <div class="item2 header">Conditions</div>
      <div class="item1">Move construction</div>
      <div class="item2">
        Returned instance is temporary constructed before return - test1 in example code.
      </div>
      <div class="item1">Return Value Optimization (RVO)</div>
      <div class="item2">
        Returned instance is temporary created in the return expression - test2 in example code.
      </div>
      <div class="item1" style="border-bottom:2px solid darkred;">Copy construction</div>
      <div class="item2" style="border-bottom:2px solid darkred;">
        Returned instance is not a temporary, or no move constructor defined - test3 in example code.
      </div>
    </div>
    <spacer-10></spacer-10>
<!--    <h3>STL Algorithms:</h3>-->
    <hr class="spread" />
    <num-cont>
      <num-item1>3.13</num-item1>
      <num-item4>STL Algorithms:</num-item4>
    </num-cont>
    Most of the STL algorithms take a container range bounded by 
    [<c-s>contr.begin()</c-s>, <c-s>contr.end()</c-s>), where
    <c-s>contr</c-s> is some STL container and <c-s>begin()</c-s> and <c-s>end()</c-s> return iterators to the 
    first element of the container and one past the last element.  
    Algorithms take a subsequent argument that defines what to do with each
    element of the container.
    <spacer-15></spacer-15>
    In the example below, we use the std::copy_if algorithm which takes the input range and an
    iterator, std::back_inserter, to insert elements into a destination container.  Finally,
    we pass a lambda expression to determine which elements to insert.
    <spacer-25></spacer-25>
    <div class="autoX">
      <defn-block>
        <defn-head style="border-bottom:2px solid darkred;">
          <span class="notice">std::copy_if example</span>
        </defn-head>
        <defn-code>
  #include &lt;algorithm&gt;
  #include &lt;string&gt;
  #include &lt;vector&gt;
  #include &lt;iostream&gt;
  #include "../Display/Display.h"

  template&lt;typename T&gt;
  void show(T t) {
    for (auto item : t)
      std::cout &lt;&lt; "\n  " &lt;&lt; item;
  }

  int main() {

    std::vector&lt;std::string&gt; src{ 
      "first string", "second str", "third collection", "another string" 
    };
    std::vector&lt;std::string&gt; dst;

    std::string s = "string";          // lambda capture

    std::copy_if(
      src.begin(), src.end(),          // range of source to copy
      std::back_inserter(dst),         // insertion iterator push_backs into dst

      [&s](const std::string& item) {  // lambda predicate defines src items to push_back   
        if (item.find(s) != std::string::npos) {
          return false;
        }
        return true;
      }
    );
  
    show(dst);
    putline(2);
  }
        </defn-code>
      </defn-block>
    </div>
    <spacer-25></spacer-25>
    One could argue that it would be no more complex just to use a for loop to iterate over the container
    instead of the copy_if algorithm.  When to use the algorithms is largely a matter of taste.  
    <spacer-15></spacer-15>
    However,
    some of the algorithms implement quite complex operations and are the simplest choice when applicable.  Also,
    the algorithms are carefully designed to provide the fastest practical processing, and that is often a
    distinct advantage.

<!--    <h3>Testing:</h3>-->
    <hr class="spread" />
    <num-cont>
      <num-item1>3.14</num-item1>
      <num-item4>Testing:</num-item4>
    </num-cont>
    All of the earlier sections in this chapter have explored facilities that C++ provides
    to operate on data.  This section looks at ways to verify that the operations deliver what we expect.
    <spacer-15></spacer-15>
    There are three kinds of testing needed for the code in this site&apos;s repositories:
    <ol>
      <li>
        <span class="notice">Construction Tests:</span>
        <div>
          These tests are implemented as an integral part of the implementation of a package&apos;s
          code<sup>1</sup>. We add a few lines of code or a small function, then add a test to ensure that the
          new code functions as expected.  If we need more than one simple test to verify the new code, then
          we aren&apos;t testing often enough.  If the test fails, we know where to find the problem - in
          the last few lines of code.  The test code may be part of the package&apos;s main function or may
          reside in a separate test package.
        </div>
      </li>
      <li>
        <span class="notice">Unit Tests:</span>
        <div>
          The intent of unit testing is to attempt to ensure that tested code meets all its obligations
          in a robust manner.  That entails testing every path through the code and testing boundary conditions,
          e.g., beginning and end of the computational range, all cases that it may need to execute, and success or 
          failure when executing operations that may fail, like opening streams or connecting a socket.
          Unit tests are labor intensive, and we may elect to unit test only those packages on which other
          packages depend.
        </div>
      </li>
      <li>
        <span class="notice">Regression Tests:</span>
        <div>
          Regression tests are tests typically conducted over a library or large subsystem during their
          implementation.  Each regression test contains a set of test cases that are executed individually
          usually in a predetermined sequence.  It is very common to use a test harness to aggregate all the
          tests and apply them to the library or subsystem whenever there is significant change.  The idea is
          to discover problems early that are due to changes in dependencies or the platform on which
          the code executes.
        </div>
      </li>
      <li>
        <span class="notice">Performance Tests:</span>
        <div>
          Performance testing attempts to construct tests that:
          <ul class="tight pad10">
            <li>
              Compare two processing streams satisfying the same obligations, to see which
              has higher throughput, lower latency, or other performance metrics.
            </li>
            <li>
              Attempt to make testing overhead a negligible part of the complete test process,
              by pulling as much overhead as possible into initial and final activities that
              are not included in measured outputs.
            </li>
            <li>
              Run many times to amortize any remaining startup and shutdown, and average over
              environmental effects that may have nothing to do with the comparison, but 
              happen to ocur during testing.
            </li>
          </ul>
          Often, a single iteration of a test may run fast enough that it is not possible to accurately
          measure the time consumed, so running many iterations is also a way of improving measurement
          accuracy.
        </div>
      </li>
    </ol>
    For construction tests, we provide simple tests that are quick to write and don&apos;t require
    a lot of analysis to build.  For unit, regression, and performance tests we need to be more careful. These tests should
    satisfy three properties:
    <ol>
      <li>
        <span class="notice">Tests should be repeatable</span> with the same results every time.
        <div>
          That implies that each test has a &quot;setup&quot; process that guarentees the testing
          environment is in a fixed state at the beginning of testing. We may choose to do that with
          an initialize function or may use a test class for each test that sets up the
          environment in its constructor.
        </div>
      </li>
      <li>
        <span class="notice">Test normal and abnormal conditions</span> as completely as practical.
        <div>
          We do that by planning each test, defining input data to provide both expected and
          possible but unexpected conditions. It helps to define functions:
          <ul class="tight">
            <li>
              <span class="notice">Requires(pred)</span>
              <div>
                defines condtions that are expected
                to hold before an operation begins.
              </div>
            </li>
            <li>
              <span class="notice">Ensures(pedicate)</span>
              <div>
                defines condtions that are expected to hold after an operation.
              </div>
            </li>
            <li>
              <span class="notice">Assert(predicate)</span>
              <div>
                defines conditions that should be true at specific places in an operation.
              </div>
            </li>
          </ul>
        </div>
        where predicate is a boolean valued operation on the test environment and/or code
        state.
      </li>
      <li>
        <span class="notice">Visualize operation results.</span>
        <div>
          Evaluating all the conditions above often results in a lot of raw data about the 
          environment and code states.  We need a way to selectively display that to a test
          developer. That means we need a logging facility that can write to the console, to
          test data files, or both.  We want to be able to select the levels of display, so
          we get very little output when the tests are running successfully, but with a lot
          more detail when operations fail or are not as expected.
        </div>
      </li>
    </ol>
    For these thorough tests it is common to write a test specification which clearly defines
    the expected test results, initial setup, and any additional instructions for test developers
    that may be needed (ideally none).
    <spacer-15></spacer-15>
    When unit or regression tests are concluded, a test report, generated by the logging
    facility, is saved in the appropriate code repository. This should have a summary of
    what passed and what failed, along with whatever data was logged during the final tests.
    <spacer-15></spacer-15>
    Below, find code declarations for a logger that provides the ability to record information
    about the test in a &quot;head&quot; message, and then add additional log messages as needed.
    <spacer-15></spacer-15>
    <indent-block>
      <details style="position:relative;">
        <summary class="darkItem labelStyle">
          Logger Code
        </summary>
        <spacer-10></spacer-10>
        <div>
    <div style="display:flex; width:100%; position:relative; left:0px;">
    <div class="autoX">
      <defn-block>
        <defn-head style="border-bottom:2px solid darkred;">
          <span class="notice">template logger facility</span>
        </defn-head>
        <defn-code style="padding-right:30px;">
  enum Level { results = 1, demo = 2, debug = 4, all = 7 };

  /*--- logger interface ------------------------------------------*/

  template &lt;typename T, size_t C = 0&gt;
  struct ILogger {
    virtual ~ILogger() {}
    virtual ILogger&lt;T, C&gt;& add(std::ostream*) = 0;
    virtual ILogger&lt;T, C&gt;& write(T t, size_t level = Level::all) = 0;
    virtual void head(T t = "") = 0;
    virtual void prefix(T prfix = "\n  ") = 0;
    virtual void wait() = 0;
    virtual void waitForWrites() = 0;
    virtual void level(size_t lv) = 0;
    virtual void name(const std::string& nm) = 0;
  };
  /*--- concrete logger -------------------------------------------*/

  template &lt;typename T, size_t C = 0&gt;
  class Logger : public ILogger&lt;T, C&gt; {
  public:
    Logger(const std::string& nm = "");
    ~Logger();
    ILogger&lt;T, C&gt;& add(std::ostream* pOstrm);
    virtual ILogger&lt;T, C&gt;& write(T t, size_t level = 0x7);
    virtual void head(T t = "");
    virtual void prefix(T prfix = "\n  ");
    virtual void level(size_t lv);
    void name(const std::string& nm);
    std::string name();
    void wait();
    void waitForWrites();
  protected:
    std::vector&lt;std::ostream*&gt; dstStrm;
    BlockingQueue&lt;T&gt; blockingQueue_;
    void threadProc();
    std::string name_;
    std::thread writeThread_;
    T head_;
    std::string prefix_ = "\n  ";
    size_t level_ = 0x7; // Level::debug + Level::demo + Level::results;   
  };
  /*--- object factory ----------------------------------------------
   *
   *  Creates static logger, so everyone calling makeLogger with
   *  the same value for C will use the same logger.
   */
  template&lt;typename T, size_t C&gt;
  inline ILogger&lt;T, C&gt;& makeLogger() {
    static Logger&lt;T, C&gt; logger;
    return logger;
  }
        </defn-code>
      </defn-block>
    </div>
    <div style="flex:1; min-width:30%;padding-left:25px;">
      At the bottom of this code listing you will find an object factory that returns a reference
      to a static logger, typed as an ILogger interface.  That means that any part of the test code
      that includes the logger header file, Logger.h, will be able to access a single static logger.
      <spacer-15></spacer-15>
      In case the test code needs two or more unique loggers, the logger&apos;s
      template parameter C is used to define a category. Logger&lt;T, 0&gt; is a different type
      than an instance of Logger&lt;T, 1&gt; so it does not share the same static logger.
      <spacer-15></spacer-15>
      The design of this logger includes a blocking queue, designed to receive log messages,
      and a write thread that dequeues messages and writes them to the available streams, perhaps
      the console and a test file. This was done so that logging minimizes write times for the 
      logging thread as much as practical.
      <spacer-15></spacer-15>
      Each call to the logger&apos;s write method accepts the message and a level.  A test-wide
      comparison level can be set with the method level(size_t lv). So if we set the test-wide
      level to debug, any call to write(msg, lv) where lv sets a bit that matches one in the
      test-wide level will be logged.  Otherwise, it will not be recorded.  The test-wide level
      is set, by default, to match all of the cases: results, demo, and debug.
      <spacer-15></spacer-15>
    </div>
    </div>
        </div>
      </details>
    </indent-block>
    <spacer-25></spacer-25>
    You can find all the code for this logger in the
    <a href="https://github.com/JimFawcett/CppStory">CppStory</a> C++ repository. Eventually it
    will be moved to its own Logger repository.
    <spacer-15></spacer-15>
    Below find code for functions that will write to the console or throw an exception when an
    unexpected condition occurs.  Eventually these will use the logger instead of simply writing
    to the console, but I need to use them in some significant testing to be sure how to configure
    them before I make that change.
    <spacer-15></spacer-15>
    <div class="indent" style="position:relative;">
      <details>
        <summary class="labelStyle darkItem">
          Requires, Ensures, and Assert
        </summary>
        <spacer-10></spacer-10>
        <indent-blocks>
    <!--<div class="autoXs">-->
      <defn-block style="position:relative; left:0px;">
        <defn-head class="defnBorder pad10">
          <span class="notice">Requires</span>, <span class="notice">Ensures</span>, and 
          <span class="notice">Assert</span>
        </defn-head>
        <defn-code style="padding-right:75px;">
  /*--- raised on unexpected condition ----------------------------*/

  inline void Assert(
    bool predicate, 
    const std::string& message = "", 
    size_t ln = 0, 
    bool doThrow = false) 
  {
    if (predicate)
      return;
    std::string sentMsg = "Assertion raised";
    if (ln > 0)
      sentMsg += " at line number " + std::to_string(ln);
    if (message.size() > 0)
      sentMsg += "\n  message: \"" + message + "\"";
    if (doThrow)
      throw std::exception(sentMsg.c_str());
    else
      std::cout << "\n  " + sentMsg;
  }
  /*--- raised when input conditions are not satisfied ------------*/

  inline void Requires(
    bool predicate, 
    const std::string& message, 
    size_t lineNo, bool doThrow = false) 
  {
    if (predicate)
      return;
    std::string sentMsg = "Requires " + message + " raised";
    sentMsg += " at line number " + std::to_string(lineNo);
    if (doThrow)
      throw std::exception(sentMsg.c_str());
    else
      std::cout << "\n  " + sentMsg;
  }
  /*--- raised when output conditions are not satisfied -----------*/

  inline void Ensures(
    bool predicate, 
    const std::string& message, 
    size_t lineNo, 
    bool doThrow = false) 
  {   
    if (predicate)
      return;
    std::string sentMsg = "Ensures " + message + " raised";
    sentMsg += " at line number " + std::to_string(lineNo);
    if (doThrow)
      throw std::exception(sentMsg.c_str());
    else
      std::cout << "\n  " + sentMsg;
  }
        </defn-code>
      </defn-block>
    <!--</div>-->
        </indent-blocks>
      </details>
    </div>
    <spacer-15></spacer-15>
    This concludes Chapter #3 - Operations.  In the next chapter we will look at the details of
    classes and class relationships.
    <spacer-25></spacer-25>
    <hr class="spread" />
    <indent-blocks>
      <ol>
        <li>
          A C++ package usually consists of a header file, [packageName].h, and implementation file
          [packageName].cpp.  If the package is an executive with no dependency parents, then it consists
          of the single [executiveName].cpp file. Infrequently, we define utility packages with only a 
          header file [utilityName].h.
        </li>
      </ol>
    </indent-blocks>
    <spacer-25></spacer-25>
  <info-bar></info-bar>
</body>
</html>