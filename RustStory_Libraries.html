<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Prologue.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Rust StdLibs</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="RustStory_References.html">N</a>
  <a id="Prev" href="RustStory_Structures.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 5. - Rust Libraries</h1>
      <h3 id="subtitle">std, collectons, fs, net, error, time, thread, process</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_Libraries.html">Libraries</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#std">Std</a>, 
       <a href="#collections">Collections</a>, <a href="#fs">FileSystem</a>, <a href="#net">Net</a>, 
       <a href="#error">Error</a>, <a href="#time">Time</a>, <a href="#thread">Thread</a>,
       <a href="#process">Process</a>, <a href="#epilogue">Epilogue</a>, <a href="#refs">References</a>
     </rt-b>
   </toc-b>

  <bb-55 class="indent">
    <a id="prologue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.0</num-item1><num-item4>Prologue:</num-item4>
    </num-cont>
    <under-construction class="indent">
      This page is under construction
    </under-construction>
    <a id="std"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.1</num-item1><num-item4>std:</num-item4>
    </num-cont>
    <t-b>
      Rust has a well endowed collection of <strong><a href="https://doc.rust-lang.org/beta/std/">std libraries</a></strong> in the
      std namespace.  You don&apos;t have to declare a use std::*, as the std::prelude::* is automatically applied.
    </t-b>
    <t-b>
      All of the libraries discussed below are part of std.
    </t-b>
    <a id="convert"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.2</num-item1><num-item4>std::convert:</num-item4>
    </num-cont>
    <t-b>
      Traits for conversions are provided in <a href="https://doc.rust-lang.org/std/convert/index.html">std::convert</a>.
      The traits provided in this module provide ways to convert from one type to another.  Each trait serves a different
      purpose:
      <div class="indent">
        <ul class="tight">
          <li>
            AsRef trait provides cheap (re-interprets) reference-to-reference conversions.
          </li>
          <li>
            AsMut trait provides cheap (re-interprets) mutable-to-mutable conversions.
          </li>
          <li>
            From trait provides consuming (move) value-to-value conversions.
          </li>
        </ul>
      </div>
    </t-b>
    <t-b>
      <div class="indent">
        <ol class="tight pad10">
          <li>
            AsRef:
            <defn-code style="font-size:1.0em;">pub trait AsRef&lt;T&gt; where T: ?Sized, {
  fn as_ref(&self) -> &T
}
            </defn-code>
            <div>
              <details>
                <summary class="labelStyle lightItem">Partial List of Implementors:</summary>
                <div class="">
                  <ul class="tight">
                    <li>
                      <c-s>[T]::as_ref&lt;[T]&gt;() -> &[T];</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_ref&lt;[T]&gt;() -> &[T];</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_ref&lt;Vec&lt;T&gt;&gt;() -> &Vec&lt;T&gt;</c-s>
                    </li>
                    <li>
                      <c-s>Box&lt;T&gt;::as_ref&lt;T&gt;() -> &T;</c-s><br />
                      <c-s>where T: ?Sized</c-s>
                    </li>
                    <li>
                      <c-s>Arc&lt;T&gt;::as_ref&lt;T&gt;() -> &T;</c-s><br />
                      <c-s>where T: ?Sized</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;[u8]&gt;() -> &[u8];</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;str&gt;() -> &str;</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;[u8]&gt;() -> &[u8];</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;str&gt;() -> &str;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;Path&gt;() -> &Path;</c-s>
                    </li>
                    <li>
                      <c-s>CStr::as_ref&lt;CStr&gt;() -> &CStr;</c-s>
                    </li>
                    <li>
                      <c-s>CString::as_ref&lt;CStr&gt;() -> &CStr;</c-s>
                    </li>
                    <li>
                      <c-s>OsStr::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>OsString::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>Path::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>PathBuf::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>PathBuf::as_ref&lt;OsStr&gt;() -> &Path;</c-s>
                    </li>
                  </ul>
                </div>
              </details>
            </div>
          </li>
          <li>
            AsMut:
            <defn-code style="font-size:1.0em;">pub trait AsMut&lt;T&gt; where T: ?Sized,
{
  fn as_mut(&mut self) -> &mut T;
}
            </defn-code>
            <div>
              <details>
                <summary class="labelStyle lightItem">Partial List of Implementors</summary>
                <div>
                  <ul class="tight">
                    <li>
                      <c-s>String::as_mut() -> &mut str</c-s>
                    </li>
                    <li>
                      <c-s>[T]::as_mut() -> &mut [T]</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_mut() -> &mut [T]</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_mut() -> &mut Vec&lt;T&gt;</c-s>
                    </li>
                    <li>
                      <c-s>Box&lt;T: ?Sized&gt;::as_mut() -> &mut T</c-s>
                    </li>
                  </ul>
                </div>
              </details>
            </div>
          </li>
          <li>
            From:
            <defn-code style="font-size:1.0em;">pub trait From&lt;T&gt; {
  fn from(T) -> Self
}
            </defn-code>
            <div>
              <details>
                <summary class="labelStyle lightItem">Partial List of Implementors</summary>
                <div>
                  <ul class="tight">
                    <li>
                      String::from(&str)
                    </li>
                    <li>
                      String::from(Box&lt;str&gt;)
                    </li>
                    <li>
                      char::from(u8)
                    </li>
                    <li>
                      PathBuf::from(String)
                    </li>
                    <li>
                      Pathbuf::from(OsString)
                    </li>
                    <li>
                      OsString::from(String)
                    </li>
                    <li>
                      OsString::From(PathBuf)
                    </li>
                    <li>
                      u32::from(char)
                    </li>
                    <li>
                      isize::from(i16)
                    </li>
                    <li>
                      f64::from(f32)
                    </li>
                    <li>
                      f64::from(i16)
                    </li>
                    <li>
                      AtomicI16::from(i16)
                    </li>
                    <li>
                      Vec&lt;u8&gt;::from(String)
                    </li>
                    <li>
                      Vec&lt;T&gt;::from(BinaryHeap&lt;T&gt;)
                    </li>
                    <li>
                      Vec&lt;T&gt;::from(VecDeque&lt;T&gt;)
                    </li>
                    <li>
                      VecDeque&lt;T&gt;::from(Vec&lt;T&gt;)
                    </li>
                    <li>
                      BinaryHeap&lt;T&gt;::from(Vec&lt;T&gt;)
                    </li>
                    <li>
                      Mutex&lt;T&gt;::from(T)
                    </li>
                    <li>
                      RWLock&lt;T&gt;::from(T)
                    </li>
                    <li>
                      Box&lt;[u8]&gt;::from(Box&gt;str&gt;)
                    </li>
                    <li>
                      Box&lt;str&gt;::from(&str)
                    </li>
                    <li>
                      Arc&lt;OsStr&gt;::from(OsString)
                    </li>
                    <li>
                      Arc&lt;Path&gt;::From(PathBuf)
                    </li>
                    <li>
                      Arc&lt;String&gt;::from(String)
                    </li>
                    <li>
                      Arc&lt;T&gt;::from(T)
                    </li>
                    <li>
                      Error::from(kind: ErrorKind)
                    </li>
                    <li>
                      Stdio::from(File)
                    </li>
                    <li>
                      Stdio::from(ChildStdin)
                    </li>
                    <li>
                      Stdio::from(ChildStdout)
                    </li>
                  </ul>
                </div>
              </details>
            </div>
          </li>
        </ol>
      </div>
    </t-b>
    <a id="collections"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.3</num-item1><num-item4>std::collections:</num-item4>
    </num-cont>
    The std namespace has a set of <a href="https://doc.rust-lang.org/std/collections/index.html">std::collections</a> 
    similar to other languages:
    <div class="" style="width:calc(100vw - 15em); padding:15px 0px;">
      <table>
        <tr>
          <th class="darkItem">Collection</th><th class="darkItem">Description</th>
        </tr>
        <tr>
          <td class="lightItem">Vec&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A self expanding indexable array of items of type T, occupying a contiguous block of memory.
            Constant time access to indexed item, linear time insertion and removal.
          </td>
        </tr>
        <tr>
          <td class="lightItem">VecDeque&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A self expanding indexable array of items of type T, with constant-time access, insertion,
            and removal on either end.
          </td>
        </tr>
        <tr>
          <td class="lightItem">LinkedList&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A doubly linked list of items of type T, with linear-time traversal.
          </td>
        </tr>
        <tr>
          <td class="lightItem">HashMap&lt;K, V&gt;</td>
          <td class="lightItem">
            Associative container:<br />
            A hashed container with almost constant time access.  Elements are randomly ordered
            (if the hash function works well for T)
          </td>
        </tr>
        <tr>
          <td class="lightItem">BTreeMap&lt;K,&nbsp;V&gt;</td>
          <td class="lightItem">
            Associative container:<br />
            A balanced binary tree container with log n time access.  Elements are sorted.
          </td>
        </tr>
        <tr>
          <td class="lightItem">HashSet&lt;K&gt;</td>
          <td class="lightItem">
            Set container:<br />
            A hashed container with almost constant time access.  Elements are randomly ordered
            (if the hash function works well for T)
          </td>
        </tr>
        <tr>
          <td class="lightItem">BTreeSet&lt;K&gt;</td>
          <td class="lightItem">
            Set container:<br />
            A balanced binary tree container with log n time access.  Elements are sorted.
          </td>
        </tr>
        <tr>
          <td class="lightItem">BinaryHeap&lt;T&gt;</td>
          <td class="lightItem">
            Priority queue:<br />
            Largest element is accessed in constant time.
          </td>
        </tr>
      </table>
    </div>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::collections::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Collections_echo</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// collections_echo - demonstrate collections library      //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 May 2020  //
/////////////////////////////////////////////////////////////

use std::collections::*;
use std::fmt::*;

/*-- displays type name and value --*/
fn show_type&lt;T: Debug&gt;(t:&amp;T) {
    let name = std::any::type_name::&lt;T&gt;();
    print!("\n  type: {:?}", name);
    print!("\n  {:?}", &amp;t);
}
/*-- echo function shows the type and value of its arg --*/
/*---------------------------------------------------------
   Illustrates how to accept and return iterable
   generic type
*/
fn echo&lt;C: Debug + Clone + IntoIterator&gt;(c:&amp;C) -&gt; &amp;C 
   where C::Item: Debug, {
    show_type(c);
    print!("\n  items are: ");
    let iter = c.clone().into_iter();  // iter consumes
    for item in iter {
        print!("{:?} ", item);
    }
    c
}
/*-- demonstration --*/
fn main() {
    let putline = || { print!("\n"); };

    print!("\n  collections_echo");
    print!("\n ==================");

    let v = vec![1,2,3];
    let r = echo(&amp;v);
    print!("\n\n  echo fn returned:");
    show_type(&amp;r);
    putline();

    let mut vd = VecDeque::&lt;f64&gt;::new();
    vd.push_back(1.0);
    vd.push_front(2.5);
    vd.push_back(-1.5);
    let r = echo(&amp;vd);
    print!("\n\n  echo fn returned:");
    show_type(&amp;r);
    putline();

    let mut hm = HashMap::&lt;i32, &amp;str&gt;::new();
    hm.insert(0,"zero");
    hm.insert(1,"one");
    hm.insert(2,"two");
    let r = echo(&amp;hm);
    print!("\n\n  echo fn returned:");
    show_type(&amp;r);
    putline();

    println!("\n  That's all Folks!\n");
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  collections_echo
 ==================
  type: "alloc::vec::Vec<i32>"
  [1, 2, 3]
  items are: 1 2 3

  echo fn returned:
  type: "&alloc::vec::Vec<i32>"
  [1, 2, 3]

  type: "alloc::collections::vec_deque::VecDeque<f64>"
  [2.5, 1.0, -1.5]
  items are: 2.5 1.0 -1.5

  echo fn returned:
  type: "&alloc::collections::vec_deque::VecDeque<f64>"
  [2.5, 1.0, -1.5]

  type: "std::collections::hash::map::HashMap<i32, &str>"
  {0: "zero", 1: "one", 2: "two"}
  items are: (0, "zero") (1, "one") (2, "two")

  echo fn returned:
  type: "&std::collections::hash::map::HashMap<i32, &str>"
  {0: "zero", 1: "one", 2: "two"}

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      Find code for this example <a href="RustLibraryDemos.html">here</a>.
    </t-b>
    <num-cont><num-item1>3.3.1</num-item1><num-item4>Iterators:</num-item4></num-cont>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/iter/index.html">std::iter</a>
    </t-b>
    <t-b>
      Iterators support iterating through collections.  They come in three flavors:
      <div class="indent pad5">
        <ul class="tight">
          <li>
            iter(), which iterates over &T
          </li>
          <li>
            iter_mut(), which iterates over &mut T
          </li>
          <li>
            into_iter(), which iterates over T
          </li>
        </ul>
      </div>
      Note that into_iter is a consuming iterator, moving items from source to destination.
    </t-b>
    <t-b>
      Iterators are lazy: they don&apos;t do anything until consumed, e.g.:
    </t-b>
    <t-b>
      <div>
        <defn-code style="font-size:1.0em;">coll.iter().for_each(|x| { /* do something with x */ });
    <t-s>or</t-s>
for x in &coll { /* do something else with x */ };
        </defn-code>
      </div>
    </t-b>
    <t-b>
      <strong>Traits:</strong>
    </t-b>
    <t-b>
      <div class="indent">
        <ol class="tight">
          <li>
            <defn-code style="font-size:1.0em; margin-left:-15px;">trait Iterator {
    type Item;
    fn next(&mut self) -> Option&lt;Self::Item&gt;
    fn count(self) -> usize
    fn last(self) -> Option&lt;Self::Item&gt;
    fn nth(&mut self, n: usize) -> Option&lt;Self::Item&gt;
    fn step_by(self, step: usize) -> StepBy&lt;Self&gt;
    fn map&lt;B, F&gt;(self, f: F) -> Map&lt;Self, F&gt;
       where F: FnMut(Self::Item) -> B
    fn for_each&lt;F&gt;(self, f: F)
       where F: FnMut(Self::Item)
    fn filter&lt;P&gt;(self, predicate: P) -> Filter&lt;Self, P&gt;
       where P: FnMut(&Self::Item) -> bool
    ...
}
            </defn-code>
          </li>
          <li>
            <defn-code style="font-size:1.0em; margin-left:-15px;">trait IntoIterator {
    type Item;
    type IntoIter: Iterator
    fn into_iter(self) -> Self::IntoIter
}
            </defn-code>
          </li>
        </ol>
      </div>
    </t-b>
    <t-b>
      Iterators provide a set of adapter methods for performing common operations on containers.
      Here&apos;s a longer partial list - see 
      <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Trait&nbsp;std::iter::Iterator</a>
      for more details:
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">Partial List of Iterator Adapters</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>fn <strong>next</strong>(&mut self) -> Option&lt;Self::Item&gt;</c-s><br />
                <s-5px></s-5px>
                Advances and returns value.
              </li>
              <li>
                <c-s>fn map&lt;B, F&gt;(self, f:F) -> Map&lt;Self, F&gt;</c-s><br />
                <c-s> where F: FnMut(Self::Item) -> B</c-s><br />
                <s-5px></s-5px>
                Takes a closure and creates an iterator that applies the closure to each item.
              </li>
              <li>
                <c-s>fn filter&lt;P&gt;(self, predicate:P) -> Filter&lt;Self, P&gt;</c-s><br />
                <c-s>where P: FnMust(&Self::Item) -> bool</c-s><br />
                <s-5px></s-5px>
                Creates an iterator that determines if an item should be included.
              </li>
              <li>
                <c-s>fn take(self, n:usize) -> Take&lt;Self&gt;</c-s>
              </li>
              <li>
                <c-s>
                  fn take_while&lt;P&gt;(self, predicate: P) -> TakeWhile&lt;Self, P&gt;<br />
                  where P: FnMut(&Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>
                  fn fold&lt;B, F&gt;(self, init:B, f:F) -> B<br />
                  where FnMut(B, Self::Item) -> B
                </c-s>
              </li>
              <li>
                <c-s>fn skip(self, n:usize) -> Skip&lt;Self&gt;</c-s>
              </li>
              <li>
                <c-s>
                  fn collect&lt;B&gt;(self) -> B<br />
                  where B: FromIterator&lt;Self::Item&gt;
                </c-s>
              </li>
              <li>
                <c-s>step_by(self, step:usize) -> StepBy&lt;Self&gt;<br /></c-s>
                <s-5px></s-5px>
                Skips step items on each iteration
              </li>
              <li>
                <c-s>nth(&mut self, n:usize) -> Option&lt;Self::item&gt;<br /></c-s>
                <s-5px></s-5px>
                Returns nth item, counting from zero
              </li>
              <li>
                <c-s>last(self) -> Option&lt;Self::item&gt;<br /></c-s>
                <s-5px></s-5px>
                Consumes iterator, returning last item
              </li>
              <li>
                <c-s>
                  fn find&lt;P&gt;(&mut self, predicate: P) -> Option&lt;Self::Item&gt;<br />
                  where FnMut(&Self::Item) -> bool
                </c-s> 
              </li>
              <li>
                <c-s>
                  fn position&lt;P&gt;(&mut self, predicate: P) -> Option&lt;usize&gt;<br />
                  where P: FnMut(Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>
                  fn for_each&lt;F&gt;(self, f:F)<br />
                  where F: FnMut(Self::Item)<br />
                </c-s>
                <s-5px></s-5px>
                Calls a closure on each element of an iterator.
              </li>
              <li>
                <c-s>fn enumerate(self) -> Enumerate&lt;Self&gt;<br /></c-s>
                <s-5px></s-5px>
                Creates an iterator returns a pair with current iteration count and next value.
              </li>
              <li>
                <c-s>fn by_ref(&mut self) -> &mut Self</c-s>
              </li>
              <li>
                <c-s>
                  fn all&lt;F&gt;(&mut self, f:F) -> bool<br />
                  where F: FnMut(Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>
                  fn any&lt;F&gt;(&mut self, f:F) -> bool<br />
                  where F: FnMut(Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>fn count(self) -> usize<br /></c-s>
                <s-5px></s-5px>
                Consumes iterator, counting number of iterations
              </li>
              <li>
                <c-s>
                  fn chain&lt;U&gt;(self, other: U) -> Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;<br />
                  where U: IntoIterator&lt;Self::Item&gt;
                </c-s>
              </li>
              <li>
                <c-s>
                  fn zip&lt;U&gt;(self, other: U) -> Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;<br />
                  where U: IntoIterator
                </c-s>
              </li>
              <li>
                <c-s>
                  fn sum&lt;S&gt;(self) -> S<br />
                  where S: Sum&lt;Self::Item&gt;
                </c-s>
              </li>
              <li>
                <c-s>
                  fn product&lt;P&gt;(self) -> P<br />
                  where P: Product&lt;Self::Item&gt;
                </c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;iteration_echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>iteration_echo</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// iter_echo::main.rs - demonstrating iteration            //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 May 2020  //
/////////////////////////////////////////////////////////////

use std::collections::*;

fn main() {

    let putline = || print!("\n");

    let mut hm: HashMap&lt;i32, &amp;str&gt; = HashMap::new();
    hm.insert(0, "zero");
    hm.insert(1, "one");
    hm.insert(2, "two");
    hm.insert(3, "three");
    hm.insert(4, "four");
    hm.insert(5, "five");
    hm.insert(6, "six");

    let iter = hm.iter();
    print!("\n  iterating over hashmap:\n  ");
    for item in iter {
        print!("{:?}", item);
    }
    putline();
    /*-- previous iter consumed so make new one --*/
    let iter = hm.iter();
    print!("\n  iterating and selecting odd entries:\n  ");
    for item in iter.step_by(2) {
        print!("{:?}", item);
    }
    putline();
    /*-- previous iter consumed so make new one --*/
    let iter = hm.iter();
    print!("\n  iterating and selecting even entries:\n  ");
    for item in iter.skip(1).step_by(2) {
        print!("{:?}", item);
    }
    putline();

    println!("\n  That's all Folks!\n");
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>

  iterating over hashmap:
  (4, "four")(6, "six")(2, "two")(1, "one")
  (0, "zero")(3, "three")(5, "five")        

  iterating and selecting odd entries:
  (4, "four")(2, "two")(0, "zero")(5, "five")

  iterating and selecting even entries:
  (6, "six")(1, "one")(3, "three")

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      Find code for this example <a href="RustLibraryDemos.html">here</a>.
    </t-b>
    <t-b>
      Similar to the C++ std::algorithms, iterators provide a readable declarative interface for code doing
      compound operations on collection items.
    </t-b>
    <a id="io"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.4</num-item1><num-item4>std::io</num-item4>
    </num-cont>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/io/index.html">std::io</a>
    </t-b>
    <t-b>
      <strong>Traits:</strong>
    </t-b>
    <t-b>
      Traits are contracts with function signatures that implementors are required to provide.  For example,
      every implementor of the Read trait is obligated to provide <c-s>read</c-s> and all the other methods
      from that trait.  The BufReader and Stdin structs both implement Read.
    </t-b>
    <t-b>
      In the dropdown, below, you will find the most important methods for the Read, BufRead, Seek, and Write
      traits.
    </t-b>
    <t-b>
      <div class="">
        <details>
          <summary class="labelStyle lightItem">Partial List of Traits</summary>
          <div class="indent">
            <s-halfEm></s-halfEm>
        <ol class="tight">
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">pub trait Read {
  fn read(&mut self, buf: &mut [u8]) -> Result&lt;usize&gt;
  fn read_exact(&mut self, buf: &mut [u8]) -> Result&lt;()&gt;
  fn read_to_end(&mut self, buf: &mut Vec&lt;u8&gt;) -> Result&lt;usize&gt;
  fn read_to_string(&mut self, buf: &mut String) -> Result&lt;usize&gt;
  fn by_ref(&mut self) -> &mut Self, where Self: Sized,
  fn bytes(self) -> Bytes&lt;Self&gt;, where Self: Sized,
  ...
}
            </defn-code>
          </li>
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">pub trait BufRead {
  fn fill_buf(&mut self) -> Result&lt;&[u8]&gt;
  fn consume(&mut self, amt: usize)
  fn read_until(&mut self, byte: u8, buf: &mut Vec&lt;u8&gt;) -> Result&lt;usize&gt;
  fn read_line(&mut self, buf: &mut String) -> Result&lt;usize&gt;
  fn lines(self) -> Lines&lt;Self&gt; // an iterator
  ...
}
            </defn-code>
          </li>
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">pub trait Write {
  fn write_all(&mut self, buf: &[u8]) -> Result&lt;()&gt;
  fn write(&mut self, buf: &[u8]) -> Result&lt;usize&gt;
  fn write_fmt(&mut self, fmt: Arguments) -> Result&lt;()&gt;
  fn by_ref(&mut self) -> &mut Self, where Self: Sized,
  fn flush(&mut self) -> Result&lt;()&gt;,
  ...
}
            </defn-code>
          </li>
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">pub trait Seek {
  fn seek(&mut self, pos: SeekFrom) -> Result&lt;u64&gt;
  fn stream_len(&mut self) -> Result&lt;u64&gt;
  ...
}
            </defn-code>
          </li>
        </ol>
            </div>
          </details>
      </div>
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      Structs are used to build library and user-defined types.  Here, you will find definitions for
      BufReader, BufWriter, Error, LineWriter, Stdin, and Stdout types.
    </t-b>
    <t-b>
      Two other structs, Bytes and Lines, are iterator types that provide access to the io state. You will find
      definitions for all of these in the dropdown, below.
    </t-b>
    <t-b>
      <div class="">
        <details>
          <summary class="labelStyle lightItem">Partial List of Structs</summary>
          <div class="indent">
          <s-halfEm></s-halfEm>
        <ol class="tight">
          <li>
            BufReader
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>BufRead, Debug, Read, Seek, ...</c-s>
                </li>
                <li>
                  <c-s>pub fn new(inner: R) -> BufReader&lt;R&gt; where R: Read</c-s>
                </li>
                <li>
                  <c-s>pub fn get_ref(&self) -> &R</c-s>
                </li>
                <li>
                  <c-s>pub fn get_mut(&self) -> &mut R</c-s>
                </li>
                <li>
                  <c-s>pub fn buffer(&self) -> &[u8]</c-s>
                </li>
                <li>
                  <c-s>pub fn into_inner(self) -> R</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            BufWriter
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Drop, Seek, Write ...</c-s>
                </li>
                <li>
                  <c-s>pub fn new(inner: W) -> BufWriter&lt;W&gt; where W: Write</c-s>
                </li>
                <li>
                  <c-s>pub fn get_ref(&self) -> &W</c-s>
                </li>
                <li>
                  <c-s>pub fn get_mut(&self) -> &mut W</c-s>
                </li>
                <li>
                  <c-s>pub fn buffer(&self) -> &[u8]</c-s>
                </li>
                <li>
                  <c-s>pub fn into_inner(self) -> Result&lt;W, IntoInnerError&lt;BufWriter&lt;W&gt;&gt;&gt;</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            Bytes
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Iterator ...</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            Error
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Display, Error, From&lt;ErrorKind&gt;, ...</c-s>
                </li>
                <li>
                  <c-s>pub fn new&lt;E&gt;(kind: ErrorKind, error: E) -> Error</c-s>
                </li>
                <li>
                  <c-s>pub fn get_ref(&self) -> Option&lt;&(dyn Error + Send + Sync + 'static')&gt;</c-s>
                </li>
                <li>
                  <c-s>pub fn get_mut(&mut self) -> Option&lt;&mut (dyn Error + Send + Sync + 'static')&gt;</c-s>
                </li>
                <li>
                  <c-s>pub fn into_inner(self) -> Option&lt;Box&lt;dyn Error + Send + Sync&gt;&gt;</c-s>
                </li>
                <li>
                  <c-s>pub fn kind(&self) -> ErrorKind</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            LineWriter
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Write ...</c-s>
                </li>
                <li>
                  <c-s>pub fn new(inner: W) -> LineWriter&lt;W&gt; where W: Write</c-s>
                </li>
                <li>
                  <c-s>pub fn get_ref(&self) -> &W</c-s>
                </li>
                <li>
                  <c-s>pub fn get_mut(&self) -> &mut W</c-s>
                </li>
                <li>
                  <c-s>pub fn into_inner(self) -> Result&lt;W, IntoInnerError&lt;LineWriter&lt;W&gt;&gt;&gt;</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            Lines
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Iterator ...</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            Stdin
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Read ...</c-s>
                </li>
                <li>
                  <c-s>pub fn lock(&self) -> StdinLock</c-s>
                </li>
                <li>
                  <c-s>pub fn read_line(&self, buf: &mut String) -> Result&lt;usize&gt;</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            Stdout
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Write ...</c-s>
                </li>
                <li>
                  <c-s>pub fn lock(&self) -> StdoutLock</c-s>
                </li>
              </ul>
            </div>
          </li>
        </ol>
            </div>
          </details>
      </div>
    </t-b>
    <t-b>
      <strong>Functions:</strong>
    </t-b>
    <t-b>
      Here you will find a short list of functions that are occasionally useful for programs dealing with io.
    </t-b>
    <t-b>
      <div class="">
        <details>
          <summary class="labelStyle lightItem">Partial List of Functions</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
        <ol class="tight">
          <li>
            <c-s>pub fn copy&lt;R: ?Sized, W: ?Sized&gt;(reader: &mut R, writer: &mut W) -> Result&lt;u64&gt;</c-s>
          </li>
          <li>
            <c-s>pub fn stderr() -> Stderr</c-s>
          </li>
          <li>
            <c-s>pub fn stdin() -> Stdin</c-s>
          </li>
          <li>
            <c-s>pub fn stdout() -> Stdout</c-s>
          </li>
        </ol>
            </div>
          </details>
      </div>
    </t-b>
    <t-b>
      <strong>Types:</strong>
    </t-b>
    <t-b>
      <div class="indent"><c-s>type Result&lt;T&gt; = Result&lt;T, Error&gt;</c-s></div>
    </t-b>
    <t-b>
      You will find a relatively simple std::io echo program in the dropdown, below.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::io::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>io_echo</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// io_echo::main.rs - std::io library demonstration        //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 May 2020  //
/////////////////////////////////////////////////////////////

use std::io::prelude::*;

fn main() -&gt; std::io::Result&lt;()&gt; {
    print!("\n  Echo std::io");
    print!("\n ==============");

    const QUIT:char = 'q';
    print!("\n  Enter single \'q\' character to terminate program");
    loop {
        print!("\n  enter some text: ");
        let _ = std::io::stdout().flush();
        let mut input_str = String::new();
        let size = std::io::stdin().read_line(&amp;mut input_str)?;

        /////////////////////////////////////////////////////////////
        // line below needs ctrl z to terminate read
        // let size = std::io::stdin().read_to_string(&amp;mut input_str)?

        print!("\n  read {} bytes", size);
        let rslt = input_str.chars().nth(0);
        if rslt == Some(QUIT) &amp;&amp; size == 3 {
            break;
        }
        let out_str = format!("\n  {:?}", input_str);
        std::io::stdout().write_all(out_str.as_ref())?;  // convert to &amp;[u8]
        std::io::stdout().flush()?;
    }
    println!("\n  That's all Folks!");
    Ok(())
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output</defn-head>
              <defn-code>
  Echo std::io
 ==============
  Enter single 'q' character to terminate program
  enter some text: this is a test

  read 16 bytes
  "this is a test\r\n"
  enter some text: another line

  read 14 bytes
  "another line\r\n"
  enter some text: q

  read 3 bytes
  That's all Folks!

              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      You will find the example code <a  href="RustLibraryDemosCode.html">here</a>.
    </t-b>
    <a id="fs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.5</num-item1><num-item4>std::fs</num-item4>
    </num-cont>
    <t-b>
      Working with files and directories is well supported in Rust with the
      <a href="https://doc.rust-lang.org/std/fs/index.html">std::fs</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The most important std::fs types are listed here - DirBuilder, DirEntry, File, FileType, Metadata,
      OpenOptions, Permissions, and ReadDir:
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>DirBuilder</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new() -> DirBuilder</c-s>
                  </li>
                  <li>
                    <c-s>pub fn recursive(&mut self, recursive: bool) -> &mut Self</c-s>
                  </li>
                  <li>
                    <c-s>pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(&mut self, path: P) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn recursive(&mut self, recursive: bool) -> &mut Self</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>DirEntry</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn path(&self) -> PathBuf</c-s>
                  </li>
                  <li>
                    <c-s>pub fn metadata(&mut self) -> Result&lt;Metadata&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn file_type(&mut self) -> Result&lt;FileType&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn file_name(&mut self) -> OsString</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>File</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, Read, Seek, Write, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;File&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;File&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_len(&mut self, size: u64) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn metadata(&mut self) -> Result&lt;Metadata&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_permissions(&mut self, perm: Permissions) -> Result&lt;()&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>FileType</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Clone, Copy, Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_dir(&mut self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_file(&mut self) -> bool</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Metadata</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Clone, Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn file_type(&mut self) -> FileType</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_dir(&mut self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_file(&mut self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn len(&mut self) -> u64</c-s>
                  </li>
                  <li>
                    <c-s>pub fn permissions(&mut self) -> Permissions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn modified(&mut self) -> Result&lt;SystemTime&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn accessed(&mut self) -> Result&lt;SystemTime&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn created(&mut self) -> Result&lt;SystemTime&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>OpenOptions</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Clone, Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new() -> OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn read(&mut self, read: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn write(&mut self, write: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn append(&mut self, append: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn create(&mut self, create: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn create_new(&mut self, create_new: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(&self, path: P) -> Result&lt;File&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Permissions</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Clone, Debug, Eq, PartialEq, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn readonly(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_readonly(&mut self, readonly: bool)</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>ReadDir</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, Iterator, ...</c-s>
                  </li>
                </ul>
                <div class="indent">
                  <t-b style="margin-top:5px; margin-bottom:5px;">
                    Iterator over entries in a directory, returned from the read_dir(p: Path)
                    function.
                  </t-b>
                  <t-b style="margin-top:5px; margin-bottom:5px;">
                    Yields instances of io::Result&lt;DirEntry&gt;
                  </t-b>
                </div>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <strong>Functions:</strong>
    </t-b>
    <t-b>
      Quite often, you may only need some of the functions, listed here, for a program&apos;s file and directory
      management needs.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">Partial List of IO Functions</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>fn canonicalize&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;PathBuf&gt;</c-s>
              </li>
              <li>
                <c-s>fn create_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn read_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;ReadDir&gt;</c-s>
              </li>
              <li>
                <c-s>fn remove_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn metadata&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;Metadata&gt;</c-s>
              </li>
              <li>
                <c-s>fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;Vec&lt;u8&gt;&gt;</c-s>
              </li>
              <li>
                <c-s>fn read_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;ReadDir&gt;</c-s>
              </li>
              <li>
                <c-s>fn read_to_string&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;String&gt;</c-s>
              </li>
              <li>
                <c-s>fn write&lt;P: AsRef&lt;Path&gt;&gt;, C: AsRef&lt;[u8]&gt;&gt;(path: P, contents: C) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn remove_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn rename&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn set_permissions&lt;P: AsRef&lt;Path&gt;&gt;(path: P, perm: Permissions) -> Result&lt;()&gt;</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::fs::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>fs_echo::main.rs</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// fs_echo::main.rs - demonstrate file operations          //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 15 May 2020  //
/////////////////////////////////////////////////////////////

use std::fs::*;
use std::io::*;

/*-----------------------------------------------------------
   Note:
   The try operator ? has been used in several places in 
   both using_File and using_OpenOptions to avoid a lot
   of explicit error handling.

   The try operator bubbles errors up to the caller, so
   if there are several places where errors may occur, 
   they can all be handled in one place by the caller.

   What is surprising, but useful, is that the Result&lt;T,E&gt;
   types are not all the same.  In some results the type T
   is File, or (), or usize.  However, the error types are
   all io::Error, and that is what ? returns to the caller,
   so it just works!

   If there are no errors, ? simply unwraps the result to 
   be used, and everything is significantly simpler.
*/
#[allow(non_snake_case)]
fn using_File(file_name:&amp;str, msg:&amp;str)
     -&gt; std::io::Result&lt;()&gt; {
    let mut wfile = File::create(file_name)?;
    print!(
        "\n  writing message {:?} to file {:?}", 
        msg, file_name
    );
    wfile.write_all(msg.as_bytes())?;
    let mut rfile = File::open(file_name)?;
    let mut rcv_msg = String::new();
    let _ = rfile.read_to_string(&amp;mut rcv_msg);
    print!(
        "\n  message {:?} read from {:?}", 
        rcv_msg, file_name
    );
    Ok(())
}
fn open_file_for_write(path:&amp;str)
     -&gt; std::io::Result&lt;File&gt; {
    let wfile = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(path)?;
    Ok(wfile)
}
fn open_file_for_read(path:&amp;str)
       -&gt; std::io::Result&lt;File&gt; {
    let rfile = OpenOptions::new()
                .read(true)
                .open(path)?;
    Ok(rfile)
}
#[allow(non_snake_case)]
fn using_OpenOptions(file_name:&amp;str, msg:&amp;str)
    -&gt; std::io::Result&lt;()&gt; {
    let mut wfile = open_file_for_write(file_name)?;
    print!(
        "\n  writing message {:?} to file {:?}", 
        msg, file_name
    );
    wfile.write_all(msg.as_bytes())?;

    let mut rfile = open_file_for_read(file_name)?;
    let mut rcv_msg = String::new();
    let _ = rfile.read_to_string(&amp;mut rcv_msg);
    print!(
        "\n  message {:?} read from {:?}", 
        rcv_msg, file_name
    );
    Ok(())
}
fn main() -&gt; std::io::Result&lt;()&gt; {
    let putline = || print!("\n");

    let file_name = "test.txt";
    let msg = "msg from writer";
    print!("\n  std::fs echo demonstration");
    print!("\n ============================");
    putline();

    print!("\n  demo using File structure");
    print!("\n ---------------------------");
    using_File(file_name, msg)?;
    putline();

    print!("\n  demo using OpenOptions structure");
    print!("\n ----------------------------------");
    using_OpenOptions(file_name, msg)?;

    println!("\n\n  That's all Folks!\n");
    Ok(())
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
std::fs echo demonstration
============================

demo using File structure
---------------------------
writing message "msg from writer" to file "test.txt"
message "msg from writer" read from "test.txt"

demo using OpenOptions structure
----------------------------------
writing message "msg from writer" to file "test.txt"
message "msg from writer" read from "test.txt"

That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be bound <a href="RustLibraryDemos.html">here</a>.
    </t-b>
    <a id="net"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.4</num-item1><num-item4>net:</num-item4>
    </num-cont>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/net/index.html">std::net</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::net types are: TcpListener, Incoming, TcpStream, UdpSocket,
      Ipv4Addr, Ipv6Addr, SocketAddrV4, SocketAddrV6, AddrParseError:
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>TcpListener</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn bind&lt;A: ToSocketAddrs&gt;(addr: A) -> Result&lt;TcpListener&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn accept(&self) -> Result&lt;(TcpStrea,. SpcletAddr)&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn inoming(&self) -> Incoming</c-s>
                  </li>
                  <li>
                    <c-s>pub fn take_error(&self) -> Result&lt;Option&lt;Error&gt;&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_nonblocking(&self, nonblocking: bool) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>TcpStream</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Read, Write, Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn connect&lt;A: ToSoketAddrs&gt;(addr: A) -> Result&lt;TcpStream&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn shutdown(&self, how: Shutdown) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn peek(&mut self, buf: &mut [u8]) -> Result&lt;usize&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn take_error(&self) -> Result&lt;Option&lt;Error&gt;&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_nonblocking(&self, nonblocking: bool) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>UdpSocket</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn bind&lt;A: ToSocketAddrs&gt;(addr: A) -> Result&lt;TcpListener&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn recv_from(&self, buf: &mut [u8]) -> Result&lt;(usize, SocketAddr)&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn peek_from(&self, buf: &mut [u8]) -> Result&lt;(usize, SocketAddr)&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn send_to&lt;A: ToSocketAddrs&gt;(&self, buf: &[u8], addr: A) -> Result&lt;usize&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_broadcast(&self, broadcast: bool) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn broadcast(&mut self) -> Result&lt;bool&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn take_error(&self) -> Result&lt;Option&lt;Error&gt;&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn connect&lt;A: ToSocketAddrs&gt;(&self, addr: A) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn send(&self, buf: &mut [u8]) -> Result&lt;usize&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn recv(&self, buf: &mut [u8]) -> Result&lt;usize&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn peek(&self, buf: &mut [u8]) -> Result&lt;usize&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_nonblocking(&self, nonblocking: bool) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>Ipv4Addr</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, Display, copy, clone, Eq, PartialEq, From ...</c-s>
                  </li>
                  <li>
                    <c-s>pub const fn new(a: u8, b: u8, c: u8, d: u8) -> IpvrAddr</c-s>
                  </li>
                  <li>
                    <c-s>pub const LOCALHOST: Self</c-s>
                  </li>
                  <li>
                    <c-s>pub const UNSPECIFIED: Self</c-s>
                  </li>
                  <li>
                    <c-s>pub const BROADCAST: Self</c-s>
                  </li>
                  <li>
                    <c-s>pub fn octets(&self) -> [u8; 4]</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_unspecified(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_loopback(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_private(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_multicast(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_broadcast(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn to_ipv6_compatible(&self) -> Ipv6Addr</c-s>
                  </li>
                  <li>
                    <c-s>pub fn to_ipv6_mapped(&self) -> Ipv6Addr</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Ipv6Addr</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, Display, copy, clone, Eq, PartialEq, From ...</c-s>
                  </li>
                  <li>
                    <c-s>pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> IpvrAddr</c-s>
                  </li>
                  <li>
                    <c-s>pub const LOCALHOST: Self</c-s>
                  </li>
                  <li>
                    <c-s>pub const UNSPECIFIED: Self</c-s>
                  </li>
                  <!--<li>
                    <c-s>pub const BROADCAST: Self</c-s>
                  </li>-->
                  <li>
                    <c-s>pub fn segments(&self) -> [u16; 8]</c-s>
                  </li>
                  <li>
                    <c-s>pub fn octets(&self) -> [u8; 16]</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_unspecified(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_loopback(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_multicast(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn to_ipv4(&self) -> Ipv4Addr</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>SocketAddrV4</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Display, Copy, Clone, Eq, PartialEq, From, FromStr, ToSocketAddrs, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4</c-s>
                  </li>
                  <li>
                    <c-s>pub fn ip(&self) -> &Ipv4Addr</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_ip(&mut self, new_ip: Ipv4Addr)</c-s>
                  </li>
                  <li>
                    <c-s>pub fn port(&self) -> u16</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_port(&mut self, new_port: u16)</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>SocketAddrV6</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Display, Copy, Clone, Eq, PartialEq, From, FromStr, ToSocketAddrs, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6</c-s>
                  </li>
                  <li>
                    <c-s>pub fn ip(&self) -> &Ipv6Addr</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_ip(&mut self, new_ip: Ipv6Addr)</c-s>
                  </li>
                  <li>
                    <c-s>pub fn port(&self) -> u16</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_port(&mut self, new_port: u16)</c-s>
                  </li>
                  <li>
                    <c-s>pub fn flowinfo(&self) -> u32</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_flowinfo(&mut self, new_flowinfo: u32)</c-s>
                  </li>
                  <li>
                    <c-s>pub fn scope_id(&self) -> u32</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_scope_id(&mut self, new_scope_id: u32)</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>AddrParseError</c-s>
                <ul class="tight">
                  <li>Traits: <c-s>Error, Debug, Display, Clone, Eq, PartialEq, ...</c-s></li>
                </ul>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <strong>Enums:</strong>
    </t-b>
    <t-b>
      The net library has enums: IpAddr, SocketAddr, Shutdown, and Ipv6MulitcastScope.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of net Enums</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>pub enum IpAddr { V4(Ipv4Addr), V6(Ipv6Addr), }</c-s>
              </li>
              <li>
                <c-s>pub enum SocketAddr { V4(SocketAddrV4), V6(SocketAddrV6), }</c-s>
              </li>
              <li>
                <c-s>pub enum Shutdown { Read, Write, Both, }</c-s>
              </li>
              <li>
                <c-s>pub enum Ipv6MulticastScope {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;InterfaceLocal, LinkLocal, RealmLocal, AdminLocal, SiteLocal, OrganizationLocal, Global,<br />
                }</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::net::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>fs_echo::main.rs</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// fs_echo::main.rs - demonstrate file operations          //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 15 May 2020  //
/////////////////////////////////////////////////////////////

use std::fs::*;
use std::io::*;

/*-----------------------------------------------------------
   Note:
   The try operator ? has been used in several places in 
   both using_File and using_OpenOptions to avoid a lot
   of explicit error handling.

   The try operator bubbles errors up to the caller, so
   if there are several places where errors may occur, 
   they can all be handled in one place by the caller.

   What is surprising, but useful, is that the Result&lt;T,E&gt;
   types are not all the same.  In some results the type T
   is File, or (), or usize.  However, the error types are
   all io::Error, and that is what ? returns to the caller,
   so it just works!

   If there are no errors, ? simply unwraps the result to 
   be used, and everything is significantly simpler.
*/
#[allow(non_snake_case)]
fn using_File(file_name:&amp;str, msg:&amp;str)
     -&gt; std::io::Result&lt;()&gt; {
    let mut wfile = File::create(file_name)?;
    print!(
        "\n  writing message {:?} to file {:?}", 
        msg, file_name
    );
    wfile.write_all(msg.as_bytes())?;
    let mut rfile = File::open(file_name)?;
    let mut rcv_msg = String::new();
    let _ = rfile.read_to_string(&amp;mut rcv_msg);
    print!(
        "\n  message {:?} read from {:?}", 
        rcv_msg, file_name
    );
    Ok(())
}
fn open_file_for_write(path:&amp;str)
     -&gt; std::io::Result&lt;File&gt; {
    let wfile = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(path)?;
    Ok(wfile)
}
fn open_file_for_read(path:&amp;str)
       -&gt; std::io::Result&lt;File&gt; {
    let rfile = OpenOptions::new()
                .read(true)
                .open(path)?;
    Ok(rfile)
}
#[allow(non_snake_case)]
fn using_OpenOptions(file_name:&amp;str, msg:&amp;str)
    -&gt; std::io::Result&lt;()&gt; {
    let mut wfile = open_file_for_write(file_name)?;
    print!(
        "\n  writing message {:?} to file {:?}", 
        msg, file_name
    );
    wfile.write_all(msg.as_bytes())?;

    let mut rfile = open_file_for_read(file_name)?;
    let mut rcv_msg = String::new();
    let _ = rfile.read_to_string(&amp;mut rcv_msg);
    print!(
        "\n  message {:?} read from {:?}", 
        rcv_msg, file_name
    );
    Ok(())
}
fn main() -&gt; std::io::Result&lt;()&gt; {
    let putline = || print!("\n");

    let file_name = "test.txt";
    let msg = "msg from writer";
    print!("\n  std::fs echo demonstration");
    print!("\n ============================");
    putline();

    print!("\n  demo using File structure");
    print!("\n ---------------------------");
    using_File(file_name, msg)?;
    putline();

    print!("\n  demo using OpenOptions structure");
    print!("\n ----------------------------------");
    using_OpenOptions(file_name, msg)?;

    println!("\n\n  That's all Folks!\n");
    Ok(())
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
std::fs echo demonstration
============================

demo using File structure
---------------------------
writing message "msg from writer" to file "test.txt"
message "msg from writer" read from "test.txt"

demo using OpenOptions structure
----------------------------------
writing message "msg from writer" to file "test.txt"
message "msg from writer" read from "test.txt"

That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be bound <a href="RustLibraryDemos.html">here</a>.
    </t-b>
    <a id="error"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.5</num-item1><num-item4>error:</num-item4>
    </num-cont>

    <a id="time"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.6</num-item1><num-item4>time:</num-item4>
    </num-cont>

    <a id="thread"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.7</num-item1><num-item4>thread:</num-item4>
    </num-cont>

    <a id="process"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.8</num-item1><num-item4>process:</num-item4>
    </num-cont>

    <a id="epilogue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.6</num-item1><num-item4>Epilogue:</num-item4>
    </num-cont>

    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.7</num-item1><num-item4>References:</num-item4>
    </num-cont>
        <table style="width:calc(100vw - 12rem);">
      <tr>
        <th class="darkItem">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html">A Gentle Introduction To Rust</a>
        </td>
        <td class="lightItem">
          First thing to read.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/book/">The Rust Book</a>
        </td>
        <td class="lightItem">
          Rust docs - walkthrough of syntax
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/reference/">The Rust Reference Book</a>
        </td>
        <td class="lightItem">
          Rust&apos;s approximation of a language standard. Clear and well written, with a glossary at the end.
          Its <a href="https://github.com/rust-lang/reference">github site</a> shows that changes are still being
          actively incorporated.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://cheats.rs/">Rust cheat sheet</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
        <td class="lightItem">
          Container diagrams
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/27683266/how-do-you-do-interprocess-communication-ipc-in-rust">Rust IPC</a></td>
        <td class="lightItem">
          Stackoverflow re Rust IPC
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/31192956/whats-the-de-facto-way-of-reading-and-writing-files-in-rust-1-x">Rust file io</a></td>
        <td class="lightItem">
          Stackoverflow re Rust file io
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/27840394/how-can-a-rust-program-access-metadata-from-its-cargo-package">Rust metadata</a></td>
        <td class="lightItem">
          Stackoverflow re reading metadata from cargo.toml
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">RIP Tutorial on Rust</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, the stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">Learning Rust ebook</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/rust/awesome-learning/book">Rust - Awesome Book</a></td>
        <td class="lightItem">
          lots of interesting discussions from RIP, the Stackoverflow Archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.rs/regex/1.3.7/regex/">std::regex</a></td>
        <td class="lightItem">
          std docs on Regex
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://docs.rs/dtolnay/0.0.8/dtolnay/macro._02__reference_types.html">
            Shared&nbsp;reference&nbsp;&amp;T&nbsp;and&nbsp;exclusive&nbsp;reference&nbsp;&amp;mut&nbsp;T
          </a>
        </td>
        <td class="lightItem">
          More accurate description than immutable reference and mutable reference
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://deterministic.space/">Blog - Pascal's Scribbles</a>
        </td>
        <td class="lightItem">
          Pascal Hertleif - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://blog.mgattozzi.dev/">Blog - Barely Functional</a>
        </td>
        <td class="lightItem">
          Michael Gattozzi - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://blog.mgattozzi.dev/rust-wasm/">Rust and the case for WebAssembly in 2018</a>
        </td>
        <td class="lightItem">
          Michael Gattozzi - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.snoyman.com/blog/2020/05/no-mutable-parameters-in-rust">Blog - S.Noyberg</a>
        </td>
        <td class="lightItem">
          Examples of aysnc/await, tokio, lifetime, ...
        </td>
      </tr>
      <tr>
        <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
        <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
      </tr>
    </table>

  </bb-55>
  <spacer-25></spacer-25>

  <info-bar></info-bar>
</body>
</html>