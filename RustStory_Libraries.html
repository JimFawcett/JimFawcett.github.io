<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Prologue.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Rust StdLibs</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
    h-s2em {
      display: inline-block;
      margin-left: 2em;
      color:#999;
    }
    h-s4em {
      display: inline-block;
      margin-left: 4em;
      color:#999;
    }
    h-s8em {
      display: inline-block;
      margin-left: 8em;
      color: #999;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="RustStory_References.html">N</a>
  <a id="Prev" href="RustStory_Structures.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 5. - Rust Libraries</h1>
      <h3 id="subtitle">std, collectons, fs, net, error, time, thread, process</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row;">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:#fefefa;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_Libraries.html">Libraries</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">top</a>, <a href="#prologue">prologue</a>, <a href="#std">std</a>, 
       <a href="#collections">coll</a>, <a href="#io">io</a>, <a href="#fs">fs</a>, 
       <a href="#net">net</a>, 
       <a href="#thread">thread</a>, <a href="#sync">sync</a>, <a href="#mpsc">mpsc</a>, <a href="#async">async</a>, 
       <a href="#process">process</a>, <a href="#time">time</a>, <a href="#epilogue">epilogue</a>, 
       <a href="#refs">refs</a>
     </rt-b>
   </toc-b>

  <bb-55 class="indent">
    <a id="prologue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.0</num-item1><num-item4>Prologue:</num-item4>
    </num-cont>
    <!--<under-construction class="indent">
      This page is under construction
    </under-construction>-->
    <t-b>
      Rust has a very well-engineered collection of standard libraries. Each library presents trait, structure, function,
      and type definitions.  The structure and function pages have examples for almost everything presented.
    </t-b>
    <t-b>
      <div style="font-size:1em; border:2px solid darkred; padding: 0.5em 1.5em; margin:0em 1.0em;">
        Source code is provided for all the std libraries.
        simply go <a href="https://doc.rust-lang.org/beta/std/">here</a>, 
        browse around and click any of the [src] tabs.
      </div>
    </t-b>
    <t-b>
      Once you are passed the stage of constantly being surprised by ownership rules, you will find the libraries easy to
      use and rich in functionality.
    </t-b>
    <a id="std"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.1</num-item1><num-item4>std:</num-item4>
    </num-cont>
    <t-b>
      Rust has a well endowed collection of more than sixty <strong><a href="https://doc.rust-lang.org/beta/std/">std libraries</a></strong> in the
      std namespace.  You don&apos;t have to declare a use std::*, as the std::prelude::* is automatically applied.
    </t-b>
    <t-b>
      All of the libraries discussed below are part of std.  There are many more - included here are libraries
      I expect you will use most often.
    </t-b>
    <t-b>
      The materials below summarize some of the Rust Library documentation, and give small examples of library use. Note that
      the Rust documentation has examples for almost everything.  The examples here are often a little larger, and
      dig into things that interested me as I learned some of the library content.
    </t-b>
    <a id="convert"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.2</num-item1><num-item4>std::convert:</num-item4>
    </num-cont>
    <t-b>
      Traits for conversions are provided in <a href="https://doc.rust-lang.org/std/convert/index.html">std::convert</a>.
      The traits provided in this module provide ways to convert from one type to another.  Each trait serves a different
      purpose:
      <div class="indent">
        <ul class="tight">
          <li>
            AsRef trait provides cheap (re-interprets) reference-to-reference conversions.
          </li>
          <li>
            AsMut trait provides cheap (re-interprets) mutable-to-mutable conversions.
          </li>
          <li>
            From trait provides consuming (move) value-to-value conversions.
          </li>
        </ul>
      </div>
    </t-b>
    <t-b>
      <div class="indent">
        <ol class="tight pad10">
          <li>
            AsRef:
            <defn-code style="font-size:1.0em;">pub trait AsRef&lt;T&gt; where T: ?Sized, {
  fn as_ref(&self) -> &T
}
            </defn-code>
            <div>
              <details>
                <summary class="labelStyle lightItem">Partial List of Implementors:</summary>
                <div class="">
                  <ul class="tight">
                    <li>
                      <c-s>[T]::as_ref&lt;[T]&gt;() -> &[T];</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_ref&lt;[T]&gt;() -> &[T];</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_ref&lt;Vec&lt;T&gt;&gt;() -> &Vec&lt;T&gt;</c-s>
                    </li>
                    <li>
                      <c-s>Box&lt;T&gt;::as_ref&lt;T&gt;() -> &T;</c-s><br />
                      <c-s>where T: ?Sized</c-s>
                    </li>
                    <li>
                      <c-s>Arc&lt;T&gt;::as_ref&lt;T&gt;() -> &T;</c-s><br />
                      <c-s>where T: ?Sized</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;[u8]&gt;() -> &[u8];</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;str&gt;() -> &str;</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;[u8]&gt;() -> &[u8];</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;str&gt;() -> &str;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;Path&gt;() -> &Path;</c-s>
                    </li>
                    <li>
                      <c-s>CStr::as_ref&lt;CStr&gt;() -> &CStr;</c-s>
                    </li>
                    <li>
                      <c-s>CString::as_ref&lt;CStr&gt;() -> &CStr;</c-s>
                    </li>
                    <li>
                      <c-s>OsStr::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>OsString::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>Path::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>PathBuf::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>PathBuf::as_ref&lt;OsStr&gt;() -> &Path;</c-s>
                    </li>
                  </ul>
                </div>
              </details>
            </div>
          </li>
          <li>
            AsMut:
            <defn-code style="font-size:1.0em;">pub trait AsMut&lt;T&gt; where T: ?Sized,
{
  fn as_mut(&mut self) -> &mut T;
}
            </defn-code>
            <div>
              <details>
                <summary class="labelStyle lightItem">Partial List of Implementors</summary>
                <div>
                  <ul class="tight">
                    <li>
                      <c-s>String::as_mut() -> &mut str</c-s>
                    </li>
                    <li>
                      <c-s>[T]::as_mut() -> &mut [T]</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_mut() -> &mut [T]</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_mut() -> &mut Vec&lt;T&gt;</c-s>
                    </li>
                    <li>
                      <c-s>Box&lt;T: ?Sized&gt;::as_mut() -> &mut T</c-s>
                    </li>
                  </ul>
                </div>
              </details>
            </div>
          </li>
          <li>
            From:
            <defn-code style="font-size:1.0em;">pub trait From&lt;T&gt; {
  fn from(T) -> Self
}
            </defn-code>
            <div>
              <details>
                <summary class="labelStyle lightItem">Partial List of Implementors</summary>
                <div>
                  <ul class="tight">
                    <li>
                      String::from(&str)
                    </li>
                    <li>
                      String::from(Box&lt;str&gt;)
                    </li>
                    <li>
                      char::from(u8)
                    </li>
                    <li>
                      PathBuf::from(String)
                    </li>
                    <li>
                      Pathbuf::from(OsString)
                    </li>
                    <li>
                      OsString::from(String)
                    </li>
                    <li>
                      OsString::From(PathBuf)
                    </li>
                    <li>
                      u32::from(char)
                    </li>
                    <li>
                      isize::from(i16)
                    </li>
                    <li>
                      f64::from(f32)
                    </li>
                    <li>
                      f64::from(i16)
                    </li>
                    <li>
                      AtomicI16::from(i16)
                    </li>
                    <li>
                      Vec&lt;u8&gt;::from(String)
                    </li>
                    <li>
                      Vec&lt;T&gt;::from(BinaryHeap&lt;T&gt;)
                    </li>
                    <li>
                      Vec&lt;T&gt;::from(VecDeque&lt;T&gt;)
                    </li>
                    <li>
                      VecDeque&lt;T&gt;::from(Vec&lt;T&gt;)
                    </li>
                    <li>
                      BinaryHeap&lt;T&gt;::from(Vec&lt;T&gt;)
                    </li>
                    <li>
                      Mutex&lt;T&gt;::from(T)
                    </li>
                    <li>
                      RWLock&lt;T&gt;::from(T)
                    </li>
                    <li>
                      Box&lt;[u8]&gt;::from(Box&gt;str&gt;)
                    </li>
                    <li>
                      Box&lt;str&gt;::from(&str)
                    </li>
                    <li>
                      Arc&lt;OsStr&gt;::from(OsString)
                    </li>
                    <li>
                      Arc&lt;Path&gt;::From(PathBuf)
                    </li>
                    <li>
                      Arc&lt;String&gt;::from(String)
                    </li>
                    <li>
                      Arc&lt;T&gt;::from(T)
                    </li>
                    <li>
                      Error::from(kind: ErrorKind)
                    </li>
                    <li>
                      Stdio::from(File)
                    </li>
                    <li>
                      Stdio::from(ChildStdin)
                    </li>
                    <li>
                      Stdio::from(ChildStdout)
                    </li>
                  </ul>
                </div>
              </details>
            </div>
          </li>
        </ol>
      </div>
    </t-b>
    <a id="collections"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.3</num-item1><num-item4>std::collections:</num-item4>
    </num-cont>
    The std namespace has a set of <a href="https://doc.rust-lang.org/std/collections/index.html">std::collections</a> 
    similar to other languages:
    <div class="" style="width:calc(100vw - 15em); padding:15px 0px;">
      <table>
        <tr>
          <th class="darkItem">Collection</th><th class="darkItem">Description</th>
        </tr>
        <tr>
          <td class="lightItem">Vec&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A self expanding indexable array of items of type T, occupying a contiguous block of memory.
            Constant time access to indexed item, linear time insertion and removal.
          </td>
        </tr>
        <tr>
          <td class="lightItem">VecDeque&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A self expanding indexable array of items of type T, with constant-time access, insertion,
            and removal on either end.
          </td>
        </tr>
        <tr>
          <td class="lightItem">LinkedList&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A doubly linked list of items of type T, with linear-time traversal.
          </td>
        </tr>
        <tr>
          <td class="lightItem">HashMap&lt;K, V&gt;</td>
          <td class="lightItem">
            Associative container:<br />
            A hashed container with almost constant time access.  Elements are randomly ordered
            (if the hash function works well for T)
          </td>
        </tr>
        <tr>
          <td class="lightItem">BTreeMap&lt;K,&nbsp;V&gt;</td>
          <td class="lightItem">
            Associative container:<br />
            A balanced binary tree container with log n time access.  Elements are sorted.
          </td>
        </tr>
        <tr>
          <td class="lightItem">HashSet&lt;K&gt;</td>
          <td class="lightItem">
            Set container:<br />
            A hashed container with almost constant time access.  Elements are randomly ordered
            (if the hash function works well for T)
          </td>
        </tr>
        <tr>
          <td class="lightItem">BTreeSet&lt;K&gt;</td>
          <td class="lightItem">
            Set container:<br />
            A balanced binary tree container with log n time access.  Elements are sorted.
          </td>
        </tr>
        <tr>
          <td class="lightItem">BinaryHeap&lt;T&gt;</td>
          <td class="lightItem">
            Priority queue:<br />
            Largest element is accessed in constant time.
          </td>
        </tr>
      </table>
    </div>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::collections::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Collections_echo</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// collections_echo - demonstrate collections library      //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 May 2020  //
/////////////////////////////////////////////////////////////

use std::collections::*;
use std::fmt::*;

/*-- displays type name and value --*/
fn show_type&lt;T: Debug&gt;(t:&amp;T) {
    let name = std::any::type_name::&lt;T&gt;();
    print!("\n  type: {:?}", name);
    print!("\n  {:?}", &amp;t);
}
/*-- echo function shows the type and value of its arg --*/
/*---------------------------------------------------------
   Illustrates how to accept and return iterable
   generic type
*/
fn echo&lt;C: Debug + Clone + IntoIterator&gt;(c:&amp;C) -&gt; &amp;C 
   where C::Item: Debug, {
    show_type(c);
    print!("\n  items are: ");
    let iter = c.clone().into_iter();  // iter consumes
    for item in iter {
        print!("{:?} ", item);
    }
    c
}
/*-- demonstration --*/
fn main() {
    let putline = || { print!("\n"); };

    print!("\n  collections_echo");
    print!("\n ==================");

    let v = vec![1,2,3];
    let r = echo(&amp;v);
    print!("\n\n  echo fn returned:");
    show_type(&amp;r);
    putline();

    let mut vd = VecDeque::&lt;f64&gt;::new();
    vd.push_back(1.0);
    vd.push_front(2.5);
    vd.push_back(-1.5);
    let r = echo(&amp;vd);
    print!("\n\n  echo fn returned:");
    show_type(&amp;r);
    putline();

    let mut hm = HashMap::&lt;i32, &amp;str&gt;::new();
    hm.insert(0,"zero");
    hm.insert(1,"one");
    hm.insert(2,"two");
    let r = echo(&amp;hm);
    print!("\n\n  echo fn returned:");
    show_type(&amp;r);
    putline();

    println!("\n  That's all Folks!\n");
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  collections_echo
 ==================
  type: "alloc::vec::Vec<i32>"
  [1, 2, 3]
  items are: 1 2 3

  echo fn returned:
  type: "&alloc::vec::Vec<i32>"
  [1, 2, 3]

  type: "alloc::collections::vec_deque::VecDeque<f64>"
  [2.5, 1.0, -1.5]
  items are: 2.5 1.0 -1.5

  echo fn returned:
  type: "&alloc::collections::vec_deque::VecDeque<f64>"
  [2.5, 1.0, -1.5]

  type: "std::collections::hash::map::HashMap<i32, &str>"
  {0: "zero", 1: "one", 2: "two"}
  items are: (0, "zero") (1, "one") (2, "two")

  echo fn returned:
  type: "&std::collections::hash::map::HashMap<i32, &str>"
  {0: "zero", 1: "one", 2: "two"}

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      Find code for this example <a href="RustLibraryDemos.html">here</a>.
    </t-b>
    <num-cont><num-item1>3.3.1</num-item1><num-item4>Iterators:</num-item4></num-cont>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/iter/index.html">std::iter</a>
    </t-b>
    <t-b>
      Iterators support iterating through collections.  They come in three flavors:
      <div class="indent pad5">
        <ul class="tight">
          <li>
            iter(), which iterates over &T
          </li>
          <li>
            iter_mut(), which iterates over &mut T
          </li>
          <li>
            into_iter(), which iterates over T
          </li>
        </ul>
      </div>
      Note that into_iter is a consuming iterator, moving items from source to destination.
    </t-b>
    <t-b>
      Iterators are lazy: they don&apos;t do anything until consumed, e.g.:
    </t-b>
    <t-b>
      <div>
        <defn-code style="font-size:1.0em;">coll.iter().for_each(|x| { /* do something with x */ });
    <t-s>or</t-s>
for x in &coll { /* do something else with x */ };
        </defn-code>
      </div>
    </t-b>
    <t-b>
      <strong>Traits:</strong>
    </t-b>
    <t-b>
      <div class="indent">
        <ol class="tight">
          <li>
            <defn-code style="font-size:1.0em; margin-left:-15px;">trait Iterator {
    type Item;
    fn next(&mut self) -> Option&lt;Self::Item&gt;
    fn count(self) -> usize
    fn last(self) -> Option&lt;Self::Item&gt;
    fn nth(&mut self, n: usize) -> Option&lt;Self::Item&gt;
    fn step_by(self, step: usize) -> StepBy&lt;Self&gt;
    fn map&lt;B, F&gt;(self, f: F) -> Map&lt;Self, F&gt;
       where F: FnMut(Self::Item) -> B
    fn for_each&lt;F&gt;(self, f: F)
       where F: FnMut(Self::Item)
    fn filter&lt;P&gt;(self, predicate: P) -> Filter&lt;Self, P&gt;
       where P: FnMut(&Self::Item) -> bool
    ...
}
            </defn-code>
          </li>
          <li>
            <defn-code style="font-size:1.0em; margin-left:-15px;">trait IntoIterator {
    type Item;
    type IntoIter: Iterator
    fn into_iter(self) -> Self::IntoIter
}
            </defn-code>
          </li>
        </ol>
      </div>
    </t-b>
    <t-b>
      Iterators provide a set of adapter methods for performing common operations on containers.
      Here&apos;s a longer partial list - see 
      <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Trait&nbsp;std::iter::Iterator</a>
      for more details:
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">Partial List of Iterator Adapters</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>fn <strong>next</strong>(&mut self) -> Option&lt;Self::Item&gt;</c-s><br />
                <s-5px></s-5px>
                Advances and returns value.
              </li>
              <li>
                <c-s>fn map&lt;B, F&gt;(self, f:F) -> Map&lt;Self, F&gt;</c-s><br />
                <c-s> where F: FnMut(Self::Item) -> B</c-s><br />
                <s-5px></s-5px>
                Takes a closure and creates an iterator that applies the closure to each item.
              </li>
              <li>
                <c-s>fn filter&lt;P&gt;(self, predicate:P) -> Filter&lt;Self, P&gt;</c-s><br />
                <c-s>where P: FnMust(&Self::Item) -> bool</c-s><br />
                <s-5px></s-5px>
                Creates an iterator that determines if an item should be included.
              </li>
              <li>
                <c-s>fn take(self, n:usize) -> Take&lt;Self&gt;</c-s>
              </li>
              <li>
                <c-s>
                  fn take_while&lt;P&gt;(self, predicate: P) -> TakeWhile&lt;Self, P&gt;<br />
                  where P: FnMut(&Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>
                  fn fold&lt;B, F&gt;(self, init:B, f:F) -> B<br />
                  where FnMut(B, Self::Item) -> B
                </c-s>
              </li>
              <li>
                <c-s>fn skip(self, n:usize) -> Skip&lt;Self&gt;</c-s>
              </li>
              <li>
                <c-s>
                  fn collect&lt;B&gt;(self) -> B<br />
                  where B: FromIterator&lt;Self::Item&gt;
                </c-s>
              </li>
              <li>
                <c-s>step_by(self, step:usize) -> StepBy&lt;Self&gt;<br /></c-s>
                <s-5px></s-5px>
                Skips step items on each iteration
              </li>
              <li>
                <c-s>nth(&mut self, n:usize) -> Option&lt;Self::item&gt;<br /></c-s>
                <s-5px></s-5px>
                Returns nth item, counting from zero
              </li>
              <li>
                <c-s>last(self) -> Option&lt;Self::item&gt;<br /></c-s>
                <s-5px></s-5px>
                Consumes iterator, returning last item
              </li>
              <li>
                <c-s>
                  fn find&lt;P&gt;(&mut self, predicate: P) -> Option&lt;Self::Item&gt;<br />
                  where FnMut(&Self::Item) -> bool
                </c-s> 
              </li>
              <li>
                <c-s>
                  fn position&lt;P&gt;(&mut self, predicate: P) -> Option&lt;usize&gt;<br />
                  where P: FnMut(Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>
                  fn for_each&lt;F&gt;(self, f:F)<br />
                  where F: FnMut(Self::Item)<br />
                </c-s>
                <s-5px></s-5px>
                Calls a closure on each element of an iterator.
              </li>
              <li>
                <c-s>fn enumerate(self) -> Enumerate&lt;Self&gt;<br /></c-s>
                <s-5px></s-5px>
                Creates an iterator returns a pair with current iteration count and next value.
              </li>
              <li>
                <c-s>fn by_ref(&mut self) -> &mut Self</c-s>
              </li>
              <li>
                <c-s>
                  fn all&lt;F&gt;(&mut self, f:F) -> bool<br />
                  where F: FnMut(Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>
                  fn any&lt;F&gt;(&mut self, f:F) -> bool<br />
                  where F: FnMut(Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>fn count(self) -> usize<br /></c-s>
                <s-5px></s-5px>
                Consumes iterator, counting number of iterations
              </li>
              <li>
                <c-s>
                  fn chain&lt;U&gt;(self, other: U) -> Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;<br />
                  where U: IntoIterator&lt;Self::Item&gt;
                </c-s>
              </li>
              <li>
                <c-s>
                  fn zip&lt;U&gt;(self, other: U) -> Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;<br />
                  where U: IntoIterator
                </c-s>
              </li>
              <li>
                <c-s>
                  fn sum&lt;S&gt;(self) -> S<br />
                  where S: Sum&lt;Self::Item&gt;
                </c-s>
              </li>
              <li>
                <c-s>
                  fn product&lt;P&gt;(self) -> P<br />
                  where P: Product&lt;Self::Item&gt;
                </c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;iteration_echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>iteration_echo</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// iter_echo::main.rs - demonstrating iteration            //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 May 2020  //
/////////////////////////////////////////////////////////////

use std::collections::*;

fn main() {

    let putline = || print!("\n");

    let mut hm: HashMap&lt;i32, &amp;str&gt; = HashMap::new();
    hm.insert(0, "zero");
    hm.insert(1, "one");
    hm.insert(2, "two");
    hm.insert(3, "three");
    hm.insert(4, "four");
    hm.insert(5, "five");
    hm.insert(6, "six");

    let iter = hm.iter();
    print!("\n  iterating over hashmap:\n  ");
    for item in iter {
        print!("{:?}", item);
    }
    putline();
    /*-- previous iter consumed so make new one --*/
    let iter = hm.iter();
    print!("\n  iterating and selecting odd entries:\n  ");
    for item in iter.step_by(2) {
        print!("{:?}", item);
    }
    putline();
    /*-- previous iter consumed so make new one --*/
    let iter = hm.iter();
    print!("\n  iterating and selecting even entries:\n  ");
    for item in iter.skip(1).step_by(2) {
        print!("{:?}", item);
    }
    putline();

    println!("\n  That's all Folks!\n");
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>

  iterating over hashmap:
  (4, "four")(6, "six")(2, "two")(1, "one")
  (0, "zero")(3, "three")(5, "five")        

  iterating and selecting odd entries:
  (4, "four")(2, "two")(0, "zero")(5, "five")

  iterating and selecting even entries:
  (6, "six")(1, "one")(3, "three")

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      Find code for this example <a href="RustLibraryDemos.html">here</a>.
    </t-b>
    <t-b>
      Similar to the C++ std::algorithms, iterators provide a readable declarative interface for code doing
      compound operations on collection items.
    </t-b>
    <a id="io"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.4</num-item1><num-item4>std::io</num-item4>
    </num-cont>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/io/index.html">std::io</a>
    </t-b>
    <t-b>
      <strong>Traits:</strong>
    </t-b>
    <t-b>
      Traits are contracts with function signatures that implementors are required to provide.  For example,
      every implementor of the Read trait is obligated to provide <c-s>read</c-s> and all the other methods
      from that trait.  The BufReader and Stdin structs both implement Read.
    </t-b>
    <t-b>
      In the dropdown, below, you will find the most important methods for the Read, BufRead, Seek, and Write
      traits.
    </t-b>
    <t-b>
      <div class="">
        <details>
          <summary class="labelStyle lightItem">Partial List of Traits</summary>
          <div class="indent">
            <s-halfEm></s-halfEm>
        <ol class="tight">
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">pub trait Read {
  fn read(&mut self, buf: &mut [u8]) -> Result&lt;usize&gt;
  fn read_exact(&mut self, buf: &mut [u8]) -> Result&lt;()&gt;
  fn read_to_end(&mut self, buf: &mut Vec&lt;u8&gt;) -> Result&lt;usize&gt;
  fn read_to_string(&mut self, buf: &mut String) -> Result&lt;usize&gt;
  fn by_ref(&mut self) -> &mut Self, where Self: Sized,
  fn bytes(self) -> Bytes&lt;Self&gt;, where Self: Sized,
  ...
}
            </defn-code>
          </li>
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">pub trait BufRead {
  fn fill_buf(&mut self) -> Result&lt;&[u8]&gt;
  fn consume(&mut self, amt: usize)
  fn read_until(&mut self, byte: u8, buf: &mut Vec&lt;u8&gt;) -> Result&lt;usize&gt;
  fn read_line(&mut self, buf: &mut String) -> Result&lt;usize&gt;
  fn lines(self) -> Lines&lt;Self&gt; // an iterator
  ...
}
            </defn-code>
          </li>
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">pub trait Write {
  fn write_all(&mut self, buf: &[u8]) -> Result&lt;()&gt;
  fn write(&mut self, buf: &[u8]) -> Result&lt;usize&gt;
  fn write_fmt(&mut self, fmt: Arguments) -> Result&lt;()&gt;
  fn by_ref(&mut self) -> &mut Self, where Self: Sized,
  fn flush(&mut self) -> Result&lt;()&gt;,
  ...
}
            </defn-code>
          </li>
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">pub trait Seek {
  fn seek(&mut self, pos: SeekFrom) -> Result&lt;u64&gt;
  fn stream_len(&mut self) -> Result&lt;u64&gt;
  ...
}
            </defn-code>
          </li>
        </ol>
            </div>
          </details>
      </div>
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      Structs are used to build library and user-defined types.  Here, you will find definitions for
      BufReader, BufWriter, Error, LineWriter, Stdin, and Stdout types.
    </t-b>
    <t-b>
      Two other structs, Bytes and Lines, are iterator types that provide access to the io state. You will find
      definitions for all of these in the dropdown, below.
    </t-b>
    <t-b>
      <div class="">
        <details>
          <summary class="labelStyle lightItem">Partial List of Structs</summary>
          <div class="indent">
          <s-halfEm></s-halfEm>
        <ol class="tight">
          <li>
            BufReader
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>BufRead, Debug, Read, Seek, ...</c-s>
                </li>
                <li>
                  <c-s>pub fn new(inner: R) -> BufReader&lt;R&gt; where R: Read</c-s>
                </li>
                <li>
                  <c-s>pub fn get_ref(&self) -> &R</c-s>
                </li>
                <li>
                  <c-s>pub fn get_mut(&self) -> &mut R</c-s>
                </li>
                <li>
                  <c-s>pub fn buffer(&self) -> &[u8]</c-s>
                </li>
                <li>
                  <c-s>pub fn into_inner(self) -> R</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            BufWriter
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Drop, Seek, Write ...</c-s>
                </li>
                <li>
                  <c-s>pub fn new(inner: W) -> BufWriter&lt;W&gt; where W: Write</c-s>
                </li>
                <li>
                  <c-s>pub fn get_ref(&self) -> &W</c-s>
                </li>
                <li>
                  <c-s>pub fn get_mut(&self) -> &mut W</c-s>
                </li>
                <li>
                  <c-s>pub fn buffer(&self) -> &[u8]</c-s>
                </li>
                <li>
                  <c-s>pub fn into_inner(self) -> Result&lt;W, IntoInnerError&lt;BufWriter&lt;W&gt;&gt;&gt;</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            Bytes
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Iterator ...</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            Error
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Display, Error, From&lt;ErrorKind&gt;, ...</c-s>
                </li>
                <li>
                  <c-s>pub fn new&lt;E&gt;(kind: ErrorKind, error: E) -> Error</c-s>
                </li>
                <li>
                  <c-s>pub fn get_ref(&self) -> Option&lt;&(dyn Error + Send + Sync + 'static')&gt;</c-s>
                </li>
                <li>
                  <c-s>pub fn get_mut(&mut self) -> Option&lt;&mut (dyn Error + Send + Sync + 'static')&gt;</c-s>
                </li>
                <li>
                  <c-s>pub fn into_inner(self) -> Option&lt;Box&lt;dyn Error + Send + Sync&gt;&gt;</c-s>
                </li>
                <li>
                  <c-s>pub fn kind(&self) -> ErrorKind</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            LineWriter
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Write ...</c-s>
                </li>
                <li>
                  <c-s>pub fn new(inner: W) -> LineWriter&lt;W&gt; where W: Write</c-s>
                </li>
                <li>
                  <c-s>pub fn get_ref(&self) -> &W</c-s>
                </li>
                <li>
                  <c-s>pub fn get_mut(&self) -> &mut W</c-s>
                </li>
                <li>
                  <c-s>pub fn into_inner(self) -> Result&lt;W, IntoInnerError&lt;LineWriter&lt;W&gt;&gt;&gt;</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            Lines
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Iterator ...</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            Stdin
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Read ...</c-s>
                </li>
                <li>
                  <c-s>pub fn lock(&self) -> StdinLock</c-s>
                </li>
                <li>
                  <c-s>pub fn read_line(&self, buf: &mut String) -> Result&lt;usize&gt;</c-s>
                </li>
              </ul>
            </div>
          </li>
          <li>
            Stdout
            <div class="indent">
              <ul class="tight">
                <li>
                  Implements Traits <c-s>Debug, Write ...</c-s>
                </li>
                <li>
                  <c-s>pub fn lock(&self) -> StdoutLock</c-s>
                </li>
              </ul>
            </div>
          </li>
        </ol>
            </div>
          </details>
      </div>
    </t-b>
    <t-b>
      <strong>Functions:</strong>
    </t-b>
    <t-b>
      Here you will find a short list of functions that are occasionally useful for programs dealing with io.
    </t-b>
    <t-b>
      <div class="">
        <details>
          <summary class="labelStyle lightItem">Partial List of Functions</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
        <ol class="tight">
          <li>
            <c-s>pub fn copy&lt;R: ?Sized, W: ?Sized&gt;(reader: &mut R, writer: &mut W) -> Result&lt;u64&gt;</c-s>
          </li>
          <li>
            <c-s>pub fn stderr() -> Stderr</c-s>
          </li>
          <li>
            <c-s>pub fn stdin() -> Stdin</c-s>
          </li>
          <li>
            <c-s>pub fn stdout() -> Stdout</c-s>
          </li>
        </ol>
            </div>
          </details>
      </div>
    </t-b>
    <t-b>
      <strong>Types:</strong>
    </t-b>
    <t-b>
      <div class="indent"><c-s>type Result&lt;T&gt; = Result&lt;T, Error&gt;</c-s></div>
    </t-b>
    <t-b>
      You will find a relatively simple std::io echo program in the dropdown, below.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::io::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>io_echo</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// io_echo::main.rs - std::io library demonstration        //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 May 2020  //
/////////////////////////////////////////////////////////////

use std::io::prelude::*;

fn main() -&gt; std::io::Result&lt;()&gt; {
    print!("\n  Echo std::io");
    print!("\n ==============");

    const QUIT:char = 'q';
    print!("\n  Enter single \'q\' character to terminate program");
    loop {
        print!("\n  enter some text: ");
        let _ = std::io::stdout().flush();
        let mut input_str = String::new();
        let size = std::io::stdin().read_line(&amp;mut input_str)?;

        /////////////////////////////////////////////////////////////
        // line below needs ctrl z to terminate read
        // let size = std::io::stdin().read_to_string(&amp;mut input_str)?

        print!("\n  read {} bytes", size);
        let rslt = input_str.chars().nth(0);
        if rslt == Some(QUIT) &amp;&amp; size == 3 {
            break;
        }
        let out_str = format!("\n  {:?}", input_str);
        std::io::stdout().write_all(out_str.as_ref())?;  // convert to &amp;[u8]
        std::io::stdout().flush()?;
    }
    println!("\n  That's all Folks!");
    Ok(())
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output</defn-head>
              <defn-code>
  Echo std::io
 ==============
  Enter single 'q' character to terminate program
  enter some text: this is a test

  read 16 bytes
  "this is a test\r\n"
  enter some text: another line

  read 14 bytes
  "another line\r\n"
  enter some text: q

  read 3 bytes
  That's all Folks!

              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      You will find the example code <a  href="RustLibraryDemosCode.html">here</a>.
    </t-b>
    <a id="fs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.5</num-item1><num-item4>std::fs</num-item4>
    </num-cont>
    <t-b>
      Working with files and directories is well supported in Rust with the
      <a href="https://doc.rust-lang.org/std/fs/index.html">std::fs</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The most important std::fs types are listed here - DirBuilder, DirEntry, File, FileType, Metadata,
      OpenOptions, Permissions, and ReadDir:
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>DirBuilder</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new() -> DirBuilder</c-s>
                  </li>
                  <li>
                    <c-s>pub fn recursive(&mut self, recursive: bool) -> &mut Self</c-s>
                  </li>
                  <li>
                    <c-s>pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(&mut self, path: P) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn recursive(&mut self, recursive: bool) -> &mut Self</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>DirEntry</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn path(&self) -> PathBuf</c-s>
                  </li>
                  <li>
                    <c-s>pub fn metadata(&mut self) -> Result&lt;Metadata&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn file_type(&mut self) -> Result&lt;FileType&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn file_name(&mut self) -> OsString</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>File</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, Read, Seek, Write, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;File&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;File&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_len(&mut self, size: u64) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn metadata(&mut self) -> Result&lt;Metadata&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_permissions(&mut self, perm: Permissions) -> Result&lt;()&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>FileType</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Clone, Copy, Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_dir(&mut self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_file(&mut self) -> bool</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Metadata</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Clone, Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn file_type(&mut self) -> FileType</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_dir(&mut self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_file(&mut self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn len(&mut self) -> u64</c-s>
                  </li>
                  <li>
                    <c-s>pub fn permissions(&mut self) -> Permissions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn modified(&mut self) -> Result&lt;SystemTime&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn accessed(&mut self) -> Result&lt;SystemTime&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn created(&mut self) -> Result&lt;SystemTime&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>OpenOptions</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Clone, Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new() -> OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn read(&mut self, read: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn write(&mut self, write: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn append(&mut self, append: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn create(&mut self, create: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn create_new(&mut self, create_new: bool) -> &mut OpenOptions</c-s>
                  </li>
                  <li>
                    <c-s>pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(&self, path: P) -> Result&lt;File&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Permissions</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Clone, Debug, Eq, PartialEq, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn readonly(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_readonly(&mut self, readonly: bool)</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>ReadDir</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, Iterator, ...</c-s>
                  </li>
                </ul>
                <div class="indent">
                  <t-b style="margin-top:5px; margin-bottom:5px;">
                    Iterator over entries in a directory, returned from the read_dir(p: Path)
                    function.
                  </t-b>
                  <t-b style="margin-top:5px; margin-bottom:5px;">
                    Yields instances of io::Result&lt;DirEntry&gt;
                  </t-b>
                </div>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <strong>Functions:</strong>
    </t-b>
    <t-b>
      Quite often, you may only need some of the functions, listed here, for a program&apos;s file and directory
      management needs.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">Partial List of IO Functions</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>fn canonicalize&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;PathBuf&gt;</c-s>
              </li>
              <li>
                <c-s>fn create_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn read_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;ReadDir&gt;</c-s>
              </li>
              <li>
                <c-s>fn remove_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn metadata&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;Metadata&gt;</c-s>
              </li>
              <li>
                <c-s>fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;Vec&lt;u8&gt;&gt;</c-s>
              </li>
              <li>
                <c-s>fn read_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;ReadDir&gt;</c-s>
              </li>
              <li>
                <c-s>fn read_to_string&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;String&gt;</c-s>
              </li>
              <li>
                <c-s>fn write&lt;P: AsRef&lt;Path&gt;&gt;, C: AsRef&lt;[u8]&gt;&gt;(path: P, contents: C) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn remove_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn rename&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn set_permissions&lt;P: AsRef&lt;Path&gt;&gt;(path: P, perm: Permissions) -> Result&lt;()&gt;</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::fs::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>fs_echo::main.rs</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// fs_echo::main.rs - demonstrate file operations          //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 15 May 2020  //
/////////////////////////////////////////////////////////////

use std::fs::*;
use std::io::*;

/*-----------------------------------------------------------
   Note:
   The try operator ? has been used in several places in 
   both using_File and using_OpenOptions to avoid a lot
   of explicit error handling.

   The try operator bubbles errors up to the caller, so
   if there are several places where errors may occur, 
   they can all be handled in one place by the caller.

   What is surprising, but useful, is that the Result&lt;T,E&gt;
   types are not all the same.  In some results the type T
   is File, or (), or usize.  However, the error types are
   all io::Error, and that is what ? returns to the caller,
   so it just works!

   If there are no errors, ? simply unwraps the result to 
   be used, and everything is significantly simpler.
*/
#[allow(non_snake_case)]
fn using_File(file_name:&amp;str, msg:&amp;str)
     -&gt; std::io::Result&lt;()&gt; {
    let mut wfile = File::create(file_name)?;
    print!(
        "\n  writing message {:?} to file {:?}", 
        msg, file_name
    );
    wfile.write_all(msg.as_bytes())?;
    let mut rfile = File::open(file_name)?;
    let mut rcv_msg = String::new();
    let _ = rfile.read_to_string(&amp;mut rcv_msg);
    print!(
        "\n  message {:?} read from {:?}", 
        rcv_msg, file_name
    );
    Ok(())
}
fn open_file_for_write(path:&amp;str)
     -&gt; std::io::Result&lt;File&gt; {
    let wfile = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(path)?;
    Ok(wfile)
}
fn open_file_for_read(path:&amp;str)
       -&gt; std::io::Result&lt;File&gt; {
    let rfile = OpenOptions::new()
                .read(true)
                .open(path)?;
    Ok(rfile)
}
#[allow(non_snake_case)]
fn using_OpenOptions(file_name:&amp;str, msg:&amp;str)
    -&gt; std::io::Result&lt;()&gt; {
    let mut wfile = open_file_for_write(file_name)?;
    print!(
        "\n  writing message {:?} to file {:?}", 
        msg, file_name
    );
    wfile.write_all(msg.as_bytes())?;

    let mut rfile = open_file_for_read(file_name)?;
    let mut rcv_msg = String::new();
    let _ = rfile.read_to_string(&amp;mut rcv_msg);
    print!(
        "\n  message {:?} read from {:?}", 
        rcv_msg, file_name
    );
    Ok(())
}
fn main() -&gt; std::io::Result&lt;()&gt; {
    let putline = || print!("\n");

    let file_name = "test.txt";
    let msg = "msg from writer";
    print!("\n  std::fs echo demonstration");
    print!("\n ============================");
    putline();

    print!("\n  demo using File structure");
    print!("\n ---------------------------");
    using_File(file_name, msg)?;
    putline();

    print!("\n  demo using OpenOptions structure");
    print!("\n ----------------------------------");
    using_OpenOptions(file_name, msg)?;

    println!("\n\n  That's all Folks!\n");
    Ok(())
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
std::fs echo demonstration
============================

demo using File structure
---------------------------
writing message "msg from writer" to file "test.txt"
message "msg from writer" read from "test.txt"

demo using OpenOptions structure
----------------------------------
writing message "msg from writer" to file "test.txt"
message "msg from writer" read from "test.txt"

That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be bound <a href="RustLibraryDemos.html">here</a>.
    </t-b>
    <a id="net"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.6</num-item1><num-item4>net:</num-item4>
    </num-cont>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/net/index.html">std::net</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::net types are: TcpListener, Incoming, TcpStream, UdpSocket,
      Ipv4Addr, Ipv6Addr, SocketAddrV4, SocketAddrV6, AddrParseError:
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>TcpListener</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn bind&lt;A: ToSocketAddrs&gt;(addr: A) -> Result&lt;TcpListener&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn accept(&self) -> Result&lt;(TcpStrea,. SpcletAddr)&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn inoming(&self) -> Incoming</c-s>
                  </li>
                  <li>
                    <c-s>pub fn take_error(&self) -> Result&lt;Option&lt;Error&gt;&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_nonblocking(&self, nonblocking: bool) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>TcpStream</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Read, Write, Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn connect&lt;A: ToSoketAddrs&gt;(addr: A) -> Result&lt;TcpStream&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn shutdown(&self, how: Shutdown) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn peek(&mut self, buf: &mut [u8]) -> Result&lt;usize&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn take_error(&self) -> Result&lt;Option&lt;Error&gt;&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_nonblocking(&self, nonblocking: bool) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>UdpSocket</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn bind&lt;A: ToSocketAddrs&gt;(addr: A) -> Result&lt;TcpListener&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn recv_from(&self, buf: &mut [u8]) -> Result&lt;(usize, SocketAddr)&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn peek_from(&self, buf: &mut [u8]) -> Result&lt;(usize, SocketAddr)&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn send_to&lt;A: ToSocketAddrs&gt;(&self, buf: &[u8], addr: A) -> Result&lt;usize&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_broadcast(&self, broadcast: bool) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn broadcast(&mut self) -> Result&lt;bool&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn take_error(&self) -> Result&lt;Option&lt;Error&gt;&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn connect&lt;A: ToSocketAddrs&gt;(&self, addr: A) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn send(&self, buf: &mut [u8]) -> Result&lt;usize&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn recv(&self, buf: &mut [u8]) -> Result&lt;usize&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn peek(&self, buf: &mut [u8]) -> Result&lt;usize&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_nonblocking(&self, nonblocking: bool) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>Ipv4Addr</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, Display, copy, clone, Eq, PartialEq, From ...</c-s>
                  </li>
                  <li>
                    <c-s>pub const fn new(a: u8, b: u8, c: u8, d: u8) -> IpvrAddr</c-s>
                  </li>
                  <li>
                    <c-s>pub const LOCALHOST: Self</c-s>
                  </li>
                  <li>
                    <c-s>pub const UNSPECIFIED: Self</c-s>
                  </li>
                  <li>
                    <c-s>pub const BROADCAST: Self</c-s>
                  </li>
                  <li>
                    <c-s>pub fn octets(&self) -> [u8; 4]</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_unspecified(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_loopback(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_private(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_multicast(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_broadcast(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn to_ipv6_compatible(&self) -> Ipv6Addr</c-s>
                  </li>
                  <li>
                    <c-s>pub fn to_ipv6_mapped(&self) -> Ipv6Addr</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Ipv6Addr</c-s>
                <ul class="tight">
                  <li>
                    Implements Traits <c-s>Debug, Display, copy, clone, Eq, PartialEq, From ...</c-s>
                  </li>
                  <li>
                    <c-s>pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> IpvrAddr</c-s>
                  </li>
                  <li>
                    <c-s>pub const LOCALHOST: Self</c-s>
                  </li>
                  <li>
                    <c-s>pub const UNSPECIFIED: Self</c-s>
                  </li>
                  <!--<li>
                    <c-s>pub const BROADCAST: Self</c-s>
                  </li>-->
                  <li>
                    <c-s>pub fn segments(&self) -> [u16; 8]</c-s>
                  </li>
                  <li>
                    <c-s>pub fn octets(&self) -> [u8; 16]</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_unspecified(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_loopback(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_multicast(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn to_ipv4(&self) -> Ipv4Addr</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>SocketAddrV4</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Display, Copy, Clone, Eq, PartialEq, From, FromStr, ToSocketAddrs, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4</c-s>
                  </li>
                  <li>
                    <c-s>pub fn ip(&self) -> &Ipv4Addr</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_ip(&mut self, new_ip: Ipv4Addr)</c-s>
                  </li>
                  <li>
                    <c-s>pub fn port(&self) -> u16</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_port(&mut self, new_port: u16)</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>SocketAddrV6</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Display, Copy, Clone, Eq, PartialEq, From, FromStr, ToSocketAddrs, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6</c-s>
                  </li>
                  <li>
                    <c-s>pub fn ip(&self) -> &Ipv6Addr</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_ip(&mut self, new_ip: Ipv6Addr)</c-s>
                  </li>
                  <li>
                    <c-s>pub fn port(&self) -> u16</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_port(&mut self, new_port: u16)</c-s>
                  </li>
                  <li>
                    <c-s>pub fn flowinfo(&self) -> u32</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_flowinfo(&mut self, new_flowinfo: u32)</c-s>
                  </li>
                  <li>
                    <c-s>pub fn scope_id(&self) -> u32</c-s>
                  </li>
                  <li>
                    <c-s>pub fn set_scope_id(&mut self, new_scope_id: u32)</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>AddrParseError</c-s>
                <ul class="tight">
                  <li>Traits: <c-s>Error, Debug, Display, Clone, Eq, PartialEq, ...</c-s></li>
                </ul>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <strong>Enums:</strong>
    </t-b>
    <t-b>
      The net library has enums: IpAddr, SocketAddr, Shutdown, and Ipv6MulitcastScope.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of net Enums</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>pub enum IpAddr { V4(Ipv4Addr), V6(Ipv6Addr), }</c-s>
              </li>
              <li>
                <c-s>pub enum SocketAddr { V4(SocketAddrV4), V6(SocketAddrV6), }</c-s>
              </li>
              <li>
                <c-s>pub enum Shutdown { Read, Write, Both, }</c-s>
              </li>
              <li>
                <c-s>pub enum Ipv6MulticastScope {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;InterfaceLocal, LinkLocal, RealmLocal, AdminLocal, SiteLocal, OrganizationLocal, Global,<br />
                }</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::net::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>net_echo::main.rs</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// net_echo::main.rs - demonstrate Tcp communication       //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 16 May 2020  //
/////////////////////////////////////////////////////////////
/*
   This demo uses TcpListener and TcpStream which use 
   sockets internally.  So, like sockets, they are byte
   oriented.

   In order to send messages, the application needs a 
   protocol for defining when to stop reading bytes.
   For this, newlines are used as message terminators,
   which works well for this demonstration.

   An application will probably need something more
   flexible like HTTP style messages.
*/
use std::io::prelude::*;
use std::net::{TcpStream, TcpListener, Shutdown::Both};
use std::thread;
use std::str;
use std::io::{BufReader};

/*-- demo handler receives one msg and replys --*/
fn handle_client(mut stream: &amp;TcpStream)
       -&gt; std::io::Result&lt;()&gt; {
    print!("\n  entered client handler");
    let mut reader = 
        BufReader::new(stream.try_clone()?);
    let mut rcv_msg = String::new();
    reader.read_line(&amp;mut rcv_msg)?;
    rcv_msg.pop();  // remove '\n' sentinal
    print!("\n  client handler received: ");
    print!("{:?}",rcv_msg);
    let _ = std::io::stdout().flush();

    rcv_msg.push_str(" recieved!\n");
    let _ = std::io::stdout().flush();
    stream.write_all(&amp;rcv_msg.as_bytes())?;
    stream.shutdown(Both)?;
    Ok(())
}
/*-- demo listener accepts only one connection --*/
fn start_listener(end_point :&amp;str)
        -&gt; std::io::Result&lt;()&gt; {
    print!(
        "\n  starting listener on {:?}", end_point
    );
    let _ = std::io::stdout().flush();
    let tcpl = TcpListener::bind(end_point)?;
    for stream in tcpl.incoming() {
        print!("\n  listener accepted connection");
        let _ = handle_client(&amp;stream?)?;
        /*-- Here, just accept one connection --*/
        break;
    }
    Ok(())
}
/*-- demonstration --*/
fn main() -&gt; std::io::Result&lt;()&gt; {

    print!("\n  net_echo demonstration");
    print!("\n ========================");

    let rcvr_endpoint = "127.0.0.1:8080";
    let mut msg = "msg from connector".to_string();

    /*-- run listener on child thread --*/
    let handle = thread::spawn( 
        move || { 
            let _ = start_listener(rcvr_endpoint); 
        }
    );

    /*-- send message --*/
    print!("\n  connecting to {:?}", rcvr_endpoint);
    let mut stream = 
        TcpStream::connect(rcvr_endpoint)?;
    print!("\n  sending message {:?}", msg);
    msg.push('\n');  // message end sentinal
    stream.write_all(&amp;msg.as_bytes())?;

    /*-- read reply message --*/
    let mut reader = 
        BufReader::new(stream.try_clone()?);
    let mut rcv_msg = String::new();
    reader.read_line(&amp;mut rcv_msg)?;
    rcv_msg.pop();  // remove '\n' sentinal
    print!(
        "\n  connector received reply {:?}", rcv_msg
    );
    let _ = std::io::stdout().flush();

    let _ = handle.join();  // wait for shutdown

    println!("\n\n  That's all Folks!\n\n");
    Ok(())
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  net_echo demonstration
 ========================
  connecting to "127.0.0.1:8080"
  starting listener on "127.0.0.1:8080"
  sending message "msg from connector"
  listener accepted connection
  entered client handler
  client handler received: "msg from connector"
  connector received reply 
                "msg from connector recieved!"

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be found <a href="RustLibraryDemos.html">here</a>.
    </t-b>

    <a id="thread"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.7</num-item1><num-item4>thread:</num-item4>
    </num-cont>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/thread/index.html">std::thread</a> library.
    </t-b>
    <t-b>
      Thread related Traits:
      <div class="indent">
        <ol class="tight">
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">trait Send { }
// marker trait
// - types that can be transferred across thread boundaries
          </defn-code>
          </li>
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">trait Sync { }
// marker trait
// - types for which it is safe to share references between threads
          </defn-code>
          </li>
        </ol>
      </div>
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::thread types are: Thread, Builder, ThreadId, JoinHandle, LocalKey, AcessError  
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>Thread</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Clone, Send, Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn id(&self) -> ThreadId</c-s>
                  </li>
                  <li>
                    <c-s>pub fn name(&self) -> Option&lt;&amp;str&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>ThreadId</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Copy, Clone, Eq, PartialEq, Send, Sync, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Builder</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Send, Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new() -> Builder</c-s>
                  </li>
                  <li>
                    <c-s>pub fn name(self, name: String) -> Builder</c-s>
                  </li>
                  <li>
                    <c-s>pub fn stack_size(self, size: usize) -> Builder</c-s>
                  </li>
                  <li>
                    <c-s>pub fn spawn&lt;F, T&gt;(self, f: F) -> Result&lt;JoinHandle&lt;T&gt;&gt;</c-s><br />
                    <c-s>where F: FnOnce() -> T, F: Send + 'static', T: Send + 'static'</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>JoinHandle</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Send, Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn thread(&self) -> &Thread</c-s>
                  </li>
                  <li>
                    <c-s>pub fn join(self) -> Result&lt;T&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>LocalKey</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Send, Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn with&lt;F, R&gt;(&'static self, f: F) -> R</c-s>
                    <c-s>where F: FnOnce(&T) -> R</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>AccessError</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Display, Clone, Copy, Eq, PartialEq, Error, Send, Sync, ...</c-s>
                  </li>
                </ul>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      Thread functions are: spawn, current, sleep, yield_now, ...
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Functions</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>pub fn spawn&lt;F, T&gt;(f: F) -> JoinHandle&lt;T&gt;</c-s>
                <c-s>where F: FnOnce() -> T, F: Send + 'static, T: Send + 'static</c-s>
              </li>
              <li>
                <c-s>pub fn current() -> Thread</c-s>
              </li>
              <li>
                <c-s>pub fn sleep(dur: std::time::Duration)</c-s>
              </li>
              <li>
                <c-s>pub fn yield_now()</c-s>
              </li>
              <li>
                <c-s>...</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      Types:
      <div class="indent">
        <c-s>type Result&lt;T&gt; = Result&ltT, Box&lt;dyn Any + Send + 'static&gt;&gt;</c-s>
      </div>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::thread::Shared</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>std::thread::shared</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// thread_shared::main.rs - shared string demo             //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 10 May 2020  //
/////////////////////////////////////////////////////////////

#![allow(dead_code)]

use std::thread;
use std::sync::{Arc, Mutex};
use std::time::Duration;

fn db_show&lt;T:std::fmt::Debug&gt;(t:T, msg:&amp;str, p:bool) {
    print!("\n  --{}", msg);
    if p {
        let name = std::any::type_name::&lt;T&gt;();
        print!(
            "\n  --TypeId: {},
            \n  --size: {}", 
            name, std::mem::size_of::&lt;T&gt;()
        );
    }
    print!("\n  --{:?}", t);
} 
fn thread_id() -&gt; thread::ThreadId {
    thread::current().id()
}
fn thread_id_value(id:thread::ThreadId) -&gt; char {
    let sid = format!("{:?}", id);
    sid.chars().nth(9).unwrap()
}
fn test2() -&gt; std::io::Result&lt;()&gt; {
    print!("\n  Two child threads sharing string");
    print!("\n ==================================");

    let thrd1_id = thread_id_value(thread::current().id());
    print!("\n  main thread id      = {:?}", thrd1_id);
    let dur = Duration::from_millis(2);  // sleep time
    let mut s = String::new();            // shared string
    s.push(thrd1_id);  // main thread gets first edit

    let data = Arc::new(Mutex::new(s));   
    // thread safe shared wrapper
    
    /*-------------------------------------------------------
        Modify String s on child thread #1
    */
    let shared1 = Arc::clone(&amp;data);
    // clones pointer to data ref
    let _handle1 = thread::spawn(move || { 
        // shared1 clone moved without moving data
        let sid:String = format!("{:?}",thread::current().id());
        // sid = "ThreadId(2)"
        if let Some(sid) = sid.chars().nth(9) {
            // ThreadId(2) =&gt; 2
            for _i in 0..15 {
                {
                    if let Ok(mut temp) = shared1.lock() {
                        temp.push(sid);  // append thread id
                    }
                }  // unlocked here
                thread::sleep(dur);
            }
        }
    });
    
    /*-------------------------------------------------------
        Modify String s on child thread #2
    */
    let shared2 = Arc::clone(&amp;data);
    // db_show(&amp;shared2, "shared2", false);
    let _handle2 = thread::spawn(move || { 
        let sid:String = format!("{:?}",thread::current().id());
        if let Some(sid) = sid.chars().nth(9) {
            for _i in 0..15 {
                {
                    if let Ok(mut temp) = shared2.lock() {
                        temp.push(sid);
                    }
                }
                thread::sleep(dur);
            }
        }
    });
    /*-------------------------------------------------------
        main thread displaying child threads ids and then
        joining them, e.g., block until threads complete
    */
    let thrd2_id = thread_id_value(_handle1.thread().id());
    print!("\n  1st child thread id = {:?}", thrd2_id);
    let _ = _handle1.join();
    let thrd3_id = thread_id_value(_handle2.thread().id());
    print!("\n  2nd child thread id = {:?}", thrd3_id);
    let _ = _handle2.join();

    /*-------------------------------------------------------
        extract mutex from arc
        - commented line is simple but may panic
        - code used here manages error without panic
    */
    // let out = Arc::try_unwrap(data).expect("lock still owned");
    let rslt = Arc::try_unwrap(data);
    let out :Mutex&lt;String&gt;;
    match rslt {
        Ok(mtx) =&gt; out = mtx,
        Err(_) =&gt; {
            let error = std::io::Error::new(
                std::io::ErrorKind::Other, 
                "Arc access error"
            );
            return Err(error);
        },
    }
    /*-------------------------------------------------------
        extract string from mutex
        - commented line is simple but may panic
        - code used here manages error without panic
    */
    //let mut shared = out.into_inner().expect("can't lock mutex");
    let mut shared: String;
    let rslt = out.into_inner();
    match rslt {
        Ok(s) =&gt; shared = s,
        Err(_) =&gt; {
            let error = std::io::Error::new(
                std::io::ErrorKind::Other, 
                "Mutex access error"
            );
            return Err(error);
        } 
    }
    shared.push(thrd1_id);  // main thread has last edit

    /*-- display result of string modifications --*/
    print!("\n  final shared string value = {:?}",shared);
    Ok(())
}
fn main() -&gt; std::io::Result&lt;()&gt; {

    test2()?;

    println!("\n\n  That's all Folks!\n\n");
    Ok(())
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  Two child threads sharing string
 ==================================
  main thread id      = '1'
  1st child thread id = '2'
  2nd child thread id = '3'
  final shared string value = 
      "12323322332233223323232323223231"   

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be found in <a href="RustLibraryDemos.html">RustLibraryDemos</a>.
    </t-b>

    <a id="sync"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.8</num-item1><num-item4>sync:</num-item4>
    </num-cont>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/sync/index.html">std::sync</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::sync types are: Arc, Barrier, BarrierWaitResult, Condvar, Mutex, MutexGuard, Once, PoisonError,
      RwLock, RwLockReadGuard, RwLockWriteGuard, WaitTimeoutResult, Weak, OnceState
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.Arc.html">Arc</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Display, Default, AsRef&lt;T&gt;, Deref, From, FromIterator, Eq, PartialEq, 
                    Pointer, Send, Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new(data: T) -> Arc&lt;T&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn try_unwrap(this: Arc&lt;T&gt;) -> Result&lt;T, Arc&lt;T&gt;&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn downgrade(this: &Arc&lt;T&gt;) -> Weak&lt;T&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn weak_count(this: &Arc&lt;T&gt;) -> usize</c-s>
                  </li>
                  <li>
                    <c-s>pub fn strong_count(this: &Arc&lt;T&gt;) -> usize</c-s>
                  </li>
                  <li>
                    <c-s>pub fn ptr_eq(this: &Arc&lt;T&gt;, other: &Arc&lt;T&gt;) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn make_mut(this: &Arc&lt;) -> &mut T</c-s> where T: Clone
                  </li>
                  <li>
                    <c-s>pub fn get_mut(this: &Arc&lt;) -> Option&lt;&mut T&gt;</c-s> where T: ?Sized
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.Mutex.html">Mutex</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Default, for, Send, Sync...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new(t: T) -> Mutex&lt;T&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn lock(&self) -> LockResult&lt;MutexGuard&lt;T&gt;&gt; where T: ?Sized</c-s>
                  </li>
                  <li>
                    <c-s>pub fn try_lock(&self) -> TryLockResult&lt;MutexGuard&lt;T&gt;&gt; where T: ?Sized</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_poisoned(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn into_inner(self) -> LockResult&lt;T&gt;</c-s> where T: Sized
                  </li>
                  <li>
                    <c-s>pub fn get_mut(&mut self) -> LockResult&lt;&mut T&gt;</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.MutexGuard.html">MutexGuard</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Default, Send, Sync, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.Condvar.html">Condvar</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Default, Send, Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new() -> ConVar</c-s>
                  </li>
                  <li>
                    <c-s>pub fn wait&lt;'a, T&gt;(&self, guard: MutexGuard&lt;'a, T&gt;)<br />
                    -> LockResult&lt;MutexGuard&lt;'a, T&gt;&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn wait_while&lt;'a, T, F&gt;(&self, guard: MutexGuard&lt;'a, T&gt;, condition: F)<br />
                    -> LockResult&lt;MutexGuard&lt;'a, T&gt;&gt; where F: FnMut(&mut T) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn wait_timeout&lt;'a, T&gt;(&self, guard: MutexGuard&lt;'a, T&gt;, dur: Duration)<br />
                    -> LockResult&lt;(MutexGuard&lt;'a, T&gt;, WaitTimeoutResult)&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn notify_one(&self)</c-s>
                  </li>
                  <li>
                    <c-s>pub fn notify_all(&self)</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.RwLock.html">RwLock</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Default, From, Send, Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new(t: T) -> RwLock&lt;T&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn read(&self) -> LockResult&lt;RwLockReadGuard&lt;T&gt;&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.RwLockReadGuard.html">RwLockReadGuard</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Display, Deref, !Send, Sync, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.RwLockWriteGuard.html">RwLockWriteGuard</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Display, Deref, DerefMut, !Send, Sync, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.Weak.html">Weak</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Default, Clone, Send, Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new() -> Weak&lt;T&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn upgrade(&self) -> Option&lt;Arc&lt;T&gt;&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn strong_count(&self) -> usize</c-s>
                  </li>
                  <li>
                    <c-s>pub fn ptr_eq(&self, other: &Weak&lt;T&gt;) -> bool</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.WaitTimeoutResult.html">WaitTimeoutResult</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Copy, Clone, Eq, PartialEq, Send, Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn timed_out(&self) -> bool</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.Once.html">Once</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Send, Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub const fn new(&self) -> Once</c-s>
                  </li>
                  <li>
                    <c-s>pub fn call_once&lt;F&gt;(&self, f: F) where F: FnOnce()</c-s>
                  </li>
                  <li>
                    <c-s>pub fn is_completed&lt;F&gt;(&self) -> bool</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.Barrier.html">Barrier</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Send, Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new(n: usize) -> Barrier</c-s>
                  </li>
                  <li>
                    <c-s>pub fn wait(&self) -> BarrierWaitResult</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s><a href="https://doc.rust-lang.org/beta/std/sync/struct.BarrierWaitResult.html">BarrierWaitResult</a></c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Send, Sync, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                ...
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <strong>Sync enum:</strong>
    </t-b>
    <t-b>
      <div class="indent pad5">
        <c-s>pub enum TryLockError&lt;T&gt; { Poisoned(PoisonError&lt;T&gt;), WouldBlock, }</c-s>
      </div>
    </t-b>
    <t-b>
      <strong>Sync type definitions:</strong>
    </t-b>
    <t-b>
      <div class="indent pad5">
        <c-s>type LockResult&lt;Guard&gt; = Result&lt;Guard, PoisonError&lt;Guard&gt;&gt;;</c-s><br />
        <c-s>type TryLockResult&lt;Guard&gt; = Result&lt;Guard, TryLockError&lt;Guard&gt;&gt;;</c-s><br />
      </div>
      <s-halfEm></s-halfEm>
    </t-b>
    <t-b>
      The example below builds a blocking queue and demonstrates sending messages.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;sync_demo - Blocking Queue</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Example:&nbsp;&nbsp;std::sync - Blocking Queue</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// sync_demo::main.rs - BlockingQueue                      //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 19 May 2020  //
/////////////////////////////////////////////////////////////
/*
   This is a prototype for a blocking queue.  There is
   another alternative, based on Rust channels which are,
   essentially blocking queues.

   I will build a prototype from channels, and then make
   a decision about which to use for a final design.
*/
#![allow(clippy::mutex_atomic)]
use std::io::*;
use std::{time};
use std::sync::atomic::*;

fn demo()  {

    use std::sync::{Arc, Mutex, Condvar};
    use std::thread;
    use std::collections::*;
    
    /*---------------------------------------------
        shared queue and condition variable 
        - condition variable makes thread wait for
          queue to have at least one entry
        - It is the reason queue blocks dequeuer
          when empty.
        - Arcs are thread-safe pointers, so both
          shared1 and its clone, shared2, refer to 
          the same locks and queue.
    */
    let shared1 = Arc::new((
        Mutex::new(VecDeque::&lt;String&gt;::new()), 
        Condvar::new(),
    ));
    let shared2 = shared1.clone();
    
    /*---------------------------------------------
        Atomic used to poll for active thread
    */
    let thread_started = Arc::new(AtomicBool::new(false));
    let checker = thread_started.clone();

    /*---------------------------------------------
        Start child thread
        - Dequeues messages sent by main thread.
    */
    let handle = thread::spawn(move|| {

        print!("\n  thread started");
        thread_started.store(true, Ordering::SeqCst);
        let _time_delay = time::Duration::from_millis(55);
        let (lq, cvar) = &amp;*shared2;
        loop {
            //thread::sleep(_time_delay);
            let item: String;
            {
                /*-- acquire lock --*/
                let mut q = lq.lock().unwrap();
                
                /*-- block on empty queue --*/
                while q.len() == 0 {  // may get spurious returns
                    q = cvar.wait(q).unwrap();
                }
                /*-- dequeue and display message --*/
                item = q.pop_front().unwrap();
            }   // lock released
            
            print!("\n  dequeued {:?} on child thread", item);
            let _ = std::io::stdout().flush();
            
            /*-- client shuts down dequeuer with quit msg --*/
            if item == "quit" {
                break;
            }
        }
    
        print!("\n  thread finishing");
    });

    /*---------------------------------------------
        Main thread thread enqueues messages
        for child thread.
    */
    /*-- wait for child thread to start ---------*/
    let _time_delay = time::Duration::from_micros(10);

    while !checker.load(Ordering::SeqCst) {
        thread::sleep(_time_delay);
    }
    /*-- start sending messages --*/
    let (lq, cvar) = &amp;*shared1;
    let mut not_processed = 0;

    let max = 5;
    for i in 0..max {
        let mut value:String;
        if i &lt; max-1 {
          value = String::from("msg #");
          value.push_str(&amp;i.to_string());
        }
        else {
            value = "quit".to_string();
        }
        print!("\n  enqueue  {:?} on main thread", &amp;value);
        {
            let mut q = lq.lock().unwrap();
            q.push_back(value);
            not_processed = q.len();
        }
        cvar.notify_one();    
    }
    /*---------------------------------------------
        Make sure all queued items are processed:
        - Needed because notifies that are issued
          before thread starts are dropped.
    */
    for _i in 0..not_processed {
        cvar.notify_one();
    }

    print!("\n  waiting for child thread to finish");
    let _ = handle.join();
}

fn main() {

    print!("\n  Blocking queue shared between threads");
    print!("\n =======================================");

    demo();
    print!("\n\n  That's all Folks!\n");
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  Blocking queue shared between threads
 ======================================= 
  thread started
  enqueue  "msg #0" on main thread
  dequeued "msg #0" on child thread
  enqueue  "msg #1" on main thread
  enqueue  "msg #2" on main thread
  enqueue  "msg #3" on main thread
  enqueue  "quit" on main thread
  waiting for child thread to finish
  dequeued "msg #1" on child thread
  dequeued "msg #2" on child thread
  dequeued "msg #3" on child thread
  dequeued "quit" on child thread
  thread finishing

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be found in <a href="RustLibraryDemos.html">RustLibraryDemos</a>.
    </t-b>

    <a id="mpsc"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.9</num-item1><num-item4>mpsc:</num-item4>
    </num-cont>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/mpsc/index.html">std::mpsc</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::mpsc types are: Receiver, Sender, SyncSender, IntoIter, Iter, TryIter, RecvError, and SendError
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>Receiver</c-s>
                <ul class="tight">
                  <li>
                    retrieves messages from a channel
                  </li>
                  <li>
                    can only be owned by one thread
                  </li>
                  <li>
                    Traits: <c-s>Debug, IntoIterator, Drop, Send, !Sync, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn try_recv(&self) -> Result&lt;T, TryRecvError&gt;<h-s4em>non-blocking</h-s4em></c-s>
                  </li>
                  <li>
                    <c-s>pub fn recv(&self) -> Result&lt;T, RecvError&gt;<h-s4em>blocks on no data</h-s4em></c-s>
                  </li>
                  <li>
                    <c-s>pub fn recv_timeout(&self, timeout: Duration) -> Result&lt;T, RecvTimeoutError&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn iter(&self) -> Iter&lt;T&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn try_iter(&self) -> TryIter&lt;T&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Sender</c-s>
                <ul class="tight">
                  <li>sends messages to a a channel, non-blocking</li>
                  <li>
                    can only be owned by one thread, but can be cloned
                  </li>
                  <li>
                    Traits: <c-s>Debug, Clone, Send, !Sync, Drop, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn send(&self, t: T) -> Result&lt;(), SendError&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>SyncSender</c-s>
                <ul class="tight">
                  <li>
                    sends messages to a channel, blocks if there is not enough space in internal buffer
                  </li>
                  <li>
                    Traits: <c-s>Debug, Clone, Send, Drop, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn send(&self, t: T) -> Result&lt;(), SendError&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn try_send(&self, t: T) -> Result&lt;(), TrySendError&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>IntoIter</c-s>
                <ul class="tight">
                  <li>
                    blocks when next is called, waiting for a new message
                  </li>
                  <li>
                    Traits: <c-s>Debug, Iterator, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Iter</c-s>
                <ul class="tight">
                  <li>
                    blocks when next is called, waiting for a new message
                  </li>
                  <li>
                    Traits: <c-s>Debug, Iterator, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>TryIter</c-s>
                <ul class="tight">
                  <li>
                    attempts to yield all pending values for a Receiver
                  </li>
                  <li>
                    Traits: <c-s>Debug, Iterator, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>SendError</c-s>
                <ul class="tight">
                  <li>
                    sends only fail if receiving end is disconnected.  
                  </li>
                  <li>
                    error contains un-sent message as payload
                  </li>
                  <li>
                    Traits: <c-s>Debug, Display, Clone, Copy, Eq, PartialEq, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>ReceiveError</c-s>
                <ul class="tight">
                  <li>
                    receives only fail if sending end is disconnected.  
                  </li>
                  <li>
                    error contains un-sent message as payload
                  </li>
                  <li>
                    Traits: <c-s>Debug, Display, Clone, Copy, Eq, PartialEq, ...</c-s>
                  </li>
                </ul>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      mpsc functions are: channel and sync_channel
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Functions</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>pub fn channel&lt;T&gt;() -> (Sender&lt;T&gt;, Receiver&lt;T&gt;)</c-s>
              </li>
              <li>
                <c-s>pub fn sync_channel&lt;T&gt;(bound: usize) -> (SyncSender&lt;T&gt;, Receiver&lt;T&gt;)</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      std::mpsc enums are: RecvTimeoutError, TryRecvError, and TrySendError
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Enumerations</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                Traits: Debug, Display, Clone, Copy, Error, Eq, PartialEq, .... 
              </li>
              <li>
                <c-s>pub enum RecvTimeoutError { Timeout, Disconnected, }</c-s>
              </li>
              <li>
                <c-s>pub enum TryRecvError { Empty, Disconnected, }</c-s>
              </li>
              <li>
                <c-s>pub enum TrySendError&lt;T&gt;{ Full(T), Disconnected(T), }</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      The example below constructs a channel and sends messages between threads.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;channel_demo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>std::mpsc - mpsc_demo::main.rs</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// mpsc_demo::main.rs - msg passing uses blocking queue    //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 22 May 2020  //
/////////////////////////////////////////////////////////////

use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn send_proc(s:&amp;str, tx : &amp;mpsc::Sender&lt;String&gt;) {
    let max = 5;
    for i in 0..max {
        let msg = format!("msg #{} from {}", i.to_string(), s);
        print!("\n  sending  {:?}", msg);
        tx.send(msg).unwrap();
        thread::yield_now();   // others ready to run?
    }
}
fn recv_proc(rx: &amp;mpsc::Receiver&lt;String&gt;) {
    for msg in rx {
        print!("\n  received {:?}", msg);
        if msg == "quit" {
            break;
        }
    }
}
fn demo() {
    /*-- setup channel --*/
    let (tx, rx) = mpsc::channel::&lt;String&gt;();
    let tx2 = mpsc::Sender::clone(&amp;tx);
    let tx_quit = mpsc::Sender::clone(&amp;tx);

    /*-- receive thread --*/
    let rcv_handle = thread::spawn(
        move || { recv_proc(&amp;rx); 
    });

    /*-- wait for receive thread to start --*/
    thread::sleep(Duration::from_millis(50));

    /*-- send threads --*/
    let toms_handle = thread::spawn(
        move || { send_proc("Tom", &amp;tx); 
    });
    let jerrys_handle = thread::spawn(
        move || { send_proc("Jerry", &amp;tx2); 
    });
    let _ = toms_handle.join();
    let _ = jerrys_handle.join();

    /*-- Tom and Jerry are finished so it's safe to stop receiver --*/
    let _ = tx_quit.send("quit".to_string());
    let _ = rcv_handle.join();
}
fn main() {
    print!("\n  Message passing demo");
    print!("\n ======================");

    demo();
    print!("\n\n That's all Folks!\n");
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  Message passing demo
 ======================
  sending  "msg #0 from Tom"
  sending  "msg #0 from Jerry"
  sending  "msg #1 from Jerry"
  sending  "msg #2 from Jerry"
  sending  "msg #3 from Jerry"
  received "msg #0 from Tom"
  received "msg #0 from Jerry"
  sending  "msg #4 from Jerry"
  sending  "msg #1 from Tom"
  sending  "msg #2 from Tom"
  received "msg #1 from Jerry"
  received "msg #2 from Jerry"
  received "msg #3 from Jerry"
  received "msg #4 from Jerry"
  received "msg #1 from Tom"
  received "msg #2 from Tom"
  sending  "msg #3 from Tom"
  sending  "msg #4 from Tom"
  received "msg #3 from Tom"
  received "msg #4 from Tom"
  received "quit"

 That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be found in <a href="RustLibraryDemos.html">RustLibraryDemos</a>.
    </t-b>

    <a id="async"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.10</num-item1><num-item4>Async/Await:</num-item4>
    </num-cont>
    <t-b>
      <a href="https://doc.rust-lang.org/std/future/index.html">std::future</a>, 
      <a href="https://crates.io/crates/futures">crates.io/crates/futures</a>, 
      <a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">async/.await Primer</a>
    </t-b>
    <t-b>
      <under-construction>
        This section is a place-holder, awaiting (pun intended) construction.
      </under-construction>
    </t-b>

    <a id="process"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.11</num-item1><num-item4>process:</num-item4>
    </num-cont>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/time/index.html">std::process</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::thread types are: Command, Child, ChildStdin, ChildStdout, ChildStderr, Output, Stdio, ExitCode  
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>Command</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new&lt;S: AsRef&lt;OsStr&gt;&gt;(program: S) -> Command</c-s>
                  </li>
                  <li>
                    <c-s>pub fn arg&lt;S: AsRef&lt;OsStr&gt;&gt;(&mut self, arg: S) -> &mut Command</c-s>
                  </li>
                  <li>
                    <c-s>pub fn args&lt;I, S&gt;(&mut self, args: I) -> &mut Command</c-s><br />
                    <c-s>where I: IntoIterator&lt;Item = S&gt;, S: AsRef&lt;OsStr&gt;,</c-s>
                  </li>
                  <li>
                    <c-s>pub fn env&lt;K, V&gt;(&mut self, key: K, val: V) -> &mut Command</c-s><br />
                    <c-s>where K: AsRef&lt;OsStr&gt;, V: AsRef&lt;OsStr&gt;,</c-s>
                  </li>
                  <li>
                    <c-s>pub fn envs&lt;I, K, V&gt;(&mut self, vars: I) -> &mut Command</c-s><br />
                    <c-s>where I: IntoIterator&lt;Item = (K, V)&gt;, K: AsRef&lt;OsStr&gt;, V: AsRef&lt;OsStr&gt;,</c-s>
                  </li>
                  <li>
                    <c-s>pub fn env_remove&lt;K: AsRef&lt;OsStr&gt;&gt;(&mut self, key: K) -> &mut Command</c-s>
                  </li>
                  <li>
                    <c-s>pub fn env_clear(&mut self) -> &mut Command</c-s>
                  </li>
                  <li>
                    <c-s>pub fn current_dir&lt;P: AsRef&lt;Path&gt;&gt;(&mut self, dir: P) -> &mut Command</c-s>
                  </li>
                  <li>
                    <c-s>pub fn stdin&lt;T: Into&lt;Stdio&gt;&gt;(&mut self, cfg: T) -> &mut Command</c-s>
                  </li>
                  <li>
                    <c-s>pub fn stdout&lt;T: Into&lt;Stdio&gt;&gt;(&mut self, cfg: T) -> &mut Command</c-s>
                  </li>
                  <li>
                    <c-s>pub fn stderr&lt;T: Into&lt;Stdio&gt;&gt;(&mut self, cfg: T) -> &mut Command</c-s>
                  </li>
                  <li>
                    <c-s>pub fn spawn(&mut self) -> Result&lt;Child&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn output(&mut self) -> Result&lt;Output&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn status(&mut self) -> Result&lt;ExitStatus&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Child</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn kill(&mut self) -> Result&lt;()&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn id(&mut self) -> u32</c-s>
                  </li>
                  <li>
                    <c-s>pub fn wait(&mut self) -> Result&lt;ExitStatus&gt;</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>ChildStdin</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, From, Write, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>ChildStdout</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, From, Read, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>ChildStderr</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, From, Read, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Stdio</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, From, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn piped() -> Stdio</c-s>
                  </li>
                  <li>
                    <c-s>pub fn inherit() -> Stdio</c-s>
                  </li>
                  <li>
                    <c-s>pub fn null() -> Stdio</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>Output</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Clone, Eq, PartialEq, ...</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <c-s>ExitStatus</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Display, Copy, Clone, Eq, PartialEq, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn success(&self) -> bool</c-s>
                  </li>
                  <li>
                    <c-s>pub fn code(&self) -> Option&lt;i32&gt;</c-s>
                  </li>
                </ul>
              </li>
              <li>
                ...
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      Process functions are: abort, exit, id
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Functions</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>pub fn abort() -> !</c-s>
              </li>
              <li>
                <c-s>pub fn exit(code: i32) -> !</c-s>
              </li>
              <li>
                <c-s>pub fn id() -> u32</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      The example below spawns a child process and collects its output for display when the child exits.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;process_demo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>std::thread::shared</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// process_demo::main.rs - start child process             //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 16 May 2020  //
/////////////////////////////////////////////////////////////

#![allow(unused_imports)]
use std::process::*;
use std::io::*;

fn main() {

    let putline = || print!("\n");

    print!("\n  spawning child process");
    print!("\n ========================\n");
    putline();

    let output = if cfg!(target_os = "windows") {
        Command::new("cmd.exe")
                .args(&amp;[
                    "/C", "type",
                    "cargo.toml"
                ])
                .output()
                .expect("failed to execute process")
    }
    else {
        Command::new("sh")
                 .arg("-C")
                 .arg("echo.hello")
                 .output()
                 .expect("failed to execute process")
    };

    std::io::stdout().write_all(
                          &amp;output.stdout
                      ).unwrap();

    println!("\n\n  That's all Folks!\n\n");
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  spawning child process
 ========================

[package]
name = "process_demo"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at 
# https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be found in <a href="RustLibraryDemos.html">RustLibraryDemos</a>.
    </t-b>

    <a id="time"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.12</num-item1><num-item4>time:</num-item4>
    </num-cont>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/time/index.html">std::time</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::time types are: Duration, Instant, SystemTime, SystemTimeError
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>Duration</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Default, Clone, Copy, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn new(secs: u64, nanos: u32) -> Duration</c-s>
                  </li>
                  <li>
                    <c-s>pub fn from_secs(secs: u64) -> Duration</c-s>
                  </li>
                  <li>
                    <c-s>pub fn from_millis(millis: u64) -> Duration</c-s>
                  </li>
                  <li>
                    <c-s>pub fn from_micros(micros: u64) -> Duration</c-s>
                  </li>
                  <li>
                    <c-s>pub fn from_nanos(nanos: u64) -> Duration</c-s>
                  </li>
                  <li>
                    <c-s>pub fn as_secs(&self) -> u64</c-s>
                  </li>
                  <li>
                    <c-s>pub fn as_millis(&self) -> u128</c-s>
                  </li>
                  <li>
                    <c-s>pub fn as_micros(&self) -> u128</c-s>
                  </li>
                  <li>
                    <c-s>pub fn as_nanos(&self) -> u128</c-s>
                  </li>
                  <li>
                    <c-s>pub fn checked_add(self, rhs: Duration) -> Option&lt;Duration&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn checked_sub(self, rhs: Duration) -> Option&lt;Duration&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn checked_mul(self, rhs: u32) -> Option&lt;Duration&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn checked_div(self, rhs: u32) -> Option&lt;Duration&gt;</c-s>
                  </li>
                  <li>s...</li>
                </ul>
              </li>
              <li>
                <c-s>Instant</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Clone, Copy, ...</c-s>
                  </li>
                  <li>
                    <c-s>pub fn now() -> Instant</c-s>
                  </li>
                  <li>
                    <c-s>pub fn duration_since(&mut self, earlier: Instant) -> Duration</c-s>
                  </li>
                  <li>
                    <c-s>pub fn checked_duration_since(&mut self, earlier: Instant) -> Option&lt;Duration&gt;</c-s>
                  </li>
                  <li>
                    <c-s>pub fn elapsed(&mut self) -> Duration</c-s>
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>SystemTime</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Clone, Copy, Eq, PartialEq, ...</c-s>
                  </li>
                  <li>
                    pub const UNIX_EPOCH: SystemTime
                  </li>
                  <li>
                    pub fn now() -> SystemTime
                  </li>
                  <li>
                    pub fn duration_since(&self, earlier: SystemTime) -> Result&lt;Duration, SystemTimeError&gt;
                  </li>
                  <li>
                    pub fn elapsed(&self) -> Result&lt;Duration, SystemTimeError&gt;
                  </li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                <c-s>SystemTimeError</c-s>
                <ul class="tight">
                  <li>
                    Traits: <c-s>Debug, Display, Clone, Error, ...</c-s>
                  </li>
                  <li>
                    pub fn duration(&self) -> Duration
                  </li>
                </ul>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      The example below may eventually do something interesting.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;time_demo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>std::time time_demo</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// time_demo::main.rs - demonstration of std::time         //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 22 May 2020  //
/////////////////////////////////////////////////////////////

use std::time;
use std::thread;
use std::convert::TryFrom;

/*-- how accurate is thread sleep ? --*/
fn sleep_proc(ms: u64) {
   let dur = time::Duration::from_millis(ms); 
   thread::sleep(dur);
}
/*-- nonsense calculation to waste time --*/
fn calc_proc(count: u64) {
    let mut _value: f64 = 42.0;
    let mut mult:i32 = 42; 
    let rslt = i32::try_from(count);
    match rslt {
        Ok(counter) =&gt; {
            for i in 0..counter {
                mult = mult + i;
                let mult = (mult + i) % 33;
                let _value = _value + mult as f64;
            }       
        },
        Err(_) =&gt; print!("\n  can't compute this number")
    }
}
/*-- writing to console is slow --*/
fn print_proc(count: u64) {
    print!("\n  ");
    for _num in 0..count {
        for _out in 0..25 {
            print!(". ");
        }
        print!("\n  ");
    }
}
/*-- stop watch timer --*/
fn measure_time&lt;F: FnOnce(u64) -&gt; ()&gt;(f: F, arg: u64) -&gt; time::Duration {
    let start = time::Instant::now();
    f(arg);
    start.elapsed()
}
/*-- demo time durations --*/
fn main() {
    print!("\n  Demonstrate std::time");
    print!("\n =======================");

    let putline = || print!("\n");

    putline();
    let mut duration = measure_time(sleep_proc, 3);
    print!("\n  thread::sleep for 3 ms actually took {:?}", duration);
    putline();

    duration = measure_time(calc_proc, 1500);
    print!("\n  time to perform nonsense calc was {:?}", duration);
    putline();

    duration = measure_time(print_proc, 15);
    print!("\n  time to print array of dots was {:?}", duration);

    println!("\n\n  That's all Folks!\n");
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  Demonstrate std::time
 =======================

  thread::sleep for 3 ms actually took 3.6934ms

  time to perform nonsense calc was 62µs

  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .

  time to print array of dots was 11.503ms

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be found in <a href="RustLibraryDemos.html">RustLibraryDemos</a>.
    </t-b>


    <a id="epilogue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.13</num-item1><num-item4>Epilogue:</num-item4>
    </num-cont>
    <t-b>
      Augmenting the standard Rust libraries, there are a large number of open-source crates on
      <a href="https://crates.io">https://crates.io</a>.  Many are developed by members of the Rust
      development team.  There are also a lot of resources available on github.  
      Here are a few interesting selections:
      <div class="indent pad10">
        <ol class="tight">
          <li>
            <a href="https://crates.io/crates/hyper">hyper</a>, an HTTP client and server api
          </li>
          <li>
            <a href="https://github.com/http-rs">http-rs</a>, HTTP client, server, and parts.
          </li>
          <li>
            <a href="https://async.rs/">async-std</a>, an implementation of the async-await pattern and
            updates of some of the std libraries to incorporate it, e.g., fs, io, net, process, sync, ...
            It provides new libraries future, stream, and task.  Here&apos;s a nice 
            <a href="https://www.philipdaniels.com/blog/2019/async-std-demo1/">set of examples</a> of its
            use.
          </li>
          <li>
            <a href="https://crates.io/crates/tokio">tokio</a>, a widely used runtime for asynchronous applications.
          </li>
          <li>
            <a href="https://crates.io/crates/serde">serde</a>, framework for serializing and deserializing 
            Rust data structures.
          </li>
          <li>
            <a href="https://github.com/rust-unofficial/awesome-rust">awesome-rust</a>, a large list
            of rust resources, mostly on github.
          </li>
        </ol>
      </div>
    </t-b>
    <t-b>
      I&apos;ve been impressed with Rust&apos;s clever ideas, professional implementation, and ease of use of the
      Rust tool chain.  Cheers!
    </t-b>
    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.14</num-item1><num-item4>References:</num-item4>
    </num-cont>
        <table style="width:calc(100vw - 12rem);">
      <tr>
        <th class="darkItem">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html">A Gentle Introduction To Rust</a>
        </td>
        <td class="lightItem">
          First thing to read.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/book/">The Rust Book</a>
        </td>
        <td class="lightItem">
          Rust docs - walkthrough of syntax
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/reference/">The Rust Reference Book</a>
        </td>
        <td class="lightItem">
          Rust&apos;s approximation of a language standard. Clear and well written, with a glossary at the end.
          Its <a href="https://github.com/rust-lang/reference">github site</a> shows that changes are still being
          actively incorporated.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://cheats.rs/">Rust cheat sheet</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
        <td class="lightItem">
          Container diagrams
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/27683266/how-do-you-do-interprocess-communication-ipc-in-rust">Rust IPC</a></td>
        <td class="lightItem">
          Stackoverflow re Rust IPC
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/31192956/whats-the-de-facto-way-of-reading-and-writing-files-in-rust-1-x">Rust file io</a></td>
        <td class="lightItem">
          Stackoverflow re Rust file io
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/27840394/how-can-a-rust-program-access-metadata-from-its-cargo-package">Rust metadata</a></td>
        <td class="lightItem">
          Stackoverflow re reading metadata from cargo.toml
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">RIP Tutorial on Rust</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, the stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">Learning Rust ebook</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/rust/awesome-learning/book">Rust - Awesome Book</a></td>
        <td class="lightItem">
          lots of interesting discussions from RIP, the Stackoverflow Archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.rs/regex/1.3.7/regex/">std::regex</a></td>
        <td class="lightItem">
          std docs on Regex
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://docs.rs/dtolnay/0.0.8/dtolnay/macro._02__reference_types.html">
            Shared&nbsp;reference&nbsp;&amp;T&nbsp;and&nbsp;exclusive&nbsp;reference&nbsp;&amp;mut&nbsp;T
          </a>
        </td>
        <td class="lightItem">
          More accurate description than immutable reference and mutable reference
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://deterministic.space/">Blog - Pascal's Scribbles</a>
        </td>
        <td class="lightItem">
          Pascal Hertleif - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://blog.mgattozzi.dev/">Blog - Barely Functional</a>
        </td>
        <td class="lightItem">
          Michael Gattozzi - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://blog.mgattozzi.dev/rust-wasm/">Rust and the case for WebAssembly in 2018</a>
        </td>
        <td class="lightItem">
          Michael Gattozzi - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.snoyman.com/blog/2020/05/no-mutable-parameters-in-rust">Blog - S.Noyberg</a>
        </td>
        <td class="lightItem">
          Examples of aysnc/await, tokio, lifetime, ...
        </td>
      </tr>
      <tr>
        <td class="darkItem" style="line-height:1.5em;"><strong><a href="RustStory_References.html">More References</a></strong></td>
        <td class="darkItem" style="line-height:1.5em;">&nbsp;</td>
      </tr>
    </table>

  </bb-55>
  <spacer-25></spacer-25>

  <info-bar></info-bar>
</body>
</html>