<!DOCTYPE html>
<html>
<!--
  RustStory_Data.html
-->
<head>
  <title>RustStory Libraries</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--<link rel="stylesheet" href="css/StylesTemplate.css" />-->
  <!--<link rel="stylesheet" href="css/StylesDefault.css" />-->
  <!--<link rel="stylesheet" href="css/StylesBrownTheme.css" />-->
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeRust.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <!--<script src="js/ScriptsPageFrameDefaults.js"></script>-->
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesRustStory.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <!-- No need for Pages script for pages with no next or prev pages -->
  <!--<script src="js/ScriptsPageFramePages.js"></script>-->
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding: 0.75em 1.5em;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width: 50em;
    }

    #github h2 {
      margin-top: 0.75em;
    }

    #github ol.tight li {
      margin-top: 0.15em;
      margin-bottom: 0.15em;
    }

    #github h3 {
      margin-top: 1.25em;
    }

    #github h4 {
      margin-top: 1em;
    }

    #github .topsp {
      margin-top: 0.5em;
    }

    #github .detailsp {
      margin-top: -1em;
      margin-bottom: 1em;
    }

    #github defn-code {
      font-size: 1em;
      font-weight: normal;
      margin-left: -1em;
    }

    #github header h3 {
      margin-top: 0em;
      margin-left: 1em;
    }
  </style>
<!--   <script>
    window.onmessage = function () {
      // alert('msg received');
      bottomMenu.sections();
    }
  </script>
 --></head>
<body id="github" onload="initialize()">

  <a id="Next" href="RustStory_References.html">Next</a>
  <a id="Prev" href="RustStory_Structures.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="page">RustStory Libraries</div>
      <div id="modified">9/24/2022</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 5. - Rust Libraries</h1>
      <h3 id="subtitle">std, collectons, fs, net, error, time, thread, process</h3>
    </hgroup>
  </header>

    <a id="prologue"></a>
    <h3>5.0 Prologue</h3>
    <!--<under-construction class="indent">
      This page is under construction
    </under-construction>-->
    <t-b>
      Rust has a very well-engineered collection of standard libraries. Each library presents trait, structure, function,
      and type definitions.  The structure and function pages have examples for almost everything presented.
    </t-b>
    <t-b>
      <div style="font-size:1em; border:2px solid darkred; padding: 0.5em 1.5em; margin:0em 1.0em;">
        Source code is provided for all the std libraries.
        simply go <a href="https://doc.rust-lang.org/beta/std/">here</a>, 
        browse around and click any of the [src] tabs.
      </div>
    </t-b>
    <t-b>
      Once you are passed the stage of constantly being surprised by ownership rules, you will find the libraries easy to
      use and rich in functionality.
    </t-b>

    <a id="std"></a>
    <h3>5.1 std Libraries</h3>
  <div class="right">
    <div class="right pad5" style="padding-right:4.5em;">
      <a href="https://doc.rust-lang.org/beta/std/">Rust std library</a>
    </div>
    <!--<div style="width:calc(100vw - 9em);">-->
    <div style="padding-right:3em">
      <photosizer-block src="Pictures/RustStd.jpg" width="400" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
        display: inline-block;
        font-weight: bold;
        font-family: 'Comic Sans MS, Tahoma';
        background-color: #ddd;
        width: 100%;
        padding: 5px 0px;
      ">
          Fig 1. Rust Std Libraries
        </span>
      </photosizer-block>
    </div>
  </div>
    <t-b>
      Rust has a well endowed collection of more than sixty <strong><a href="https://doc.rust-lang.org/beta/std/">std libraries</a></strong> in the
      std namespace.  You don&apos;t have to declare a use std::*, as the std::prelude::* is automatically applied.
    </t-b>
    <t-b>
      All of the libraries discussed below are part of std.  There are many more - included here are libraries
      I expect you will use most often.
    </t-b>
    <t-b>
      The materials below summarize some of the Rust Library documentation, and give small examples of library use. Note that
      the Rust documentation has examples for almost everything.  The examples here are often a little larger, and
      dig into things that interested me as I learned some of the library content.
    </t-b>
    <a id="convert"></a>
    <h3>5.2 std::convert - <span style="font-size:medium; font-weight:normal;">conversions between types</span></h3>
    <t-b>
      Traits for conversions are provided in <a href="https://doc.rust-lang.org/std/convert/index.html">std::convert</a>.
      The traits provided in this module provide ways to convert from one type to another.  Each trait serves a different
      purpose:
      <div class="indents topsp">
        <ul class="tight">
          <li>
            AsRef trait provides cheap (re-interprets) reference-to-reference conversions.
          </li>
          <li>
            AsMut trait provides cheap (re-interprets) mutable-to-mutable conversions.
          </li>
          <li>
            From trait provides consuming (move) value-to-value conversions.
          </li>
        </ul>
      </div>
    </t-b>
    <t-b>
      <div class="indent">
        <ol class="tight pad10">
          <li>
            AsRef:
            <defn-code style="font-size:0.9em;">pub trait AsRef&lt;T&gt; where T: ?Sized, {
  fn as_ref(&self) -> &T
}
            </defn-code>
            <div class="detailsp">
              <details>
                <summary class="labelStyle lightItem">Partial List of Implementors:</summary>
                <div class="">
                  <ul class="tight">
                    <li>
                      <c-s>[T]::as_ref&lt;[T]&gt;() -> &[T];</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_ref&lt;[T]&gt;() -> &[T];</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_ref&lt;Vec&lt;T&gt;&gt;() -> &Vec&lt;T&gt;</c-s>
                    </li>
                    <li>
                      <c-s>Box&lt;T&gt;::as_ref&lt;T&gt;() -> &T;</c-s><br />
                      <c-s>where T: ?Sized</c-s>
                    </li>
                    <li>
                      <c-s>Arc&lt;T&gt;::as_ref&lt;T&gt;() -> &T;</c-s><br />
                      <c-s>where T: ?Sized</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;[u8]&gt;() -> &[u8];</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;str&gt;() -> &str;</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;[u8]&gt;() -> &[u8];</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;str&gt;() -> &str;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;Path&gt;() -> &Path;</c-s>
                    </li>
                    <li>
                      <c-s>CStr::as_ref&lt;CStr&gt;() -> &CStr;</c-s>
                    </li>
                    <li>
                      <c-s>CString::as_ref&lt;CStr&gt;() -> &CStr;</c-s>
                    </li>
                    <li>
                      <c-s>OsStr::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>OsString::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>Path::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>PathBuf::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>PathBuf::as_ref&lt;OsStr&gt;() -> &Path;</c-s>
                    </li>
                  </ul>
                </div>
              </details>
            </div>
          </li>
          <li>
            AsMut:
            <defn-code style="font-size:1.0em;">pub trait AsMut&lt;T&gt; where T: ?Sized,
{
  fn as_mut(&mut self) -> &mut T;
}
            </defn-code>
            <div class="detailsp">
              <details>
                <summary class="labelStyle lightItem">Partial List of Implementors</summary>
                <div>
                  <ul class="tight">
                    <li>
                      <c-s>String::as_mut() -> &mut str</c-s>
                    </li>
                    <li>
                      <c-s>[T]::as_mut() -> &mut [T]</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_mut() -> &mut [T]</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_mut() -> &mut Vec&lt;T&gt;</c-s>
                    </li>
                    <li>
                      <c-s>Box&lt;T: ?Sized&gt;::as_mut() -> &mut T</c-s>
                    </li>
                  </ul>
                </div>
              </details>
            </div>
          </li>
          <li>
            From:
            <defn-code style="font-size:1.0em;">pub trait From&lt;T&gt; {
  fn from(T) -> Self
}
            </defn-code>
            <div class="detailsp">
              <details>
                <summary class="labelStyle lightItem">Partial List of Implementors</summary>
                <div>
                  <ul class="tight">
                    <li>
                      String::from(&str)
                    </li>
                    <li>
                      String::from(Box&lt;str&gt;)
                    </li>
                    <li>
                      char::from(u8)
                    </li>
                    <li>
                      PathBuf::from(String)
                    </li>
                    <li>
                      Pathbuf::from(OsString)
                    </li>
                    <li>
                      OsString::from(String)
                    </li>
                    <li>
                      OsString::From(PathBuf)
                    </li>
                    <li>
                      u32::from(char)
                    </li>
                    <li>
                      isize::from(i16)
                    </li>
                    <li>
                      f64::from(f32)
                    </li>
                    <li>
                      f64::from(i16)
                    </li>
                    <li>
                      AtomicI16::from(i16)
                    </li>
                    <li>
                      Vec&lt;u8&gt;::from(String)
                    </li>
                    <li>
                      Vec&lt;T&gt;::from(BinaryHeap&lt;T&gt;)
                    </li>
                    <li>
                      Vec&lt;T&gt;::from(VecDeque&lt;T&gt;)
                    </li>
                    <li>
                      VecDeque&lt;T&gt;::from(Vec&lt;T&gt;)
                    </li>
                    <li>
                      BinaryHeap&lt;T&gt;::from(Vec&lt;T&gt;)
                    </li>
                    <li>
                      Mutex&lt;T&gt;::from(T)
                    </li>
                    <li>
                      RWLock&lt;T&gt;::from(T)
                    </li>
                    <li>
                      Box&lt;[u8]&gt;::from(Box&gt;str&gt;)
                    </li>
                    <li>
                      Box&lt;str&gt;::from(&str)
                    </li>
                    <li>
                      Arc&lt;OsStr&gt;::from(OsString)
                    </li>
                    <li>
                      Arc&lt;Path&gt;::From(PathBuf)
                    </li>
                    <li>
                      Arc&lt;String&gt;::from(String)
                    </li>
                    <li>
                      Arc&lt;T&gt;::from(T)
                    </li>
                    <li>
                      Error::from(kind: ErrorKind)
                    </li>
                    <li>
                      Stdio::from(File)
                    </li>
                    <li>
                      Stdio::from(ChildStdin)
                    </li>
                    <li>
                      Stdio::from(ChildStdout)
                    </li>
                  </ul>
                </div>
              </details>
            </div>
          </li>
        </ol>
      </div>
    </t-b>
    <a id="coll"></a>
    <h3 style="margin-top: -1.0em;">5.3 std::collections - <span style="font-size:medium; font-weight:normal;">containers and iterators</span></h3>
    The std namespace has a set of <a href="https://doc.rust-lang.org/std/collections/index.html">std::collections</a> 
    similar to other languages:
    <div class="" style="width:calc(100vw - 15em); padding:15px 0px;">
      <table>
        <tr>
          <th class="darkItem">Collection</th><th class="darkItem">Description</th>
        </tr>
        <tr>
          <td class="lightItem">Vec&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A self expanding indexable array of items of type T, occupying a contiguous block of memory.
            Constant time access to indexed item, linear time insertion and removal.
          </td>
        </tr>
        <tr>
          <td class="lightItem">VecDeque&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A self expanding indexable array of items of type T, with constant-time access, insertion,
            and removal on either end.
          </td>
        </tr>
        <tr>
          <td class="lightItem">LinkedList&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A doubly linked list of items of type T, with linear-time traversal.
          </td>
        </tr>
        <tr>
          <td class="lightItem">HashMap&lt;K, V&gt;</td>
          <td class="lightItem">
            Associative container:<br />
            A hashed container with almost constant time access.  Elements are randomly ordered
            (if the hash function works well for T)
          </td>
        </tr>
        <tr>
          <td class="lightItem">BTreeMap&lt;K,&nbsp;V&gt;</td>
          <td class="lightItem">
            Associative container:<br />
            A balanced binary tree container with log n time access.  Elements are sorted.
          </td>
        </tr>
        <tr>
          <td class="lightItem">HashSet&lt;K&gt;</td>
          <td class="lightItem">
            Set container:<br />
            A hashed container with almost constant time access.  Elements are randomly ordered
            (if the hash function works well for T)
          </td>
        </tr>
        <tr>
          <td class="lightItem">BTreeSet&lt;K&gt;</td>
          <td class="lightItem">
            Set container:<br />
            A balanced binary tree container with log n time access.  Elements are sorted.
          </td>
        </tr>
        <tr>
          <td class="lightItem">BinaryHeap&lt;T&gt;</td>
          <td class="lightItem">
            Priority queue:<br />
            Largest element is accessed in constant time.
          </td>
        </tr>
      </table>
    </div>
    <t-b>
      <div class="detailsps">
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::collections::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Collections_echo</defn-head>
              <defn-code>
  /////////////////////////////////////////////////////////////
  // collections_echo - demonstrate collections library      //
  //                                                         //
  // Jim Fawcett, https://JimFawcett.github.io, 14 May 2020  //
  /////////////////////////////////////////////////////////////

  use std::collections::*;
  use std::fmt::*;

  /*-- displays type name and value --*/
  fn show_type&lt;T: Debug&gt;(t:&amp;T) {
      let name = std::any::type_name::&lt;T&gt;();
      print!("\n  type: {:?}", name);
      print!("\n  {:?}", &amp;t);
  }
  /*-- echo function shows the type and value of its arg --*/
  /*---------------------------------------------------------
     Illustrates how to accept and return iterable
     generic type
  */
  fn echo&lt;C: Debug + Clone + IntoIterator&gt;(c:&amp;C) -&gt; &amp;C 
     where C::Item: Debug, {
      show_type(c);
      print!("\n  items are: ");
      let iter = c.clone().into_iter();  // iter consumes
      for item in iter {
          print!("{:?} ", item);
      }
      c
  }
  /*-- demonstration --*/
  fn main() {
      let putline = || { print!("\n"); };

      print!("\n  collections_echo");
      print!("\n ==================");

      let v = vec![1,2,3];
      let r = echo(&amp;v);
      print!("\n\n  echo fn returned:");
      show_type(&amp;r);
      putline();

      let mut vd = VecDeque::&lt;f64&gt;::new();
      vd.push_back(1.0);
      vd.push_front(2.5);
      vd.push_back(-1.5);
      let r = echo(&amp;vd);
      print!("\n\n  echo fn returned:");
      show_type(&amp;r);
      putline();

      let mut hm = HashMap::&lt;i32, &amp;str&gt;::new();
      hm.insert(0,"zero");
      hm.insert(1,"one");
      hm.insert(2,"two");
      let r = echo(&amp;hm);
      print!("\n\n  echo fn returned:");
      show_type(&amp;r);
      putline();

      println!("\n  That's all Folks!\n");
  }
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  collections_echo
 ==================
  type: "alloc::vec::Vec<i32>"
  [1, 2, 3]
  items are: 1 2 3

  echo fn returned:
  type: "&alloc::vec::Vec<i32>"
  [1, 2, 3]

  type: "alloc::collections::vec_deque::VecDeque<f64>"
  [2.5, 1.0, -1.5]
  items are: 2.5 1.0 -1.5

  echo fn returned:
  type: "&alloc::collections::vec_deque::VecDeque<f64>"
  [2.5, 1.0, -1.5]

  type: "std::collections::hash::map::HashMap<i32, &str>"
  {0: "zero", 1: "one", 2: "two"}
  items are: (0, "zero") (1, "one") (2, "two")

  echo fn returned:
  type: "&std::collections::hash::map::HashMap<i32, &str>"
  {0: "zero", 1: "one", 2: "two"}

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      Find code for this example <a href="RustLibraryDemos.html">here</a>.
    </t-b>
    <a id="iter"></a>
    <h4>5.3.1 Iterators</h4>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/iter/index.html">std::iter</a>
    </t-b>
    <t-b>
      Iterators support iterating through collections.  They come in three flavors:
      <div class="pad5">
        <ul class="tight">
          <li>
            iter(), which iterates over &T
          </li>
          <li>
            iter_mut(), which iterates over &mut T
          </li>
          <li>
            into_iter(), which iterates over T
          </li>
        </ul>
      </div>
      Note that into_iter is a consuming iterator, moving items from source to destination.
    </t-b>
    <t-b>
      Iterators are lazy: they don&apos;t do anything until consumed, e.g.:
    </t-b>
    <t-b>
      <div class="indent">
        <defn-code style="font-size:0.9em;">coll.iter().for_each(|x| { /* do something with x */ });
    <t-s>or</t-s>
for x in &coll { /* do something else with x */ };
        </defn-code>
      </div>
    </t-b>
    <t-b>
      <strong>Traits:</strong>
    </t-b>
    <t-b>
      <div class="indent">
        <ol class="tight">
          <li>
            <defn-code style="font-size:1.0em; margin-left:-1em;">trait Iterator {
  type Item;
  fn next(&mut self) -> Option&lt;Self::Item&gt;
  fn count(self) -> usize
  fn last(self) -> Option&lt;Self::Item&gt;
  fn nth(&mut self, n: usize) -> Option&lt;Self::Item&gt;
  fn skip(self, n: usize) -> Skip&lt;Self&gt;
  fn step_by(self, step: usize) -> StepBy&lt;Self&gt;
  fn map&lt;B, F&gt;(self, f: F) -> Map&lt;Self, F&gt;
     where F: FnMut(Self::Item) -> B
  fn for_each&lt;F&gt;(self, f: F)
     where F: FnMut(Self::Item)
  fn filter&lt;P&gt;(self, predicate: P) -> Filter&lt;Self, P&gt;
     where P: FnMut(&Self::Item) -> bool
  ...
}
            </defn-code>
          </li>
          <li>
            <defn-code style="font-size:1.0em; margin-left:-15px;">trait IntoIterator {
  type Item;
  type IntoIter: Iterator
  fn into_iter(self) -> Self::IntoIter
}
            </defn-code>
          </li>
        </ol>
      </div>
    </t-b>
    <t-b>
      Iterators provide a set of adapter methods for performing common operations on containers.
      Here&apos;s a longer partial list - see 
      <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Trait&nbsp;std::iter::Iterator</a>
      for more details:
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">Partial List of Iterator Adapters</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>fn <strong>next</strong>(&mut self) -> Option&lt;Self::Item&gt;</c-s><br />
                <s-5px></s-5px>
                Advances and returns value.
              </li>
              <li>
                <c-s>fn map&lt;B, F&gt;(self, f:F) -> Map&lt;Self, F&gt;</c-s><br />
                <c-s> where F: FnMut(Self::Item) -> B</c-s><br />
                <s-5px></s-5px>
                Takes a closure and creates an iterator that applies the closure to each item.
              </li>
              <li>
                <c-s>fn filter&lt;P&gt;(self, predicate:P) -> Filter&lt;Self, P&gt;</c-s><br />
                <c-s>where P: FnMust(&Self::Item) -> bool</c-s><br />
                <s-5px></s-5px>
                Creates an iterator that determines if an item should be included.
              </li>
              <li>
                <c-s>fn take(self, n:usize) -> Take&lt;Self&gt;</c-s>
              </li>
              <li>
                <c-s>
                  fn take_while&lt;P&gt;(self, predicate: P) -> TakeWhile&lt;Self, P&gt;<br />
                  where P: FnMut(&Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>
                  fn fold&lt;B, F&gt;(self, init:B, f:F) -> B<br />
                  where FnMut(B, Self::Item) -> B
                </c-s>
              </li>
              <li>
                <c-s>fn skip(self, n:usize) -> Skip&lt;Self&gt;</c-s>
              </li>
              <li>
                <c-s>
                  fn collect&lt;B&gt;(self) -> B<br />
                  where B: FromIterator&lt;Self::Item&gt;
                </c-s>
              </li>
              <li>
                <c-s>step_by(self, step:usize) -> StepBy&lt;Self&gt;<br /></c-s>
                <s-5px></s-5px>
                Skips step items on each iteration
              </li>
              <li>
                <c-s>nth(&mut self, n:usize) -> Option&lt;Self::item&gt;<br /></c-s>
                <s-5px></s-5px>
                Returns nth item, counting from zero
              </li>
              <li>
                <c-s>last(self) -> Option&lt;Self::item&gt;<br /></c-s>
                <s-5px></s-5px>
                Consumes iterator, returning last item
              </li>
              <li>
                <c-s>
                  fn find&lt;P&gt;(&mut self, predicate: P) -> Option&lt;Self::Item&gt;<br />
                  where FnMut(&Self::Item) -> bool
                </c-s> 
              </li>
              <li>
                <c-s>
                  fn position&lt;P&gt;(&mut self, predicate: P) -> Option&lt;usize&gt;<br />
                  where P: FnMut(Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>
                  fn for_each&lt;F&gt;(self, f:F)<br />
                  where F: FnMut(Self::Item)<br />
                </c-s>
                <s-5px></s-5px>
                Calls a closure on each element of an iterator.
              </li>
              <li>
                <c-s>fn enumerate(self) -> Enumerate&lt;Self&gt;<br /></c-s>
                <s-5px></s-5px>
                Creates an iterator returns a pair with current iteration count and next value.
              </li>
              <li>
                <c-s>fn by_ref(&mut self) -> &mut Self</c-s>
              </li>
              <li>
                <c-s>
                  fn all&lt;F&gt;(&mut self, f:F) -> bool<br />
                  where F: FnMut(Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>
                  fn any&lt;F&gt;(&mut self, f:F) -> bool<br />
                  where F: FnMut(Self::Item) -> bool
                </c-s>
              </li>
              <li>
                <c-s>fn count(self) -> usize<br /></c-s>
                <s-5px></s-5px>
                Consumes iterator, counting number of iterations
              </li>
              <li>
                <c-s>
                  fn chain&lt;U&gt;(self, other: U) -> Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;<br />
                  where U: IntoIterator&lt;Self::Item&gt;
                </c-s>
              </li>
              <li>
                <c-s>
                  fn zip&lt;U&gt;(self, other: U) -> Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;<br />
                  where U: IntoIterator
                </c-s>
              </li>
              <li>
                <c-s>
                  fn sum&lt;S&gt;(self) -> S<br />
                  where S: Sum&lt;Self::Item&gt;
                </c-s>
              </li>
              <li>
                <c-s>
                  fn product&lt;P&gt;(self) -> P<br />
                  where P: Product&lt;Self::Item&gt;
                </c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;iteration_echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>iteration_echo</defn-head>
              <defn-code>
  /////////////////////////////////////////////////////////////
  // iter_echo::main.rs - demonstrating iteration            //
  //                                                         //
  // Jim Fawcett, https://JimFawcett.github.io, 14 May 2020  //
  /////////////////////////////////////////////////////////////

  use std::collections::*;

  fn main() {

      let putline = || print!("\n");

      let mut hm: HashMap&lt;i32, &amp;str&gt; = HashMap::new();
      hm.insert(0, "zero");
      hm.insert(1, "one");
      hm.insert(2, "two");
      hm.insert(3, "three");
      hm.insert(4, "four");
      hm.insert(5, "five");
      hm.insert(6, "six");

      let iter = hm.iter();
      print!("\n  iterating over hashmap:\n  ");
      for item in iter {
          print!("{:?}", item);
      }
      putline();
      /*-- previous iter consumed so make new one --*/
      let iter = hm.iter();
      print!("\n  iterating and selecting odd entries:\n  ");
      for item in iter.step_by(2) {
          print!("{:?}", item);
      }
      putline();
      /*-- previous iter consumed so make new one --*/
      let iter = hm.iter();
      print!("\n  iterating and selecting even entries:\n  ");
      for item in iter.skip(1).step_by(2) {
          print!("{:?}", item);
      }
      putline();

      println!("\n  That's all Folks!\n");
  }
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>

  iterating over hashmap:
  (4, "four")(6, "six")(2, "two")(1, "one")
  (0, "zero")(3, "three")(5, "five")        

  iterating and selecting odd entries:
  (4, "four")(2, "two")(0, "zero")(5, "five")

  iterating and selecting even entries:
  (6, "six")(1, "one")(3, "three")

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      Find code for this example <a href="RustLibraryDemos.html">here</a>.
    </t-b>
    <t-b>
      Similar to the C++ std::algorithms, iterators provide a readable declarative interface for code doing
      compound operations on collection items.
    </t-b>
    <a id="io"></a>
    <h3>5.4 std::io - <span style="font-size:medium; font-weight:normal;">Base I/O, console operations</span></h3>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/io/index.html">std::io</a>
    </t-b>
    <t-b>
      <strong>Traits:</strong>
    </t-b>
    <t-b>
      Traits are contracts with function signatures that implementors are required to provide.  For example,
      every implementor of the Read trait is obligated to provide <c-s>read</c-s> and all the other methods
      from that trait.  The BufReader and Stdin structs both implement Read.
    </t-b>
    <t-b>
      In the dropdown, below, you will find the most important methods for the Read, BufRead, Seek, and Write
      traits.
    </t-b>
    <t-b>
      <div class="">
        <details>
          <summary class="labelStyle lightItem">Partial List of Traits</summary>
          <div class="indent">
            <s-halfEm></s-halfEm>
        <ol class="tight">
          <li>
          <defn-code>pub trait Read {
  fn read(&mut self, buf: &mut [u8]) -> Result&lt;usize&gt;
  fn read_exact(&mut self, buf: &mut [u8]) -> Result&lt;()&gt;
  fn read_to_end(&mut self, buf: &mut Vec&lt;u8&gt;) -> Result&lt;usize&gt;
  fn read_to_string(&mut self, buf: &mut String) -> Result&lt;usize&gt;
  fn by_ref(&mut self) -> &mut Self, where Self: Sized,
  fn bytes(self) -> Bytes&lt;Self&gt;, where Self: Sized,
  ...
}
            </defn-code>
          </li>
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">pub trait BufRead {
  fn fill_buf(&mut self) -> Result&lt;&[u8]&gt;
  fn consume(&mut self, amt: usize)
  fn read_until(&mut self, byte: u8, buf: &mut Vec&lt;u8&gt;) -> Result&lt;usize&gt;
  fn read_line(&mut self, buf: &mut String) -> Result&lt;usize&gt;
  fn lines(self) -> Lines&lt;Self&gt; // an iterator
  ...
}
            </defn-code>
          </li>
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">pub trait Write {
  fn write_all(&mut self, buf: &[u8]) -> Result&lt;()&gt;
  fn write(&mut self, buf: &[u8]) -> Result&lt;usize&gt;
  fn write_fmt(&mut self, fmt: Arguments) -> Result&lt;()&gt;
  fn by_ref(&mut self) -> &mut Self, where Self: Sized,
  fn flush(&mut self) -> Result&lt;()&gt;,
  ...
}
            </defn-code>
          </li>
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">pub trait Seek {
  fn seek(&mut self, pos: SeekFrom) -> Result&lt;u64&gt;
  fn stream_len(&mut self) -> Result&lt;u64&gt;
  ...
}
            </defn-code>
          </li>
        </ol>
            </div>
          </details>
      </div>
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      Structs are used to build library and user-defined types.  Here, you will find definitions for
      BufReader, BufWriter, Error, LineWriter, Stdin, and Stdout types.
    </t-b>
    <t-b>
      Two other structs, Bytes and Lines, are iterator types that provide access to the io state. You will find
      definitions for all of these in the dropdown, below.
    </t-b>
    <t-b>
      <div class="">
        <details>
          <summary class="labelStyle lightItem">Partial List of Structs</summary>
          <div class="indents">
          <s-halfEm></s-halfEm>
        <ol class="tights">
          <li>
            <defn-code>BufReader
  Implements Traits BufRead, Debug, Read, Seek, ...
  pub fn new(inner: R) -> BufReader&lt;R&gt; where R: Read
  pub fn get_ref(&self) -> &R
  pub fn get_mut(&self) -> &mut R
  pub fn buffer(&self) -> &[u8]
  pub fn into_inner(self) -> R
            </defn-code>
          </li>
          <li>
            <defn-code>BufWriter
  Implements Traits Debug, Drop, Seek, Write ...
  pub fn new(inner: W) -> BufWriter&lt;W&gt; where W: Write
  pub fn get_ref(&self) -> &W
  pub fn get_mut(&self) -> &mut W
  pub fn buffer(&self) -> &[u8]
  pub fn into_inner(self) -> Result&lt;W, IntoInnerError&lt;BufWriter&lt;W&gt;&gt;&gt;
            </defn-code>
          </li>
          <li>
            <defn-code>Bytes
  Implements Traits Debug, Iterator ...
            </defn-code>
          </li>
          <li>
            <defn-code>Error
  Implements Traits Debug, Display, Error, From&lt;ErrorKind&gt;, ...
  pub fn new&lt;E&gt;(kind: ErrorKind, error: E) -> Error
  pub fn get_ref(&self) -> Option&lt;&(dyn Error + Send + Sync + 'static')&gt;
  pub fn get_mut(&mut self) -> Option&lt;&mut (dyn Error + Send + Sync + 'static')&gt;
  pub fn into_inner(self) -> Option&lt;Box&lt;dyn Error + Send + Sync&gt;&gt;
  pub fn kind(&self) -> ErrorKind
            </defn-code>
          </li>
          <li>
            <defn-code>LineWriter
  Implements Traits Debug, Write ...
  pub fn new(inner: W) -> LineWriter&lt;W&gt; where W: Write
  pub fn get_ref(&self) -> &W
  pub fn get_mut(&self) -> &mut W
  pub fn into_inner(self) -> Result&lt;W, IntoInnerError&lt;LineWriter&lt;W&gt;&gt;&gt;
            </defn-code>
          </li>
          <li>
            <defn-code>Lines
  Implements Traits Debug, Iterator ...
            </defn-code>
          </li>
          <li>
            <defn-code>Stdin
  Implements Traits Debug, Read ...
  pub fn lock(&self) -> StdinLock
  pub fn read_line(&self, buf: &mut String) -> Result&lt;usize&gt;
            </defn-code>
          </li>
          <li>
            <defn-code>Stdout
  Implements Traits <c-s>Debug, Write ...</c-s>
  pub fn lock(&self) -> StdoutLock
            </defn-code>
          </li>
        </ol>
            </div>
          </details>
      </div>
    </t-b>
    <t-b>
      <strong>Functions:</strong>
    </t-b>
    <t-b>
      Here you will find a short list of functions that are occasionally useful for programs dealing with io.
    </t-b>
    <t-b>
      <div class="">
        <details>
          <summary class="labelStyle lightItem">Partial List of Functions</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
        <ol class="tight">
          <li>
            <c-s>pub fn copy&lt;R: ?Sized, W: ?Sized&gt;(reader: &mut R, writer: &mut W) -> Result&lt;u64&gt;</c-s>
          </li>
          <li>
            <c-s>pub fn stderr() -> Stderr</c-s>
          </li>
          <li>
            <c-s>pub fn stdin() -> Stdin</c-s>
          </li>
          <li>
            <c-s>pub fn stdout() -> Stdout</c-s>
          </li>
        </ol>
            </div>
          </details>
      </div>
    </t-b>
    <t-b>
      <strong>Types:</strong>
    </t-b>
    <t-b>
      <div class="indent"><c-s>type Result&lt;T&gt; = Result&lt;T, Error&gt;</c-s></div>
    </t-b>
    <t-b>
      You will find a relatively simple std::io echo program in the dropdown, below.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::io::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>io_echo</defn-head>
              <defn-code>
  /////////////////////////////////////////////////////////////
  // io_echo::main.rs - std::io library demonstration        //
  //                                                         //
  // Jim Fawcett, https://JimFawcett.github.io, 14 May 2020  //
  /////////////////////////////////////////////////////////////

  use std::io::prelude::*;

  fn main() -&gt; std::io::Result&lt;()&gt; {
      print!("\n  Echo std::io");
      print!("\n ==============");

      const QUIT:char = 'q';
      print!("\n  Enter single \'q\' character to terminate program");
      loop {
          print!("\n  enter some text: ");
          let _ = std::io::stdout().flush();
          let mut input_str = String::new();
          let size = std::io::stdin().read_line(&amp;mut input_str)?;

          /////////////////////////////////////////////////////////////
          // line below needs ctrl z to terminate read
          // let size = std::io::stdin().read_to_string(&amp;mut input_str)?

          print!("\n  read {} bytes", size);
          let rslt = input_str.chars().nth(0);
          if rslt == Some(QUIT) &amp;&amp; size == 3 {
              break;
          }
          let out_str = format!("\n  {:?}", input_str);
          std::io::stdout().write_all(out_str.as_ref())?;  // convert to &amp;[u8]
          std::io::stdout().flush()?;
      }
      println!("\n  That's all Folks!");
      Ok(())
  }
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output</defn-head>
              <defn-code>
  Echo std::io
 ==============
  Enter single 'q' character to terminate program
  enter some text: this is a test

  read 16 bytes
  "this is a test\r\n"
  enter some text: another line

  read 14 bytes
  "another line\r\n"
  enter some text: q

  read 3 bytes
  That's all Folks!

              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      You will find the example code <a  href="RustLibraryDemosCode.html">here</a>.
    </t-b>
    <a id="fs"></a>
    <h3>5.5 std::fs - <span style="font-size:medium; font-weight:normal;">File system operations</span></h3>
    <t-b>
      Working with files and directories is well supported in Rust with the
      <a href="https://doc.rust-lang.org/std/fs/index.html">std::fs</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The most important std::fs types are listed here - DirBuilder, DirEntry, File, FileType, Metadata,
      OpenOptions, Permissions, and ReadDir:
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li><defn-code>DirBuilder
  Implements Traits Debug, ...
  pub fn new() -> DirBuilder
  pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(&mut self, path: P) -> Result&lt;()&gt;
  pub fn recursive(&mut self, recursive: bool) -> &mut Self
                </defn-code>
              </li>
              <li><defn-code>DirEntry
  Implements Traits Debug, ...
  pub fn path(&self) -> PathBuf
  pub fn metadata(&mut self) -> Result&lt;Metadata&gt;
  pub fn metadata(&mut self) -> Result&lt;Metadata&gt;
  pub fn metadata(&mut self) -> Result&lt;Metadata&gt;
  pub fn file_name(&mut self) -> OsString
                </defn-code>
              </li>
              <li><defn-code>File
  Implements Traits Debug, Read, Seek, Write, ...
  pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;File&gt;
  pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;File&gt;
  pub fn set_len(&mut self, size: u64) -> Result&lt;()&gt;
  pub fn metadata(&mut self) -> Result&lt;Metadata&gt;
  pub fn set_permissions(&mut self, perm: Permissions) -> Result&lt;()&gt;
                </defn-code>
              </li>
              <li><defn-code>FileType
  Implements Traits Clone, Copy, Debug, ...
  pub fn is_dir(&mut self) -> bool
  pub fn is_file(&mut self) -> bool
                </defn-code>
              </li>
              <li><defn-code>Metadata
  Implements Traits Clone, Debug, ...
  pub fn file_type(&mut self) -> FileType
  pub fn is_dir(&mut self) -> bool
  pub fn is_file(&mut self) -> bool
  pub fn len(&mut self) -> u64
  pub fn permissions(&mut self) -> Permissions
  pub fn modified(&mut self) -> Result&lt;SystemTime&gt;
  pub fn accessed(&mut self) -> Result&lt;SystemTime&gt;
  pub fn created(&mut self) -> Result&lt;SystemTime&gt;
                </defn-code>
              </li>
              <li><defn-code>OpenOptions
  Implements Traits Clone, Debug, ...
  pub fn new() -> OpenOptions
  pub fn read(&mut self, read: bool) -> &mut OpenOptions
  pub fn write(&mut self, write: bool) -> &mut OpenOptions
  pub fn append(&mut self, append: bool) -> &mut OpenOptions
  pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions
  pub fn create(&mut self, create: bool) -> &mut OpenOptions
  pub fn create_new(&mut self, create_new: bool) -> &mut OpenOptions
  pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(&self, path: P) -> Result&lt;File&gt;
                </defn-code>
              </li>
              <li><defn-code>Permissions
  Implements Traits Clone, Debug, Eq, PartialEq, ...
  pub fn readonly(&self) -> bool
  pub fn set_readonly(&mut self, readonly: bool)
                </defn-code>
              </li>
              <li><defn-code>ReadDir
  Implements Traits Debug, Iterator, ...
                </defn-code>
                <div class="indent" style="margin-top:-1em;">
                  <t-b style="margin-top:5px; margin-bottom:5px;">
                    Iterator over entries in a directory, returned from the read_dir(p: Path)
                    function.
                  </t-b>
                  <t-b style="margin-top:5px; margin-bottom:5px;">
                    Yields instances of io::Result&lt;DirEntry&gt;
                  </t-b>
                </div>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <strong>Functions:</strong>
    </t-b>
    <t-b>
      Quite often, you may only need some of the functions, listed here, for a program&apos;s file and directory
      management needs.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">Partial List of IO Functions</summary>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>fn canonicalize&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;PathBuf&gt;</c-s>
              </li>
              <li>
                <c-s>fn create_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn read_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;ReadDir&gt;</c-s>
              </li>
              <li>
                <c-s>fn remove_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn metadata&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;Metadata&gt;</c-s>
              </li>
              <li>
                <c-s>fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;Vec&lt;u8&gt;&gt;</c-s>
              </li>
              <li>
                <c-s>fn read_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;ReadDir&gt;</c-s>
              </li>
              <li>
                <c-s>fn read_to_string&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;String&gt;</c-s>
              </li>
              <li>
                <c-s>fn write&lt;P: AsRef&lt;Path&gt;&gt;, C: AsRef&lt;[u8]&gt;&gt;(path: P, contents: C) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn remove_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn rename&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;</c-s>
              </li>
              <li>
                <c-s>fn set_permissions&lt;P: AsRef&lt;Path&gt;&gt;(path: P, perm: Permissions) -> Result&lt;()&gt;</c-s>
              </li>
            </ol>
          </div>
          <div style="height:0.5em;"></div>
        </details>
      </div>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::fs::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>fs_echo::main.rs</defn-head>
              <defn-code>
  /////////////////////////////////////////////////////////////
  // fs_echo::main.rs - demonstrate file operations          //
  //                                                         //
  // Jim Fawcett, https://JimFawcett.github.io, 15 May 2020  //
  /////////////////////////////////////////////////////////////

  use std::fs::*;
  use std::io::*;

  /*-----------------------------------------------------------
     Note:
     The try operator ? has been used in several places in 
     both using_File and using_OpenOptions to avoid a lot
     of explicit error handling.

     The try operator bubbles errors up to the caller, so
     if there are several places where errors may occur, 
     they can all be handled in one place by the caller.

     What is surprising, but useful, is that the Result&lt;T,E&gt;
     types are not all the same.  In some results the type T
     is File, or (), or usize.  However, the error types are
     all io::Error, and that is what ? returns to the caller,
     so it just works!

     If there are no errors, ? simply unwraps the result to 
     be used, and everything is significantly simpler.
  */
  #[allow(non_snake_case)]
  fn using_File(file_name:&amp;str, msg:&amp;str)
       -&gt; std::io::Result&lt;()&gt; {
      let mut wfile = File::create(file_name)?;
      print!(
          "\n  writing message {:?} to file {:?}", 
          msg, file_name
      );
      wfile.write_all(msg.as_bytes())?;
      let mut rfile = File::open(file_name)?;
      let mut rcv_msg = String::new();
      let _ = rfile.read_to_string(&amp;mut rcv_msg);
      print!(
          "\n  message {:?} read from {:?}", 
          rcv_msg, file_name
      );
      Ok(())
  }
  fn open_file_for_write(path:&amp;str)
       -&gt; std::io::Result&lt;File&gt; {
      let wfile = OpenOptions::new()
                  .create(true)
                  .write(true)
                  .truncate(true)
                  .open(path)?;
      Ok(wfile)
  }
  fn open_file_for_read(path:&amp;str)
         -&gt; std::io::Result&lt;File&gt; {
      let rfile = OpenOptions::new()
                  .read(true)
                  .open(path)?;
      Ok(rfile)
  }
  #[allow(non_snake_case)]
  fn using_OpenOptions(file_name:&amp;str, msg:&amp;str)
      -&gt; std::io::Result&lt;()&gt; {
      let mut wfile = open_file_for_write(file_name)?;
      print!(
          "\n  writing message {:?} to file {:?}", 
          msg, file_name
      );
      wfile.write_all(msg.as_bytes())?;

      let mut rfile = open_file_for_read(file_name)?;
      let mut rcv_msg = String::new();
      let _ = rfile.read_to_string(&amp;mut rcv_msg);
      print!(
          "\n  message {:?} read from {:?}", 
          rcv_msg, file_name
      );
      Ok(())
  }
  fn main() -&gt; std::io::Result&lt;()&gt; {
      let putline = || print!("\n");

      let file_name = "test.txt";
      let msg = "msg from writer";
      print!("\n  std::fs echo demonstration");
      print!("\n ============================");
      putline();

      print!("\n  demo using File structure");
      print!("\n ---------------------------");
      using_File(file_name, msg)?;
      putline();

      print!("\n  demo using OpenOptions structure");
      print!("\n ----------------------------------");
      using_OpenOptions(file_name, msg)?;

      println!("\n\n  That's all Folks!\n");
      Ok(())
  }
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  std::fs echo demonstration
  ============================

  demo using File structure
  ---------------------------
  writing message "msg from writer" to file "test.txt"
  message "msg from writer" read from "test.txt"

  demo using OpenOptions structure
  ----------------------------------
  writing message "msg from writer" to file "test.txt"
  message "msg from writer" read from "test.txt"

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be bound <a href="RustLibraryDemos.html">here</a>.
    </t-b>
    <a id="net"></a>
    <h3>5.6 net: - <span style="font-size:medium; font-weight:normal;">Socket operations</span></h3>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/net/index.html">std::net</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::net types are: 
      <c-b style="margin-top:-0.5em;">
  TcpListener, Incoming, TcpStream, UdpSocket, Ipv4Addr, Ipv6Addr, 
  SocketAddrV4, SocketAddrV6, AddrParseError, ...
      </c-b>
    </t-b>
    <t-b>
      <div class="detailsp">
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li> <defn-code> TcpListener
   Traits: Debug, ...
   pub fn bind&lt;A: ToSocketAddrs&gt;(addr: A) -> Result&lt;TcpListener&gt;
   pub fn accept(&self) -> Result&lt;(TcpStrea,. SpcletAddr)&gt;
   pub fn inoming(&self) -> Incoming
   pub fn take_error(&self) -> Result&lt;Option&lt;Error&gt;&gt;
   pub fn set_nonblocking(&self, nonblocking: bool) -> Result&lt;()&gt;
   ...
                </defn-code>
              </li>
              <li><defn-code>TcpStream
  Traits: Read, Write, Debug, ...
  pub fn connect&lt;A: ToSoketAddrs&gt;(addr: A) -> Result&lt;TcpStream&gt;
  pub fn shutdown(&self, how: Shutdown) -> Result&lt;()&gt;
  pub fn peek(&mut self, buf: &mut [u8]) -> Result&lt;usize&gt;
  pub fn take_error(&self) -> Result&lt;Option&lt;Error&gt;&gt;
  pub fn set_nonblocking(&self, nonblocking: bool) -> Result&lt;()&gt;
  ...
                </defn-code>
              </li>
              <li><defn-code>UdpSocket
  Traits: Debug, ...
  pub fn bind&lt;A: ToSocketAddrs&gt;(addr: A) -> Result&lt;TcpListener&gt;
  pub fn recv_from(&self, buf: &mut [u8]) -> Result&lt;(usize, SocketAddr)&gt;
  pub fn peek_from(&self, buf: &mut [u8]) -> Result&lt;(usize, SocketAddr)&gt;
  pub fn send_to&lt;A: ToSocketAddrs&gt;(&self, buf: &[u8], addr: A) -> Result&lt;usize&gt;
  pub fn set_broadcast(&self, broadcast: bool) -> Result&lt;()&gt;
  pub fn broadcast(&mut self) -> Result&lt;bool&gt;
  pub fn take_error(&self) -> Result&lt;Option&lt;Error&gt;&gt;
  pub fn connect&lt;A: ToSocketAddrs&gt;(&self, addr: A) -> Result&lt;()&gt;
  pub fn send(&self, buf: &mut [u8]) -> Result&lt;usize&gt;
  pub fn recv(&self, buf: &mut [u8]) -> Result&lt;usize&gt;
  pub fn peek(&self, buf: &mut [u8]) -> Result&lt;usize&gt;
  pub fn set_nonblocking(&self, nonblocking: bool) -> Result&lt;()&gt;
  ...
                </defn-code>
              </li>
              <li><defn-code>Ipv4Addr
  Implements Traits Debug, Display, copy, clone, Eq, PartialEq, From ...
  pub const fn new(a: u8, b: u8, c: u8, d: u8) -> IpvrAddr
  pub const LOCALHOST: Self
  pub const UNSPECIFIED: Self
  pub const BROADCAST: Self
  pub fn octets(&self) -> [u8; 4]
  pub fn is_unspecified(&self) -> bool
  pub fn is_loopback(&self) -> bool
  pub fn is_private(&self) -> bool
  pub fn is_multicast(&self) -> bool
  pub fn is_broadcast(&self) -> bool
  pub fn to_ipv6_compatible(&self) -> Ipv6Addr
  pub fn to_ipv6_mapped(&self) -> Ipv6Addr
                </defn-code>
              </li>
              <li><defn-code>Ipv6Addr
  Implements Traits Debug, Display, copy, clone, Eq, PartialEq, From ...
  pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> IpvrAddr
  pub const LOCALHOST: Self
  pub const UNSPECIFIED: Self
  pub fn segments(&self) -> [u16; 8]
  pub fn octets(&self) -> [u8; 16]
  pub fn is_unspecified(&self) -> bool
  pub fn is_loopback(&self) -> bool
  pub fn is_multicast(&self) -> bool
  pub fn to_ipv4(&self) -> Ipv4Addr
                </defn-code>
              </li>
              <li><defn-code>SocketAddrV4
  Traits: Debug, Display, Copy, Clone, Eq, PartialEq, From, FromStr, ToSocketAddrs, ...
  pub fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4
  pub fn ip(&self) -> &Ipv4Addr
  pub fn set_ip(&mut self, new_ip: Ipv4Addr)
  pub fn port(&self) -> u16
  pub fn set_port(&mut self, new_port: u16)
                </defn-code>
              </li>
              <li><defn-code>SocketAddrV6
  Traits: Debug, Display, Copy, Clone, Eq, PartialEq, From, FromStr, ToSocketAddrs, ...
  pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6
  pub fn ip(&self) -> &Ipv6Addr
  pub fn set_ip(&mut self, new_ip: Ipv6Addr)
  pub fn port(&self) -> u16
  pub fn set_port(&mut self, new_port: u16)
  pub fn flowinfo(&self) -> u32
  pub fn set_flowinfo(&mut self, new_flowinfo: u32)
  pub fn scope_id(&self) -> u32
  pub fn set_scope_id(&mut self, new_scope_id: u32)
                  </defn-code>
                </li>
                <li><defn-code>AddrParseError
  Traits: Error, Debug, Display, Clone, Eq, PartialEq, ...
                  </defn-code>
                </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <strong>Enums:</strong>
    </t-b>
    <t-b>
      The net library has enums: IpAddr, SocketAddr, Shutdown, and Ipv6MulitcastScope.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of net Enums</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>pub enum IpAddr { V4(Ipv4Addr), V6(Ipv6Addr), }</c-s>
              </li>
              <li>
                <c-s>pub enum SocketAddr { V4(SocketAddrV4), V6(SocketAddrV6), }</c-s>
              </li>
              <li>
                <c-s>pub enum Shutdown { Read, Write, Both, }</c-s>
              </li>
              <li>
                <c-s>pub enum Ipv6MulticastScope {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;InterfaceLocal, LinkLocal, RealmLocal, AdminLocal, SiteLocal, OrganizationLocal, Global,<br />
                }</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::net::echo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>net_echo::main.rs</defn-head>
              <defn-code>
  /////////////////////////////////////////////////////////////
  // net_echo::main.rs - demonstrate Tcp communication       //
  //                                                         //
  // Jim Fawcett, https://JimFawcett.github.io, 16 May 2020  //
  /////////////////////////////////////////////////////////////
  /*
     This demo uses TcpListener and TcpStream which use 
     sockets internally.  So, like sockets, they are byte
     oriented.

     In order to send messages, the application needs a 
     protocol for defining when to stop reading bytes.
     For this, newlines are used as message terminators,
     which works well for this demonstration.

     An application will probably need something more
     flexible like HTTP style messages.
  */
  use std::io::prelude::*;
  use std::net::{TcpStream, TcpListener, Shutdown::Both};
  use std::thread;
  use std::str;
  use std::io::{BufReader};

  /*-- demo handler receives one msg and replys --*/
  fn handle_client(mut stream: &amp;TcpStream)
         -&gt; std::io::Result&lt;()&gt; {
      print!("\n  entered client handler");
      let mut reader = 
          BufReader::new(stream.try_clone()?);
      let mut rcv_msg = String::new();
      reader.read_line(&amp;mut rcv_msg)?;
      rcv_msg.pop();  // remove '\n' sentinal
      print!("\n  client handler received: ");
      print!("{:?}",rcv_msg);
      let _ = std::io::stdout().flush();

      rcv_msg.push_str(" recieved!\n");
      let _ = std::io::stdout().flush();
      stream.write_all(&amp;rcv_msg.as_bytes())?;
      stream.shutdown(Both)?;
      Ok(())
  }
  /*-- demo listener accepts only one connection --*/
  fn start_listener(end_point :&amp;str)
          -&gt; std::io::Result&lt;()&gt; {
      print!(
          "\n  starting listener on {:?}", end_point
      );
      let _ = std::io::stdout().flush();
      let tcpl = TcpListener::bind(end_point)?;
      for stream in tcpl.incoming() {
          print!("\n  listener accepted connection");
          let _ = handle_client(&amp;stream?)?;
          /*-- Here, just accept one connection --*/
          break;
      }
      Ok(())
  }
  /*-- demonstration --*/
  fn main() -&gt; std::io::Result&lt;()&gt; {

      print!("\n  net_echo demonstration");
      print!("\n ========================");

      let rcvr_endpoint = "127.0.0.1:8080";
      let mut msg = "msg from connector".to_string();

      /*-- run listener on child thread --*/
      let handle = thread::spawn( 
          move || { 
              let _ = start_listener(rcvr_endpoint); 
          }
      );

      /*-- send message --*/
      print!("\n  connecting to {:?}", rcvr_endpoint);
      let mut stream = 
          TcpStream::connect(rcvr_endpoint)?;
      print!("\n  sending message {:?}", msg);
      msg.push('\n');  // message end sentinal
      stream.write_all(&amp;msg.as_bytes())?;

      /*-- read reply message --*/
      let mut reader = 
          BufReader::new(stream.try_clone()?);
      let mut rcv_msg = String::new();
      reader.read_line(&amp;mut rcv_msg)?;
      rcv_msg.pop();  // remove '\n' sentinal
      print!(
          "\n  connector received reply {:?}", rcv_msg
      );
      let _ = std::io::stdout().flush();

      let _ = handle.join();  // wait for shutdown

      println!("\n\n  That's all Folks!\n\n");
      Ok(())
  }
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  net_echo demonstration
 ========================
  connecting to "127.0.0.1:8080"
  starting listener on "127.0.0.1:8080"
  sending message "msg from connector"
  listener accepted connection
  entered client handler
  client handler received: "msg from connector"
  connector received reply 
                "msg from connector recieved!"

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be found <a href="RustLibraryDemos.html">here</a>.
    </t-b>

    <a id="thread"></a>
    <h3>5.7 Thread - <span style="font-size:medium; font-weight:normal;">basic threads</span></h3>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/thread/index.html">std::thread</a> library.
    </t-b>
    <t-b>
      Thread related Traits:
      <div class="indent">
        <ol class="tight">
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">trait Send { }
// marker trait
// - types that can be transferred across thread boundaries
          </defn-code>
          </li>
          <li>
          <defn-code style="font-size:1.0em; margin-left:-15px;">trait Sync { }
// marker trait
// - types for which it is safe to share references between threads
          </defn-code>
          </li>
        </ol>
      </div>
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::thread types are: Thread, Builder, ThreadId, JoinHandle, LocalKey, AcessError  
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li><defn-code>Thread
  Traits: Debug, Clone, Send, Sync, ...
  pub fn id(&self) -> ThreadId
  pub fn name(&self) -> Option&lt;&amp;str&gt;
                </defn-code>
              </li>
              <li><defn-code>ThreadId
  Traits: Debug, Copy, Clone, Eq, PartialEq, Send, Sync, ...
                </defn-code>
              </li>
              <li><defn-code>Builder
  Traits: Debug, Send, Sync, ...
  pub fn new() -> Builder
  pub fn name(self, name: String) -> Builder
  pub fn stack_size(self, size: usize) -> Builder
  pub fn spawn&lt;F, T&gt;(self, f: F) -> Result&lt;JoinHandle&lt;T&gt;&gt;
  where F: FnOnce() -> T, F: Send + 'static', T: Send + 'static'
                </defn-code>
              </li>
              <li><defn-code>JoinHandle
  Traits: Debug, Send, Sync, ...
  pub fn thread(&self) -> &Thread
  pub fn join(self) -> Result&lt;T&gt;
                </defn-code>
              </li>
              <li><defn-code>LocalKey
  Traits: Debug, Send, Sync, ...
  pub fn with&lt;F, R&gt;(&'static self, f: F) -> R
  where F: FnOnce(&T) -> R
  ...
                </defn-code>
              </li>
              <li><defn-code>AccessError
  Traits: Debug, Display, Clone, Copy, Eq, PartialEq, Error, Send, Sync, ...
                </defn-code>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      Thread functions are: <c-s>spawn, current, sleep, yield_now, ...</c-s>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Functions</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>pub fn spawn&lt;F, T&gt;(f: F) -> JoinHandle&lt;T&gt;</c-s>
                <c-s>where F: FnOnce() -> T, F: Send + 'static, T: Send + 'static</c-s>
              </li>
              <li>
                <c-s>pub fn current() -> Thread</c-s>
              </li>
              <li>
                <c-s>pub fn sleep(dur: std::time::Duration)</c-s>
              </li>
              <li>
                <c-s>pub fn yield_now()</c-s>
              </li>
              <li>
                <c-s>...</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      Types:
      <div class="indent">
        <c-s>type Result&lt;T&gt; = Result&ltT, Box&lt;dyn Any + Send + 'static&gt;&gt;</c-s>
      </div>
    </t-b>
    <div style="height:0.5em;"></div>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;std::thread::Shared</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>std::thread::shared</defn-head>
              <defn-code>
  /////////////////////////////////////////////////////////////
  // thread_shared::main.rs - shared string demo             //
  //                                                         //
  // Jim Fawcett, https://JimFawcett.github.io, 10 May 2020  //
  /////////////////////////////////////////////////////////////

  #![allow(dead_code)]

  use std::thread;
  use std::sync::{Arc, Mutex};
  use std::time::Duration;

  fn db_show&lt;T:std::fmt::Debug&gt;(t:T, msg:&amp;str, p:bool) {
      print!("\n  --{}", msg);
      if p {
          let name = std::any::type_name::&lt;T&gt;();
          print!(
              "\n  --TypeId: {},
              \n  --size: {}", 
              name, std::mem::size_of::&lt;T&gt;()
          );
      }
      print!("\n  --{:?}", t);
  } 
  fn thread_id() -&gt; thread::ThreadId {
      thread::current().id()
  }
  fn thread_id_value(id:thread::ThreadId) -&gt; char {
      let sid = format!("{:?}", id);
      sid.chars().nth(9).unwrap()
  }
  fn test2() -&gt; std::io::Result&lt;()&gt; {
      print!("\n  Two child threads sharing string");
      print!("\n ==================================");

      let thrd1_id = thread_id_value(thread::current().id());
      print!("\n  main thread id      = {:?}", thrd1_id);
      let dur = Duration::from_millis(2);  // sleep time
      let mut s = String::new();            // shared string
      s.push(thrd1_id);  // main thread gets first edit

      let data = Arc::new(Mutex::new(s));   
      // thread safe shared wrapper
    
      /*-------------------------------------------------------
          Modify String s on child thread #1
      */
      let shared1 = Arc::clone(&amp;data);
      // clones pointer to data ref
      let _handle1 = thread::spawn(move || { 
          // shared1 clone moved without moving data
          let sid:String = format!("{:?}",thread::current().id());
          // sid = "ThreadId(2)"
          if let Some(sid) = sid.chars().nth(9) {
              // ThreadId(2) =&gt; 2
              for _i in 0..15 {
                  {
                      if let Ok(mut temp) = shared1.lock() {
                          temp.push(sid);  // append thread id
                      }
                  }  // unlocked here
                  thread::sleep(dur);
              }
          }
      });
    
      /*-------------------------------------------------------
          Modify String s on child thread #2
      */
      let shared2 = Arc::clone(&amp;data);
      // db_show(&amp;shared2, "shared2", false);
      let _handle2 = thread::spawn(move || { 
          let sid:String = format!("{:?}",thread::current().id());
          if let Some(sid) = sid.chars().nth(9) {
              for _i in 0..15 {
                  {
                      if let Ok(mut temp) = shared2.lock() {
                          temp.push(sid);
                      }
                  }
                  thread::sleep(dur);
              }
          }
      });
      /*-------------------------------------------------------
          main thread displaying child threads ids and then
          joining them, e.g., block until threads complete
      */
      let thrd2_id = thread_id_value(_handle1.thread().id());
      print!("\n  1st child thread id = {:?}", thrd2_id);
      let _ = _handle1.join();
      let thrd3_id = thread_id_value(_handle2.thread().id());
      print!("\n  2nd child thread id = {:?}", thrd3_id);
      let _ = _handle2.join();

      /*-------------------------------------------------------
          extract mutex from arc
          - commented line is simple but may panic
          - code used here manages error without panic
      */
      // let out = Arc::try_unwrap(data).expect("lock still owned");
      let rslt = Arc::try_unwrap(data);
      let out :Mutex&lt;String&gt;;
      match rslt {
          Ok(mtx) =&gt; out = mtx,
          Err(_) =&gt; {
              let error = std::io::Error::new(
                  std::io::ErrorKind::Other, 
                  "Arc access error"
              );
              return Err(error);
          },
      }
      /*-------------------------------------------------------
          extract string from mutex
          - commented line is simple but may panic
          - code used here manages error without panic
      */
      //let mut shared = out.into_inner().expect("can't lock mutex");
      let mut shared: String;
      let rslt = out.into_inner();
      match rslt {
          Ok(s) =&gt; shared = s,
          Err(_) =&gt; {
              let error = std::io::Error::new(
                  std::io::ErrorKind::Other, 
                  "Mutex access error"
              );
              return Err(error);
          } 
      }
      shared.push(thrd1_id);  // main thread has last edit

      /*-- display result of string modifications --*/
      print!("\n  final shared string value = {:?}",shared);
      Ok(())
  }
  fn main() -&gt; std::io::Result&lt;()&gt; {

      test2()?;

      println!("\n\n  That's all Folks!\n\n");
      Ok(())
  }
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  Two child threads sharing string
 ==================================
  main thread id      = '1'
  1st child thread id = '2'
  2nd child thread id = '3'
  final shared string value = 
      "12323322332233223323232323223231"   

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be found in <a href="RustLibraryDemos.html">RustLibraryDemos</a>.
    </t-b>

    <a id="sync"></a>
    <h3>5.8 sync - <span style="font-size:medium; font-weight:normal;">Serialization with Mutexes, Condvars</span></h3>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/sync/index.html">std::sync</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::sync types are: 
      <c-b class="indent" style="margin-top: -0.5em; margin-bottom: -1em; ">
  Arc, Barrier, BarrierWaitResult, Condvar, Mutex, MutexGuard, Once, PoisonError,
  RwLock, RwLockReadGuard, RwLockWriteGuard, WaitTimeoutResult, Weak, OnceState
      </c-b>
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.Arc.html">Arc</a>
  Traits: Debug, Display, Default, AsRef&lt;T&gt;, Deref, From, FromIterator, Eq, PartialEq, 
  Pointer, Send, Sync, ...
  pub fn new(data: T) -> Arc&lt;T&gt;
  pub fn try_unwrap(this: Arc&lt;T&gt;) -> Result&lt;T, Arc&lt;T&gt;&gt;
  pub fn downgrade(this: &Arc&lt;T&gt;) -> Weak&lt;T&gt;
  pub fn weak_count(this: &Arc&lt;T&gt;) -> usize
  pub fn strong_count(this: &Arc&lt;T&gt;) -> usize
  pub fn ptr_eq(this: &Arc&lt;T&gt;, other: &Arc&lt;T&gt;) -> bool
  pub fn make_mut(this: &Arc&lt;) -> &mut T where T: Clone
  pub fn get_mut(this: &Arc&lt;) -> Option&lt;&mut T&gt; where T: ?Sized
                </defn-code>
              </li>
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.Mutex.html">Mutex</a>
  Traits: Debug, Default, for, Send, Sync...
  pub fn new(t: T) -> Mutex&lt;T&gt;
  pub fn lock(&self) -> LockResult&lt;MutexGuard&lt;T&gt;&gt; where T: ?Sized
  pub fn try_lock(&self) -> TryLockResult&lt;MutexGuard&lt;T&gt;&gt; where T: ?Sized
  pub fn is_poisoned(&self) -> bool
  pub fn into_inner(self) -> LockResult&lt;T&gt; where T: Sized
  pub fn get_mut(&mut self) -> LockResult&lt;&mut T&gt;
  ...
                </defn-code>
              </li>
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.MutexGuard.html">MutexGuard</a>
  Traits: <c-s>Debug, Default, Send, Sync, ...
                </defn-code>
              </li>
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.Condvar.html">Condvar</a>
  Traits: <c-s>Debug, Default, Send, Sync, ...
  pub fn new() -> ConVar
  pub fn wait&lt;'a, T&gt;(&self, guard: MutexGuard&lt;'a, T&gt;)
      -> LockResult&lt;MutexGuard&lt;'a, T&gt;&gt;
  pub fn wait_while&lt;'a, T, F&gt;(&self, guard: MutexGuard&lt;'a, T&gt;, condition: F)
      -> LockResult&lt;MutexGuard&lt;'a, T&gt;&gt; where F: FnMut(&mut T) -> bool
  pub fn wait_timeout&lt;'a, T&gt;(&self, guard: MutexGuard&lt;'a, T&gt;, dur: Duration)
      -> LockResult&lt;(MutexGuard&lt;'a, T&gt;, WaitTimeoutResult)&gt;
  pub fn notify_one(&self)
  pub fn notify_all(&self)
                </defn-code>
              </li>
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.RwLock.html">RwLock</a>
  Traits: rDebug, Default, From, Send, Sync, ...
  pub fn new(t: T) -> RwLock&lt;T&gt;
  pub fn read(&self) -> LockResult&lt;RwLockReadGuard&lt;T&gt;&gt;
                </defn-code>
              </li>
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.RwLockReadGuard.html">RwLockReadGuard</a>
  Traits: <c-s>Debug, Display, Deref, !Send, Sync, ...
                </defn-code>
              </li>
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.RwLockWriteGuard.html">RwLockWriteGuard</a>
  Traits: <c-s>Debug, Display, Deref, DerefMut, !Send, Sync, ...
                </defn-code>
              </li>
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.Weak.html">Weak</a>
  Traits: Debug, Default, Clone, Send, Sync, ...
  pub fn new() -> Weak&lt;T&gt;
  pub fn upgrade(&self) -> Option&lt;Arc&lt;T&gt;&gt;
  pub fn strong_count(&self) -> usize
  pub fn ptr_eq(&self, other: &Weak&lt;T&gt;) -> bool
                </defn-code>
              </li>
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.WaitTimeoutResult.html">WaitTimeoutResult</a>
  Traits: Debug, Copy, Clone, Eq, PartialEq, Send, Sync, ...
  pub fn timed_out(&self) -> bool
                </defn-code>
              </li>
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.Once.html">Once</a>
  Traits: Debug, Send, Sync, ...
  pub const fn new(&self) -> Once
  pub fn call_once&lt;F&gt;(&self, f: F) where F: FnOnce()
  pub fn is_completed&lt;F&gt;(&self) -> bool
                </defn-code>
              </li>
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.Barrier.html">Barrier</a>
  Traits: Debug, Send, Sync, ...
  pub fn new(n: usize) -> Barrier
  pub fn wait(&self) -> BarrierWaitResult
                </defn-code>
              </li>
              <li><defn-code><a href="https://doc.rust-lang.org/beta/std/sync/struct.BarrierWaitResult.html">BarrierWaitResult</a>
  Traits: Debug, Send, Sync, ...
                </defn-code>
              </li>
              <li>
                ...
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      <strong>Sync enum:</strong>
    </t-b>
    <t-b>
      <div class="indent pad5">
        <c-s>pub enum TryLockError&lt;T&gt; { Poisoned(PoisonError&lt;T&gt;), WouldBlock, }</c-s>
      </div>
    </t-b>
    <t-b>
      <strong>Sync type definitions:</strong>
    </t-b>
    <t-b>
      <div class="indent pad5">
        <c-s>type LockResult&lt;Guard&gt; = Result&lt;Guard, PoisonError&lt;Guard&gt;&gt;;</c-s><br />
        <c-s>type TryLockResult&lt;Guard&gt; = Result&lt;Guard, TryLockError&lt;Guard&gt;&gt;;</c-s><br />
      </div>
      <s-halfEm></s-halfEm>
    </t-b>
    <t-b>
      The example below builds a loosely coupled set of parts, using <c-s>Arc</c-s>,<c-s> Mutex</c-s>, and 
      <c-s>Condvar</c-s>, that act like a blocking queue
      and demonstrate sending messages.  Focus here
      on the use of synchronization constructs to avoid data races (the code won&apos;t compile 
      if you don&apos;t use them).
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;sync_demo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Example:&nbsp;&nbsp;std::sync - Blocking Queue Parts</defn-head>
              <defn-code>
  /////////////////////////////////////////////////////////////
  // sync_demo::main.rs - BlockingQueue Prototype            //
  //                                                         //
  // Jim Fawcett, https://JimFawcett.github.io, 19 May 2020  //
  /////////////////////////////////////////////////////////////
  /*
     This is a prototype for a blocking queue, essentially some
     pieces that act like a blocking queue, but not yet put
     into an abstraction for that.

     In the next demo we build a nice abstraction for this
     behavior.
  */
  #![allow(clippy::mutex_atomic)]
  use std::io::*;
  use std::{time};
  use std::sync::atomic::*;

  fn demo()  {

      use std::sync::{Arc, Mutex, Condvar};
      use std::thread;
      use std::collections::*;
    
      /*---------------------------------------------
          shared queue and condition variable 
          - condition variable makes thread wait for
            queue to have at least one entry
          - It is the reason queue blocks dequeuer
            when empty.
          - Arcs are thread-safe pointers, so both
            shared1 and its clone, shared2, refer to 
            the same locks and queue.
      */
      let shared1 = Arc::new((
          Mutex::new(VecDeque::&lt;String&gt;::new()), 
          Condvar::new(),
      ));
      let shared2 = shared1.clone();
    
      /*---------------------------------------------
          Atomic used to poll for active thread
      */
      let thread_started = Arc::new(AtomicBool::new(false));
      let checker = thread_started.clone();

      /*---------------------------------------------
          Start child thread
          - Dequeues messages sent by main thread.
      */
      let handle = thread::spawn(move|| {

          print!("\n  thread started");
          thread_started.store(true, Ordering::SeqCst);
          let _time_delay = time::Duration::from_millis(55);
          let (lq, cvar) = &amp;*shared2;
          loop {
              //thread::sleep(_time_delay);
              let item: String;
              {
                  /*-- acquire lock --*/
                  let mut q = lq.lock().unwrap();
                
                  /*-- block on empty queue --*/
                  while q.len() == 0 {  // may get spurious returns
                      q = cvar.wait(q).unwrap();
                  }
                  /*-- dequeue and display message --*/
                  item = q.pop_front().unwrap();
              }   // lock released
            
              print!("\n  dequeued {:?} on child thread", item);
              let _ = std::io::stdout().flush();
            
              /*-- client shuts down dequeuer with quit msg --*/
              if item == "quit" {
                  break;
              }
          }
    
          print!("\n  thread finishing");
      });

      /*---------------------------------------------
          Main thread thread enqueues messages
          for child thread.
      */
      /*-- wait for child thread to start ---------*/
      let _time_delay = time::Duration::from_micros(10);

      while !checker.load(Ordering::SeqCst) {
          thread::sleep(_time_delay);
      }
      /*-- start sending messages --*/
      let (lq, cvar) = &amp;*shared1;
      let mut not_processed = 0;

      let max = 5;
      for i in 0..max {
          let mut value:String;
          if i &lt; max-1 {
            value = String::from("msg #");
            value.push_str(&amp;i.to_string());
          }
          else {
              value = "quit".to_string();
          }
          print!("\n  enqueue  {:?} on main thread", &amp;value);
          {
              let mut q = lq.lock().unwrap();
              q.push_back(value);
              not_processed = q.len();
          }
          cvar.notify_one();    
      }
      /*---------------------------------------------
          Make sure all queued items are processed:
          - Needed because notifies that are issued
            before thread starts are dropped.
      */
      for _i in 0..not_processed {
          cvar.notify_one();
      }

      print!("\n  waiting for child thread to finish");
      let _ = handle.join();
  }

  fn main() {

      print!("\n  Blocking queue shared between threads");
      print!("\n =======================================");

      demo();
      print!("\n\n  That's all Folks!\n");
  }
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  Blocking queue shared between threads
 ======================================= 
  thread started
  enqueue  "msg #0" on main thread
  dequeued "msg #0" on child thread
  enqueue  "msg #1" on main thread
  enqueue  "msg #2" on main thread
  enqueue  "msg #3" on main thread
  enqueue  "quit" on main thread
  waiting for child thread to finish
  dequeued "msg #1" on child thread
  dequeued "msg #2" on child thread
  dequeued "msg #3" on child thread
  dequeued "quit" on child thread
  thread finishing

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      Next, we use these ideas to provide a good BlockingQueue abstraction, without using unsafe code, that
      has essentially the same behavior.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;Blocking Queue</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>blocking_queue::main.rs</defn-head>
              <defn-code>
  /////////////////////////////////////////////////////////////
  // sync_demo::main.rs - BlockingQueue                      //
  //                                                         //
  // Jim Fawcett, https://JimFawcett.github.io, 19 May 2020  //
  /////////////////////////////////////////////////////////////
  /*
     This is a BlockingQueue abstraction.  To be shared between
     threads without using unsafe code, any abstraction must
     be composed only of Mutexes and Condvars or a struct or
     tuple with only those members.

     So, the blocking queue must hold its native queue in a 
     Mutex, as shown below.
   
     There is another alternative, based on Rust channels, which 
     are essentially blocking queues.

     In another demo I will build a prototype from channels, and 
     then discuss the advantages and disadvantages of each.
  */
  use std::io::*;
  use std::sync::*;
  use std::collections::*;
  use std::thread;

  #[derive(Debug)]
  struct BlockingQueue&lt;T&gt; {
      q: Mutex&lt;VecDeque&lt;T&gt;&gt;,
      cv: Condvar,
  }
  impl&lt;T&gt; BlockingQueue&lt;T&gt; {
      fn new() -&gt; Self {
          Self {
              q: Mutex::new(VecDeque::new()),
              cv: Condvar::new(),
          }
      }
      fn en_q(&amp;self, t:T) {
          let mut lq = self.q.lock().unwrap();
          lq.push_back(t);
          self.cv.notify_one();
      }
      fn de_q(&amp;self) -&gt; T {
          let mut lq = self.q.lock().unwrap();
          while lq.len() == 0 {
              lq = self.cv.wait(lq).unwrap();
          }
          lq.pop_front().unwrap()
      }
      fn len(&amp;self) -&gt; usize {
          self.q.lock().unwrap().len()
      }
  }

  /*-- simple test of BlockingQueue --*/
  fn test() {

      let share = Arc::new(BlockingQueue::&lt;String&gt;::new());
      let share1 = Arc::clone(&amp;share);
      let share2 = Arc::clone(&amp;share);

      let flush = || { let _ = std::io::stdout().flush(); };

      /*-- child thread dequeues messages --*/
      let handle = thread::spawn(move || {
          print!("\n  child thread started");
          flush();
          loop {
              let t = share1.de_q();
              print!("\n  dequeued {} on child thread", t);
              flush();
              if &amp;t == "quit" {
                  break;
              }
          }
          print!("\n  thread shutting down");
          flush();
      });

      /*-- main thread enqueues messages --*/
      for i in 0..5 {
          let msg = format!("msg #{}", i.to_string());
          print!("\n  enqueued {:?} on main thread", msg);
          flush();
          share2.en_q(msg);
      }
      /*-- shut down child thread --*/
      print!("\n  enqueued {:?} on main thread", "quit");
      flush();
      share2.en_q("quit".to_string());

      /*-- child thread must complete before exiting --*/
      print!("\n  waiting for child thread to stop");
      flush();
      let _ = handle.join();

      print!("\n  queue length = {}", share2.len());
  }

  fn main() {

      print!("\n  Demonstrate queue shared between threads");
      print!("\n ==========================================");

      //demo();
      test();
      print!("\n\n  That's all Folks!\n");
  }              
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  Demonstrate queue shared between threads
 ==========================================
  enqueued "msg #0" on main thread
  child thread started
  dequeued msg #0 on child thread
  enqueued "msg #1" on main thread
  enqueued "msg #2" on main thread
  dequeued msg #1 on child thread
  dequeued msg #2 on child thread
  enqueued "msg #3" on main thread
  enqueued "msg #4" on main thread
  enqueued "quit" on main thread
  waiting for child thread to stop
  dequeued msg #3 on child thread
  dequeued msg #4 on child thread
  dequeued quit on child thread
  thread shutting down
  queue length = 0

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for these examples can be found in <a href="RustLibraryDemos.html">RustLibraryDemos</a>.
    </t-b>

    <a id="mpsc"></a>
    <h3>5.9 mpsc - <span style="font-size:medium; font-weight:normal;">Message passing between threads</span></h3>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/mpsc/index.html">std::mpsc</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::mpsc types are: Receiver, Sender, SyncSender, IntoIter, Iter, TryIter, RecvError, and SendError
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li><defn-code>Receiver
  retrieves messages from a channel
  can only be owned by one thread
  Traits: Debug, IntoIterator, Drop, Send, !Sync, ...
  pub fn try_recv(&self) -> Result&lt;T, TryRecvError&gt;<h-s4em>non-blocking</h-s4em>
  pub fn recv(&self) -> Result&lt;T, RecvError&gt;<h-s4em>blocks on no data</h-s4em>
  pub fn recv_timeout(&self, timeout: Duration) -> Result&lt;T, RecvTimeoutError&gt;
  pub fn iter(&self) -> Iter&lt;T&gt;
  pub fn try_iter(&self) -> TryIter&lt;T&gt;
                </defn-code>
              </li>
              <li><defn-code>Sender
  sends messages to a a channel, non-blocking
  can only be owned by one thread, but can be cloned
  Traits: Debug, Clone, Send, !Sync, Drop, ...
  pub fn send(&self, t: T) -> Result&lt;(), SendError&gt;
                </defn-code>
              </li>
              <li><defn-code>SyncSender
  sends messages to a channel, blocks if there is not enough space in internal buffer
  Traits: Debug, Clone, Send, Drop, ...
  pub fn send(&self, t: T) -> Result&lt;(), SendError&gt;
  pub fn try_send(&self, t: T) -> Result&lt;(), TrySendError&gt;
                </defn-code>
              </li>
              <li><defn-code>IntoIter
  blocks when next is called, waiting for a new message
  Traits: Debug, Iterator, ...
                </defn-code>
              </li>
              <li><defn-code>Iter
  blocks when next is called, waiting for a new message
  Traits: Debug, Iterator, ...
                </defn-code>
              </li>
              <li><defn-code>TryIter
  attempts to yield all pending values for a Receiver
  Traits: Debug, Iterator, ...
                </defn-code>
              </li>
              <li><defn-code>SendError
  sends only fail if receiving end is disconnected.  
  error contains un-sent message as payload
  Traits: Debug, Display, Clone, Copy, Eq, PartialEq, ...
                </defn-code>
              </li>
              <li><defn-code>ReceiveError
  receives only fail if sending end is disconnected.  
  error contains un-sent message as payload
  Traits: Debug, Display, Clone, Copy, Eq, PartialEq, ...
                </defn-code>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      mpsc functions are: channel and sync_channel
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Functions</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>pub fn channel&lt;T&gt;() -> (Sender&lt;T&gt;, Receiver&lt;T&gt;)</c-s>
              </li>
              <li>
                <c-s>pub fn sync_channel&lt;T&gt;(bound: usize) -> (SyncSender&lt;T&gt;, Receiver&lt;T&gt;)</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      std::mpsc enums are: RecvTimeoutError, TryRecvError, and TrySendError
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Enumerations</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                Traits: Debug, Display, Clone, Copy, Error, Eq, PartialEq, .... 
              </li>
              <li>
                <c-s>pub enum RecvTimeoutError { Timeout, Disconnected, }</c-s>
              </li>
              <li>
                <c-s>pub enum TryRecvError { Empty, Disconnected, }</c-s>
              </li>
              <li>
                <c-s>pub enum TrySendError&lt;T&gt;{ Full(T), Disconnected(T), }</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      The example below constructs a channel and sends messages between threads.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;channel_demo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>std::mpsc - mpsc_demo::main.rs</defn-head>
              <defn-code>
  /////////////////////////////////////////////////////////////
  // mpsc_demo::main.rs - msg passing uses blocking queue    //
  //                                                         //
  // Jim Fawcett, https://JimFawcett.github.io, 22 May 2020  //
  /////////////////////////////////////////////////////////////

  use std::sync::mpsc;
  use std::thread;
  use std::time::Duration;

  fn send_proc(s:&amp;str, tx : &amp;mpsc::Sender&lt;String&gt;) {
      let max = 5;
      for i in 0..max {
          let msg = format!("msg #{} from {}", i.to_string(), s);
          print!("\n  sending  {:?}", msg);
          tx.send(msg).unwrap();
          thread::yield_now();   // others ready to run?
      }
  }
  fn recv_proc(rx: &amp;mpsc::Receiver&lt;String&gt;) {
      for msg in rx {
          print!("\n  received {:?}", msg);
          if msg == "quit" {
              break;
          }
      }
  }
  fn demo() {
      /*-- setup channel --*/
      let (tx, rx) = mpsc::channel::&lt;String&gt;();
      let tx2 = mpsc::Sender::clone(&amp;tx);
      let tx_quit = mpsc::Sender::clone(&amp;tx);

      /*-- receive thread --*/
      let rcv_handle = thread::spawn(
          move || { recv_proc(&amp;rx); 
      });

      /*-- wait for receive thread to start --*/
      thread::sleep(Duration::from_millis(50));

      /*-- send threads --*/
      let toms_handle = thread::spawn(
          move || { send_proc("Tom", &amp;tx); 
      });
      let jerrys_handle = thread::spawn(
          move || { send_proc("Jerry", &amp;tx2); 
      });
      let _ = toms_handle.join();
      let _ = jerrys_handle.join();

      /*-- Tom and Jerry are finished so it's safe to stop receiver --*/
      let _ = tx_quit.send("quit".to_string());
      let _ = rcv_handle.join();
  }
  fn main() {
      print!("\n  Message passing demo");
      print!("\n ======================");

      demo();
      print!("\n\n That's all Folks!\n");
  }
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  Message passing demo
 ======================
  sending  "msg #0 from Tom"
  sending  "msg #0 from Jerry"
  sending  "msg #1 from Jerry"
  sending  "msg #2 from Jerry"
  sending  "msg #3 from Jerry"
  received "msg #0 from Tom"
  received "msg #0 from Jerry"
  sending  "msg #4 from Jerry"
  sending  "msg #1 from Tom"
  sending  "msg #2 from Tom"
  received "msg #1 from Jerry"
  received "msg #2 from Jerry"
  received "msg #3 from Jerry"
  received "msg #4 from Jerry"
  received "msg #1 from Tom"
  received "msg #2 from Tom"
  sending  "msg #3 from Tom"
  sending  "msg #4 from Tom"
  received "msg #3 from Tom"
  received "msg #4 from Tom"
  received "quit"

 That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be found in <a href="RustLibraryDemos.html">RustLibraryDemos</a>.
    </t-b>

    <a id="async"></a>
    <h3>5.10 Async/Await - <span style="font-size:medium; font-weight:normal;">concurrent functions and blocks</span></h3>
    <t-b>
      <a href="https://doc.rust-lang.org/std/future/index.html">std::future</a>, 
      <a href="https://crates.io/crates/futures">crates.io/crates/futures</a>, 
      <a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">async/.await Primer</a>
    </t-b>
    <t-b>
      <under-construction>
        This section is a place-holder, awaiting (pun intended) construction.
      </under-construction>
    </t-b>

    <a id="process"></a>
    <h3>5.11 process - <span style="font-size:medium; font-weight:normal;">Creating child processes</span></h3>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/time/index.html">std::process</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::thread types are: Command, Child, ChildStdin, ChildStdout, ChildStderr, Output, Stdio, ExitCode  
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <div class="indent">
            <ol class="tight">
              <li><defn-code>Command
  Traits: Debug, ...
  pub fn new&lt;S: AsRef&lt;OsStr&gt;&gt;(program: S) -> Command
  pub fn arg&lt;S: AsRef&lt;OsStr&gt;&gt;(&mut self, arg: S) -> &mut Command
  pub fn args&lt;I, S&gt;(&mut self, args: I) -> &mut Command
    where I: IntoIterator&lt;Item = S&gt;, S: AsRef&lt;OsStr&gt;,
  pub fn env&lt;K, V&gt;(&mut self, key: K, val: V) -> &mut Command
    where K: AsRef&lt;OsStr&gt;, V: AsRef&lt;OsStr&gt;,
  pub fn envs&lt;I, K, V&gt;(&mut self, vars: I) -> &mut Command
    where I: IntoIterator&lt;Item = (K, V)&gt;, K: AsRef&lt;OsStr&gt;, V: AsRef&lt;OsStr&gt;,
  pub fn env_remove&lt;K: AsRef&lt;OsStr&gt;&gt;(&mut self, key: K) -> &mut Command
  pub fn env_clear(&mut self) -> &mut Command
  pub fn current_dir&lt;P: AsRef&lt;Path&gt;&gt;(&mut self, dir: P) -> &mut Command
  pub fn stdin&lt;T: Into&lt;Stdio&gt;&gt;(&mut self, cfg: T) -> &mut Command
  pub fn stdout&lt;T: Into&lt;Stdio&gt;&gt;(&mut self, cfg: T) -> &mut Command
  pub fn stderr&lt;T: Into&lt;Stdio&gt;&gt;(&mut self, cfg: T) -> &mut Command
  pub fn spawn(&mut self) -> Result&lt;Child&gt;
  pub fn output(&mut self) -> Result&lt;Output&gt;
  pub fn status(&mut self) -> Result&lt;ExitStatus&gt;
                </defn-code>
              </li>
              <li><defn-code>Child
  Traits: Debug, ...
  pub fn kill(&mut self) -> Result&lt;()&gt;
  pub fn id(&mut self) -> u32
  pub fn wait(&mut self) -> Result&lt;ExitStatus&gt;
                </defn-code>
              </li>
              <li><defn-code>ChildStdin
  Traits: Debug, From, Write, ...
                </defn-code>
              </li>
              <li><defn-code>ChildStdout
  Traits: Debug, From, Read, ...
                </defn-code>
              </li>
              <li><defn-code>ChildStderr
  Traits: Debug, From, Read, ...
                </defn-code>
              </li>
              <li><defn-code>Stdio
  Traits: Debug, From, ...
  pub fn piped() -> Stdio
  pub fn inherit() -> Stdio
  pub fn null() -> Stdio
                </defn-code>
              </li>
              <li><defn-code>Output
  Traits: Debug, Clone, Eq, PartialEq, ...
                </defn-code>
              </li>
              <li><defn-code>ExitStatus
  Traits: Debug, Display, Copy, Clone, Eq, PartialEq, ...
  pub fn success(&self) -> bool
  pub fn code(&self) -> Option&lt;i32&gt;
                </defn-code>
              </li>
              <li>
                ...
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      Process functions are: abort, exit, id
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Functions</summary>
          <s-halfEm></s-halfEm>
          <div class="indent">
            <ol class="tight">
              <li>
                <c-s>pub fn abort() -> !</c-s>
              </li>
              <li>
                <c-s>pub fn exit(code: i32) -> !</c-s>
              </li>
              <li>
                <c-s>pub fn id() -> u32</c-s>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      The example below spawns a child process and collects its output for display when the child exits.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;process_demo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>std::thread::shared</defn-head>
              <defn-code>
  /////////////////////////////////////////////////////////////
  // process_demo::main.rs - start child process             //
  //                                                         //
  // Jim Fawcett, https://JimFawcett.github.io, 16 May 2020  //
  /////////////////////////////////////////////////////////////

  #![allow(unused_imports)]
  use std::process::*;
  use std::io::*;

  fn main() {

      let putline = || print!("\n");

      print!("\n  spawning child process");
      print!("\n ========================\n");
      putline();

      let output = if cfg!(target_os = "windows") {
          Command::new("cmd.exe")
                  .args(&amp;[
                      "/C", "type",
                      "cargo.toml"
                  ])
                  .output()
                  .expect("failed to execute process")
      }
      else {
          Command::new("sh")
                   .arg("-C")
                   .arg("echo.hello")
                   .output()
                   .expect("failed to execute process")
      };

      std::io::stdout().write_all(
                            &amp;output.stdout
                        ).unwrap();

      println!("\n\n  That's all Folks!\n\n");
  }
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
    spawning child process
   ========================

  [package]
  name = "process_demo"
  version = "0.1.0"
  authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
  edition = "2018"

  # See more keys and their definitions at 
  # https://doc.rust-lang.org/cargo/reference/manifest.html

  [dependencies]

    That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be found in <a href="RustLibraryDemos.html">RustLibraryDemos</a>.
    </t-b>

    <a id="time"></a>
    <h3>5.12 time - <span style="font-size:medium; font-weight:normal;">System time, time durations</span></h3>
    <t-b>
      Reference: <a href="https://doc.rust-lang.org/std/time/index.html">std::time</a> library.
    </t-b>
    <t-b>
      <strong>Structs:</strong>
    </t-b>
    <t-b>
      The std::time types are: Duration, Instant, SystemTime, SystemTimeError
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle lightItem">List of Structs</summary>
          <div class="indent">
            <ol class="tight">
              <li><defn-code>Duration
  Traits: Debug, Default, Clone, Copy, ...
  pub fn new(secs: u64, nanos: u32) -> Duration
  pub fn from_secs(secs: u64) -> Duration
  pub fn from_millis(millis: u64) -> Duration
  pub fn from_micros(micros: u64) -> Duration
  pub fn from_nanos(nanos: u64) -> Duration
  pub fn as_secs(&self) -> u64
  pub fn as_millis(&self) -> u128
  pub fn as_micros(&self) -> u128
  pub fn as_nanos(&self) -> u128
  pub fn checked_add(self, rhs: Duration) -> Option&lt;Duration&gt;
  pub fn checked_sub(self, rhs: Duration) -> Option&lt;Duration&gt;
  pub fn checked_mul(self, rhs: u32) -> Option&lt;Duration&gt;
  pub fn checked_div(self, rhs: u32) -> Option&lt;Duration&gt;
  s...
                </defn-code>
              </li>
              <li><defn-code>Instant
  Traits: Debug, Clone, Copy, ...
  pub fn now() -> Instant
  pub fn duration_since(&mut self, earlier: Instant) -> Duration
  pub fn checked_duration_since(&mut self, earlier: Instant) -> Option&lt;Duration&gt;
  pub fn elapsed(&mut self) -> Duration
  ...
                </defn-code>
              </li>
              <li><defn-code>SystemTime
  Traits: Debug, Clone, Copy, Eq, PartialEq, ...
  pub const UNIX_EPOCH: SystemTime
  pub fn now() -> SystemTime
  pub fn duration_since(&self, earlier: SystemTime) -> Result&lt;Duration, SystemTimeError&gt;
  pub fn elapsed(&self) -> Result&lt;Duration, SystemTimeError&gt;
  ...
                </defn-code>
              </li>
              <li><defn-code>SystemTimeError
  Traits: Debug, Display, Clone, Error, ...
  Traits: Debug, Display, Clone, Error, ...
  pub fn duration(&self) -> Duration
                </defn-code>
              </li>
            </ol>
          </div>
        </details>
      </div>
    </t-b>
    <t-b>
      The example below may eventually do something interesting.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Example:&nbsp;&nbsp;time_demo</summary>
          <s-halfEm></s-halfEm>
          <defn-outerBlock>
            <defn-block>
              <defn-head>std::time time_demo</defn-head>
              <defn-code>
  /////////////////////////////////////////////////////////////
  // time_demo::main.rs - demonstration of std::time         //
  //                                                         //
  // Jim Fawcett, https://JimFawcett.github.io, 22 May 2020  //
  /////////////////////////////////////////////////////////////

  use std::time;
  use std::thread;
  use std::convert::TryFrom;

  /*-- how accurate is thread sleep ? --*/
  fn sleep_proc(ms: u64) {
     let dur = time::Duration::from_millis(ms); 
     thread::sleep(dur);
  }
  /*-- nonsense calculation to waste time --*/
  fn calc_proc(count: u64) {
      let mut _value: f64 = 42.0;
      let mut mult:i32 = 42; 
      let rslt = i32::try_from(count);
      match rslt {
          Ok(counter) =&gt; {
              for i in 0..counter {
                  mult = mult + i;
                  let mult = (mult + i) % 33;
                  let _value = _value + mult as f64;
              }       
          },
          Err(_) =&gt; print!("\n  can't compute this number")
      }
  }
  /*-- writing to console is slow --*/
  fn print_proc(count: u64) {
      print!("\n  ");
      for _num in 0..count {
          for _out in 0..25 {
              print!(". ");
          }
          print!("\n  ");
      }
  }
  /*-- stop watch timer --*/
  fn measure_time&lt;F: FnOnce(u64) -&gt; ()&gt;(f: F, arg: u64) -&gt; time::Duration {
      let start = time::Instant::now();
      f(arg);
      start.elapsed()
  }
  /*-- demo time durations --*/
  fn main() {
      print!("\n  Demonstrate std::time");
      print!("\n =======================");

      let putline = || print!("\n");

      putline();
      let mut duration = measure_time(sleep_proc, 3);
      print!("\n  thread::sleep for 3 ms actually took {:?}", duration);
      putline();

      duration = measure_time(calc_proc, 1500);
      print!("\n  time to perform nonsense calc was {:?}", duration);
      putline();

      duration = measure_time(print_proc, 15);
      print!("\n  time to print array of dots was {:?}", duration);

      println!("\n\n  That's all Folks!\n");
  }
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
  Demonstrate std::time
 =======================

  thread::sleep for 3 ms actually took 3.6934ms

  time to perform nonsense calc was 62s

  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . .

  time to print array of dots was 11.503ms

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The code for this example can be found in <a href="RustLibraryDemos.html">RustLibraryDemos</a>.
    </t-b>

    <a id="date"></a>
    <h3>5.13 Date - <span style="font-size:medium; font-weight:normal;">Date and time stamps</span></h3>
    <t-b>
      <under-construction>
        placeholder awaiting construction
      </under-construction>
    </t-b>
    <a id="epilogue"></a>
    <h3>5.14 Epilogue</h3>
    <t-b>
      Augmenting the standard Rust libraries, there are a large number of open-source crates on
      <a href="https://crates.io">https://crates.io</a>.  Many are developed by members of the Rust
      development team.  There are also a lot of resources available on github.  
      Here are a few interesting selections:
      <div class="indent pad10">
        <ol class="tight">
          <li>
            <a href="https://crates.io/crates/hyper">hyper</a>, an HTTP client and server api
          </li>
          <li>
            <a href="https://github.com/http-rs">http-rs</a>, HTTP client, server, and parts.
          </li>
          <li>
            <a href="https://async.rs/">async-std</a>, an implementation of the async-await pattern and
            updates of some of the std libraries to incorporate it, e.g., fs, io, net, process, sync, ...
            It provides new libraries future, stream, and task.  Here&apos;s a nice 
            <a href="https://www.philipdaniels.com/blog/2019/async-std-demo1/">set of examples</a> of its
            use.
          </li>
          <li>
            <a href="https://crates.io/crates/tokio">tokio</a>, a widely used runtime for asynchronous applications.
          </li>
          <li>
            <a href="https://crates.io/crates/serde">serde</a>, framework for serializing and deserializing 
            Rust data structures.
          </li>
          <li>
            <a href="https://github.com/rust-unofficial/awesome-rust">awesome-rust</a>, a large list
            of rust resources, mostly on github.
          </li>
        </ol>
      </div>
    </t-b>
    <t-b>
      I&apos;ve been impressed with Rust&apos;s clever ideas, professional implementation, and ease of use of the
      Rust tool chain.  Cheers!
    </t-b>
    <a id="refs"></a>
    <h3>5.15 References</h3>
        <table style="width:calc(100vw - 12rem);">
      <tr>
        <th class="darkItem">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html">A Gentle Introduction To Rust</a>
        </td>
        <td class="lightItem">
          First thing to read.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/book/">The Rust Book</a>
        </td>
        <td class="lightItem">
          Rust docs - walkthrough of syntax
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/reference/">The Rust Reference Book</a>
        </td>
        <td class="lightItem">
          Rust&apos;s approximation of a language standard. Clear and well written, with a glossary at the end.
          Its <a href="https://github.com/rust-lang/reference">github site</a> shows that changes are still being
          actively incorporated.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://cheats.rs/">Rust cheat sheet</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
        <td class="lightItem">
          Container diagrams
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/27683266/how-do-you-do-interprocess-communication-ipc-in-rust">Rust IPC</a></td>
        <td class="lightItem">
          Stackoverflow re Rust IPC
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/31192956/whats-the-de-facto-way-of-reading-and-writing-files-in-rust-1-x">Rust file io</a></td>
        <td class="lightItem">
          Stackoverflow re Rust file io
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/27840394/how-can-a-rust-program-access-metadata-from-its-cargo-package">Rust metadata</a></td>
        <td class="lightItem">
          Stackoverflow re reading metadata from cargo.toml
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">RIP Tutorial on Rust</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, the stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">Learning Rust ebook</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/rust/awesome-learning/book">Rust - Awesome Book</a></td>
        <td class="lightItem">
          lots of interesting discussions from RIP, the Stackoverflow Archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.rs/regex/1.3.7/regex/">std::regex</a></td>
        <td class="lightItem">
          std docs on Regex
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://docs.rs/dtolnay/0.0.8/dtolnay/macro._02__reference_types.html">
            Shared&nbsp;reference&nbsp;&amp;T&nbsp;and&nbsp;exclusive&nbsp;reference&nbsp;&amp;mut&nbsp;T
          </a>
        </td>
        <td class="lightItem">
          More accurate description than immutable reference and mutable reference
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://deterministic.space/">Blog - Pascal's Scribbles</a>
        </td>
        <td class="lightItem">
          Pascal Hertleif - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://blog.mgattozzi.dev/">Blog - Barely Functional</a>
        </td>
        <td class="lightItem">
          Michael Gattozzi - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://blog.mgattozzi.dev/rust-wasm/">Rust and the case for WebAssembly in 2018</a>
        </td>
        <td class="lightItem">
          Michael Gattozzi - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.snoyman.com/blog/2020/05/no-mutable-parameters-in-rust">Blog - S.Noyberg</a>
        </td>
        <td class="lightItem">
          Examples of aysnc/await, tokio, lifetime, ...
        </td>
      </tr>
      <tr>
        <td class="darkItem" style="line-height:1.5em;"><strong><a href="RustStory_References.html">More References</a></strong></td>
        <td class="darkItem" style="line-height:1.5em;">&nbsp;</td>
      </tr>
    </table>

    <spacer-25></spacer-25>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <!--<menu-elem class="secElem"><a href="#exercises">exercises</a></menu-elem>-->
        <menu-elem class="secElem"><a href="#epilogue">epilogue</a></menu-elem>
        <menu-elem class="secElem"><a href="#date">date</a></menu-elem>
        <menu-elem class="secElem"><a href="#time">time</a></menu-elem>
        <menu-elem class="secElem"><a href="#process">process</a></menu-elem>
        <menu-elem class="secElem"><a href="#async">async</a></menu-elem>
        <menu-elem class="secElem"><a href="#mpsc">mpsc</a></menu-elem>
        <menu-elem class="secElem"><a href="#sync">sync</a></menu-elem>
        <menu-elem class="secElem"><a href="#thread">thread</a></menu-elem>
        <menu-elem class="secElem"><a href="#net">net</a></menu-elem>
        <menu-elem class="secElem"><a href="#iter">iter</a></menu-elem>
        <menu-elem class="secElem"><a href="#coll">coll</a></menu-elem>
        <menu-elem class="secElem"><a href="#convert">convert</a></menu-elem>
        <menu-elem class="secElem"><a href="#std">std</a></menu-elem>
        <menu-elem class="secElem"><a href="#prologue">prologue</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
</body>
</html>