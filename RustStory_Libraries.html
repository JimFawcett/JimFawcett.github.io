<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Prologue.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Rust StdLibs</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="RustStory_References.html">N</a>
  <a id="Prev" href="RustStory_Structures.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 5. - Rust Libraries</h1>
      <h3 id="subtitle">std, collectons, fs, net, error, time, thread, process</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_Libraries.html">Libraries</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#std">Std</a>, 
       <a href="#collections">Collections</a>, <a href="#fs">FileSystem</a>, <a href="#net">Net</a>, 
       <a href="#error">Error</a>, <a href="#time">Time</a>, <a href="#thread">Thread</a>,
       <a href="#process">Process</a>, <a href="#epilogue">Epilogue</a>, <a href="#refs">References</a>
     </rt-b>
   </toc-b>

  <bb-55 class="indent">
    <a id="prologue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.0</num-item1><num-item4>Prologue:</num-item4>
    </num-cont>
    <under-construction class="indent">
      This page is under construction
    </under-construction>
    <a id="std"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.1</num-item1><num-item4>std:</num-item4>
    </num-cont>
    <t-b>
      Rust has a well endowed collection of <strong><a href="https://doc.rust-lang.org/beta/std/">std libraries</a></strong> in the
      std namespace.  You don&apos;t have to declare a use std::*, as the std::prelude::* is automatically applied.
    </t-b>
    <t-b>
      All of the libraries discussed below are part of std.
    </t-b>
    <a id="convert"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.2</num-item1><num-item4>std::convert:</num-item4>
    </num-cont>
    <t-b>
      <div class="indent">
        <ol class="tight pad10">
          <li>
            AsRef:
            <defn-code style="font-size:1.0em;">trait std::convert::AsRef {
  fn as_ref(&self) -> &T
}
            </defn-code>
            <div>
              <details>
                <summary class="labelStyle lightItem">Partial List of Implementors:</summary>
                <div class="">
                  <ul class="tight">
                    <li>
                      <c-s>[T]::as_ref&lt;[T]&gt;() -> &[T];</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_ref&lt;[T]&gt;() -> &[T];</c-s>
                    </li>
                    <li>
                      <c-s>Vec&lt;T&gt;::as_ref&lt;Vec&lt;T&gt;&gt;() -> &Vec&lt;T&gt;</c-s>
                    </li>
                    <li>
                      <c-s>Box&lt;T&gt;::as_ref&lt;T&gt;() -> &T;</c-s><br />
                      <c-s>where T: ?Sized</c-s>
                    </li>
                    <li>
                      <c-s>Arc&lt;T&gt;::as_ref&lt;T&gt;() -> &T;</c-s><br />
                      <c-s>where T: ?Sized</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;[u8]&gt;() -> &[u8];</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;str&gt;() -> &str;</c-s>
                    </li>
                    <li>
                      <c-s>str::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;[u8]&gt;() -> &[u8];</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;str&gt;() -> &str;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>String::as_ref&lt;Path&gt;() -> &Path;</c-s>
                    </li>
                    <li>
                      <c-s>CStr::as_ref&lt;CStr&gt;() -> &CStr;</c-s>
                    </li>
                    <li>
                      <c-s>CString::as_ref&lt;CStr&gt;() -> &CStr;</c-s>
                    </li>
                    <li>
                      <c-s>OsStr::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>OsString::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>Path::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>PathBuf::as_ref&lt;OsStr&gt;() -> &OsStr;</c-s>
                    </li>
                    <li>
                      <c-s>PathBuf::as_ref&lt;OsStr&gt;() -> &Path;</c-s>
                    </li>
                  </ul>
                </div>
              </details>
            </div>
          </li>
          <li>
            From:
            <defn-code style="font-size:1.0em;">pub trait From&lt;T&gt; {
  fn from(T) -> Self
}
            </defn-code>
            <div>
              <details>
                <summary class="labelStyle lightItem">Partial List of Implementors</summary>
                <div>
                  <ul class="tight">
                    <li>
                      String::from(&str)
                    </li>
                    <li>
                      String::from(Box&lt;str&gt;)
                    </li>
                    <li>
                      char::from(u8)
                    </li>
                    <li>
                      PathBuf::from(String)
                    </li>
                    <li>
                      Pathbuf::from(OsString)
                    </li>
                    <li>
                      OsString::from(String)
                    </li>
                    <li>
                      OsString::From(PathBuf)
                    </li>
                    <li>
                      u32::from(char)
                    </li>
                    <li>
                      isize::from(i16)
                    </li>
                    <li>
                      f64::from(f32)
                    </li>
                    <li>
                      f64::from(i16)
                    </li>
                    <li>
                      AtomicI16::from(i16)
                    </li>
                    <li>
                      Vec&lt;u8&gt;::from(String)
                    </li>
                    <li>
                      Vec&lt;T&gt;::from(BinaryHeap&lt;T&gt;)
                    </li>
                    <li>
                      Vec&lt;T&gt;::from(VecDeque&lt;T&gt;)
                    </li>
                    <li>
                      VecDeque&lt;T&gt;::from(Vec&lt;T&gt;)
                    </li>
                    <li>
                      Error::from(kind: ErrorKind)
                    </li>
                    <li>
                      Box&lt;[u8]&gt;::from(Box&gt;str&gt;)
                    </li>
                    <li>
                      Arc&lt;OsStr&gt;::from(OsString)
                    </li>
                    <li>
                      Stdio::from(File)
                    </li>
                    <li>
                      Arc&lt;Path&gt;::From(PathBuf)
                    </li>
                    <li>
                      Stdio::from(ChildStdin)
                    </li>
                    <li>
                      Stdio::from(ChildStdout)
                    </li>
                    <li>
                      Arc&lt;String&gt;::from(String)
                    </li>
                    <li>
                      Box&lt;str&gt;::from(&str)
                    </li>
                    <li>
                      BinaryHeap&lt;T&gt;::from(Vec&lt;T&gt;)
                    </li>
                    <li>
                      Arc&lt;T&gt;::from(T)
                    </li>
                    <li>
                      Mutex&lt;T&gt;::from(T)
                    </li>
                    <li>
                      RWLock&lt;T&gt;::from(T)
                    </li>
                  </ul>
                </div>
              </details>
            </div>
          </li>
        </ol>
      </div>
    </t-b>
    <a id="collections"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.2</num-item1><num-item4>std::collections:</num-item4>
    </num-cont>
    The std namespace has a set of <a href="https://doc.rust-lang.org/std/collections/index.html">std::collections</a> 
    similar to other languages:
    <div class="" style="width:calc(100vw - 15em); padding:15px 0px;">
      <table>
        <tr>
          <th class="darkItem">Collection</th><th class="darkItem">Description</th>
        </tr>
        <tr>
          <td class="lightItem">Vec&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A self expanding indexable array of items of type T, occupying a contiguous block of memory.
            Constant time access to indexed item, linear time insertion and removal.
          </td>
        </tr>
        <tr>
          <td class="lightItem">VecDeque&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A self expanding indexable array of items of type T, with constant-time access, insertion,
            and removal on either end.
          </td>
        </tr>
        <tr>
          <td class="lightItem">LinkedList&lt;T&gt;</td>
          <td class="lightItem">
            Sequence container:<br />
            A doubly linked list of items of type T, with linear-time traversal.
          </td>
        </tr>
        <tr>
          <td class="lightItem">HashMap&lt;K, V&gt;</td>
          <td class="lightItem">
            Associative container:<br />
            A hashed container with almost constant time access.  Elements are randomly ordered
            (if the hash function works well for T)
          </td>
        </tr>
        <tr>
          <td class="lightItem">BTreeMap&lt;K,&nbsp;V&gt;</td>
          <td class="lightItem">
            Associative container:<br />
            A balanced binary tree container with log n time access.  Elements are sorted.
          </td>
        </tr>
        <tr>
          <td class="lightItem">HashSet&lt;K&gt;</td>
          <td class="lightItem">
            Set container:<br />
            A hashed container with almost constant time access.  Elements are randomly ordered
            (if the hash function works well for T)
          </td>
        </tr>
        <tr>
          <td class="lightItem">BTreeSet&lt;K&gt;</td>
          <td class="lightItem">
            Set container:<br />
            A balanced binary tree container with log n time access.  Elements are sorted.
          </td>
        </tr>
        <tr>
          <td class="lightItem">BinaryHeap&lt;T&gt;</td>
          <td class="lightItem">
            Priority queue:<br />
            Largest element is accessed in constant time.
          </td>
        </tr>
      </table>
    </div>
    <num-cont><num-item1>3.2.1</num-item1><num-item4>Iterators:</num-item4></num-cont>
    <t-b>
      Iterators support iterating through all the collections.  They come in three flavors:
      iter, iter_mut, and into_iter.  Note that into_iter is a consuming iterator, moving items
      from source to destination.
    </t-b>
    <t-b>
      Iterators provide a set of adapter methods for performing common operations on containers.
      Here&apos;s a partial list - see 
      <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Trait&nbsp;std::iter::Iterator</a>
      for more details:
      <div style="padding:5px 25px;">
        <ol class="tight">
          <li>
            <c-s>fn <strong>next</strong>(&mut self) -> Option&lt;Self::Item&gt;</c-s><br />
            <s-5px></s-5px>
            Advances and returns value.
          </li>
          <li>
            <c-s>fn map&lt;B, F&gt;(self, f:F) -> Map&lt;Self, F&gt;</c-s><br />
            <c-s> where F: FnMut(Self::Item) -> B</c-s><br />
            <s-5px></s-5px>
            Takes a closure and creates an iterator that applies the closure to each item.
          </li>
          <li>
            <c-s>fn filter&lt;P&gt;(self, predicate:P) -> Filter&lt;Self, P&gt;</c-s><br />
            <c-s>where P: FnMust(&Self::Item) -> bool</c-s><br />
            <s-5px></s-5px>
            Creates an iterator that determines if an item should be included.
          </li>
          <li>
            <c-s>fn take(self, n:usize) -> Take&lt;Self&gt;</c-s>
          </li>
          <li>
            <c-s>
              fn take_while&lt;P&gt;(self, predicate: P) -> TakeWhile&lt;Self, P&gt;<br />
              where P: FnMut(&Self::Item) -> bool
            </c-s>
          </li>
          <li>
            <c-s>
              fn fold&lt;B, F&gt;(self, init:B, f:F) -> B<br />
              where FnMut(B, Self::Item) -> B
            </c-s>
          </li>
          <li>
            <c-s>fn skip(self, n:usize) -> Skip&lt;Self&gt;</c-s>
          </li>
          <li>
            <c-s>
              fn collect&lt;B&gt;(self) -> B<br />
              where B: FromIterator&lt;Self::Item&gt;
            </c-s>
          </li>
          <li>
            <c-s>step_by(self, step:usize) -> StepBy&lt;Self&gt;<br /></c-s>
            <s-5px></s-5px>
            Skips step items on each iteration
          </li>
          <li>
            <c-s>nth(&mut self, n:usize) -> Option&lt;Self::item&gt;<br /></c-s>
            <s-5px></s-5px>
            Returns nth item, counting from zero
          </li>
          <li>
            <c-s>last(self) -> Option&lt;Self::item&gt;<br /></c-s>
            <s-5px></s-5px>
            Consumes iterator, returning last item
          </li>
          <li>
            <c-s>
              fn find&lt;P&gt;(&mut self, predicate: P) -> Option&lt;Self::Item&gt;<br />
              where FnMut(&Self::Item) -> bool
            </c-s> 
          </li>
          <li>
            <c-s>
              fn position&lt;P&gt;(&mut self, predicate: P) -> Option&lt;usize&gt;<br />
              where P: FnMut(Self::Item) -> bool
            </c-s>
          </li>
          <li>
            <c-s>
              fn for_each&lt;F&gt;(self, f:F)<br />
              where F: FnMut(Self::Item)<br />
            </c-s>
            <s-5px></s-5px>
            Calls a closure on each element of an iterator.
          </li>
          <li>
            <c-s>fn enumerate(self) -> Enumerate&lt;Self&gt;<br /></c-s>
            <s-5px></s-5px>
            Creates an iterator returns a pair with current iteration count and next value.
          </li>
          <li>
            <c-s>fn by_ref(&mut self) -> &mut Self</c-s>
          </li>
          <li>
            <c-s>
              fn all&lt;F&gt;(&mut self, f:F) -> bool<br />
              where F: FnMut(Self::Item) -> bool
            </c-s>
          </li>
          <li>
            <c-s>
              fn any&lt;F&gt;(&mut self, f:F) -> bool<br />
              where F: FnMut(Self::Item) -> bool
            </c-s>
          </li>
          <li>
            <c-s>fn count(self) -> usize<br /></c-s>
            <s-5px></s-5px>
            Consumes iterator, counting number of iterations
          </li>
          <li>
            <c-s>
              fn chain&lt;U&gt;(self, other: U) -> Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;<br />
              where U: IntoIterator&lt;Self::Item&gt;
            </c-s>
          </li>
          <li>
            <c-s>
              fn zip&lt;U&gt;(self, other: U) -> Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;<br />
              where U: IntoIterator
            </c-s>
          </li>
          <li>
            <c-s>
              fn sum&lt;S&gt;(self) -> S<br />
              where S: Sum&lt;Self::Item&gt;
            </c-s>
          </li>
          <li>
            <c-s>
              fn product&lt;P&gt;(self) -> P<br />
              where P: Product&lt;Self::Item&gt;
            </c-s>
          </li>
        </ol>
      </div>
    </t-b>
    <t-b>
      Similar to the C++ std::algorithms, these provide a readable declarative interface for code doing
      compound operations on collection items.
    </t-b>
    <a id="fs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.3</num-item1><num-item4>std::fs</num-item4>
    </num-cont>
    Working with files and directories is well supported in Rust with the 
    <a href="https://doc.rust-lang.org/std/fs/index.html">std::fs</a> library.
    <t-b>
      <div class="indent">
        <ol class="tight">
          <li>
            fn create_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;()&gt;
          </li>
        </ol>
      </div>
    </t-b>
    <a id="net"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.4</num-item1><num-item4>net:</num-item4>
    </num-cont>

    <a id="error"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.5</num-item1><num-item4>error:</num-item4>
    </num-cont>

    <a id="time"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.6</num-item1><num-item4>time:</num-item4>
    </num-cont>

    <a id="thread"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.7</num-item1><num-item4>thread:</num-item4>
    </num-cont>

    <a id="process"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.8</num-item1><num-item4>process:</num-item4>
    </num-cont>

    <a id="epilogue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.6</num-item1><num-item4>Epilogue:</num-item4>
    </num-cont>

    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.7</num-item1><num-item4>References:</num-item4>
    </num-cont>
        <table style="width:calc(100vw - 12rem);">
      <tr>
        <th class="darkItem">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html">A Gentle Introduction To Rust</a>
        </td>
        <td class="lightItem">
          First thing to read.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/book/">The Rust Book</a>
        </td>
        <td class="lightItem">
          Rust docs - walkthrough of syntax
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/reference/">The Rust Reference Book</a>
        </td>
        <td class="lightItem">
          Rust&apos;s approximation of a language standard. Clear and well written, with a glossary at the end.
          Its <a href="https://github.com/rust-lang/reference">github site</a> shows that changes are still being
          actively incorporated.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://cheats.rs/">Rust cheat sheet</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
        <td class="lightItem">
          Container diagrams
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/27683266/how-do-you-do-interprocess-communication-ipc-in-rust">Rust IPC</a></td>
        <td class="lightItem">
          Stackoverflow re Rust IPC
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/31192956/whats-the-de-facto-way-of-reading-and-writing-files-in-rust-1-x">Rust file io</a></td>
        <td class="lightItem">
          Stackoverflow re Rust file io
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://stackoverflow.com/questions/27840394/how-can-a-rust-program-access-metadata-from-its-cargo-package">Rust metadata</a></td>
        <td class="lightItem">
          Stackoverflow re reading metadata from cargo.toml
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">RIP Tutorial on Rust</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, the stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">Learning Rust ebook</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/rust/awesome-learning/book">Rust - Awesome Book</a></td>
        <td class="lightItem">
          lots of interesting discussions from RIP, the Stackoverflow Archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.rs/regex/1.3.7/regex/">std::regex</a></td>
        <td class="lightItem">
          std docs on Regex
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://docs.rs/dtolnay/0.0.8/dtolnay/macro._02__reference_types.html">
            Shared&nbsp;reference&nbsp;&amp;T&nbsp;and&nbsp;exclusive&nbsp;reference&nbsp;&amp;mut&nbsp;T
          </a>
        </td>
        <td class="lightItem">
          More accurate description than immutable reference and mutable reference
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://deterministic.space/">Blog - Pascal's Scribbles</a>
        </td>
        <td class="lightItem">
          Pascal Hertleif - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://blog.mgattozzi.dev/">Blog - Barely Functional</a>
        </td>
        <td class="lightItem">
          Michael Gattozzi - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://blog.mgattozzi.dev/rust-wasm/">Rust and the case for WebAssembly in 2018</a>
        </td>
        <td class="lightItem">
          Michael Gattozzi - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.snoyman.com/blog/2020/05/no-mutable-parameters-in-rust">Blog - S.Noyberg</a>
        </td>
        <td class="lightItem">
          Examples of aysnc/await, tokio, lifetime, ...
        </td>
      </tr>
      <tr>
        <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
        <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
      </tr>
    </table>

  </bb-55>
  <spacer-25></spacer-25>

  <info-bar></info-bar>
</body>
</html>