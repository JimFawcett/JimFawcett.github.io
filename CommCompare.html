<!DOCTYPE html>
<html>
<!--
  CommCompare.html
-->
<head>
  <title>CommCompare</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeDefault.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrameOtherRepos.js"></script>
  <script src="js/ScriptsPageFramePagesOtherRepos.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }

    .container {
      display: grid;
      grid-template-columns: 0em 0.6fr 1.5fr 0.6fr 1fr 0em;
      // link to pg, descrip, link to repo, status grid-column-gap: 0em;
      padding: 0.0em;
      margin: 0em 0.25em 1em 0.25em;
      border: 1px solid var(--dark);
    }

    .item1 {
      grid-column: 2;
      padding: 0.2em 1em;
      border: 2px solid var(--dark);
    }

    .item2 {
      grid-column: 3;
      padding: 0.2em 1em;
      border: 2px solid var(--dark);
    }

    .item3 {
      grid-column: 4;
      padding: 0.2em 1em;
      border: 2px solid var(--dark);
    }

    .item4 {
      grid-column: 5;
      padding: 0.2em 1em;
      border: 2px solid var(--dark);
    }

    .gray {
      background-color: #ddd;
    }

    .spread {
      margin: 1em;
    }

    .tightSpread {
      margin: 0.5em;
    }
    two-column {
      display: grid;
      grid-template-columns: 50% 50%;
      grid-template-areas: "cppcomm rustcomm";
      /*grid-gap: 0.15em;*/
      width: 100%;
      margin: 1em 0em;
      border: 0.10em solid #4c2f27;
      background-color: #4c2f27;
      overflow: auto;
    }

    cpp-content {
      position: relative;
      grid-area: cppcomm;
      width: calc(100%-2em);
      margin: 0.10em;
      padding: 1.5em;
      background-color: #fefefa; /* baby powder */
      color: #4c2f27;
    }

    rust-content {
      position: relative;
      grid-area: rustcomm;
      width: calc(100%-2em);
      margin: 0.10em;
      padding: 1.5em;
      background-color: #fefefa; /* baby powder */
      color: #4c2f27;
    }
/*    #github #pagetitle {
      color: var(--dark);
      background-color: var(--atten);
    }

    #github #title {
      color: var(--dark);
      background-color: var(--atten);
    }

    #github #subtitle {
      color: var(--dark);
      background-color: var(--atten);
    }

    #github a.repoLink {
      background-color: var(--atten);
      color: var(--dark);
    }
*/  </style>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="BasicBiteByByte.html">N</a>
  <a id="Prev" href="CommCompare.html">P</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="modified">12/08/2022</div>
      <div id="page">CommCompare</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
  <header>
    <a class="repoLink" href="https://github.com/JimFawcett/CommCompare">CommCompare code</a>
    <hgroup id="pagetitle">
      <h1 id="title">CommCompare&nbsp;&nbsp;Repository</h1>
      <h3 id="subtitle" class="indent">Comparing C++ and Rust Message-passing communicators</h3>
    </hgroup>

    <indent-block>
      <div style="padding-right:25px; position:absolute; top:1.65em; right:-0.75em;">
        <details class="quickStatus">
          <summary class="attenItem quickStatus" style="border:1px solid var(--dark);">Quick Status</summary>
          <status-grid style="padding:5px 10px;" class="lightItem border">
            <status-itemLeft>
              Code functions correctly
            </status-itemLeft>
            <status-itemRight>
              No known defects
            </status-itemRight>
            <status-itemLeft>
              Demonstration code
            </status-itemLeft>
            <status-itemRight>
              yes
            </status-itemRight>
            <status-itemLeft>
              Documentation
            </status-itemLeft>
            <status-itemRight>
              yes
            </status-itemRight>
            <status-itemLeft>
              Test cases
            </status-itemLeft>
            <status-itemRight>
              yes
            </status-itemRight>
            <status-itemLeft>
              Static library
            </status-itemLeft>
            <status-itemRight>
              yes
            </status-itemRight>
            <status-itemLeft>
              Build requires
            </status-itemLeft>
            <status-itemRight>
              Rust and C++ installation
            </status-itemRight>
            <status-itemLeft>
              Planned changes
            </status-itemLeft>
            <status-itemRight>
              None at this time
            </status-itemRight>
          </status-grid>
        </details>
      </div>
    </indent-block>
  </header>

  <h2 id="compare">Comparing C++ and Rust</h2>
  <t-b>
    My collaborator, Mike Corley, and I are interested in Rust and how it compares with the C++ programming language.
    To do this in a practical setting, we decided to implement message-passing communicators using socket-based 
    connections and simple variable-sized messages.  The results of that are what you find in this repository.
  </t-b>
  <t-b>
    Here, we will compare performance, complexity, ease of construction, code size, and safety.  For some of these
    attributes, like performance, we can be quite specific.  For others, like ease of construction, we will be 
    satisfied with subjective judgments.
  </t-b>
  <t-b>
    We established several goals for this demonstration:
    <ol class="tights">
      <li>
        The C++ and Rust designs should be as similar as practical within constraints of the two languages.
        Both use:
        <ul class="tight">
          <li>Synchronous, full-duplex sockets for client to server client-handler communication.</li>
          <li>Queues for message input in both client and server.</li>
          <li>Server Threadpools to avoid context thrashing for large numbers of concurrent clients.</li>
          <li>Simple variable-size messages which may have binary bodies.</li>
          <li>
            Server processing simply echos client messages back (client handlers are designed to support
            significantly more complex server operations).
          </li>
        </ul>
      </li>
      <li>
        These projects will use each language&apos;s standard libraries for programming resources, but will not
        use other third party libraries like Boost and those from Crates.io.  The intent is to compare our work with
        C++ and Rust, not some other developer&apos;s work.
      </li>
      <li>
        The C++ code should use modern C++17 constructs supporting safe data handling.  Safe Rust enforces memory
        and data race safety at compile time.  No unsafe blocks will be used in any of the Rust code (excluding
        unsafe blocks used in, and thoroughly vetted for, the standard library).
      </li>
      <li>
        The code should provide build processes for Windows, Linux, and (eventually) macOS.
      </li>
      <li>
        Implementations will use professional care, but no extraordinary efforts will be made to squeeze out additional
        performance or other measured attributes.  This is supposed to reflect good &quot;business as usual&quot; practice.
      </li>
    </ol>
  </t-b>
  <hr class="above" />
  <h3 id="concept">Communicator Concepts</h3>
  <div>
    <div style="display:flex; flex-wrap:nowrap;">
      <cpp-content style="padding-top:0.25em; border:2px solid #5c2107;">
        <h3>C++ Communicator</h3>
        <div>
        <t-b>
          Message-Passing Library (MPL) provides message-passing communication between a TCPConnector
          and TCPResponder.  
        </t-b>
        <div>
        <photosizer-block src="Pictures/MPL.jpg" width="350" class="photoSizerBlock" style="margin-top:0;">
          <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS', Tahoma;
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
          ">
            Fig 1. MPL Concept
          </span>
        </photosizer-block>
        </div>
        <t-b>
          It uses TCPClientSocket and TCPServerSocket classes to establish synchronous bilateral
          connections between instances of TCPConnector and ClientHandler.
        </t-b>
        <t-b>
          Fig. 2 illustrates a typical set of sessions between 16 TCPConnector clients and their server-side
          ClientHandlers.  Clients send 1000 4K messages concurrently with the other clients.
        </t-b>
        </div>
        <div>
          <photosizer-block src="Pictures/TestMPL.jpg" width="400" class="photoSizerBlock" style="margin-top:0;">
            <span style="
            display: inline-block;
            font-weight: bold;
            font-family: 'Comic Sans MS', Tahoma;
            background-color: #ddd;
            width: 100%;
            padding: 5px 0px;
          ">
              Fig 2. MPL Output Test4
            </span>
          </photosizer-block>
        </div>
        <t-b>
          Each client has a sending thread and a receiving thread, so the client does not wait for a reply
          before sending its next message.
        </t-b>
      </cpp-content>
      <rust-content style="padding-top:0.25em; border:2px solid #5c2107;">
        <h3>Rust Communicator</h3>
        <div>
          <t-b>
            RustComm is a facility for sending messages between a Connector and Listener.  
          </t-b>
          <div>
          <photosizer-block src="Pictures/RustCommConcept.jpg" width="300" class="photoSizerBlock" style="margin-top:0;">
            <span style="
            display: inline-block;
            font-weight: bold;
            font-family: 'Comic Sans MS', Tahoma;
            background-color: #ddd;
            width: 100%;
            padding: 5px 0px;
            ">
              Fig 1. RustComm Concept
            </span>
          </photosizer-block>
          </div>
          <t-b>
            It uses the std::net::TcpStream and
            std::net::TcpListener types to establish communication between Connector and Listener::Process components.
          </t-b>
          <t-b>
            Listener::Process plays the same role as the MPL ClientHandler, handling message transactions between
            the Listener and its associated Connector.
          </t-b>
          <t-b>
            For each incoming connection the Listener dispatches a threadpool thread to execute Listener::Process
            code for the associated Connector.
          </t-b>
        </div>
        <div>
          <photosizer-block src="Pictures/TestRustCommExper.jpg" width="400" class="photoSizerBlock" style="margin-top:0;">
            <span style="
            display: inline-block;
            font-weight: bold;
            font-family: 'Comic Sans MS', Tahoma;
            background-color: #ddd;
            width: 100%;
            padding: 5px 0px;
          ">
              Fig 2. RustComm Output Test4
            </span>
          </photosizer-block>
        </div>
        <t-b>
          Fig 2. illustrates communication sessions for 16 clients and their associated Listener::Process components.
          As with MPL, clients send 1000 4K messages while other clients are also sending.
        </t-b>
        <t-b>
          Each client has a sending and a receiving thread, so the client does not wait for a reply before sending the
          next message.
        </t-b>
      </rust-content>
    </div>
  </div>
  <hr class="above" />
  <h3 id="comp">Communicator Comparisons</h3>
  <t-b>
    <ol class="tight">
      <li>
        <h4>Performance:</h4>
        <t-b>
          Performance is a very important issue for most C++ and Rust developers.  
          In this section we compare performance of the two message-passing systems described above.
          One is implemented using C++17 and the other using Rust 1.48.  The designs of each are as
          close as practical, given the syntax and semantics of the two languages.
        </t-b>
        <t-b>
          We measured performance by 
          message-passing throughput in MegaBytes per Second for 16 concurrent clients each passing 1000 messages
          to a server that that uses a threadpool running client handlers that simply echo back each message.
        </t-b>
        <t-b>
          Clients send on one thread, receive on another, and don&apos;t wait for replies before sending the next
          message.  Throughput is measured as the total message content bytes for all clients divided by the time
          between sending the first message and receiving the last.
        </t-b> 
        <t-b>
          Here are the results for six different environments, e.g., three different desktops, two operating
          systems, running on both the native platform and in a VMware virtual machine.
        </t-b>
        <div class="indents pad3" style="width:calc(100vw - 10em); margin-top:1.5em;">
          RustComm 5.20% faster than MPL on Windows - Core i7-7700
          <two-column>
            <cpp-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">C++ MPL</div>
              <table style="width:100%">
                <tr>
                  <td colspan="7">
                    Intel Core i7-7700 CPU, 16 GB RAM, 932GB SSD, 64b&nbsp;Windows&nbsp;10&nbsp;ver&nbsp;2004,
                    cl ver 19.28
                  </td>
                </tr>
                <tr>
                  <td>Thruput MB/s with 8 thrds, 16 clients</td>
                  <td>202</td>
                  <td>218</td>
                  <td>229</td>
                  <td>230</td>
                  <td>195</td>
                  <td>217</td>
                </tr>
                <tr>
                  <td colspan="7">Avg Thruput: 215.2 MB/s</td>
                </tr>
              </table>
            </cpp-content>
            <rust-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">Rust Comm</div>
              <table style="width:100%">
                <tr>
                  <td colspan="7">
                    Intel Core i7-7700 CPU, 16 GB RAM, 932GB SSD, 64b&nbsp;Windows&nbsp;10&nbsp;ver&nbsp;2004, 
                    Rustc 1.47.0
                  </td>
                </tr>
                <tr>
                  <td>Thruput MB/s with 8 thrds, 16 clients</td>
                  <td>227</td>
                  <td>248</td>
                  <td>229</td>
                  <td>214</td>
                  <td>235</td>
                  <td>209</td>
                </tr>
                <tr>
                  <td colspan="7">Avg Thruput: 227.0 MB/s</td>
                </tr>
              </table>
            </rust-content>
          </two-column>
        </div>
        <div class="indents pad3" style="width:calc(100vw - 10em);">
          C++ MPL 9.32% faster than RustComm on Ubuntu - Core i7-2600
          <two-column>
            <cpp-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">C++ MPL</div>
              <table style="width:100%">
                <tr>
                  <td colspan="7">
                    Intel Core i7-2600 CPU, 8 GB RAM, 1.5 TB ATA, 64b&nbsp;Ubuntu&nbsp;version&nbsp;20.04,
                    gcc version 9.3.0
                  </td>
                </tr>
                <tr>
                  <td>Thruput MB/s with 8 thrds, 16 clients</td>
                  <td>610</td>
                  <td>640</td>
                  <td>626</td>
                  <td>622</td>
                  <td>610</td>
                  <td>785</td>
                </tr>
                <tr>
                  <td colspan="7">Avg Thruput: 648.8 MB/s</td>
                </tr>
              </table>
            </cpp-content>
            <rust-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">Rust Comm</div>
              <table style="width:100%">
                <tr>
                  <td colspan="7">
                    Intel Core i7-2600 CPU, 8 GB RAM, 1.5 TB ATA, 64b&nbsp;Ubuntu&nbsp;version&nbsp;20.04,
                    Rustc 1.47.0
                  </td>
                </tr>
                <tr>
                  <td>Thruput MB/s with 8 thrds, 16 clients</td>
                  <td>671</td>
                  <td>608</td>
                  <td>606</td>
                  <td>618</td>
                  <td>456</td>
                  <td>571</td>
                </tr>
                <tr>
                  <td colspan="7">Avg Thruput: 588.3 MB/s</td>
                </tr>
              </table>
            </rust-content>
          </two-column>
        </div>
        <div class="indents pad3" style="width:calc(100vw - 10em);">
          RustComm 17.2% faster than MPL on Windows - Xeon Workstation
          <two-column>
            <cpp-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">C++ MPL</div>
              <table style="width:100%">
                <tr>
                  <td colspan="7">
                    Xeon E3-1535M v6, 32 GB RAM, 64b&nbsp;Windows 10 Workstation&nbsp;,
                    cl version 19.28.29334
                  </td>
                </tr>
                <tr>
                  <td>Thruput MB/s with 8 thrds, 16 clients</td>
                  <td>395</td>
                  <td>438</td>
                  <td>385</td>
                  <td>398</td>
                  <td>422</td>
                  <td>391</td>
                </tr>
                <tr>
                  <td colspan="7">Avg Thruput: 404.8 MB/s</td>
                </tr>
              </table>
            </cpp-content>
            <rust-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">Rust Comm</div>
              <table style="width:100%">
                <tr>
                  <td colspan="7">
                    Xeon E3-1535M v6, 32 GB RAM, 64b&nbsp;Windows 10 Workstation&nbsp;,
                    Rustc ver 1.48.0
                  </td>
                </tr>
                <tr>
                  <td>Thruput MB/s with 8 thrds, 16 clients</td>
                  <td>499</td>
                  <td>513</td>
                  <td>434</td>
                  <td>495</td>
                  <td>486</td>
                  <td>507</td>
                </tr>
                <tr>
                  <td colspan="7">Avg Thruput: 489.0 MB/s</td>
                </tr>
              </table>
            </rust-content>
          </two-column>
        </div>
        <div class="indents pad3" style="width:calc(100vw - 10em);">
          MPL 4.21% faster than RustComm on Windows - Xeon Workstation, VMware VM
          <two-column>
            <cpp-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">C++ MPL</div>
              <table style="width:100%">
                <tr>
                  <td colspan="7">
                    Xeon E3-1535M v6, 32 GB RAM, 64b&nbsp;Windows 10 on VMware workstation 16.1.0&nbsp;,
                    cl version 19.28.29334
                  </td>
                </tr>
                <tr>
                  <td>Thruput MB/s with 8 thrds, 16 clients</td>
                  <td>355</td>
                  <td>424</td>
                  <td>435</td>
                  <td>411</td>
                  <td>418</td>
                  <td>436</td>
                </tr>
                <tr>
                  <td colspan="7">Avg Thruput: 413.2 MB/s</td>
                </tr>
              </table>
            </cpp-content>
            <rust-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">Rust Comm</div>
              <table style="width:100%">
                <tr>
                  <td colspan="7">
                    Xeon E3-1535M v6, 32 GB RAM, 64b&nbsp;Windows 10 on VMware workstation 16.1.0&nbsp;,
                    Rustc ver 1.48.0
                  </td>
                </tr>
                <tr>
                  <td>Thruput MB/s with 8 thrds, 16 clients</td>
                  <td>383</td>
                  <td>421</td>
                  <td>411</td>
                  <td>373</td>
                  <td>373</td>
                  <td>414</td>
                </tr>
                <tr>
                  <td colspan="7">Avg Thruput: 395.8 MB/s</td>
                </tr>
              </table>
            </rust-content>
          </two-column>
        </div>
        <div class="indents pad3" style="width:calc(100vw - 10em);">
          MPL 14.8% faster than RustComm on Linux - Xeon Workstation, VMware VM
          <two-column>
            <cpp-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">C++ MPL</div>
              <table style="width:100%">
                <tr>
                  <td colspan="7">
                    Xeon E3-1535M v6, 32 GB RAM, 64b&nbsp;Linux Mint ver 20 on VMware workstation 16.1.0&nbsp;,
                    g++ 9.3
                  </td>
                </tr>
                <tr>
                  <td>Thruput MB/s with 8 thrds, 16 clients</td>
                  <td>630</td>
                  <td>640</td>
                  <td>639</td>
                  <td>600</td>
                  <td>607</td>
                  <td>614</td>
                </tr>
                <tr>
                  <td colspan="7">Avg Thruput: 621.7 MB/s</td>
                </tr>
              </table>
            </cpp-content>
            <rust-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">Rust Comm</div>
              <table style="width:100%">
                <tr>
                  <td colspan="7">
                    Xeon E3-1535M v6, 32 GB RAM, 64b&nbsp;Linux Mint ver 20 on VMware workstation 16.1.0&nbsp;,
                    Rustc ver 1.48.0
                  </td>
                </tr>
                <tr>
                  <td>Thruput MB/s with 8 thrds, 16 clients</td>
                  <td>522</td>
                  <td>517</td>
                  <td>633</td>
                  <td>439</td>
                  <td>492</td>
                  <td>574</td>
                </tr>
                <tr>
                  <td colspan="7">Avg Thruput: 529.5 MB/s</td>
                </tr>
              </table>
            </rust-content>
          </two-column>
        </div>
        <t-b>
          If you want to reproduce these results, you will find the code here:
          <ul class="tight">
            <li>
              <a href="https://github.com/JimFawcett/RustCommExperiments/tree/master/RustComm_VariableSizeMsg">
                RustComm_VariableSizeMsg, master branch
              </a>
            </li>
            <li>
              <a href="https://github.com/mwcorley79/MPL/tree/no-shared-ptr-rust-message-compatibility">
                MPL, no-shared-ptr-rust-message-compatibility branch
              </a>
            </li>
          </ul>
          with build instructions in Readme.md files in the repository roots.
        </t-b>
        <t-b>
          <h4>Summary and Conclusions:</h4>
          The performance results are similar, over the several environments used.  There aren&apos;t
          many surprises here, faster processors yield faster performance, throughput on Linux is faster than
          throughput on Windows.
          <s-halfEm></s-halfEm>
          The conclusion is that C++ and Rust have very similar performance, both very good.
        </t-b>
      </li>
      <li>
        <h4 id="cmplx">Size and Complexity</h4>
        <t-b>
          In this item we compare the two communicators in terms of size of the source code and complexity
          measured by the number of scopes in source codes used to build the communicator programs and
          also by the number of functions in that code.  Here are the results:
        </t-b>
        <div class="indents pad3" style="width:calc(100vw - 10em);">
          <two-column>
            <cpp-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">C++ MPL</div>
              <table style="width:100%">
                <tr>
                  <td>Size - Lines of Source Code</td><td style="text-align:right;">5153</td>
                </tr>
                <tr>
                  <td>Number of Functions</td><td style="text-align:right;">266</td>
                </tr>
                <tr>
                  <td>Number of Scopes</td><td style="text-align:right;">544</td>
                </tr>
              </table>
            </cpp-content>
            <rust-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">Rust Comm</div>
              <table style="width:100%">
                <tr>
                  <td>Size - Lines of Source Code</td><td style="text-align:right;">2313</td>
                </tr>
                <tr>
                  <td>Number of Functions</td><td style="text-align:right;">146</td>
                </tr>
                <tr>
                  <td>Number of Scopes</td><td style="text-align:right;">402</td>
                </tr>
              </table>
            </rust-content>
          </two-column>
        </div>
        <t-b>
          This analysis includes, along with implementing code, codes we used to test MPL and RustComm.
          Test code is an integral part of development and maintenance and, as such, should be counted
          as part of its size and complexity.
        </t-b>
        <t-b>
          Also, analysis includes not only the declarative and executable statements, but white space
          and comments that make the code readable and maintainable.  That is, the lines of code count
          everything.
        </t-b>
        <t-b>
          The data above are affected by the fact that Rust has a fairly high level TCPStream library
          while C++, as of C++20, has no networking library.  The MPL code used platform socket APIs to develop a solid
          library at the same level of abstraction as the Rust TCPStream library.  The abstraction
          implementation had to use the slightly different platform socket APIs on Windows and Linux.
        </t-b>
        <t-b>
          We chose to include the C++ socket library since it is code that had to be developed to
          complete the C++ MPL project.
          The result of this is that we judge Rust to result in somewhat smaller and simpler code, mostly
          because of the scope of its standard libraries.
        </t-b>
      </li>
      <li>
        <h4 id="constr">Ease of Construction:</h4>
        <div class="indents pad3" style="width:calc(100vw - 10em);">
          <t-b>
            This comparison is based on personal experience developing C++ programs for years and more than
            one year of experience with Rust.  Treat these comments as opinion, not evidence-based fact.
          </t-b>
          <two-column>
            <cpp-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">C++</div>
              <hr />
              <t-b>
                For experienced developers, getting a C++ project to compile is usually relatively easy, with the
                possible exception of template metaprogramming code.
              </t-b>
              <t-b>
                Developers tend to spend most of their time debugging operations, especially for multi-threaded
                code. Modern C++ constructs have improved memory safety significantly, but for large systems
                there are likely to be a few places where modern idioms are not followed, resulting in errors
                that are hard to find and fix.
              </t-b>
            </cpp-content>
            <rust-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">Rust</div>
              <hr />
              <t-b>
                The Rust compiler uses static analysis to provide memory and data race safety by construction.
                That means that developers spend significantly more time getting complex programs to compile
                than they would with C++.  Compiler error messages are very helpful, so this isn&apos;t as
                difficult as it would otherwise be.
              </t-b>
              <t-b>
                Rust developers tend to spend much less time debugging code, compared with C++, because Rust 
                compiler analysis has eliminated all memory access and data race errors, leaving only logical
                errors with program operations.
              </t-b>
            </rust-content>
          </two-column>
        </div>
      </li>
      <li>
        <h4 id="safety">Safety:</h4>
        <t-b>
          Modern C++ is memory safe by convention.  It has facilities and common idioms that eliminate most 
          memory use errors, as long the conventions are followed everywhere.
        </t-b>
        <t-b>
          Rust is memory safe by construction and is also data race safe by construction.  The compiler ensures
          that there are  no opportunities for memory and data race errors.
        </t-b>
        <div class="indents pad3" style="width:calc(100vw - 10em);">
          <two-column>
            <cpp-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">C++ MPL</div>
              <hr />
              <t-b>
                C++17 has facilities to ensure data safety by convention:
                <ul class="tight">
                  <li>
                    range-based for loops prevent indexing outside collections
                  </li>
                  <li>
                    iterators prevent dangling pointers when containers reallocate memory
                  </li>
                  <li>
                    std::unique_ptr and std::shared_ptr provide deallocation when they go out of scope
                  </li>
                </ul>
                However, it can be difficult to ensure that in large systems all code satisfies those
                conventions.
              </t-b>
              <t-b>
                C++ has locks to avoid data races by protecting blocks of code, but provides no guarentees 
                that they are used 
                correctly, e.g., do all threads share the same lock, are locks released in the presence
                of errors, ...
              </t-b>
              <hr />
              <t-b>
                During construction of MPL a significant portion of the development time was spent finding
                data races. 
              </t-b>
            </cpp-content>
            <rust-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">Rust Comm</div>
              <hr />
              <t-b>
                Rust guarentees memory saftey by construction:
                <ul class="tight">
                  <li>
                    Indexing out-of-bounds an array or container causes an ordered shutdown, called a panic,
                    that prevents accessing unowned memory.
                  </li>
                  <li>
                    Rust enforces data ownership at compile-time using a reference checker that ensures
                    references to data:
                    <ul class="tight" style="list-style-type:square;">
                      <li>
                        are initialized before use.
                      </li>
                      <li>
                        do not out live their referends.
                      </li>
                      <li>
                        do not view data mutated by the owner or other references.
                      </li>
                    </ul>
                  </li>
                </ul>
                Code that does not conform will fail to build, ensuring memory saftey even for large
                systems.
              </t-b>
              <t-b>
                Rust locks protect data, not sections of code, which gaurentees that all threads accessing
                the same data use the same lock.
              </t-b>
              <t-b>
                That, combinded with Rust&apos;s data ownership rules, avoid data races.
              </t-b>
              <hr />
              <t-b>
              When implementing Rust Comm, it took care to create multi-threaded code that compiled successfully.
              But once built there were no data races to find.
              </t-b>
              <t-b>
                So, its harder to build, but much easier to debug
                multi-threaded code in Rust.
              </t-b>
            </rust-content>
          </two-column>
        </div>
      </li>
      <li>
        <h4 id="maint">Ease of Maintenance:</h4>
        Both MPL and RustComm are well commented, factored into single-focus components, and have effective
        build environments.  Those factors are all part of a good maintenance strategy.  In this block we
        will focus on those maintenance attributes that are largely determined by the C++ and Rust languages and their
        environments.
        <div class="indents pad3" style="width:calc(100vw - 10em);">
          <two-column>
            <cpp-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">C++ MPL</div>
              <hr />
              <t-b>
                The existence and longevity of many large software systems written with C++ demonstrate that,
                if well designed, C++ code can be effectively maintained.
              </t-b>
              <t-b>
                Unlike Rust, C++ does not have a lot of test facilities delivered as part of its default 
                environment.  That means there is a tendency to test in batches periodically
                rather than continuously during construction.
              </t-b>
              <t-b>
                One other issue with C++ is its use of header file #includes.  Builds using these includes
                work well, but if a project gets deployed to a different directory structure, there is a painful
                process of correcting include links before the project builds again.
              </t-b>
            </cpp-content>
            <rust-content style="padding-top:0em;">
              <div style="font-weight:bold; padding:0.25em;">Rust Comm</div>
              <hr />
              <t-b>
                The Rust ecosystem has a tool called cargo.  It is a package and build manager, an executor, and
                it provides access to a linter, clippy, and documentor, rustdoc.
              </t-b>
              <t-b>
                This tool chain makes maintenance of Rust programs very productive.  One of its best features is
                the facilities it provides for test.  Cargo builds libraries with a preconfigured test hook that
                makes it easy to build unit tests as library construction proceeds.
              </t-b>
              <t-b>
                In addition to that, cargo will build any console app it finds in a /examples directory and link
                to the package library.  So it is easy to provide a number of test and demonstration programs that
                illustrate library facilities.
              </t-b>
            </rust-content>
          </two-column>
        </div>
      </li>
    </ol>
  </t-b>
  <hr class="above" />
  <h3 id="impl">Implementations</h3>
  <div>
  <two-column>
    <cpp-content style="padding-top:0.25em;">
      <h3 id="cppcomm">C++ Communicator</h3>
      <div>
        <t-b>
          Unlike Rust, C++ does not have a networking library yet (probably coming with C++2023).  So MPL
          implements a networking library with three main classes, TCPConnector, TCPResponder, and TCPSocket.
          These take care of a lot of the low-level things that are hard to implement cleanly.
        </t-b>
        <t-b>
          The MPL library:
          <ul class="tight">
            <li>
              Uses queued full-duplex buffered message transfers.
            </li>
            <li>
              Each message has a fixed size header and a body consisting of an array of bytes.
            </li>
            <li>
              For each incoming connection the TCPResponder requests a threadpool thread and processes
              messages with an instance of ClientHandler.
            </li>
            <li>
              For this demonstration ClientHandler instances echo back the incoming message, marked as
              reply.
            </li>
          </ul>
        </t-b>
        <t-b>
          The long-term goal for MPL Comm is to serve as a lightweight, flexible, and performant messaging 
          middleware for systems that require simple and robust end to end messaging.  
          The TCPConnector and TCPResponder each provide an object-oriented interface that gives users 
          ability to define application specific message processing.  
        </t-b>
        <t-b>
          Additionally, The TCP socket library is an efficient and portable C++ wrapper around native 
          TCP socket APIs available on Windows and Linux.  This library can be extracted and used on Windows 
          and Linux as an alternative the native (non-portable platform specific) APIs.
        </t-b>
        <h3>Current Design:</h3>
        <t-b>
          There are user-defined types Message, TCPConnector, TCPResponder, ClientHandler, and TCPSocket.
          TCPConnector and ClientHandler have derived classes for specific message types, which in this
          demonstration are: VariableSizeConnector and VariableSizeClientHandler.
        </t-b>
        <t-b>
          TCPSocket has derived classes TCPClientSocket nad TCPServerSocket.
        </t-b>
        <hr />
        <div class="pad10">
        Messages consist of a header with mtype and content_len attributes and an array of bytes for the
        body.
        </div>
        <hr />
        <t-b class="indents">
          <strong>Message methods:</strong>
          <ol class="tight">
            <li>
              <strong><c-s>Message(usize sz, const u8 content_buf[], usize content_len, u8 mtype)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create new <c-s>Message</c-s> from array of bytes
              </div>
            </li>
            <li>
              <strong><c-s>Message(usize sz, const std::string& str, u8 mtype)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create new <c-s>Message</c-s> from string
              </div>
            </li>
            <li>
              <strong><c-s>Message(MessageType mtype=MessageType::DEFAULT)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create new <c-s>Message</c-s> with no contents
              </div>
            </li>
            <li>
              <strong><c-s>Message(const Message &msg) </c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Copy constructor
              </div>
            </li>
            <li>
              <strong><c-s>Message &operator=(const Message &msg)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Copy assignment
              </div>
            </li>
            <li>
              <strong><c-s>Message(Message &&msg)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Move constructor
              </div>
            </li>
            <li>
              <strong><c-s>Message &operator=(Message &&msg)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Move assignment
              </div>
            </li>
            <li>
              <strong><c-s>~Message()</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Destructor
              </div>
            </li>
            <li>
              <strong><c-s>u8 operator[](int index) const</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Const index operator
              </div>
            </li>
            <li>
              <strong><c-s>void set_type(u8 mt)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Set MessageType to one of TEXT, BYTES, STRING
              </div>
            </li>
            <li>
              <strong><c-s>unsigned get_type() const</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Returns instance of MessageType
              </div>
            </li>
            <li>
              <strong><c-s>usize get_content_len() const</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Returns length of message body in bytes
              </div>
            </li>
            <li>
              <strong><c-s>void set_content_bytes(const u8 buff[], size_t len)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Copy byte array into message body
              </div>
            </li>
            <li>
              <strong><c-s>void set_content_str(const std::string &str)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Copy string to message body
              </div>
            </li>
            <li>
              <strong><c-s>std::string get_content_str()</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Return message body as string
              </div>
            </li>
          </ol>
        </t-b>
        <hr />
        <div class="pad10">
          TCPConnector supports direct and queued messaging with a connected TCPResponder.
        </div>
        <hr />
        <t-b>
          TCPConnector methods:
          <ol class="tight">
            <li>
              <strong><c-s>TCPConnector(TCPSocketOptions *sc = nullptr);</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create new TCPConnector
              </div>
            </li>
            <li>
              <strong><c-s>bool Close()</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Shutdown TCPConnector and signal server-side ClientHandler to shutdown.
              </div>
            </li>
            <li>
              <strong><c-s>bool IsConnected() const;</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Has valid connection?
              </div>
            </li>
            <li>
              <strong><c-s>bool IsSending() const;</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Is send thread running?
              </div>
            </li>
            <li>
              <strong><c-s>bool IsReceiving() const;</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Is receive thread running?
              </div>
            </li>
            <li>
              <strong><c-s>void UseSendReceiveQueues(bool use_qs);</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Starts dedicated send and receive threads.
              </div>
            </li>
            <li>
              <strong><c-s>void UseSendQueue(bool use_q);</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Start send thread on connection established.
              </div>
            </li>
            <li>
              <strong><c-s>void UseReceiveQueue(bool use_q);</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Start receive thread on connection established.
              </div>
            </li>
            <li>
              <strong><c-s>void PostMessage(const Message &m);</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Enqueues message for sending to associated TCPResponder.
              </div>
            </li>
            <li>
              <strong><c-s>void SendMessage(const Message &m);</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Sends message directly instead of posting to send queue.
              </div>
            </li>
            <li>
              <strong><c-s>Message GetMessage()</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Dequeue received message if available, else block.
              </div>
            </li>
            <li>
              <strong><c-s>Message ReceiveMessage()</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Read message from socket if available, else block.
              </div>
            </li>
          </ol>
        </t-b>
        <hr />
        <div class="pad10">
          TCPResponder uses threadpool threads to support concurrent communication sessions.
        </div>
        <hr />
        <t-b>
          <strong>TCPResponder methods:</strong>
          <ol class="tight">
            <li>
              <strong><c-s>TCPResponder(const EndPoint& ep, TCPSocketOptions* sc = nullptr)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create new TCPResponder
              </div>
            </li>
            <li>
              <strong><c-s>void RegisterClientHandler(ClientHandler* ch);</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Register ClientHandler prototype - defines server-side message processing.
              </div>
            </li>
            <li>
              <strong><c-s>void Start(int backlog=20)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Start dedicated server listening thread.
              </div>
            </li>
            <li>
              <strong><c-s>void Stop()</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Stop listening service.
              </div>
            </li>
            <li>
              <strong><c-s>void UseClientSendReceiveQueues(bool use_qs);</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Start dedicated send and receive threads when extablishing a connection.
              </div>
            </li>
            <li>
              <strong><c-s>void UseClientSendQueue(bool use_q);</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Start dedicated send thread when establishing a connection.
              </div>
            </li>
            <li>
              <strong><c-s>void UseClientReceiveQueue(bool use_q);</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Start dedicated receive thread when establishing a connection.
              </div>
            </li>
          </ol>
        </t-b>
        <hr />
        <div class="pad10">
          ClientHandlers communicate directly with associated TCPConnectors. Derived ClientHandler
          classes define application specific message handling operations.
        </div>
        <hr />
        <t-b>
          <strong>ClientHandler methods:</strong>
          <ol class="tight">
            <li>
              <strong><c-s>Message GetMessage()</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Dequeue message from receive queue if available, else blocks.
              </div>
            </li>
            <li>
              <strong><c-s>Message ReceiveMessage()</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Read message directly from socket if available, else blocks.
              </div>
            </li>
            <li>
              <strong><c-s>void PostMessage(const Message& m)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Enqueues message for connected client.
              </div>
            </li>
            <li>
              <strong><c-s>void SendMessage(const Message& m)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Write message directly to connected socket.
              </div>
            </li>
            <li>
              <strong><c-s>virtual void AppProc() = 0</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Application message processing supplied by derived ClientHandler class.
              </div>
            </li>
            <li>
              <strong><c-s>virtual ClientHandler* Clone() = 0;</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create application defined ClientHandler instances.
              </div>
            </li>
          </ol>
        </t-b>
      </div>
    </cpp-content>
    <rust-content style="padding-top:0.25em;">
      <h3 id="rustcomm">Rust Communication</h3>
      <div>
        <t-b>
          RustComm is a facility for sending messages between a Sender and Receiver.  It uses the std::net::TcpStream and
          std::net::TcpListener types.
          <spacer-15></spacer-15>
          This is a prototype for message-passing communication system. It provides three user defined types: <c-s>Connector</c-s>,
          <c-s>Listener</c-s>, and <c-s>Message</c-s>, with generic parameters <c-s>M</c-s>, <c-s>P</c-s>, and <c-s>L</c-s>, as shown in Fig. 1.  
          <spacer-15></spacer-15>
          <c-s>M</c-s> implements the <c-s>Msg</c-s> trait and represents a message to be sent between endpoints. 
          <c-s>P</c-s> implements the <c-s>Process&lt;M&gt;</c-s> trait that defines message processing, and 
          <c-s>L</c-s> implements the <c-s>Logger</c-s> trait that supports logging events to the console that can be 
          turned on or off by the types supplied for <c-s>L</c-s>, e.g., <c-s>VerboseLog</c-s> and <c-s>MuteLog</c-s>.
          <spacer-15></spacer-15>
          The RustComm library:
          <t-b class="mtz">
            <ul class="tight mtz">
              <li>
                Uses queued full-duplex buffered message sending and receiving
              </li>
              <li>
                Each message has a fixed size header and <c-s>Vec&lt;u8&gt;</c-s> body.
              </li>
              <li>
                For each <c-s>Connector&lt;P, M, L&gt;</c-s> connection, <c-s>Listener&lt;P, L&gt;</c-s> processes messages 
                until receiving a message with MessageType::END.
              </li>
              <li>
                <c-s>Listener&lt;P, L&gt;</c-s> requests a thread from ThreadPool&lt;P&gt; for each client connection and 
                processes messages in <c-s>P::process_message</c-s>.
              </li>
              <li>
                In this version, <c-s>P::process_message</c-s> echos back message with &quot;reply&quot; appended as 
                reply to sender.  You observe that behavior by running test1, e.g., <c-s>cargo run --example test1</c-s>. 
              </li>
            </ul>
          </t-b>
        </t-b>
        <t-b>
          The long-term goal for RustComm is to serve as a prototyping platform for various messaging and processing
          strategies.  This version defines traits: <c-s>Sndr&lt;M&gt;</c-s>, <c-s>Rcvr&lt;M&gt;</c-s>, 
          <c-s>Process&lt;M&gt;</c-s>, <c-s>Msg</c-s>, and <c-s>Logger</c-s>.
        </t-b>
        <t-b>
          The user-defined types, <c-s>M</c-s> and <c-s>P</c-s>, are things that change as we change the message structure, defined
          by <c-s>M</c-s> and connector and listener processing defined by <c-s>P</c-s>.  
          These types are defined in the rust_comm_processing crate.
          <spacer-15></spacer-15>
          The somewhat complex handling of TcpStreams and TcpListener are expected to remain fixed.  They are defined in
          the crate rust_comm.
        
          Finally, logger <c-s>L</c-s> provides a write method that will,  
          using <c-s>VerboseLog</c-s> for <c-s>L</c-s>, write its argument to the console.  <c-s>MuteLog</c-s> simply discards its argument.
        </t-b>
      </div>
      <t-b>
        RustComm uses a threadpool, as shown in Fig. 1., to avoid context trashing for a large number of concurrent
        clients.  In Fig 2. we show message processing for 16 clients on a machine with 4 hyper-threaded processors.
      </t-b>
      <t-b>
        Each client sends a stream of 1000 4kB messages, all running concurrently.  Timing was executed with a high
        resolution clock with microsecond precision.
      </t-b>
      <t-b>
        Client sends and receives where executed on separate threads, so message sending did not wait for message
        receptions.  Note that the client&apos;s connector internally blocks waiting for reply messages, then enqueues 
        them for the client.
      </t-b>
    <h3>Current Design:</h3>
    <t-b>
      <t-b>
        There are three user-defined types: Message, Connector, and Listener.  Connector and Listener each use an
        existing component BlockingQueue&lt;Message&gt;
        <div class="pad5">
          <t-b>
            <strong>Message:</strong>
            Methods:
          </t-b>
          <ol class="tight">
            <li>
              <strong><c-s>new() -> Message</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create new <c-s>Message</c-s> with empty body and MessageType::TEXT.
              </div>
            </li>
            <li>
              <strong><c-s>set_type(&mut self, mt: u8)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Set <c-s>MessageType</c-s> member to one of: <c-s>TEXT, BYTES, END</c-s>.
              </div>
            </li>
            <li>
              <strong><c-s>get_type(&self) -> MessageType</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Return <c-s>MessageType</c-s> member value.
              </div>
            </li>
            <li>
              <strong><c-s>set_body_bytes(&mut self, b: Vec&lt;u8&gt;)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Set <c-s>body_buffer</c-s> member to bytes from<c-s>b: Vec&lt;u8&gt;</c-s>.
              </div>
            </li>
            <li>
              <strong><c-s>set_body_str(&mut self, s: &str;)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Set <c-s>body_buffer</c-s> member to bytes from<c-s>s: &str</c-s>.
              </div>
            </li>
            <li>
              <strong><c-s>get_body_size(&self) -> usize</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Return size in bytes of body member.
              </div>
            </li>
            <li>
              <strong><c-s>get_body(&self) -> &Vec&lt;u8&gt;</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Return <c-s>body_buffer</c-s> member.
              </div>
            </li>
            <li>
              <strong><c-s>get_body_str(&self) -> String</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Return body contents as lossy <c-s>String</c-s>.
              </div>
            </li>
            <li>
              <strong><c-s>clear(&self)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                clear body contents.
              </div>
            </li>
          </ol>
          <t-b>
            <hr />
            <div class="pad10">
              Both <c-s>Connector&lt;P, M, L&gt;</c-s> and <c-s>Listener&lt;P, L&gt;</c-s> are parameterized with <c-s>L</c-s>,
              a type satisfying a <c-s>Logger</c-s> trait.  The package defines two types that implement the trait,
              <c-s>VerboseLog</c-s> and <c-s>MuteLog</c-s> that allow users to easily turn on and off event display
              outputs.  Fig 2. uses <c-s>MuteLog</c-s> in both <c-s>Connector&lt;P, M, L&gt;</c-s> and 
              <c-s>Listener&lt;P, L&gt;</c-s>.
            </div>
            <hr />
          </t-b>
          <t-b><strong>Connector&lt;P, M, L&gt;</strong> methods:</t-b>
          <ol class="tight">
            <li>
              <strong><c-s>new(addr: &'static str) -> std::io::Result&lt;Connector&lt;P,M,L&gt;&gt;</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create new <c-s>Connector&lt;P,M,L&gt;</c-s> with running send and receive threads.
              </div>
            </li>
            <li>
              <strong><c-s>is_connected(&self) -> bool</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                is connected to <c-s>addr</c-s>?.
              </div>
            </li>
            <li>
              <strong><c-s>post_message(&self, msg: M)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Enqueues msg to send to connected Receiver.
              </div>
            </li>
            <li>
              <strong><c-s>get_message(&mut self) -> M</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Reads reply message if available, else blocks.
              </div>
            </li>
            <li>
              <strong><c-s>has_message(&self) -> bool</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Returns true if reply message is available.
              </div>
            </li>
          </ol>
          <t-b><strong>Listener&lt;P, L&gt;</strong> methods:</t-b>
          <ol class="tight">
            <li>
              <strong><c-s>new(nt: u8) -> Listener&lt;P, L&gt;</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create new <c-s>Listener&lt;P, L&gt;</c-s> with nt threads running.
              </div>
            </li>
            <li>
              <strong><c-s>start(&mut self, addr: &'static str) -> std::io::Result&lt;JoinHandle&lt;()&gt;&gt;</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Bind <c-s>Listener&lt;P,L&gt;</c-s> to <c-s>addr</c-s> and start listening on dedicated thread.
              </div>
            </li>
          </ol>
          <t-b>
            <hr />
            <div class="pad10">
              <c-s>CommProcessing&lt;L&gt;</c-s> is parameterized with <c-s>L</c-s>,
              a type satisfying a <c-s>Logger</c-s> trait.  The package defines two types that implement the trait,
              <c-s>VerboseLog</c-s> and <c-s>MuteLog</c-s> that allow users to easily turn on and off event display
              outputs.
            </div>
            <hr />
          </t-b>
          <t-b>
            <strong>CommProcessing&lt;L&gt;</strong> methods:
            <ol class="tight">
              <li>
                <strong><c-s>new() -> CommProcessing&lt;L&gt;</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create instance of CommProcessing&lt;L&gt;
              </div>
              </li>
              <li>
                <strong><c-s>send_message(msg:&M, stream:&mut&lt;TcpStream) -> std::io::Result&lt;()&gt;</c-s></strong>
                <div style="padding:3px 10px 5px 10px;">
                  Write message to TcpStream connected to Connector&lt;P,M,L&gt;
                </div>
              </li>
              <li>
                <strong><c-s>buf_send_message(msg:&M, stream:&mut&nbsp;BufWriter&lt;TcpStream&gt;) -> std::io::Result&lt;()&gt;</c-s></strong>
                <div style="padding:3px 10px 5px 10px;">
                  Write message to TcpStream connected to Connector&lt;P,M,L&gt;
                </div>
              </li>
              <li>
                <strong><c-s>recv_message(stream:&mut&nbsp;TcpStream) -> std::io::Result&lt;M&gt;</c-s></strong>
                <div style="padding:3px 10px 5px 10px;">
                  Read message from TcpStream connected to Connector&lt;P,M,L&gt;
                </div>
              </li>
              <li>
                <strong><c-s>buf_recv_message(stream:&mut&nbsp;BufReader&lt;TcpStream&gt;) -> std::io::Result&lt;M&gt;</c-s></strong>
                <div style="padding:3px 10px 5px 10px;">
                  Read message from TcpStream connected to Connector&lt;P,M,L&gt;
                </div>
              </li>
              <li>
                <strong><c-s>process_message(msg:&mut&nbsp;M)</c-s></strong>
                <div style="padding:3px 10px 5px 10px;">
                  Process message using mutable reference.
                </div>
              </li>
            </ol>
          </t-b>
        </div>
      </t-b>
    </t-b>
    </rust-content>
  </two-column>
  </div>
  <!--<t-b>
    We both are seasoned professional developers.
    <ul>
      <li>
        I&apos;ve used C++ since 1988 when the Zortec compiler was first issued.  My intersts then were for computer-aided
        design for control systems.  My experience with Rust began when I retired from Syracuse University in 2019.
        I was particularly attracted to its memory and data race safety.
      </li>
      <li>
        Mike has been developing code in C++, C#, and Java since the beginning of 2000.  He does a lot of prototyping of
        interesting applications to determine feasibility and aquire funding for advanced development acitivities.
      </li>
    </ul>
  </t-b>-->
  <div class="clear"></div>
    <h3 id="build">Build:</h3>
    <t-b class="indent">
      You will find code discussed in this documentation in the two repositories:
      <ul class="tight">
        <li>
          <a href="https://github.com/mwcorley79/MPL/tree/no-shared-ptr-rust-message-compatibility">MPL Repository</a>
        </li>
        <li>
          <a href="https://github.com/JimFawcett/RustCommExperiments">RustComm Repository</a>
        </li>
      </ul>
      Build instructions are provided in the Readme.md files in each.  Note that the code for MPL was built from
      the no-shared-ptr-rust-message-compatibility branch.  The code for RustComm was built from the master branch.
    </t-b>
    <h3 id="status">Status:</h3>
    <t-b>
      This code implements all of the features we intended for comparison.  There are no known defects.
      Both codes provide prototypes for future projects, but will be kept here "as-is".
    </t-b>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <sec-elem style="width:0.0em">&nbsp;</sec-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <!--<menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.decrZoomScreen()">Zout</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.normZoomScreen()">Zdef</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.incrZoomScreen()">Zin</menu-elem>-->
    </frame-footer>
  </page-frame>
</body>
</html>