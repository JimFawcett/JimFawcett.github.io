<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Libraries.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Story-Libs</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    #github .pad10-15 {
      padding: 10px 15px;
    }

    #github .codeStyle {
      overflow: hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github .labelStyle {
      font-family: sans-serif;
      /*font-weight:bold;*/
      font-size: 1.0em;
    }

    #github .normal {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github summary {
      padding: 3px 0px 5px 0px;
      font-weight: bold;
      width: max-content;
    }

      #github summary ~ div {
        width: max-content;
        max-width: 95%;
      }

      #github summary ~ indent-block {
        width: max-content;
        max-width: 95%;
        padding-left: 20px;
        padding-right: 20px;
        /*background-color: #eee;*/
      }

    #github photosizer-block {
      position: relative;
      z-index: 2;
      background-color: white;
    }

    #github comment-block {
      width: max-content;
      max-width: 95%;
      padding: 10px 15px;
      background-color: #eee;
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github c-s {
      overflow: hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github t-s {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github .notice {
      font-size: 1.1em;
      font-weight: bolder;
      font-style: italic;
      font-family: Consolas, sans-serif;
      border: none;
      color: darkred;
    }

    #github background-block {
      display: block;
      background-color: #ddd;
      max-width: 90%;
      width: max-content;
      padding: 10px 15px;
    }

    #github .footnote {
      font-size: 0.85em;
    }

    #github ol.footnote li {
      padding-bottom: 0px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Interesting.html">N</a>
  <a id="Prev" href="CppStory_TemplateMetaprog.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #8 - C++ Libraries</h1>
      <h3 id="subtitle">example code</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="CppStory_Prologue.html">Prologue</a><br />
       <a href="CppStory_Survey.html">Survey</a><br />
       <a href="CppStory_Data.html">Data</a><br />
       <a href="CppStory_Operations.html">Operations</a><br />
       <a href="CppStory_Classes.html">Classes</a><br />
       <a href="CppStory_ClassRelationships.html">ClassRel</a><br />
       <a href="CppStory_Templates.html">Templates</a><br />
       <a href="CppStory_TemplateMetaprog.html">TMP</a><br />
       <a href="CppStory_Libraries.html">Libraries</a><br />
       <a href="CppStory_Interesting.html">Interesting</a>
     </up-b>
     <rt-b id="sects">
      <a href="#top">Top</a>, <a href="#libs">Libraries</a>, <a href="#streams">Streams</a>, 
     <a href="#stl">STL</a>,  <a href="#filesystem">File System</a>, 
      <a href="#threads">Threads</a>, <a href="#sockets">Sockets</a>, 
      <a href="#xmldoc">XmlDoc</a>, <a href="#Boost">Boost</a>, 
      <a href="#json">JSON</a>, <a href="#thirdparty">Third-Party</a>,
      <a href="#refs">References</a>, 
     </rt-b>
   </toc-b>

  <a id="libs"></a>
  <hr class="spread" />
  <bb-55>
    <num-cont>
      <num-item1>8.0</num-item1><num-item4>Libraries Prologue:</num-item4>
    </num-cont>
    <t-b>
      The C++ language comes with a great collection of standard libraries. There are scores of very
      well designed facilities and more are coming with the next standardization in C++20.
      We will be discussing
      four of them here - the ones most often used building server and desktop applications.
    </t-b>
    <t-b>
      We will also discuss one of the (very many) Boost libraries, Boost::Asio, of which part is very
      likely to become a networking standard library.
    </t-b>
    <t-b>
      I will be working on this chapter intermittently - targetting completion mid Spring 2020.
    </t-b>
    <a id="streams"></a>
    <hr class="spread" />
    <div style="width:calc(100vw - 12rem);">
    <hidephotosizer-block src="Pictures/iostreams.JPG" width="400" class="photoSizerBlock right">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 1. IOStream Hierarchy
      </span>
    </hidephotosizer-block>
    </div>
    <num-cont>
      <num-item1>8.1</num-item1><num-item4>Streams:</num-item4>
    </num-cont>
    <t-b>
      The stream library is structured as shown in Fig 1.  <c-s>std::ios</c-s> is a class responsible
      for managing formatting and error information. All its derived classed, <c-s>std::istream</c-s>,
      <c-s>std::ostream</c-s>, ... provide an invariant interface for streams.  They make the language
      we use to interact with streams.
    </t-b>
    <t-b>
      The buffers <c-s>std::streambuf</c-s> and its derived classes have a number of virtual functions that
      support customization. This is a really elegant design. The interface is fixed so everyone knows how
      to deal with streams, but their semantics can be customized by implementing application specific 
      buffer adapters.
    </t-b>
    <t-b>
      I did that as an example in a graduate course CSE776 - Design Patterns, using the &quot;Adapter Pattern&quot;.
      That example supported sending socket messages through a stream interface.
    </t-b>
    <t-b>
      All of the real stream functionality is provided by the buffers.  You can open, read, write, and close
      files, for example, just using an instance of std::filebuf.
    </t-b>
    <div class="clear"></div>
    <a id="strmscode"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8.2</num-item1><num-item4>Streams Code Examples:</num-item4>
    </num-cont>
    <t-b>
      std::iostreams formatting is fairly simple. All the format settings are encoded in bits in
      a long int which you can access from the functions:
      <defn-code class="pad10">long frmt = flags();  // retrieve the current format settings
flags(frmt);          // restore the original settings</defn-code>
      A lot of the settings can be activated by toggling individual bits when there are only two
      format choices.  However, there are three formats that each have three choices:
      <t-b indent>
        <indent-block>
          <ol class="tight">
            <li>
              right, left, and internal adjust in a specified field width:<br />
              <c-s>std::cout.setf(ios::left, ios::adjustfield);</c-s>
            </li>
            <li>
              scientific, fixed, and automatic for floating point numbers:<br />
              <c-s>std::cout.setf(ios::scientific, ios::floatfield);</c-s>
            </li>
            <li>
              dec, oct, and hex for number formatting:<br />
              <c-s>std::cout.setf(ios::hex, ios::basefield);</c-s>
            </li>
          </ol>
        </indent-block>
        <s-5px></s-5px>
        Each of the choices is encoded in a single bit, so it is possible, for example, that both left and right
        adjust could be set, resulting in undefined behavior. The adjustfield, floatfield, and basefield
        arguments cause all of the bits for that format to be zeroed, then the one you want is set with
        ios::left, for example.
      </t-b>
      <t-b>
        The code example, below, shows most of the formatting mechanisms in iostreams.
      </t-b>
    </t-b>
    <details>
    <summary class="labelStyle lightItem">Example: std::iostream formats</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>Formats.cpp</defn-head>
            <defn-code style="font-size:0.7rem;">
///////////////////////////////////////////////////////////
// formats.cpp                                           //
//   demonstrate ios formating                           //
//                                                       //
// Jim Fawcett, 24 Mar 96, modified 04 Mar 02            //
///////////////////////////////////////////////////////////

#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
using namespace std;

void main() {

  title("Demonstrating ios formatting",'=');

  title("formating integers");

  /////////////////////////////////////////////////////////////
  // flags:                                                  //
  //   skipws  showbase showpoint uppercase   showpos        //
  //  unitbuf     stdio                                      //
  /////////////////////////////////////////////////////////////
  //  basefield:                                             //
  //    dec       hex       oct                              //
  /////////////////////////////////////////////////////////////

  long save = cout.flags();    // save format state
  cout.setf(ios::showbase|ios::uppercase);
  cout &lt;&lt; "  " &lt;&lt; 59 &lt;&lt; " in hexadecimal is "
       &lt;&lt; hex  &lt;&lt; 59 &lt;&lt; dec &lt;&lt; endl
       &lt;&lt; "  " &lt;&lt; 59 &lt;&lt; " in octal is       "
       &lt;&lt; oct  &lt;&lt; 59 &lt;&lt; dec &lt;&lt; endl;
  cout.flags(save);            // restore original format state

  title("formating doubles");

  /////////////////////////////////////////////////////////////////
  // function:                                                   //
  //     width()     width(n)       fill()      fill(n)          //
  // precision() precision(n)                                    //
  /////////////////////////////////////////////////////////////////
  // floatfield:                                                 //
  //  scientific        fixed    automatic                       //
  /////////////////////////////////////////////////////////////////

  cout.precision(6);
  cout.setf(ios::right, ios::adjustfield);
  cout.setf(ios::scientific, ios::floatfield);
  cout.setf(ios::showpoint);
  double d = 9;
  int i;
  for(i=0; i&lt;5; i++)
    cout &lt;&lt; setw(14) &lt;&lt; (d /= 3);
  cout &lt;&lt; endl;
  cout.flags(save);

  title("adjust, fill, and width");

  /////////////////////////////////////////////////////////////////
  // adjustfield:                                                //
  //        left        right     internal                       //
  /////////////////////////////////////////////////////////////////

  char *numbers[5] = { "zero", "one", "two", "three", "four" };
  int nums[5] = { 0, 1, 2, 3, 4 };
  cout.fill('.');
  for(i=0; i&lt;5; i++) {
    cout.setf(ios::left, ios::adjustfield);
    cout &lt;&lt; "  " &lt;&lt; setw(30) &lt;&lt; numbers[i];
    cout.setf(ios::right, ios::adjustfield);
    cout &lt;&lt; setw(30) &lt;&lt; nums[i] &lt;&lt; endl;
  }
  cout.flags(save);

  title("stream manipulators");

  /////////////////////////////////////////////////////////////
  // manipulators:                                           //
  //   iostream.h -  dec, oct, hex, endl, ws, ends, flush,   //
  //   iomanip.h  -                                          //
  //     setfill(char), setw(int), setprecision(int),        //
  //     setiosflags(long), resetiosflags(long)              //
  /////////////////////////////////////////////////////////////

  cout &lt;&lt; "  " &lt;&lt; setprecision(5) &lt;&lt; (d = 1.0/3.0) &lt;&lt; endl;
  cout &lt;&lt; "  " &lt;&lt; setfill('.') &lt;&lt; setw(20) &lt;&lt; d &lt;&lt; endl;
  cout &lt;&lt; "  " &lt;&lt; setiosflags(ios::left | ios::showpos)
       &lt;&lt; setw(20) &lt;&lt; d &lt;&lt; endl;
  cout &lt;&lt; "  " &lt;&lt; resetiosflags(ios::left | ios::showpos)
        &lt;&lt; d &lt;&lt; endl;
  cout.flags(save);
  cout &lt;&lt; endl;
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output:</defn-head>
            <defn-code style="font-size:0.7rem;">
 ==============================
  Demonstrating ios formatting
 ==============================

  formating integers
 --------------------
  59 in hexadecimal is 0X3B
  59 in octal is       073

  formating doubles
 -------------------
  3.000000e+00  1.000000e+00  3.333333e-01  1.111111e-01  3.703704e-02

  adjust, fill, and width
 -------------------------
  zero.......................................................0
  one........................................................1
  two........................................................2
  three......................................................3
  four.......................................................4

  stream manipulators
 ---------------------
  0.33333
  .............0.33333
  +0.33333............
  0.33333
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
    <t-b>
      The next example illustrates working with file streams.  Many of the things you will need to
      do when working with files are presented in the example. 
    </t-b>
    <t-b>
      Files can be opened in two ways and closed:
      <t-b>
        <indent-block>
          <ol class="tight">
            <li><c-s>std::ifstream in(filename, ios::in);</c-s></li>
            <li><c-s>std::ifstream in; in.open(filename, ios::in);</c-s></li>
            <li><c-s>in.close();</c-s></li>
          </ol>
        </indent-block>
      </t-b>      When file streams go out of scope their destructors call <c-s>close()</c-s>, but it does no
      harm to close the file before it goes out of scope, freeing the internal OS file handle.
    </t-b>
    <t-b>
      The example illustrates standard error handling.
      When you attempt to open a file that may or may not succeed.
      <t-b>
        <indent-block>
          <ol class="tight">
            <li>The file name may be incorrect or the file may not exist.</li>
            <li>Other code may have that file opened.</li>
            <li>The user may not have permissions to open the file.</li>
          </ol>
        </indent-block>
      </t-b>      For this, standard streams have a simple error handling process.  Streams can be in any of
      three states:
      <t-b>
        <indent-block>
          <ol class="tight">
            <li>
              <span class="notice">good</span> state, tested with the function <c-s>bool good()</c-s>.  When good is true the
              stream operates normally.
            </li>
            <li>
              <span class="notice">bad</span> state, tested with <c-s>bool bad()</c-s>. Streams in a bad state are fully
              functional, but will not respond to any commands until the stream error is cleared with
              <c-s>void clear()</c-s>. A state can go bad when it attempts to read an end of file
              integer, <c-s>eof</c-s>. To restore normal operation, clear the error and back up at
              least one character by calling <c-s>strm.seek(-1);</c-s>
            </li>
            <li>
              <span class="notice">fail</span> state, tested with <c-s>bool fail()</c-s>. Streams in a fail state have been corrupted.
              The only thing you can do with a failed stream is to destroy it or re-initialize with an
              <c-s>open(filename, ios attributes);</c-s>.
            </li>
          </ol>
        </indent-block>
      </t-b>
      You should <span class="notice">always</span> check filestream state after opening, before any attempt
      to use it.  We often do that with:
      <indent-block class="pad10">
        <c-s>
          std::ofstream out(filename, ios::out);<br />
          if(!out.good()) {
          /* do some clean up and return */
          }
        </c-s>
      </indent-block>
      Finally, here&apos;s the example:
    </t-b>
    <details>
      <summary class="labelStyle lightItem">Example: std::fstreams I/O</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>Fileio.cpp</defn-head>
            <defn-code style="font-size:0.7em;">
///////////////////////////////////////////////////////////////
// fileio.cpp - demonstrate fstreams                         //
//                                                           //
// Jim Fawcett, 24 Mar 96, modified 04 Mar 02                //
///////////////////////////////////////////////////////////////

#include &lt;iostream&gt;     // cout, &lt;&lt;
#include &lt;fstream&gt;      // ifstream(), &lt;&lt;, &gt;&gt;
#include &lt;cstdlib&gt;      // exit(1);
#include &lt;sstream&gt;
#include &lt;string&gt;
using namespace std;

//----&lt; display titles &gt;---------------------------------------

void title(const char *t, char ul = '-', ostream &amp;out = cout) {

  int len = strlen(t) + 2;
  string line(len,ul);
  if(ul == '=')
    out &lt;&lt; "\n " &lt;&lt; line;
  out &lt;&lt; "\n  " &lt;&lt; t
      &lt;&lt; "\n " &lt;&lt; line &lt;&lt; endl;
}

//----&lt; begin demonstration &gt;----------------------------------

void main(int argc, char *argv[]) {

  /////////////////////////////////////////////////
  title("Demonstrating Basic File Operations",'=');
  /////////////////////////////////////////////////

  if(argc &lt; 2) {
    cout &lt;&lt; "\nplease enter name of text file on command line\n\n";
    exit(1);
  }
  const int bufSize = 80;
  char buffer[bufSize];

//

  // create a scope with { } and define an input stream inside
  // then read line-by-line and send to standard output
  {
    ifstream in(argv[argc-1]);
    if(!in.good()) {
      cout &lt;&lt; "can't open file " &lt;&lt; argv[argc-1] &lt;&lt; endl;
      exit(1);
    }
    else {
      ostringstream temp;
      temp &lt;&lt; "processing file " &lt;&lt; argv[argc-1]
           &lt;&lt; " using istream::getline()";

      title(temp.str().c_str());
      //////////////////////////
    }

    while(in.good()) {
      in.getline(buffer,bufSize);
      cout &lt;&lt; buffer &lt;&lt; endl;
    }
  }  // in goes out of scope and is destroyed

  // define stream again at global level, get pointer to
  // its filebuf and stream input directly to output

  ostringstream temp;
  temp &lt;&lt; "processing file " &lt;&lt; argv[argc-1]
       &lt;&lt; " using filebuf::rdbuf()";
  title(temp.str().c_str());
  //////////////////////////
  
  ifstream in(argv[argc-1]);
  filebuf *bptr = in.rdbuf();    // get pointer to stream
  cout &lt;&lt; bptr &lt;&lt; endl;          // stream input to output
  in.close();                    // still in scope so close it

//

  // open stream again, seek to end to find size, and
  // backup half way, then send last half to stdout

  in.open(argv[argc-1]);         // open it again
  in.seekg(0, ios::end);         // go to end of file
  streampos sp = in.tellg();     // size = number of bytes from beg
  in.seekg(-sp/2, ios::end);     // go to middle
  in.getline(buffer,bufSize);    // go to next newline

  ostringstream temp2;
  temp2 &lt;&lt; "processing last half of this " &lt;&lt; sp &lt;&lt; " byte file";
  title(temp2.str().c_str());
  ///////////////////////////

  cout &lt;&lt; in.rdbuf() &lt;&lt; endl;    // output from that point to end

  title("stream state goes bad when attempting to read past end of file");
  ////////////////////////////////////////////////////////////////////////

  char ch;
  in &gt;&gt; ch;
  if(!in.good())
    cout &lt;&lt; "  attempting to read past EOF makes stream state"
         &lt;&lt; " not good\n";

  title("can't read any more until we clear stream to good state");
  /////////////////////////////////////////////////////////////////

  in.clear();
  if(in.good())
    cout &lt;&lt; "  stream state good after clear()\n";
  in.seekg(-1,ios::end);         // back up to good char
  in &gt;&gt; ch;
  if(in.good())
    cout &lt;&lt; "  after backing up and reading " &lt;&lt; ch
         &lt;&lt; " stream state still good\n";
  in &gt;&gt; ch;
  if(!in.good())
    cout &lt;&lt; "  after reading EOF stream state not good again\n";
  cout &lt;&lt; endl;
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output:</defn-head>
            <defn-code style="font-size:0.7em;">
 =====================================
  Demonstrating Basic File Operations
 =====================================

  processing file test.txt using istream::getline()
 ---------------------------------------------------
this is the first line
second line
third line
fourth line
fifth line
this is the sixth and final line

  processing file test.txt using filebuf::rdbuf()
 -------------------------------------------------
this is the first line
second line
third line
fourth line
fifth line
this is the sixth and final line

  processing last half of this 106 byte file
 --------------------------------------------
fifth line
this is the sixth and final line

  stream state goes bad when attempting to read past end of file
 ----------------------------------------------------------------
  attempting to read past EOF makes stream state not good

  can't read any more until we clear stream to good state
 ---------------------------------------------------------
  stream state good after clear()
  after backing up and reading e stream state still good
  after reading EOF stream state not good again
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
    <t-b>
      The next example illustrates that most things you can do with a standard stream object you can
      also do with its internal filebuf. In other words, the stream object presents a (non-virtual)
      interface and its filebuf does all the work.
    </t-b>
    <details>
      <summary class="labelStyle lightItem">Example: std::Filebuf I/O</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>Filebuf.cpp</defn-head>
            <defn-code style="font-size:0.7em;">
/////////////////////////////////////////////////////////////////
// filebuf.cpp                                                 //
//   demonstrate low level input and output using streambufs   //
//   built from FILE pointer and stdout                        //
//                                                             //
// Jim Fawcett, 24 Mar 96, modified 23 Mar 97, 01 Mar 04       //
/////////////////////////////////////////////////////////////////

#include &lt;iostream&gt;    // cout, &lt;&lt;
#include &lt;fstream&gt;     // ifstream(), &lt;&lt;, &gt;&gt;
using namespace std;

//----&lt; display titles &gt;---------------------------------------

void title(const char *t, char ul = '-', ostream &amp;out = cout) {

  int len = strlen(t) + 2;
  std::string line(len,ul);
  if(ul == '=')
    out &lt;&lt; "\n " &lt;&lt; line.c_str();
  out &lt;&lt; "\n  " &lt;&lt; t
      &lt;&lt; "\n " &lt;&lt; line.c_str() &lt;&lt; endl;
}

//----&lt; begin demonstration &gt;----------------------------------

void main(int argc, char *argv[]) {

  //////////////////////////////////////////////////////////////
  title("Demonstrating use of Stream Buffers with File IO",'=');
  //////////////////////////////////////////////////////////////

  if(argc &lt; 2) {
    cout &lt;&lt; "\nplease enter name of text file on command line\n";
    exit(1);
  }

  title("using streambuf for input from file");
  /////////////////////////////////////////////

  filebuf ifb;                       // create filebuf
  ifb.open(argv[argc-1],ios::in);    // attach to file
  cout &lt;&lt; &amp;ifb &lt;&lt; endl;              // stream to cout
  cout.flush();

  title("using streambuf for output to stdout");
  //////////////////////////////////////////////

  istream in(&amp;ifb);            // make stream in, attached to ifb
  in.seekg(0);                 // move to top of input buffer
  ostream out(cout.rdbuf());   // make stream out, attached to cout streambuf
  out &lt;&lt; &amp;ifb &lt;&lt; endl;         // stream it to out
  out.flush();

// could replace last statement with the lower level
// gets and puts shown below

  title("using low-level streambuf interface for output to stdout");
  //////////////////////////////////////////////////////////////////

  streambuf* pOfb = cout.rdbuf();
  in.seekg(0);
  char ch;
  while((ch = ifb.sbumpc()) != EOF)
    pOfb-&gt;sputc(ch);

  cout &lt;&lt; "\n\n";
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output:</defn-head>
            <defn-code style="font-size:0.7em;">
 ==================================================
  Demonstrating use of Stream Buffers with File IO
 ==================================================

  using streambuf for input from file
 -------------------------------------
this is the first line
second line
third line
fourth line
fifth line
this is the sixth and final line

  using streambuf for output to stdout
 --------------------------------------
this is the first line
second line
third line
fourth line
fifth line
this is the sixth and final line

  using low-level streambuf interface for output to stdout
 ----------------------------------------------------------
this is the first line
second line
third line
fourth line
fifth line
this is the sixth and final line
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
    <t-b>
      The next example illustrates that you can read and write to the same file using a single filebuf
      for both reading and writing.  You might do that if you were building a database record manager
      where you need to read existing data but also enter new data into the same file.
    </t-b>
    <t-b>
      In order to make this work for something useful you will have to devise a schema which defines
      regions of the file where you read and write specific columns of a record.  That&apos;s what
      SQL databases do.
    </t-b>
    <t-b>
      This example just demonstrates that you can both read and write.  It doesn&apos;t do any schema-based
      record management (but that wouldn&apos;t be too hard to do). The way we get that to work is to
      wrap a common filebuf with both an input stream and an output stream.  Here&apos;s the details:
    </t-b>
    <details>
      <summary class="labelStyle lightItem">Read/Write Streams</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>Readwrite.cpp</defn-head>
            <defn-code style="font-size:0.7rem;">
///////////////////////////////////////////////////////////////
// readwrit.cpp - demonstrate read/write fstreams            //
//                with buffer location seeking               //
// Jim Fawcett, 24 Mar 96, modified 23 Mar 97                //
///////////////////////////////////////////////////////////////

#include &lt;iostream&gt;     // cout, &lt;&lt;
#include &lt;fstream&gt;      // ifstream(), &lt;&lt;, &gt;&gt;
#include &lt;cstdlib&gt;      // exit(1);
#include &lt;string&gt;
using namespace std;

//----&lt; display titles &gt;---------------------------------------

void title(const char *t, char ul = '-', ostream &amp;out = cout) {

  int len = strlen(t) + 2;
  string line(len,ul);
  if(ul == '=')
    out &lt;&lt; "\n " &lt;&lt; line;
  out &lt;&lt; "\n  " &lt;&lt; t
      &lt;&lt; "\n " &lt;&lt; line &lt;&lt; endl;
}

//----&lt; begin demonstration &gt;----------------------------------

void main(int argc, char *argv[]) {

  ///////////////////////////////////////////////////////////////
  title("Demonstration of Reading AND Writing to a Common File",'=');
  ///////////////////////////////////////////////////////////////

  if(argc &lt; 2) {
    cout &lt;&lt; "please enter file name on command line\n";
    exit(1);
  }

//

  ///////////////////////////////////////////////////////////////
  // file open modes:        in       out       app       ate  //
  //                             nocreate noreplace     trunc  //
  ///////////////////////////////////////////////////////////////

  // save input file contents in a temporary file 
  // for reading and writing

  ifstream masterin(argv[argc-1]);
  ofstream tempout("tmp.tmp");
  tempout &lt;&lt; masterin.rdbuf();
  masterin.close();
  tempout.close();

  // open temporary for input AND output processing
  ifstream in("tmp.tmp", ios::in|ios::out);
  if(!in.good()) {
    cout &lt;&lt; "can't open file tmp.tmp" &lt;&lt; endl;
    exit(1);
  }

  // use input stream buffer for output stream too
  ostream out(in.rdbuf());

  // now, try reading and writing
  
  title("this is a test file for reading and writing");
  /////////////////////////////////////////////////////

  cout &lt;&lt; in.rdbuf();
  out &lt;&lt; "---\nthis text is added to the end\n";

  // how many bytes in file?
  streampos sp = out.tellp();
  out.seekp(-sp, ios::end);            // back up from end
  out &lt;&lt; "this text overwrites beginning of file\n";
  cout &lt;&lt; endl;

  // write it out to see what happened
 
  title("modified file:");
  ////////////////////////

  in.seekg(ios::beg);                  // go to beginning
  cout &lt;&lt; in.rdbuf() &lt;&lt; endl;
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output:</defn-head>
            <defn-code style="font-size:0.7rem;">
 =======================================================
  Demonstration of Reading AND Writing to a Common File
 =======================================================

  this is a test file for reading and writing
 ---------------------------------------------
this is the first line
second line
third line
fourth line
fifth line
this is the sixth and final line

  modified file:
 ----------------
this text overwrites beginning of file
rd line
fourth line
fifth line
this is the sixth and final line---
this text is added to the end
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
    <t-b>
      The final example demonstrates stringstreams.  These are particularly useful for doing object to
      string and string to object transformations.  That&apos;s what a std::ostream does.  If you write:
      <indent-block class="pad10">
        double d{ 3.14159 };<br />
        std::cout << d;
      </indent-block>
      <c-s>std::cout</c-s> transforms its double input into a sequence of characters written to your
      terminal, e.g., a string. All the standard streams do this, and, with stringstream objects, we
      can retrieve the string for processing rather than write it to a terminal.
      Here&apos;s the demo:
    </t-b>
    <details>
      <summary class="labelStyle lightItem">Example: std::stringstreams</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>Strio.cpp</defn-head>
            <defn-code style="font-size:0.7rem;">
///////////////////////////////////////////////////////////////
// strio.cpp - demonstrate stringstreams                     //
//                                                           //
// Jim Fawcett, 24 Mar 96, modified 04 Mar 02                //
///////////////////////////////////////////////////////////////

#include &lt;iostream&gt;     // cout, &lt;&lt;
#include &lt;sstream&gt;      // istringstream(), ostringstream(), &lt;&lt;, &gt;&gt;
#include &lt;string&gt;

using namespace std;

//----&lt; display titles &gt;---------------------------------------

void title(const char *t, char ul = '-', ostream &amp;out = cout) {

  int len = strlen(t) + 2;
  string line(len,ul);
  if(ul == '=')
    out &lt;&lt; "\n " &lt;&lt; line;
  out &lt;&lt; "\n  " &lt;&lt; t
      &lt;&lt; "\n " &lt;&lt; line &lt;&lt; endl;
}

//----&lt; begin demonstration &gt;----------------------------------

void main() {

  ///////////////////////////////////////////////////
  title("Demonstrating stringstream operations",'=');
  ///////////////////////////////////////////////////

  title("reading from istringstream");
  /////////////////////////////

  istringstream source("15 3.1415927 Now is the hour");
  cout &lt;&lt; "\n  " &lt;&lt; source.str() &lt;&lt; endl;

  title("writing to ostringstream");
  ////////////////////////////////////

  ostringstream destin;
  destin &lt;&lt; source.str();
  stringbuf *pStringBuf = destin.rdbuf();
  cout &lt;&lt; "\n--source-----" &lt;&lt; source.str();
  cout &lt;&lt; "\n--destin-----" &lt;&lt; destin.str();
  cout &lt;&lt; "\n--stringBuf--" &lt;&lt; pStringBuf-&gt;str() &lt;&lt; endl;

//

  title("writing to custom buffer no longer supported in ostringstream");
  ///////////////////////////////////////////////////////////////////////

  title("parsing input buffer");
  //////////////////////////////

  int i;
  const int bufSize=50; 
  double d; 
  char savebuf[bufSize];
  
  source.seekg(0);
  source &gt;&gt; i &gt;&gt; d;
  cout &lt;&lt; endl;
  cout &lt;&lt; "  i = " &lt;&lt; i &lt;&lt; endl;
  cout &lt;&lt; "  d = " &lt;&lt; d &lt;&lt; endl;
  int j;

  // The following operation is dangerous!
  //   extraction writes whole word into buffer,
  //   even if word size is larger than buffer

  for(j=0; j&lt;4; j++) {
    source &gt;&gt; savebuf;
    cout &lt;&lt; "  savebuf = " &lt;&lt; savebuf &lt;&lt; endl;
  }

  // Here is a saver, though less convenient way
  // to read strings from a stream

  title("safe parsing using destination string");
  ///////////////////////////////////////////////

  source.clear();
  source.seekg(0);
  string temp;
  while(source.good()) {
    source &gt;&gt; temp;
    cout &lt;&lt; "\n  " &lt;&lt; temp;
  }
  cout &lt;&lt; "\n\n";

  title("char-by-char parsing");
  //////////////////////////////

  source.clear();
  source.seekg(0);
  temp = "";
  while(source.good()) {
    char ch = source.get();
    if(!isspace(ch))
      temp += ch;
    else if(temp.size() &gt; 0) {
      cout &lt;&lt; "\n  " &lt;&lt; temp.c_str();
      temp = "";
    }
  }
  if(temp.size() &gt; 0)
    cout &lt;&lt; "\n  " &lt;&lt; temp.c_str();
  cout &lt;&lt; "\n\n";
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output</defn-head>
            <defn-code style="font-size:0.7rem;">
 =======================================
  Demonstrating stringstream operations
 =======================================

  reading from istringstream
 ----------------------------

  15 3.1415927 Now is the hour

  writing to ostringstream
 --------------------------

--source-----15 3.1415927 Now is the hour
--destin-----15 3.1415927 Now is the hour
--stringBuf--15 3.1415927 Now is the hour

  parsing input buffer
 ----------------------

  i = 15
  d = 3.14159
  savebuf = Now
  savebuf = is
  savebuf = the
  savebuf = hour

  safe parsing using destination string
 ---------------------------------------

  15
  3.1415927
  Now
  is
  the
  hour

  char-by-char parsing
 ----------------------

  15
  3.1415927
  Now
  is
  the
  hour 
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
    <div class="clear"></div>
    <a id="stl"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8.2</num-item1><num-item4>STL:</num-item4>
    </num-cont>
    <a id="filesystem"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8.3</num-item1><num-item4>FileSystem:</num-item4>
    </num-cont>

    <a id="threads"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8.4</num-item1><num-item4>Threads:</num-item4>
    </num-cont>

    <a id="sockets"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8.5</num-item1><num-item4>Sockets:</num-item4>
    </num-cont>

    <a id="xmldoc"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8.6</num-item1><num-item4>XmlDocument:</num-item4>
    </num-cont>

    <a id="Boost"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8.7</num-item1><num-item4>Boost:</num-item4>
    </num-cont>
    <num-cont>
      <num-item1>8.71</num-item1><num-item4>Boost::Asio:</num-item4>
    </num-cont>

    <a id="json"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8.8</num-item1><num-item4>JSON:</num-item4>
    </num-cont>

    <a id="thirdparty"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8.9</num-item1><num-item4>Survey of Third-Party Libraries:</num-item4>
    </num-cont>

    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8.10</num-item1><num-item4>References:</num-item4>
    </num-cont>
    <indent-block>
      <a href="https://cplusplus.github.io/networking-ts/draft.pdf">C++ Networking TS draft</a><br />
      <a href="https://blog.ybalrid.info/2018/12/no-nonsense-networking-for-c-introducing-kissnet-a-k-i-s-s-socket-library/">KissNet</a><br />
      <a href="https://github.com/boostcon/cppnow_presentations_2018/blob/master/05-08-2018_tuesday/smart_output_iterators__jonathan_boccara__cppnow_05082018.pdf">Smart Output Iterators - Jonathan Boccara</a><br />
      <a href="https://www.fluentcpp.com/2019/08/13/smart-output-iterators-become-pipes/">Smart output iterators become pipes - Jonathan Boccara</a>
      <a href="https://www.youtube.com/watch?v=qH6sSOr-yk8">C++ Seasoning (video) - Sean Parent - Going Native 2013</a><br />
      <a href="https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf">string formatting (see answer 15) - stackoverflow</a><br />
    </indent-block>
    <spacer-25></spacer-25>
    <spacer-25></spacer-25>
    <spacer-25></spacer-25>
    <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->
  </bb-55>
    <info-bar></info-bar>
</body>
</html>