<!DOCTYPE html>
<html>
<!--
  RustStory_Data.html
-->
<head>
  <title>RustStory Structures</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--<link rel="stylesheet" href="css/StylesTemplate.css" />-->
  <!--<link rel="stylesheet" href="css/StylesDefault.css" />-->
  <!--<link rel="stylesheet" href="css/StylesBrownTheme.css" />-->
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeRust.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <!--<script src="js/ScriptsPageFrameDefaults.js"></script>-->
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesRustStory.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <!-- No need for Pages script for pages with no next or prev pages -->
  <!--<script src="js/ScriptsPageFramePages.js"></script>-->
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding: 0.75em 1.5em;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width: 50em;
    }

    #github h2 {
      margin-top: 0.75em;
    }

    #github ol.tight li {
      margin-top: 0.15em;
      margin-bottom: 0.15em;
    }

    #github h3 {
      margin-top: 1.25em;
    }

    #github h4 {
      margin-top: 1em;
    }

    #github header h3 {
      margin-top: 0em;
      margin-left: 1em;
    }
  </style>
<!--   <script>
    window.onmessage = function () {
      // alert('msg received');
      bottomMenu.sections();
    }
  </script>
 --></head>
<body id="github" onload="initialize()">

  <a id="Next" href="RustStory_Libraries.html">Next</a>
  <a id="Prev" href="RustStory_Operations.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="page">RustStory Structures</div>
      <div id="modified">9/21/2022</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 4. - Rust Structures</h1>
      <h3 id="subtitle">Example libraries, tests, and documentation</h3>
    </hgroup>
  </header>

   <!--<toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyHlpMenu.help()" style="color:#fefefa;">Help</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:#fefefa;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Chaps</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_Libraries.html">Libraries</a><br />
       <a href="RustStory_CodeIndex.html">Code Index</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#logger">Logger</a>, 
       <a href="#cmdlnproc">CmdLnProc</a>, <a href="#dirnav">DirNav</a>, 
       <a href="#epilogue">Epilogue</a>, <a href="#refs">References</a>
     </rt-b>
   </toc-b>-->
    <div id="hlp" style="display:none;">
    </div>


    <a id="prologue"></a>
    <h3>4.0 Prologue</h3>
    <t-b>
      Previous chapters have provided a lot of technical details about the Rust programming language.  In this chapter we will bring all that
      together by presenting a few libraries: Logger, CmdLineParser, and DirNavigator.
    </t-b>
    <t-b>
      For the first library, <n-s>Logger</n-s> we will explore library structure, its implementation, testing, and documentation.  The Rust tool cargo,
      in concert with the rustc compiler, provide an excellent environment for building libraries and applications, with detailed testing and
      documentation.
    </t-b>
    <t-b>
      This chapter is a good place to start exploring that.
    </t-b>
    <a id="logger"></a>
    <h3>4.1 Logger Library</h3>
    <div style="width:calc(100vw - 9em);">
      <photosizer-block src="Pictures/RustLoggerOutput.JPG" width="300" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
        display: inline-block;
        font-weight: bold;
        font-family: 'Comic Sans MS, Tahoma';
        background-color: #ddd;
        width: 100%;
        padding: 5px 0px;
      ">
          Fig 1. Rust Logger Output
        </span>
      </photosizer-block>
    </div>
    <t-b>
      The Logger Library provides a light-weight logger, useful for debugging and demonstration.
      Library development started with <span>specifications</span>:
      <indent-block class="pad5">
        <ol class="tight">
          <li>
            Support simultaneous writes to console and a file.
          </li>
          <li>
            Provide file open and close operations and enable or disable
            console output.
          </li>
          <li>
            Write text messages.
          </li>
          <li>
            Optionally prepend a message with a date-time stamp, using local system time.
          </li>
        </ol>
      </indent-block>
    </t-b>
    <t-b>
      Implementation starts with a struct:
    </t-b>
    <t-b>
      <div class="left" style="padding:5px 25px">
        <defn-block>
          <defn-head>
            Logger Struct
          </defn-head>
          <defn-code>
pub struct Logger {
    fl:Option&lt;File&gt;,
    console:bool,
}
          </defn-code>
        </defn-block>
      </div>
    </t-b>
    <t-b>
      Logger has two data members: <c-s>fl</c-s> and <c-s>console</c-s>. <c-s>fl</c-s> is an <c-s>Option</c-s> enumeration that either holds a <c-s>File</c-s>
      instance as <c-s>Some(f:File)</c-s> or <c-s>None</c-s>.  When you create a logger with <c-s>Logger::new()</c-s>, 
      <c-s>fl</c-s> is <c-s>None</c-s>, so the logger is not attached to a file.
    </t-b>
    <t-b>
      The member <c-s>console</c-s> is a boolean that determines whether a write sends its output to the console.  <c-s>Logger::new()</c-s> sets 
      <c-s>console</c-s> to <c-s>true</c-s>, so the logger will, by default, write to the console. To do anything useful, we need some functions 
      that operate on that member data.  Note
      that the Logger structure is public, but its data members are not, so only Logger methods can alter their state.
    </t-b>
    <t-b>
      Logger has nine methods: 
      <div class="pad5 indent">
        <c-s>new()</c-s>, <c-s>init(f:File, con:bool)</c-s>,
        <c-s>console(con:bool)</c-s>, <c-s>file(f:file)</c-s>, <c-s>opt(f:Option&lt;File&gt;)</c-s>,
        <c-s>open(file_name:&str)</c-s>, <c-s>ts_write(s:&str)</c-s>, <c-s>write(s:&str)</c-s>,
        and <c-s>close()</c-s>
      </div>
      <c-s>new</c-s> and <c-s>init</c-s> are creational methods, <c-s>console</c-s>, <c-s>file</c-s>, and <c-s>opt</c-s> mutate the logger state,
      <c-s>open</c-s> and <c-s>close</c-s> manage the state of logger&apos;s file member, and <c-s>write</c-s> and <c-s>ts_write</c-s> handle 
      logger&apos;s main business, writing to the console and/or file.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Logger Methods and Functions:</summary>
          <defn-outerblock>
          <defn-block>
            <defn-head>Logger Methods:</defn-head>
            <defn-code>
#[allow(dead_code)]
impl Logger {
    /*-- create default logger --*/
    pub fn new() -&gt; Self {
        Self { fl:None, console:true, }
    }
    /*-- create initialized logger --*/
    pub fn init(f:File, con:bool) -&gt; Self {
        Self { fl:Some(f), console:con, }
    }
    /*-- enable | disable writing to console --*/
    pub fn console(&amp;mut self, con:bool) {
        self.console = con
    }
    /*-- attach file --*/
    pub fn file(&amp;mut self, f:File) {
        self.fl = Some(f);
    }
    /*-- attach Option&lt;File&gt; --*/
    pub fn opt(&amp;mut self, f:Option&lt;File&gt;) {
        self.fl = f;
    }
    /*-- attempt to open logger file --*/
    pub fn open(&amp;mut self, s:&amp;str) -&gt; bool {
        use std::fs::OpenOptions;
        self.fl = OpenOptions::new()
                .write(true)
                .create(true)
                .append(true)
                .open(s).ok();
        if self.fl.is_some() {
            return true;
        }
        false
    }
    /*-- write log entry with date-time stamp */
    /*-- can be chained                       */
    pub fn ts_write(&amp;mut self, s:&amp;str) 
          -&gt; &amp;mut Self {
        
        let now: DateTime&lt;Local&gt; = Local::now();
        /* format DateTime string */
        let mut now_str = 
          format!("\n  {}", now.to_rfc2822());
        /* remove trailing -0400 */
        now_str.truncate(now_str.len() - 6);

        let _ = Logger::write(self, &amp;now_str);
        let rslt = Logger::write(self, s);
        rslt
    }
    /*-- write log entry, can be chained --*/
    pub fn write(&amp;mut self, s:&amp;str) 
          -&gt; &amp;mut Self {
        if self.console {
            print!("{}", s);
        }
        if let Some(ref mut f) = self.fl {
            let rslt = f.write(s.as_bytes());
            match rslt {
                Ok(_) =&gt; {},
                Err(_) =&gt; 
                  print!("\n  file write failed\n"),
            }
        }
        self
    }
    /*-- close log file */
    pub fn close(&amp;mut self) {
        self.fl = None;
    }
}
#[derive(PartialEq)]
#[allow(dead_code)]
pub enum OpenMode { Truncate, Append }
#[allow(dead_code)]
/*-----------------------------------------
  Helper functions
*/
/*-- attempt to open file by name --*/
pub fn open_file(s:&amp;str, mode:OpenMode) 
      -&gt; Option&lt;File&gt; {
    let fl:Option&lt;File&gt;;
    use std::fs::OpenOptions;
    if mode == OpenMode::Truncate {
        fl = OpenOptions::new()
             .write(true)
             .truncate(true)
             .open(s).ok();
    }
    else {
        fl = OpenOptions::new()
             .write(true)
             .create(true)
             .append(true)
             .open(s).ok();
    }
    fl
}
/*-- attempt to remove file by name --*/
pub fn remove_file(s:&amp;str) -&gt; bool {
    let rslt = std::fs::remove_file(s);
    rslt.is_ok()
}
/*-- does file contain a string? --*/
pub fn file_contains(fl:&amp;str, ts:&amp;str) 
      -&gt; bool {
    let contents = std::fs::read_to_string(fl);
    let mut s = "".to_string();
    if contents.is_ok() {
        s = contents.unwrap();
    }
    s.contains(ts)
}
/*-- display contents of named file --*/
pub fn file_contents(fl:&amp;str) {
    let contents = std::fs::read_to_string(fl);
     if contents.is_ok() {
        let s = contents.unwrap();
        print!("{}", s);
     }
     else {
         print!("\n  no contents");
     }
}
/*-- does file exist? --*/
pub fn file_exists(s:&amp;str) -&gt; bool {
    let path = Path::new(s);
    return path.exists();
}

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Explanations:</defn-head>
            <defn-body style="width:25em;">
              <t-b>
                Methods are defined in one or more impl blocks.
                Each block contains method definitions, as you see in the right panel.
              </t-b>
              <t-b>
                The type Self is the type of the Structure, e.g., Logger. The variable self is a reference
                to the instance on which the method was called.
              </t-b>
              <t-b>
                The method new() returns an instance of the type Self, e.g., the logger we are creating with
                this method. It only has one line: <c-s>Self { fl:None, console:true, }</c-s>. Since there
                is no semicolon following the closing brace in this line, this is an expression, and any scope has the value
                of its last expression, so we are returning <c-s>Logger { fl:None, console:true }</c-s>.
              </t-b>
              <t-b>
                Many of the methods are relatively simple, but the <c-s>write</c-s> method has some peculiar code, e.g.:
                <indent-block class="pad5">
                  <c-s>if let Some(ref&nbsp;&nbsp;mut&nbsp;&nbsp;f) = self.fl { ... }</c-s>
                </indent-block>
                The &quot;=&quot; operator is not an assignment.  It is a matching operator. The term &quot;<c-s>Some(ref&nbsp;&nbsp;mut&nbsp;&nbsp;f)</c-s>
                is the <c-s>Option&lt;T&gt;::Some(t:T)</c-s> holding a mutable reference to a File instance.  So, we are matching
                <c-s>self.fl</c-s> with a pattern that requires the <c-s>Some</c-s> option rather than <c-s>None</c-s>.
                If the match is satisfied, e.g., the logger has a file reference, then we write to the file.
              </t-b>
              <t-b>
                The remainder of the function
                is a test to see if the user elected to use the console, and if so, writes to the console.  So, if both conditions match, the
                logger writes to both the console and the log file.
              </t-b>
              <t-b>
                The <c-s>ts_write</c-s> method uses code from the DateTime crate to generate the local system date and time, format it, and then write
                using the <c-s>write</c-s> method. It then repeats with its string argument.
              </t-b>
            </defn-body>
          </defn-block>
          </defn-outerblock>
        </details>
      </div>
    </t-b>
    <t-b class="mbz">
      Both <c-s>write</c-s> and <c-s>ts_write</c-s> return <c-s>&mut Self</c-s>, so they can be chained, e.g.,
      <c-s>l.write("first).write(", second");</c-s>
    </t-b>
    <t-b class="mbz">
      Logger also contains functions:
      <div class="pad5 indent">
        <c-s>open_file(file_name, open_mode)</c-s>, <c-s>remove_file(file_name)</c-s>,
        <c-s>file_contains(file_name, search_text)</c-s>, <c-s>file_contents(file_name)</c-s>, 
        and <c-s>file_exists(file_name)</c-s>.
      </div>
      These are helper files used during logger testing.  They will probably be useful for testing other projects.
    </t-b>
    <div class="clear"></div>
    <div style="height:0.25em;"></div>
    <a id="unittest"></a>
    <h4>4.1.1 Library Unit Tests</h4>
    <t-b>
      when cargo creates a library project with <c-s>cargo new --lib</c-s>, it creates a src directory containing a <c-s>lib.rs</c-s> 
      file.  At the end of the file you will find a #[cfg(test)] directive that defines one or more tests to run.
    </t-b>
    <t-b>
      Each test starts with a #[test] directive containing a single test function.  The test function is expected to have one or more
      assertions.  The test passes if all assertions are satisfied, otherwise it fails.
    </t-b>
    <t-b>
      You run unit tests with the cargo command:
      <indent-block class="pad5">
        <c-s>cargo test</c-s>
      </indent-block>
    </t-b>
    <t-b>
      The details dropdown, below, lists all of the unit tests for the Logger library. 
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Logger Unit Tests:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Unit Test Code:</defn-head>
              <defn-code>
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_open_file() {
        let stest = "test_open.txt";
        let mut l = Logger::new();
        l.open(stest);
        open_file(stest, OpenMode::Truncate);
        assert_eq!(file_exists(stest),true);
        remove_file(stest);
        assert_eq!(file_exists(stest),false);
    }
    #[test]
    fn test_file_contains() {
        let stest = "test_contains.txt";
        let mut l = Logger::new();
        l.open(stest);
        assert_eq!(l.fl.is_some(), true);
        l.write("test contents with a short string");
        l.close();
        assert_eq!(file_exists(stest), true);
        assert_eq!(file_contains(stest, "a short"), true);
        remove_file(stest);
        assert_eq!(file_exists(stest),false);
    }
    #[test]
    fn test_remove_file() {
        let stest = "test_remove";
        open_file(stest, OpenMode::Truncate);
        remove_file(stest);
        assert_eq!(file_exists(stest),false);
    }
    #[test]
    fn test_file_exists() {
        assert_eq!(file_exists("foobar.fee"),false);
    }
    #[test]
    fn test_new() {
        let stest = "test_new";
        let mut l = Logger::new();
        l.open(stest);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_init() {
        let stest = "test_new";
        let opt = open_file(stest, OpenMode::Append);
        let mut l = Logger::init(opt.unwrap(), false);
        l.open(stest);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_console() {
        let mut l = Logger::new();
        assert_eq!(l.console == true, true);
        l.console(false);
        assert_eq!(l.console == false, true);
    }
    #[test]
    fn test_file() {
        let mut l = Logger::new();
        let stest = "test_file";
        l.file(open_file(stest, OpenMode::Append).unwrap());
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_opt() {
        let mut l = Logger::new();
        let stest = "test_file";
        let file_opt = open_file(stest, OpenMode::Append);
        l.opt(file_opt);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_open() {
        let mut l = Logger::new();
        let stest = "test_open";
        l.open(stest);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_write() {
        let mut l = Logger::new();
        let stest = "test_write";
        l.open(stest);
        let stxt = "abc 012 xyz 789";
        let _ = l.write(stxt);
        assert_eq!(file_contains(stest, stxt), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_ts_write() {
        let mut l = Logger::new();
        let stest = "test_ts_write";
        l.open(stest);
        let sdt = "2020";  // change if year != 2020
        let stxt = "abc 012 xyz 789";
        let _ = l.ts_write(stxt);
        assert_eq!(file_contains(stest,sdt), true);
        assert_eq!(file_contains(stest, stxt), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_close() {
        let mut l = Logger::new();
        let stest = "test_close.txt";
        l.open(stest);
        assert_eq!(l.fl.is_some(), true);
        l.close();
        assert_eq!(l.fl.is_none(), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
C:\github\JimFawcett\RustBasicDemos\logger>
cargo test

   // compiler output elided

running 13 tests
test tests::test_console ... ok
test tests::test_file_exists ... ok
test tests::test_new ... ok
test tests::test_file ... ok
test tests::test_close ... ok
test tests::test_open ... ok
test tests::test_remove_file ... ok
test tests::test_file_contains ... ok
test tests::test_open_file ... ok
test tests::test_opt ... ok
test tests::test_init ... ok
test tests::test_write ... ok
test tests::test_ts_write ... ok

test result: ok. 
13 passed; 
0 failed; 
0 ignored; 
0 measured; 
0 filtered out    
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      Since cargo sets up the unit test configuration code for each library crate that it creates, 
      it is quite easy to write unit tests as we write functions.  When development is finished we
      have a robust test sequence that can be run any time maintenance changes are made to the library.
    </t-b>

    <a id="examples"></a>
    <h4>4.1.2 Library Examples</h4>
    <t-b>
      If you create an examples directory as a sibling of src, then you can put code there with a main function that
      exercises your library, perhaps to demonstrate its operations for new users.  If you do that then
      <indent-block class="pad5">
        <c-s>cargo run --example test1</c-s>
      </indent-block>
        will trigger cargo to attempt to build a binary crate from
        test1.rs and run its executable.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Examples:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Examples/test1.rs</defn-head>
              <defn-code>
  Demonstrating Logger
 ======================

  deleted previous log file
  writing to "Log.txt"
 ----------------------
  Thu, 19 Mar 2020 18:18:59
  starting log
  first entry, second entry, third entry

  contents of log.txt
 ---------------------
  Thu, 19 Mar 2020 18:18:59
  starting log
  first entry, second entry, third entry

  closing then reopening log
 ----------------------------
  Thu, 19 Mar 2020 18:18:59
  reopening log
  after reopen
  found "first entry" in "log.txt"

  That's all Folks!

              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
>cargo run --example test1

    // compiler output elided

  Demonstrating Logger
 ======================

  deleted previous log file
  writing to "Log.txt"
 ----------------------
  Wed, 18 Mar 2020 14:37:40
  starting log
  first entry, second entry, third entry
  Wed, 18 Mar 2020 14:37:40
  reopening log
  after reopen
  contents = 
  Wed, 18 Mar 2020 14:37:40
  starting log
  first entry, second entry, third entry
  Wed, 18 Mar 2020 14:37:40
  reopening log
  after reopen
  found first entry in log.txt

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b class="mbz">
      You can have any number of example files in the examples directory, each with a main function that demonstrates some
      particular aspect of your library. You can also supply examples suitable for developer&apos;s with different levels
      of expertise with Rust.
    </t-b>

    <a id="docs"></a>
    <h4>4.1.3 Library Documentation</h4>
    <t-b>
      <div style="width:calc(100vw - 9em);">
        <photosizer-block src="Pictures/RustDoc.JPG" width="600" class="photoSizerBlock right clear">
          <span style="font-family:'Comic Sans MS';">Figure 1. Logger Documentation</span>
        </photosizer-block>

      </div>
    </t-b>
    <t-b>
      You can endow your own libraries with the same kind of documentation provided for the std libraries.
      If you put comments above each method or function with the format:
      <indent-block class="pad5">
        <defn-code>
/// ```
/// let mut logr = Logger::new();
///
/// sets fl:None, console:true;
/// ```
pub fn new() -> Self {
    Self { fl:None, console:true, }
}
        </defn-code>
      </indent-block>
      That places your comments in the document below the function, as shown in Figure 1.  
    </t-b>
    <t-b>
      To create documentation, simply issue the cargo command:
      <indent-block class="pad5">
        <c-s>cargo doc --document-private-items</c-s>
      </indent-block>
      If you don&apos;t want to display private items, then leave off that option.
    </t-b>
    <t-b>
      The <c-s>doc</c-s> command builds documentation and deposites it in your <n-s>Target</n-s> folder.
      This creates documentation, not only for your code, but also for code it depends upon.
    </t-b>
    <t-b>
      Be aware that if you issue a <c-s>cargo clean</c-s> command that will delete all the
      documentation because clean deletes the <n-s>Target</n-s> folder.
    </t-b>
    <t-b>
      One more thing: if you put documentation comments in your code, you need to set 
      <c-s>doctest = false</c-s> in a <c-s>[lib]</c-s> section of your <c-s>cargo.toml</c-s> file.
      If you don&apos;t do this, the compiler attempts to compile your comments and emits a lot of
      errors and warnings.
    </t-b>
    <div>
      <details>
        <summary class="labelStyle lightItem">Cargo.toml</summary>
      <t-b>
        The <c-s>[lib]</c-s> section needs to come before <c-s>[dependencies]</c-s>
      </t-b>
      <t-b>
        <div>
          <defn-block>
            <defn-head>Logger Cargo File</defn-head>
            <defn-code>
[package]
name = "logger"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>
  "]
  edition = "2018"

  # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

  [lib]
  # prevents rustc from attempting to compile doc comments
  doctest = false

  [dependencies]
  chrono = "0.2.16"
  display = { path = "../display" }
            </defn-code>
          </defn-block>
        </div>
      </t-b>
        </details>
    </div>
    <t-b>
      This completes our discussion of the <n-s>Logger</n-s> project.  You can find the code and discussion
      in <a href="RustLogger.html">RustLogger</a> repository.
    </t-b>

    <a id="cmdlnproc"></a>
    <h3>4.2 CmdLine Parser Library</h3>
    <div style="width:calc(100vw - 9em);">
      <photosizer-block src="Pictures/RustCmdLineParserOutput.JPG" width="600" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
        display: inline-block;
        font-weight: bold;
        font-family: 'Comic Sans MS, Tahoma';
        background-color: #ddd;
        width: 100%;
        padding: 5px 0px;
      ">
          Fig 1. CmdLineParser Output
        </span>
      </photosizer-block>
    </div>
    <indent-blocks>
      RustCmdLine is a facility for parsing command line arguments.  Here&apos;s a sample:
      <div class="indent pad5">
        <c-s>/P "." /p "rs,txt" /s /H /r "abc"</c-s>
      </div>
      where:
      <div class="indent pad5">
        <c-s>/P "."&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- path<br />
        /p "rs,txt" - file patterns<br />
        /s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- recurse through directory tree rooted at path<br />
        /H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- hide directories that don&apos;t contain target files<br />
        /r "abc"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- regular expression</c-s>
      </div>
      <spacer-15></spacer-15>
      The intent is that a program creates an instance of CmdLineParser, uses that to parse its command line, then
      passes it to any code that needs to know about a pattern or an option.
    </indent-blocks>
    <h4>Design:</h4>
    <indent-blocks>
      <t-b>
        This library contains a single user-defined type: CmdLineParser.
        <s-5px></s-5px>
        <t-b class="left">
          <div style="padding-right:1em;">
            <defn-block>
              <defn-head style="margin-top:0px;">CmdLineParser Struct</defn-head>
              <defn-code>
pub struct CmdLineParse {
  opt_map : Options,
  patterns : CmdLinePatterns,
  help_str : String,
}
              </defn-code>
            </defn-block>
          </div>
        </t-b>
        <t-b>
          The opt_map field is a HashMap&lt;K, V&gt; of key-value pairs, where each key is a command line
          option; that is, a character from the command line that is preceeded by a '/' character.
          If an option, o, is succeeded by a non-option string, that becomes the value. If there is no value,
          then the opt_map contains &quot;true&quot; for the value of the key o.
        </t-b>
        <t-b>
          The field, patterns, is a vector of Strings where each string is expected to be a file extension,
          e.g., rs.  Note that using *.rs will not work as expected for applications like RustTextFinder.
        </t-b>
        <t-b>
          It is expected that applications using CmdLineParser will process only files with the specified
          extensions.  If none are supplied, then the application processes all files it encounters.
        </t-b>
        <t-b>
          The field, help_str, is a String containing information to supply to the user in response to an
          option /h.  In this library, the string contains the defaults, cited above, but an application
          can change the string with <c-s>replace_help(hs&str)</c-s>.
        </t-b>
      </t-b>
      <div class="clear"></div>
      <a id="parmethods"></a>
      <h4>4.2.1 CmdLine Parser Methods</h4>
      <t-b>
        CmdLineParser implements the following methods and functions:
        <div class="indent">
          <ol class="tight">
            <li>
              <strong><c-s>new() -> Self</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create new <c-s>CmdLineParser</c-s> which has an options hashmap, patterns vector, and help string.
              </div>
            </li>
            <li>
              <strong><c-s>parse(&self)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Builds internal options hashmap and patterns vector.
              </div>
            </li>
            <li>
              <strong><c-s>path(&self) -> String</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Return value of relative root path, held in options map.
              </div>
            </li>
            <li>
              <strong><c-s>abs_path(&self) -> String</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Return value of absolute root path, from canonicalized relative path.
              </div>
            </li>
            <li>
              <strong><c-s>set_path(&mut self, p:&str)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Replaces value of root path, held in options map.
              </div>
            </li>
            <li>
              <strong><c-s>set_regex(&mut self, re:&str)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Replaces value of regex string, held in options map.
              </div>
            </li>
            <li>
              <strong><c-s>get_regex(&mut self) -> &str</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Retrieves value of regex string, held in options map.
              </div>
            </li>
            <li>
              <strong><c-s>default_options(&mut self)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Sets values of some of the options in options map.
              </div>
            </li>
            <li>
              <strong><c-s>contains_option(&self, opt:char) -> bool</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                returns true if options map contains key opt, else returns false.
              </div>
            </li>
            <li>
              <strong><c-s>add_option(&mut self, opt:char, val:&str)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Inserts option in options hashmap, adding key if it does not exist, else overriding previous value.
              </div>
            </li>
            <li>
              <strong><c-s>value(&self, opt:char) -> &str</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Inserts option in options hashmap, adding key if it does not exist, else overriding previous value.
              </div>
            </li>
            <li>
              <strong><c-s>add_pattern(&mut self, patt:&str) -> &mut self</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Inserts patt into patterns vector.  Method can be chained.
              </div>
            </li>
            <li>
              <strong><c-s>patterns(&self) -> &CmdLinePatterns</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Returns reference to vector of patterns.
              </div>
            </li>
            <li>
              <strong><c-s>options(&self) -> &Options</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Returns reference to hashmap of options.
              </div>
            </li>
            <li>
              <strong><c-s>help(&self) -> &str</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Returns default help string.
              </div>
            </li>
            <li>
              <strong><c-s>replace_help(&mut self, hs:&str)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Replace internal help string.
              </div>
            </li>
          </ol>
        </div>
      </t-b>
      <t-b>
        Code for CmdLineParser library and a demonstration program are provided in the dropdown, below.
      </t-b>
      <t-b>
        <div>
          <details>
            <summary class="labelStyle darkItem">CmdLineParser Implementation</summary>
            <defn-outerBlock>
              <defn-block>
                <defn-head>CmdLineParser lib.rs</defn-head>
                <defn-code>
/////////////////////////////////////////////////////////////
// rust_cmd_line::lib.rs                                   //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 19 Apr 2020  //
/////////////////////////////////////////////////////////////

use std::env::{args};
use std::collections::HashMap;
use std::fs::*;

/////////////////////////////////////////////////////////////
// sample command line with options
//-----------------------------------------------------------
// /P "." /p "rs,txt" /s [true] /r "abc" /h [true] /H [true]
//
// P - path in either absolute or relative form
// p - pattern, a file extension indicating file to process
// s - recurse directory tree rooted at P
// r - regular expression
// H - hide directories that don't contain any target files
// h - help: display this message
// custom option:
// /x [v] - x is application specific option which may
//          have value, v
// Note:
// Any attribute that has no value on command line will
// have value "true" in option map
/////////////////////////////////////////////////////////////
// CmdLineParse methods
//-----------------------------------------------------------
// new() -&gt; CmdLineParse
// parse(&amp;self)
// contains_option(&amp;self, opt: char) -&gt; bool
// value(&amp;self, char opt) -&gt; &amp;str
// options(&amp;self) -&gt; &amp;HashMap&lt;char, String&gt;
// - defaults are created with default_options():
//   - /P "."    - root search path is current directory
//   - /s "true" - recurse
//   - /r "."    - match all text
//   - /H "true" - hide unused directories
//   - no patterns are equivalent to all files
// path(&amp;self) -&gt; String
// abs_path(&amp;self) -&gt; String
// set_path(&amp;self, p:&amp;str)
// patterns(&amp;self) -&gt; &amp;Vec&lt;String&gt;
// add_pattern(&amp;mut self, p:&amp;str) -&gt; &amp;mut self
// set_regex(&amp;mut self, re:&amp;str)
// get_regex(&amp;self) -&gt; &amp;str
// help(&amp;self) -&gt; String
// replace_help(&amp;mut self, &amp;str) -&gt; String

/// display command line arguments
pub fn show_cmd_line() {
    print!("\n  {:?}\n  ", args().next());
    for arg in args().skip(1) {
        print!("{:?} ", arg)
    }
}

pub type Options = HashMap&lt;char, String&gt;;
pub type CmdLinePatterns = Vec&lt;String&gt;;

/// Parses command line into options and patterns
#[derive(Debug, Default)]
pub struct CmdLineParse {
    opt_map : Options,
    patterns : CmdLinePatterns,
    help_str : String,
}
impl CmdLineParse {
    /// create new instance of parser
    pub fn new() -&gt; Self {
        let help = CmdLineParse::help_txt();
        Self {
            opt_map: Options::default(),
            patterns: CmdLinePatterns::new(),
            help_str: help,
        }
    }
    /// returns string with command line arguments example
    fn help_txt() -&gt; String {
        let mut str =
        "\n  Help:\n  Options: /P . /p \"rs,txt\"".to_string();  
        str.push_str(" /s /r \"abc\" /H /h"); 
        str
    }
    /// does the command line argument start with '/'
    fn is_opt(&amp;self, s:&amp;str) -&gt; bool {
        let bytes = s.as_bytes();
        bytes[0] as char == '/'
    }
    /// returns path string with default value "."
    pub fn path(&amp;self) -&gt; String {
        if self.contains_option('P') {
            self.opt_map[&amp;'P'].clone()
        }
        else {
            ".".to_string()
        }
    }

    /// replace Win path separator "\\" with Linux "/"
    /// - use only with absolute paths for Windows 
    fn replace_sep(path: &amp;str) -&gt; String {
        let mut rtn = path.to_string();
        if rtn.contains("\\") {
            rtn = rtn.replace("\\", "/");
            rtn = rtn.chars().skip(4).collect();
        }
        rtn
    }
    /// convert relative to absolute path
    pub fn abs_path(&amp;self) -&gt; String {
        let abs = std::path::PathBuf::from(self.path());
        let rslt = canonicalize(&amp;abs);
        match rslt {
            Ok(path_buf) =&gt; {
                // print!("\n--path_buf = {:?}",path_buf);
                let ap = path_buf.to_string_lossy().to_string();
                let ap = CmdLineParse::replace_sep(&amp;ap);
                // print!("\n--abs_path = {:?}",ap);
                ap
            }
            Err(error) =&gt; error.to_string()
        }
    }
    /// set new root path
    pub fn set_path(&amp;mut self, p:&amp;str) {
        self.opt_map.insert('P', p.to_string());
    }
    /// set new regex string for matching
    pub fn set_regex(&amp;mut self, re:&amp;str) {
        self.opt_map.insert('r', re.to_string());
    }
    /// return current regex string
    pub fn get_regex(&amp;self) -&gt; &amp;str {
        let re_opt = self.opt_map.get(&amp;'r');
        match re_opt {
            Some(value) =&gt; value,
            None =&gt; ".",
        }
    }
    /// commonly used default options
    pub fn default_options(&amp;mut self) {
        self.opt_map.insert('P', ".".to_string());
        self.opt_map.insert('s', "true".to_string());  
        self.opt_map.insert('r', ".".to_string());     
        self.opt_map.insert('H', "true".to_string());  
    }
    /// does options contain opt char? 
    pub fn contains_option(&amp;self, opt:char) -&gt; bool {
        self.opt_map.contains_key(&amp;opt)
    }
    /// insert {o,v} if o key doesn't exist, else overwrite v
    pub fn add_option(&amp;mut self, o:char, v:&amp;str) {
        self.opt_map.insert(o, v.to_string());
    }
    /// return option value
    pub fn value(&amp;self, opt:char) -&gt; &amp;str {
        &amp;self.opt_map[&amp;opt]
    }
    /// add file ext (with no "*.")
    pub fn add_pattern(&amp;mut self, p:&amp;str)
           -&gt; &amp;mut Self {
        let s = String::from(p);
        if !self.patterns.contains(&amp;s) {
            self.patterns.push(s);
        }
        self
    }
    /// returns non-mutable reference to patterns
    pub fn patterns(&amp;self) -&gt; &amp;CmdLinePatterns {
        &amp;self.patterns
    }
    /// returns non-mutable reference to options
    pub fn options(&amp; self) -&gt; &amp;Options {
        &amp;self.opt_map
    }
    /// return help string
    pub fn help(&amp;self) -&gt; &amp;str {
        &amp;self.help_str
    }
    /// replace help string
    pub fn replace_help(&amp;mut self, s:&amp;str) {
        self.help_str = s.to_string();
    }
    /// parse command line arguments, provided by env()
    pub fn parse(&amp;mut self) {
    
        let cl_args:Vec&lt;String&gt; = args().collect();
        let end = cl_args.len();
        for i in 1..end {
            if self.is_opt(&amp;cl_args[i]) {
                let bytes = cl_args[i].as_bytes();
                let key = bytes[1] as char;
                if i &lt; end - 1 {
                    if !self.is_opt(&amp;cl_args[i+1]) {
                        self.opt_map.insert(
                            key,cl_args[i+1].to_string()
                        );
                    }
                    else {
                        self.opt_map.insert(
                            key, "true".to_string()
                        );
                    }
                }
                else {
                    self.opt_map.insert(
                        key, "true".to_string()
                    );
                }
            }
        }
        /*-- build patterns --*/
        if self.contains_option('p') {
            let pat_str = self.value('p').to_string();
            let split_iter = pat_str.split(',');
            for patt in split_iter {
                self.add_pattern(patt);
            }
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn cl_args() {
        let _mock_args = vec!["/P", ".", "/p", "rs,txt", "/s"];
        print!("\n  cl args: ");
        for arg in args() {
            print!("{:?} ", arg);
        }
        let mut parser = CmdLineParse::new();
        parser.parse();
        for arg in args() {
            let bytes = arg.as_bytes();
            if '/' == (bytes[0] as char) {
                assert!(
                    parser.opt_map.contains_key(
                        &amp;(bytes[1] as char)
                  )
                );
            }
        }
    }
}
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Example program</defn-head>
                <defn-code>
/////////////////////////////////////////////////////////////
// rust_cmd_line::test1.rs                                 //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 19 Apr 2020  //
/////////////////////////////////////////////////////////////

use rust_cmd_line::*;

fn main() {

    print!("\n  Command line arguments:");
    show_cmd_line();

    let mut parser = CmdLineParse::new();
    // let mut parser = CmdLineParse::default();
    parser.default_options();
    print!("\n  {}\n",parser.help());
    parser.parse();
    print!("\n  path     = {:?}", parser.path());
    print!("\n  abspath  = {:?}", parser.abs_path());
    let new_path = "C:/github/foo";
    parser.set_path(new_path);
    print!("\n  setting path to {:?}", new_path);
    print!("\n  path     = {:?}", parser.path());
    parser.add_pattern("rs");
    parser.add_pattern("rs");  // is not repeated
    parser.add_pattern("exe");
    let patts = parser.patterns();
    print!("\n  patts    = {:?}", patts);
    print!("\n  regex    = {:?}", parser.get_regex());
    let opts = parser.options();
    print!("\n  opts     = {:#?}", opts);
    print!("\n\n  adding option {{x,false}}");
    parser.add_option('x', "false");
    let opts = parser.options();
    print!("\n  opts     = {:#?}", opts);
    print!("\n\n  adding option {{x,true}}");
    parser.add_option('x', "true");
    let opts = parser.options();
    print!("\n  opts     = {:#?}", opts);

    print!("\n\n  That's all Folks!\n\n")
}
                </defn-code>
                <defn-head class="defnBorderTop">Output:</defn-head>
                <defn-code>
  Command line arguments:
  
  Help:
  Options: /P . /p "rs,txt" /s /r "abc" /H /h

  path     = "."
  abspath  = "C:/github/JimFawcett/RustCmdLine"
  setting path to "C:/github/foo"
  path     = "C:/github/foo"
  patts    = ["rs", "exe"]
  regex    = "."
  opts     = {
    'r': ".",
    'H': "true",
    's': "true",
    'P': "C:/github/foo",
}

  adding option {x,false}
  opts     = {
    'x': "false",
    'r': ".",
    'H': "true",
    's': "true",
    'P': "C:/github/foo",
}

  adding option {x,true}
  opts     = {
    'x': "true",
    'r': ".",
    'H': "true",
    's': "true",
    'P': "C:/github/foo",
}

  That's all Folks!
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </details>
        </div>
      </t-b>
      The CmdLineParser library is used in the <a href="RustTextFinder.html">RustTextFinder</a> application.
      I expect to use it for many more tools.
    </indent-blocks>

    <a id="dirnav"></a>
    <h3>4.3 Directory Navigator Library</h3>
      <div style="width:calc(100vw - 9em);">
        <photosizer-block src="Pictures/RustDirNav.jpg" width="500" class="photoSizerBlock right" style="margin-top:0;">
          <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
            Fig 1. Directory Navigator Types
          </span>
        </photosizer-block>
      </div>
      <div style="width:calc(100vw - 9em);">
        <photosizer-block src="Pictures/RustDirNavOutput.JPG" width="500" class="photoSizerBlock right clear" style="margin-top:0;">
          <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
            Fig 1. Directory Navigator Output
          </span>
        </photosizer-block>
      </div>
    <!--<h3>Concept:</h3>-->
    <indent-blocks>
      RustDirNav is a facility for Depth-First-Search (DFS) of a specified directory tree.  It uses generic parameter 
      App to provide application specific do_dir and do_file operations.
      <spacer-15></spacer-15>
    </indent-blocks>
    <h4>Design:</h4>
    <indent-blocks>
      <t-b>
        There is one struct, DirNav&lt;App&gt;, with methods and functions implementing this design:
        <indent-block class="pad5">
          Methods:
          <ol class="tight">
            <li>
              <strong><c-s>new() -> Self</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create new <c-s>DirNav</c-s> which has visit method for recursive DFS.
              </div>
            </li>
            <li>
              <strong><c-s>add_pat(&mut self, s&str) -> Self</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Add pattern to match file extension.  Can be chained.
              </div>
            </li>
            <li>
              <strong><c-s>visit(&mut self, p:&Path)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Walks directory tree rooted at path p, looking for files matching pattern(s).
              </div>
            </li>
            <li>
              <strong><c-s>recurse(&mut self, p:bool)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Sets or resets option to recurse directory tree.
              </div>
            </li>
            <li>
              <strong><c-s>hide(&mut self, p:bool)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Sets or resets option to hide directories with no target contents.
              </div>
            </li>
            <li>
              <strong><c-s>get_app(&mut self) -> &mut app</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Retrieves reference to embedded application, set with generic parameter.
              </div>
            </li>
            <li>
              <strong><c-s>get_dirs(&self) -> usize</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Retrieves the number of directories entered
              </div>
            </li>
            <li>
              <strong><c-s>get_files(&self) -> usize</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Retrieves the number of files processed.
              </div>
            </li>
            <li>
              <strong><c-s>get_patts(&self) -> &SearchPatterns</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Retrieves vector of patterns.
              </div>
            </li>
            <li>
              <strong><c-s>clear(&self)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Returns DirNav&lt;app&gt; to its initial state.
              </div>
            </li>
          </ol>
        </indent-block>
      </t-b>
      <t-b>
        The DirEvent trait constrains the App generic parameter to supply do_dir and do_file methods that
        define what the application will do when the navigator encounters a new directory or file.
      </t-b>
      <div>
        <defn-code style="font-size:1em;"> pub trait DirEvent {
     fn do_dir(&mut self, d: &str);
     fn do_file(&mut self, f: &str);
 }</defn-code>
      </div>
      <t-b>
        The DirNav package provides a demonstration of the library in its /examples/test1.rs file.  For the
        demo, test1 simply displays each directory once, and all of the files in that directory.  The App
        type is defined by implementing the DirEvent trait, which may contain data members.
      </t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Directory Navigator Implementation</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>lib.rs</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// rust_dir_nav::lib1.rs                                   //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 12 Apr 2020  //
/////////////////////////////////////////////////////////////
/*
   DirNav&lt;App&gt; is a directory navigator that  uses generic
   parameter App to define how files and directories are
   handled.
   - displays only paths that have file targets by default
   - hide(false) will show all directories traversed
   - recurses directory tree at specified root by default
   - recurse(false) examines only specified path.
*/
use std::fs::{self, DirEntry};
use std::io;
use std::io::{Error, ErrorKind};
#[allow(unused_imports)]
use std::path::{Path, PathBuf};

/// trait required of the App generic parameter type
pub trait DirEvent {
    fn do_dir(&amp;mut self, d: &amp;str);
    fn do_file(&amp;mut self, f: &amp;str);
}
//---------------------------------------
// Sample implementation of DirNav param
// --------------------------------------
// #[derive(Debug, Default)]
// pub struct Appl;
// impl DirEvent for Appl {
//     fn do_dir(&amp;mut self, d:&amp;str) {
//         print!("\n  {:?}", d);
//     }
//     fn do_file(&amp;mut self, f:&amp;str) {
//         print!("\n    {:?}", f);
//     }
// }

/////////////////////////////////////////////////
// Patterns are a collection of extension strings
// used to identify files as search targets

type SearchPatterns = Vec&lt;std::ffi::OsString&gt;;

/// Directory Navigator Structure
#[allow(dead_code)]
#[derive(Debug, Default)]
pub struct DirNav&lt;App: DirEvent&gt; {
    /// file extensions to look for
    pats: SearchPatterns,
    /// instance of App : DirEvent, requires do_file 
    /// and do_dir methods
    app: App,
    /// number of files processed
    num_file: usize,
    /// number of dirs processed
    num_dir: usize,
    /// recurse ?
    recurse : bool,
    /// hide dirs with no targets ?
    hide: bool,
}
impl&lt;App: DirEvent + Default&gt; DirNav&lt;App&gt; {
    pub fn new() -&gt; Self
    where
        App: DirEvent + Default,
    {
        Self {
            pats: SearchPatterns::new(),
            app: App::default(),
            num_file: 0,
            num_dir: 0,
            recurse: true,
            hide: true,
        }
    }
    /// do recursive visit?
    pub fn recurse(&amp;mut self, p:bool) {
        self.recurse = p;
    }
    /// hide dirs with no targets?
    pub fn hide(&amp;mut self, p:bool) {
        self.hide = p;
    }
    /// return reference to App to get results, if any
    pub fn get_app(&amp;mut self) -&gt; &amp;mut App {
        &amp;mut self.app
    }
    /// return number of dirs processed
    pub fn get_dirs(&amp;self) -&gt; usize {
        self.num_dir
    }
    /// return number of files processed
    pub fn get_files(&amp;self) -&gt; usize {
        self.num_file
    }
    /// return patterns, e.g., file extensions to look for
    pub fn get_patts(&amp;self) -&gt; &amp;SearchPatterns {
        &amp;self.pats
    }

    /// add ext to search for - takes either String or &amp;str
    pub fn add_pat&lt;S: Into&lt;String&gt;&gt;(
           &amp;mut self, p: S
        ) -&gt; &amp;mut DirNav&lt;App&gt; {
        let mut t = std::ffi::OsString::new();
        t.push(p.into());
        self.pats.push(t);
        self
    }
    /// reset to default state
    pub fn clear(&amp;mut self) {
        self.pats.clear();
        self.num_dir = 0;
        self.num_file = 0;
        self.app = App::default();
    }
    /// Depth First Search for file exts starting at path dir&lt;br /&gt;
    /// Displays only directories with files matching pattern
    pub fn visit(&amp;mut self, dir: &amp;Path)
           -&gt; io::Result&lt;()&gt; where App: DirEvent
    {
        self.num_dir += 1;
        let dir_name: String = 
          self.replace_sep(dir).to_string_lossy().to_string();
        let mut files = Vec::&lt;std::ffi::OsString&gt;::new();
        let mut sub_dirs = 
            Vec::&lt;std::ffi::OsString&gt;::new();
        if dir.is_dir() {
            /* search local directory */
            for entry in fs::read_dir(dir)? {
                let entry = entry?;
                let path = entry.path();
                if path.is_dir() {
                    let cd = self.replace_sep(&amp;path);
                    sub_dirs.push(cd);
                } else {
                    self.num_file += 1;
                    if self.in_patterns(&amp;entry) 
                       | self.pats.is_empty() {
                        files.push(entry.file_name());
                    }
                }
            }
            /*-- display only dirs with found files --*/
            if !files.is_empty() || !self.hide {
                self.app.do_dir(&amp;dir_name);
            }
            for fl in files {
                let flnm = fl.to_string_lossy().to_string();
                self.app.do_file(&amp;flnm);
            }
            /*-- recurse into subdirectories --*/
            for sub in sub_dirs {
                let mut pb = std::path::PathBuf::new();
                pb.push(sub);
                if self.recurse {
                    self.visit(&amp;pb)?;
                }
            }
            return Ok(());  // normal return
        }
        Err(Error::new(ErrorKind::Other, "not a directory"))
    }
    /// replace Windows directory separator with Linux separator
    pub fn replace_sep(
            &amp;self, path: &amp;Path
        ) -&gt; std::ffi::OsString {
        let rtn = path.to_string_lossy();
        let mod_path = rtn.replace("\\", "/");
        let mut os_str: std::ffi::OsString = 
                std::ffi::OsString::new();
        os_str.push(mod_path);
        os_str
    }
    /// does store contain d.path().extension() ?
    pub fn in_patterns(&amp;self, d: &amp;DirEntry) -&gt; bool {
        let p = d.path();
        let ext = p.extension();
        match ext {
            Some(extn) =&gt; self.pats.contains(
                &amp;(extn.to_os_string())
            ),
            None =&gt; false,
        }
    }
}

#[cfg(test)]
mod tests {
    // test_setup() should run first. To ensure that:
    //   use cargo -- --test-threads=1
    // to see console output:
    //   use cargo test -- --show-output --test-threads=1
    use super::*;
    #[derive(Debug)]
    struct ApplTest {
        rslt_store: Vec&lt;String&gt;,
    }
    impl DirEvent for ApplTest {
        fn do_dir(&amp;mut self, _d: &amp;str) {
            //print!("\n  {:?}", d);
        }
        fn do_file(&amp;mut self, f: &amp;str) {
            //print!("\n    {:?}", f);
            self.rslt_store.push((*f).to_string());
        }
    }
    impl Default for ApplTest {
        fn default() -&gt; Self {
            ApplTest {
                rslt_store: Vec::&lt;String&gt;::new(),
            }
        }
    }
    #[test]
    fn test_setup() {
        let _ = std::fs::create_dir("./test_dir");
        let _ = std::fs::create_dir("./test_dir/test_sub1_dir");
        let _ = std::fs::create_dir("./test_dir/test_sub2_dir");
        let _ = std::fs::File::create("./test_dir/test_file.rs");
        let _ = std::fs::File::create(
                  "./test_dir/test_sub1_dir/test_file1.rs"
                );
        let _ = std::fs::File::create(
                  "./test_dir/test_sub1_dir/test_file2.exe"
                );
        let _ = std::fs::File::create(
                  "./test_dir/test_sub2_dir/test_file3.txt"
                );
    }
    #[test]
    fn test_walk() {
        let mut dn = DirNav::&lt;ApplTest&gt;::new();
        dn.add_pat("rs").add_pat("exe").add_pat("txt");
        let mut pb = PathBuf::new();
        pb.push("./test_dir".to_string());
        let _ = dn.visit(&amp;pb);
        let rl = &amp;dn.get_app().rslt_store;
        /*
          run exe in target/debug with --nocapture option
          to see output of print statement below.
        */
        print!("\n  {:?}", rl);

        // test for found files
        let l = |s: &amp;str| -&gt; String { s.to_string() };

        assert!(rl.contains(&amp;l("test_file.rs")));
        assert!(rl.contains(&amp;l("test_file1.rs")));
        assert!(rl.contains(&amp;l("test_file2.exe")));
        assert!(rl.contains(&amp;l("test_file3.txt")));
        /*
          uncomment line below to make test fail
        */
        //assert!(rl.contains(&amp;l("foobar")));
    }
    #[test]
    fn test_patts() {
        let mut dn = DirNav::&lt;ApplTest&gt;::new();
        dn.add_pat("foo").add_pat("bar");
        assert_eq!(dn.get_patts().len(), 2);
        let pats = dn.get_patts();
        let mut foo_str = std::ffi::OsString::new();
        foo_str.push("foo");
        assert!(pats.contains(&amp;foo_str));
        let mut bar_str = std::ffi::OsString::new();
        bar_str.push("bar");
        assert!(pats.contains(&amp;bar_str));
        dn.clear();
        assert_eq!(dn.get_patts().len(), 0);
    }
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>test1.rs</defn-head>
              <defn-code>
/////////////////////////////////////////////////////////////
// rust_dir_nav::test1.rs                                  //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 12 Apr 2020  //
/////////////////////////////////////////////////////////////

use rust_dir_nav::*;
#[allow(unused_imports)]
use std::env::current_dir;
use std::io;

struct Appl;
impl DirEvent for Appl {
    fn do_dir(&amp;mut self, d: &amp;str) {
        print!("\n  {}", d);
    }
    fn do_file(&amp;mut self, f: &amp;str) {
        print!("\n      {}", f);
    }
}
impl Default for Appl {
    fn default() -&gt; Self {
        Appl
    }
}

fn main() -&gt; io::Result&lt;()&gt; {

    let mut dn = DirNav::&lt;Appl&gt;::new();

    /*-- takes a variety of formats --*/

    let _pat1: String = "rs".to_string();
    let _pat4: String = "rlib".to_string();

    dn.add_pat(&amp;_pat1);
    dn.add_pat("toml".to_string());
    dn.add_pat("txt");
    dn.add_pat(_pat4);
    dn.add_pat(&amp;"exe".to_string());

    //dn.hide(false);

    let path = current_dir()?;
    print!("\n  Searching path {:?}\n", &amp;path);

    let _rslt = dn.visit(&amp;path)?;
    
    print!(
        "\n\n  processed {} files and {} dirs",
        dn.get_files(),
        dn.get_dirs()
    );
    print!("\n");

    dn.clear();
    dn.add_pat("rs").add_pat("toml").add_pat("exe").add_pat("txt");
    let mut path = std::path::PathBuf::new();
    path.push("./test_dir");
    print!("\n  Searching path {:?}\n", &amp;path);
    let _rslt = dn.visit(&amp;path)?;
    print!(
        "\n\n  processed {} files in {} dirs",
        dn.get_files(),
        dn.get_dirs()
    );
    ///////////////////////////////////////////////
    // uncomment lines below to see error return
    //---------------------------------------------
    // print!("\n");
    // path.pop();
    // path.push("foobar");
    // dn.visit(&amp;path)?;
    
    print!("\n\n");
    Ok(())
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
  Searching path "C:\\github\\JimFawcett\\RustDirNav"

  C:/github/JimFawcett/RustDirNav
      Cargo.toml
      Output.txt
  C:/github/JimFawcett/RustDirNav/examples
      test1.rs
  C:/github/JimFawcett/RustDirNav/src
      lib.rs
  C:/github/JimFawcett/RustDirNav/target/debug/deps
      librust_dir_nav-dd84fa97b7e9c811.rlib
  C:/github/JimFawcett/RustDirNav/target/debug/examples
      test1.exe
  C:/github/JimFawcett/RustDirNav/test_dir
      test_file.rs
  C:/github/JimFawcett/RustDirNav/test_dir/test_sub1_dir
      test_file1.rs
      test_file2.exe
  C:/github/JimFawcett/RustDirNav/test_dir/test_sub2_dir
      test_file3.txt

  processed 582 files and 256 dirs

  Searching path "./test_dir"

  ./test_dir
      test_file.rs
  ./test_dir/test_sub1_dir
      test_file1.rs
      test_file2.exe
  ./test_dir/test_sub2_dir
      test_file3.txt

  processed 4 files in 3 dirs

              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
      <t-b>
        The lib.rs file defines all of the DirNav processing and, in its tests section, defines an ApplTest
        type that implements DirEvent and contains a vector that will hold each of the files found during test, 
        so we can verify its operation.
      </t-b>
    </indent-blocks>
    <div class="clears"></div>

    <a id="epilogue"></a>
    <h3>4.4 Epilogue</h3>
    The three libraries discussed here: Logger, CmdLineParser, and DirNav are good examples to study while learning
    the Rust programming language.  They illustrate common Rust coding idioms and the great support for testing
    and documentation provided by <c-s>cargo</c-s>, <c-s>rustc</c-s>, and <c-s>rustdoc</c-s>.  I&apos;ve  used the
    clippy tool, e.g., <c-s>cargo clippy</c-s>,
    to find non-idiomatic or inefficient code, before including here.
    <a id="refs"></a>
    <h3>4.5 References</h3>
    <table>
      <tr>
        <th class="darkItem" style="padding:3px 10px 10px 10px;">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/">A half-hour to learn Rust</a>
        </td>
        <td class="lightItem">
          Code fragments with commentary that cover most of the Rust ideas.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://intorust.com/">intorust.com</a>
        </td>
        <td class="lightItem">
          A few short screen casts - Nicholas Matsakis, ...
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://readrust.net/getting-started">readrust.net/getting-started</a>
        </td>
        <td class="lightItem">
          Nice set of &quot;first-look&quot; posts.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://github.com/ctjhoa/rust-learning">rust-learning repository</a>
        </td>
        <td class="lightItem">
          Extensive list of resources: books, videos, podcasts, ...
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html">A Gentle Introduction To Rust</a>
        </td>
        <td class="lightItem">
          A good walkthrough for most of the Rust ideas.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/1.30.0/book/2018-edition/foreword.html">The Rust Programming Language</a>
        </td>
        <td class="lightItem">
          Long but gentle walkthrough of the Rust Language
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://words.steveklabnik.com/a-new-introduction-to-rust">An alternative introduction to Rust</a>
        </td>
        <td class="lightItem">
          Steve Klabnik
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://stevedonovan.github.io/rust-gentle-intro/pain-points.html">Rust pain-points</a>
        </td>
        <td class="lightItem">
          Steve Donovan
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust by Example</a>
        </td>
        <td class="lightItem">
          Rust docs - walkthrough of syntax
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.twelve21.io/getting-started-with-rust-on-windows-and-visual-studio-code/">
            Getting Started with Rust on Windows and Visual Studio Code
          </a>
        </td>
        <td class="lightItem">
          Install Rust, Verify, Configure Visual Studio Code, Create Hello World, Create Build Task, 
          Configuring Unit Tests, Configure Debugging, 
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.rust-lang.org/">rust-lang.org home page</a>
        </td>
        <td class="lightItem">
          Links to download and documentation
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://cheats.rs/">rust cheat sheet</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/cargo/">rust cargo book</a>
        </td>
        <td class="lightItem">Very clear, simple, description of the cargo facilities and commands.</td>
      </tr>
      <tr>
        <th class="darkItem">
          <a href="RustStory_References.html">More References</a>
        </th>
        <th class="darkItem" style="padding:3px 10px 10px 10px;">Basic, intermediate, and advanced references</th>
      </tr>
    </table>

  </bb-55>
  <spacer-25></spacer-25>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <!--<menu-elem class="secElem"><a href="#exercises">exercises</a></menu-elem>-->
        <menu-elem class="secElem"><a href="#epilogue">epilogue</a></menu-elem>
        <menu-elem class="secElem"><a href="#dirnav">dirnav</a></menu-elem>
        <menu-elem class="secElem"><a href="#parmethods">parmethods</a></menu-elem>
        <menu-elem class="secElem"><a href="#cmdlnproc">cmdlnproc</a></menu-elem>
        <menu-elem class="secElem"><a href="#docs">docs</a></menu-elem>
        <menu-elem class="secElem"><a href="#examples">examples</a></menu-elem>
        <menu-elem class="secElem"><a href="#unittest">unittest</a></menu-elem>
        <menu-elem class="secElem"><a href="#logger">logger</a></menu-elem>
        <menu-elem class="secElem"><a href="#prologue">prologue</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
</body>
</html>