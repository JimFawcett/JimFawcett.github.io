<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - RustStory_Structures.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Rust Structures</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="RustStory_Libraries.html">N</a>
  <a id="Prev" href="RustStory_Operations.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 4. - Rust Structures</h1>
      <h3 id="subtitle">Example libraries, tests, and documentation</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_Libraries.html">Libraries</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#logger">Logger</a>, 
       <a href="#cmdlnproc">CmdLnProc</a>, <a href="#dirnav">DirNav</a>, <a href="#unittest">UnitTest</a>, 
       <a href="#examples">Examples</a>, <a href="#docs">Documentation</a>, 
       <a href="#epilogue">Epilogue</a>, <a href="#refs">References</a>
     </rt-b>
   </toc-b>

  <bb-55 class="indent">
    <a id="prologue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.0</num-item1><num-item4>Prologue:</num-item4>
    </num-cont>
    <t-b>
      Previous chapters have provided a lot of technical details about the Rust programming language.  In this chapter we will bring all that
      together by presenting a few libraries: Logger, CmdLineParser, and DirNavigator.
    </t-b>
    <t-b>
      For the first library, <n-s>Logger</n-s> we will explore library structure, its implementation, testing, and documentation.  The Rust tool cargo,
      in concert with the rustc compiler, provide an excellent environment for building libraries and applications, with detailed testing and
      documentation.
    </t-b>
    <t-b>
      This chapter is a good place to start exploring that.
    </t-b>
    <a id="logger"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.1</num-item1><num-item4>Logger Library:</num-item4>
    </num-cont>
    <t-b>
      The Logger Library provides a light-weight logger, useful for debugging and demonstration.
      Library development started with <span>specifications</span>:
      <indent-block class="pad5">
        <ol class="tight">
          <li>
            Support simultaneous writes to console and a file.
          </li>
          <li>
            Provide file open and close operations and enable or disable
            console output.
          </li>
          <li>
            Write text messages.
          </li>
          <li>
            Optionally prepend a message with a date-time stamp, using local system time.
          </li>
        </ol>
      </indent-block>
    </t-b>
    <t-b>
      Implementation starts with a struct:
    </t-b>
    <t-b>
      <div class="left" style="padding:5px 25px">
        <defn-block>
          <defn-head>
            Logger Struct
          </defn-head>
          <defn-code>
pub struct Logger {
    fl:Option&lt;File&gt;,
    console:bool,
}
          </defn-code>
        </defn-block>
      </div>
    </t-b>
    <t-b>
      Logger has two data members: <c-s>fl</c-s> and <c-s>console</c-s>. <c-s>fl</c-s> is an <c-s>Option</c-s> enumeration that either holds a <c-s>File</c-s>
      instance as <c-s>Some(f:File)</c-s> or <c-s>None</c-s>.  When you create a logger with <c-s>Logger::new()</c-s>, 
      <c-s>fl</c-s> is <c-s>None</c-s>, so the logger is not attached to a file.
    </t-b>
    <t-b>
      The member <c-s>console</c-s> is a boolean that determines whether a write sends its output to the console.  <c-s>Logger::new()</c-s> sets 
      <c-s>console</c-s> to <c-s>true</c-s>, so the logger will, by default, write to the console. To do anything useful, we need some functions 
      that operate on that member data.  Note
      that the Logger structure is public, but its data members are not, so only Logger methods can alter their state.
    </t-b>
    <t-b>
      Logger has nine methods: 
      <div class="pad5 indent">
        <c-s>new()</c-s>, <c-s>init(f:File, con:bool)</c-s>,
        <c-s>console(con:bool)</c-s>, <c-s>file(f:file)</c-s>, <c-s>opt(f:Option&lt;File&gt;)</c-s>,
        <c-s>open(file_name:&str)</c-s>, <c-s>ts_write(s:&str)</c-s>, <c-s>write(s:&str)</c-s>,
        and <c-s>close()</c-s>
      </div>
      <c-s>new</c-s> and <c-s>init</c-s> are creational methods, <c-s>console</c-s>, <c-s>file</c-s>, and <c-s>opt</c-s> mutate the logger state,
      <c-s>open</c-s> and <c-s>close</c-s> manage the state of logger&apos;s file member, and <c-s>write</c-s> and <c-s>ts_write</c-s> handle 
      logger&apos;s main business, writing to the console and/or file.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Logger Methods and Functions:</summary>
          <defn-outerblock>
          <defn-block>
            <defn-head>Logger Methods:</defn-head>
            <defn-code>
#[allow(dead_code)]
impl Logger {
    /*-- create default logger --*/
    pub fn new() -&gt; Self {
        Self { fl:None, console:true, }
    }
    /*-- create initialized logger --*/
    pub fn init(f:File, con:bool) -&gt; Self {
        Self { fl:Some(f), console:con, }
    }
    /*-- enable | disable writing to console --*/
    pub fn console(&amp;mut self, con:bool) {
        self.console = con
    }
    /*-- attach file --*/
    pub fn file(&amp;mut self, f:File) {
        self.fl = Some(f);
    }
    /*-- attach Option&lt;File&gt; --*/
    pub fn opt(&amp;mut self, f:Option&lt;File&gt;) {
        self.fl = f;
    }
    /*-- attempt to open logger file --*/
    pub fn open(&amp;mut self, s:&amp;str) -&gt; bool {
        use std::fs::OpenOptions;
        self.fl = OpenOptions::new()
                .write(true)
                .create(true)
                .append(true)
                .open(s).ok();
        if self.fl.is_some() {
            return true;
        }
        false
    }
    /*-- write log entry with date-time stamp */
    /*-- can be chained                       */
    pub fn ts_write(&amp;mut self, s:&amp;str) 
          -&gt; &amp;mut Self {
        
        let now: DateTime&lt;Local&gt; = Local::now();
        /* format DateTime string */
        let mut now_str = 
          format!("\n  {}", now.to_rfc2822());
        /* remove trailing -0400 */
        now_str.truncate(now_str.len() - 6);

        let _ = Logger::write(self, &amp;now_str);
        let rslt = Logger::write(self, s);
        rslt
    }
    /*-- write log entry, can be chained --*/
    pub fn write(&amp;mut self, s:&amp;str) 
          -&gt; &amp;mut Self {
        if self.console {
            print!("{}", s);
        }
        if let Some(ref mut f) = self.fl {
            let rslt = f.write(s.as_bytes());
            match rslt {
                Ok(_) =&gt; {},
                Err(_) =&gt; 
                  print!("\n  file write failed\n"),
            }
        }
        self
    }
    /*-- close log file */
    pub fn close(&amp;mut self) {
        self.fl = None;
    }
}
#[derive(PartialEq)]
#[allow(dead_code)]
pub enum OpenMode { Truncate, Append }
#[allow(dead_code)]
/*-----------------------------------------
  Helper functions
*/
/*-- attempt to open file by name --*/
pub fn open_file(s:&amp;str, mode:OpenMode) 
      -&gt; Option&lt;File&gt; {
    let fl:Option&lt;File&gt;;
    use std::fs::OpenOptions;
    if mode == OpenMode::Truncate {
        fl = OpenOptions::new()
             .write(true)
             .truncate(true)
             .open(s).ok();
    }
    else {
        fl = OpenOptions::new()
             .write(true)
             .create(true)
             .append(true)
             .open(s).ok();
    }
    fl
}
/*-- attempt to remove file by name --*/
pub fn remove_file(s:&amp;str) -&gt; bool {
    let rslt = std::fs::remove_file(s);
    rslt.is_ok()
}
/*-- does file contain a string? --*/
pub fn file_contains(fl:&amp;str, ts:&amp;str) 
      -&gt; bool {
    let contents = std::fs::read_to_string(fl);
    let mut s = "".to_string();
    if contents.is_ok() {
        s = contents.unwrap();
    }
    s.contains(ts)
}
/*-- display contents of named file --*/
pub fn file_contents(fl:&amp;str) {
    let contents = std::fs::read_to_string(fl);
     if contents.is_ok() {
        let s = contents.unwrap();
        print!("{}", s);
     }
     else {
         print!("\n  no contents");
     }
}
/*-- does file exist? --*/
pub fn file_exists(s:&amp;str) -&gt; bool {
    let path = Path::new(s);
    return path.exists();
}

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Explanations:</defn-head>
            <defn-body style="width:25em;">
              <t-b>
                Methods are defined in one or more impl blocks.
                Each block contains method definitions, as you see in the right panel.
              </t-b>
              <t-b>
                The type Self is the type of the Structure, e.g., Logger. The variable self is a reference
                to the instance on which the method was called.
              </t-b>
              <t-b>
                The method new() returns an instance of the type Self, e.g., the logger we are creating with
                this method. It only has one line: <c-s>Self { fl:None, console:true, }</c-s>. Since there
                is no semicolon following the closing brace in this line, this is an expression, and any scope has the value
                of its last expression, so we are returning <c-s>Logger { fl:None, console:true }</c-s>.
              </t-b>
              <t-b>
                Many of the methods are relatively simple, but the <c-s>write</c-s> method has some peculiar code, e.g.:
                <indent-block class="pad5">
                  <c-s>if let Some(ref&nbsp;&nbsp;mut&nbsp;&nbsp;f) = self.fl { ... }</c-s>
                </indent-block>
                The &quot;=&quot; operator is not an assignment.  It is a matching operator. The term &quot;<c-s>Some(ref&nbsp;&nbsp;mut&nbsp;&nbsp;f)</c-s>
                is the <c-s>Option&lt;T&gt;::Some(t:T)</c-s> holding a mutable reference to a File instance.  So, we are matching
                <c-s>self.fl</c-s> with a pattern that requires the <c-s>Some</c-s> option rather than <c-s>None</c-s>.
                If the match is satisfied, e.g., the logger has a file reference, then we write to the file.
              </t-b>
              <t-b>
                The remainder of the function
                is a test to see if the user elected to use the console, and if so, writes to the console.  So, if both conditions match, the
                logger writes to both the console and the log file.
              </t-b>
              <t-b>
                The <c-s>ts_write</c-s> method uses code from the DateTime crate to generate the local system date and time, format it, and then write
                using the <c-s>write</c-s> method. It then repeats with its string argument.
              </t-b>
            </defn-body>
          </defn-block>
          </defn-outerblock>
        </details>
      </div>
    </t-b>
    <t-b class="mbz">
      Both <c-s>write</c-s> and <c-s>ts_write</c-s> return <c-s>&mut Self</c-s>, so they can be chained, e.g.,
      <c-s>l.write("first).write(", second");</c-s>
    </t-b>
    <t-b class="mbz">
      Logger also contains functions:
      <div class="pad5 indent">
        <c-s>open_file(file_name, open_mode)</c-s>, <c-s>remove_file(file_name)</c-s>,
        <c-s>file_contains(file_name, search_text)</c-s>, <c-s>file_contents(file_name)</c-s>, 
        and <c-s>file_exists(file_name)</c-s>.
      </div>
      These are helper files used during logger testing.  They will probably be useful for testing other projects.
    </t-b>
    <div class="clear"></div>

    <a id="unittest"></a>
    <s-halfEm></s-halfEm>
    <num-cont>
      <num-item1>3.2.1</num-item1><num-item4>Library Unit Tests:</num-item4>
    </num-cont>
    <t-b>
      when cargo creates a library project with <c-s>cargo new --lib</c-s>, it creates a src directory containing a <c-s>lib.rs</c-s> 
      file.  At the end of the file you will find a #[cfg(test)] directive that defines one or more tests to run.
    </t-b>
    <t-b>
      Each test starts with a #[test] directive containing a single test function.  The test function is expected to have one or more
      assertions.  The test passes if all assertions are satisfied, otherwise it fails.
    </t-b>
    <t-b>
      You run unit tests with the cargo command:
      <indent-block class="pad5">
        <c-s>cargo test</c-s>
      </indent-block>
    </t-b>
    <t-b>
      The details dropdown, below, lists all of the unit tests for the Logger library. 
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Logger Unit Tests:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Unit Test Code:</defn-head>
              <defn-code>
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_open_file() {
        let stest = "test_open.txt";
        let mut l = Logger::new();
        l.open(stest);
        open_file(stest, OpenMode::Truncate);
        assert_eq!(file_exists(stest),true);
        remove_file(stest);
        assert_eq!(file_exists(stest),false);
    }
    #[test]
    fn test_file_contains() {
        let stest = "test_contains.txt";
        let mut l = Logger::new();
        l.open(stest);
        assert_eq!(l.fl.is_some(), true);
        l.write("test contents with a short string");
        l.close();
        assert_eq!(file_exists(stest), true);
        assert_eq!(file_contains(stest, "a short"), true);
        remove_file(stest);
        assert_eq!(file_exists(stest),false);
    }
    #[test]
    fn test_remove_file() {
        let stest = "test_remove";
        open_file(stest, OpenMode::Truncate);
        remove_file(stest);
        assert_eq!(file_exists(stest),false);
    }
    #[test]
    fn test_file_exists() {
        assert_eq!(file_exists("foobar.fee"),false);
    }
    #[test]
    fn test_new() {
        let stest = "test_new";
        let mut l = Logger::new();
        l.open(stest);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_init() {
        let stest = "test_new";
        let opt = open_file(stest, OpenMode::Append);
        let mut l = Logger::init(opt.unwrap(), false);
        l.open(stest);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_console() {
        let mut l = Logger::new();
        assert_eq!(l.console == true, true);
        l.console(false);
        assert_eq!(l.console == false, true);
    }
    #[test]
    fn test_file() {
        let mut l = Logger::new();
        let stest = "test_file";
        l.file(open_file(stest, OpenMode::Append).unwrap());
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_opt() {
        let mut l = Logger::new();
        let stest = "test_file";
        let file_opt = open_file(stest, OpenMode::Append);
        l.opt(file_opt);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_open() {
        let mut l = Logger::new();
        let stest = "test_open";
        l.open(stest);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_write() {
        let mut l = Logger::new();
        let stest = "test_write";
        l.open(stest);
        let stxt = "abc 012 xyz 789";
        let _ = l.write(stxt);
        assert_eq!(file_contains(stest, stxt), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_ts_write() {
        let mut l = Logger::new();
        let stest = "test_ts_write";
        l.open(stest);
        let sdt = "2020";  // change if year != 2020
        let stxt = "abc 012 xyz 789";
        let _ = l.ts_write(stxt);
        assert_eq!(file_contains(stest,sdt), true);
        assert_eq!(file_contains(stest, stxt), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_close() {
        let mut l = Logger::new();
        let stest = "test_close.txt";
        l.open(stest);
        assert_eq!(l.fl.is_some(), true);
        l.close();
        assert_eq!(l.fl.is_none(), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
C:\github\JimFawcett\RustBasicDemos\logger>
cargo test

   // compiler output elided

running 13 tests
test tests::test_console ... ok
test tests::test_file_exists ... ok
test tests::test_new ... ok
test tests::test_file ... ok
test tests::test_close ... ok
test tests::test_open ... ok
test tests::test_remove_file ... ok
test tests::test_file_contains ... ok
test tests::test_open_file ... ok
test tests::test_opt ... ok
test tests::test_init ... ok
test tests::test_write ... ok
test tests::test_ts_write ... ok

test result: ok. 
13 passed; 
0 failed; 
0 ignored; 
0 measured; 
0 filtered out    
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      Since cargo sets up the unit test configuration code for each library crate that it creates, 
      it is quite easy to write unit tests as we write functions.  When development is finished we
      have a robust test sequence that can be run any time maintenance changes are made to the library.
    </t-b>

    <a id="examples"></a>
    <s-halfEm></s-halfEm>
    <num-cont>
      <num-item1>3.2.2</num-item1><num-item4>Library Examples:</num-item4>
    </num-cont>
    <t-b>
      If you create an examples directory as a sibling of src, then you can put code there with a main function that
      exercises your library, perhaps to demonstrate its operations for new users.  If you do that then
      <indent-block class="pad5">
        <c-s>cargo run --example test1</c-s>
      </indent-block>
        will trigger cargo to attempt to build a binary crate from
        test1.rs and run its executable.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Examples:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Examples/test1.rs</defn-head>
              <defn-code>
  Demonstrating Logger
 ======================

  deleted previous log file
  writing to "Log.txt"
 ----------------------
  Thu, 19 Mar 2020 18:18:59
  starting log
  first entry, second entry, third entry

  contents of log.txt
 ---------------------
  Thu, 19 Mar 2020 18:18:59
  starting log
  first entry, second entry, third entry

  closing then reopening log
 ----------------------------
  Thu, 19 Mar 2020 18:18:59
  reopening log
  after reopen
  found "first entry" in "log.txt"

  That's all Folks!

              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
>cargo run --example test1

    // compiler output elided

  Demonstrating Logger
 ======================

  deleted previous log file
  writing to "Log.txt"
 ----------------------
  Wed, 18 Mar 2020 14:37:40
  starting log
  first entry, second entry, third entry
  Wed, 18 Mar 2020 14:37:40
  reopening log
  after reopen
  contents = 
  Wed, 18 Mar 2020 14:37:40
  starting log
  first entry, second entry, third entry
  Wed, 18 Mar 2020 14:37:40
  reopening log
  after reopen
  found first entry in log.txt

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b class="mbz">
      You can have any number of example files in the examples directory, each with a main function that demonstrates some
      particular aspect of your library. You can also supply examples suitable for developer&apos;s with different levels
      of expertise with Rust.
    </t-b>

    <a id="docs"></a>
    <s-halfEm class="clear"></s-halfEm>
    <num-cont>
      <num-item1>3.2.3</num-item1><num-item4>Library Documentation:</num-item4>
    </num-cont>
    <t-b>
      <div style="width:calc(100vw - 12em);">
        <photosizer-block src="Pictures/RustDoc.JPG" width="600" class="photoSizerBlock right clear">
          <span style="font-family:'Comic Sans MS';">Figure 1. Logger Documentation</span>
        </photosizer-block>

      </div>
    </t-b>
    <t-b>
      You can endow your own libraries with the same kind of documentation provided for the std libraries.
      If you put comments above each method or function with the format:
      <indent-block class="pad5">
        <defn-code>
/// ```
/// let mut logr = Logger::new();
///
/// sets fl:None, console:true;
/// ```
pub fn new() -> Self {
    Self { fl:None, console:true, }
}
        </defn-code>
      </indent-block>
      That places your comments in the document below the function, as shown in Figure 1.  
    </t-b>
    <t-b>
      To create documentation, simply issue the cargo command:
      <indent-block class="pad5">
        <c-s>cargo doc --document-private-items</c-s>
      </indent-block>
      If you don&apos;t want to display private items, then leave off that option.
    </t-b>
    <t-b>
      The <c-s>doc</c-s> command builds documentation and deposites it in your <n-s>Target</n-s> folder.
      This creates documentation, not only for your code, but also for code it depends upon.
    </t-b>
    <t-b>
      Be aware that if you issue a <c-s>cargo clean</c-s> command that will delete all the
      documentation because clean deletes the <n-s>Target</n-s> folder.
    </t-b>
    <t-b>
      One more thing: if you put documentation comments in your code, you need to set 
      <c-s>doctest = false</c-s> in a <c-s>[lib]</c-s> section of your <c-s>cargo.toml</c-s> file.
      If you don&apos;t do this, the compiler attempts to compile your comments and emits a lot of
      errors and warnings.
    </t-b>
    <div>
      <details>
        <summary class="labelStyle lightItem">Cargo.toml</summary>
      <t-b>
        The <c-s>[lib]</c-s> section needs to come before <c-s>[dependencies]</c-s>
      </t-b>
      <t-b>
        <div>
          <defn-block>
            <defn-head>Logger Cargo File</defn-head>
            <defn-code>
[package]
name = "logger"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>
  "]
  edition = "2018"

  # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

  [lib]
  # prevents rustc from attempting to compile doc comments
  doctest = false

  [dependencies]
  chrono = "0.2.16"
  display = { path = "../display" }
            </defn-code>
          </defn-block>
        </div>
      </t-b>
        </details>
    </div>
    <t-b>
      This completes our discussion of the <n-s>Logger</n-s> project.  You can find the code and discussion
      in <a href="RustLogger.html">RustLogger</a> repository.
    </t-b>

    <a id="cmdlnproc"></a>
    <hr class="spread clear" />
    <num-cont>
      <num-item1>3.2</num-item1><num-item4>CmdLine Processor Library:</num-item4>
    </num-cont>

    <a id="dirnav"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.3</num-item1><num-item4>Directory Navigator Library:</num-item4>
    </num-cont>

    <a id="unittest"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.4</num-item1><num-item4>Unit Tests:</num-item4>
    </num-cont>

    <a id="examples"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.5</num-item1><num-item4>Library Demo Examples:</num-item4>
    </num-cont>

    <a id="docs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.6</num-item1><num-item4>Library Documentation:</num-item4>
    </num-cont>

    <a id="epilogue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.7</num-item1><num-item4>Epilogue:</num-item4>
    </num-cont>

    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.8</num-item1><num-item4>References:</num-item4>
    </num-cont>

  </bb-55>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>