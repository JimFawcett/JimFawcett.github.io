<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - RustStory_Structures.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Rust Structures</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="RustStory_Libraries.html">N</a>
  <a id="Prev" href="RustStory_Operations.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 4. - Rust Structures</h1>
      <h3 id="subtitle">Example libraries, tests, and documentation</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_Libraries.html">Libraries</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#logger">Logger</a>, 
       <a href="#cmdlnproc">CmdLnProc</a>, <a href="#dirnav">DirNav</a>, <a href="#unittest">UnitTest</a>, 
       <a href="#examples">Examples</a>, <a href="#docs">Documentation</a>, 
       <a href="#epilogue">Epilogue</a>, <a href="#refs">References</a>
     </rt-b>
   </toc-b>

  <bb-55 class="indent">
    <a id="prologue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.0</num-item1><num-item4>Prologue:</num-item4>
    </num-cont>
    <t-b>
      Previous chapters have provided a lot of technical details about the Rust programming language.  In this chapter we will bring all that
      together by presenting a few libraries: Logger, CmdLineParser, and DirNavigator.
    </t-b>
    <t-b>
      For the first library, <n-s>Logger</n-s> we will explore library structure, its implementation, testing, and documentation.  The Rust tool cargo,
      in concert with the rustc compiler, provide an excellent environment for building libraries and applications, with detailed testing and
      documentation.
    </t-b>
    <t-b>
      This chapter is a good place to start exploring that.
    </t-b>
    <a id="logger"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.1</num-item1><num-item4>Logger Library:</num-item4>
    </num-cont>
    <t-b>
      The Logger Library provides a light-weight logger, useful for debugging and demonstration.
      Library development started with <span>specifications</span>:
      <indent-block class="pad5">
        <ol class="tight">
          <li>
            Support simultaneous writes to console and a file.
          </li>
          <li>
            Provide file open and close operations and enable or disable
            console output.
          </li>
          <li>
            Write text messages.
          </li>
          <li>
            Optionally prepend a message with a date-time stamp, using local system time.
          </li>
        </ol>
      </indent-block>
    </t-b>
    <t-b>
      Implementation starts with a struct:
    </t-b>
    <t-b>
      <div class="left" style="padding:5px 25px">
        <defn-block>
          <defn-head>
            Logger Struct
          </defn-head>
          <defn-code>
pub struct Logger {
    fl:Option&lt;File&gt;,
    console:bool,
}
          </defn-code>
        </defn-block>
      </div>
    </t-b>
    <t-b>
      Logger has two data members: <c-s>fl</c-s> and <c-s>console</c-s>. <c-s>fl</c-s> is an <c-s>Option</c-s> enumeration that either holds a <c-s>File</c-s>
      instance as <c-s>Some(f:File)</c-s> or <c-s>None</c-s>.  When you create a logger with <c-s>Logger::new()</c-s>, 
      <c-s>fl</c-s> is <c-s>None</c-s>, so the logger is not attached to a file.
    </t-b>
    <t-b>
      The member <c-s>console</c-s> is a boolean that determines whether a write sends its output to the console.  <c-s>Logger::new()</c-s> sets 
      <c-s>console</c-s> to <c-s>true</c-s>, so the logger will, by default, write to the console. To do anything useful, we need some functions 
      that operate on that member data.  Note
      that the Logger structure is public, but its data members are not, so only Logger methods can alter their state.
    </t-b>
    <t-b>
      Logger has nine methods: 
      <div class="pad5 indent">
        <c-s>new()</c-s>, <c-s>init(f:File, con:bool)</c-s>,
        <c-s>console(con:bool)</c-s>, <c-s>file(f:file)</c-s>, <c-s>opt(f:Option&lt;File&gt;)</c-s>,
        <c-s>open(file_name:&str)</c-s>, <c-s>ts_write(s:&str)</c-s>, <c-s>write(s:&str)</c-s>,
        and <c-s>close()</c-s>
      </div>
      <c-s>new</c-s> and <c-s>init</c-s> are creational methods, <c-s>console</c-s>, <c-s>file</c-s>, and <c-s>opt</c-s> mutate the logger state,
      <c-s>open</c-s> and <c-s>close</c-s> manage the state of logger&apos;s file member, and <c-s>write</c-s> and <c-s>ts_write</c-s> handle 
      logger&apos;s main business, writing to the console and/or file.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Logger Methods and Functions:</summary>
          <defn-outerblock>
          <defn-block>
            <defn-head>Logger Methods:</defn-head>
            <defn-code>
#[allow(dead_code)]
impl Logger {
    /*-- create default logger --*/
    pub fn new() -&gt; Self {
        Self { fl:None, console:true, }
    }
    /*-- create initialized logger --*/
    pub fn init(f:File, con:bool) -&gt; Self {
        Self { fl:Some(f), console:con, }
    }
    /*-- enable | disable writing to console --*/
    pub fn console(&amp;mut self, con:bool) {
        self.console = con
    }
    /*-- attach file --*/
    pub fn file(&amp;mut self, f:File) {
        self.fl = Some(f);
    }
    /*-- attach Option&lt;File&gt; --*/
    pub fn opt(&amp;mut self, f:Option&lt;File&gt;) {
        self.fl = f;
    }
    /*-- attempt to open logger file --*/
    pub fn open(&amp;mut self, s:&amp;str) -&gt; bool {
        use std::fs::OpenOptions;
        self.fl = OpenOptions::new()
                .write(true)
                .create(true)
                .append(true)
                .open(s).ok();
        if self.fl.is_some() {
            return true;
        }
        false
    }
    /*-- write log entry with date-time stamp */
    /*-- can be chained                       */
    pub fn ts_write(&amp;mut self, s:&amp;str) 
          -&gt; &amp;mut Self {
        
        let now: DateTime&lt;Local&gt; = Local::now();
        /* format DateTime string */
        let mut now_str = 
          format!("\n  {}", now.to_rfc2822());
        /* remove trailing -0400 */
        now_str.truncate(now_str.len() - 6);

        let _ = Logger::write(self, &amp;now_str);
        let rslt = Logger::write(self, s);
        rslt
    }
    /*-- write log entry, can be chained --*/
    pub fn write(&amp;mut self, s:&amp;str) 
          -&gt; &amp;mut Self {
        if self.console {
            print!("{}", s);
        }
        if let Some(ref mut f) = self.fl {
            let rslt = f.write(s.as_bytes());
            match rslt {
                Ok(_) =&gt; {},
                Err(_) =&gt; 
                  print!("\n  file write failed\n"),
            }
        }
        self
    }
    /*-- close log file */
    pub fn close(&amp;mut self) {
        self.fl = None;
    }
}
#[derive(PartialEq)]
#[allow(dead_code)]
pub enum OpenMode { Truncate, Append }
#[allow(dead_code)]
/*-----------------------------------------
  Helper functions
*/
/*-- attempt to open file by name --*/
pub fn open_file(s:&amp;str, mode:OpenMode) 
      -&gt; Option&lt;File&gt; {
    let fl:Option&lt;File&gt;;
    use std::fs::OpenOptions;
    if mode == OpenMode::Truncate {
        fl = OpenOptions::new()
             .write(true)
             .truncate(true)
             .open(s).ok();
    }
    else {
        fl = OpenOptions::new()
             .write(true)
             .create(true)
             .append(true)
             .open(s).ok();
    }
    fl
}
/*-- attempt to remove file by name --*/
pub fn remove_file(s:&amp;str) -&gt; bool {
    let rslt = std::fs::remove_file(s);
    rslt.is_ok()
}
/*-- does file contain a string? --*/
pub fn file_contains(fl:&amp;str, ts:&amp;str) 
      -&gt; bool {
    let contents = std::fs::read_to_string(fl);
    let mut s = "".to_string();
    if contents.is_ok() {
        s = contents.unwrap();
    }
    s.contains(ts)
}
/*-- display contents of named file --*/
pub fn file_contents(fl:&amp;str) {
    let contents = std::fs::read_to_string(fl);
     if contents.is_ok() {
        let s = contents.unwrap();
        print!("{}", s);
     }
     else {
         print!("\n  no contents");
     }
}
/*-- does file exist? --*/
pub fn file_exists(s:&amp;str) -&gt; bool {
    let path = Path::new(s);
    return path.exists();
}

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Explanations:</defn-head>
            <defn-body style="width:25em;">
              <t-b>
                Methods are defined in one or more impl blocks.
                Each block contains method definitions, as you see in the right panel.
              </t-b>
              <t-b>
                The type Self is the type of the Structure, e.g., Logger. The variable self is a reference
                to the instance on which the method was called.
              </t-b>
              <t-b>
                The method new() returns an instance of the type Self, e.g., the logger we are creating with
                this method. It only has one line: <c-s>Self { fl:None, console:true, }</c-s>. Since there
                is no semicolon following the closing brace in this line, this is an expression, and any scope has the value
                of its last expression, so we are returning <c-s>Logger { fl:None, console:true }</c-s>.
              </t-b>
              <t-b>
                Many of the methods are relatively simple, but the <c-s>write</c-s> method has some peculiar code, e.g.:
                <indent-block class="pad5">
                  <c-s>if let Some(ref&nbsp;&nbsp;mut&nbsp;&nbsp;f) = self.fl { ... }</c-s>
                </indent-block>
                The &quot;=&quot; operator is not an assignment.  It is a matching operator. The term &quot;<c-s>Some(ref&nbsp;&nbsp;mut&nbsp;&nbsp;f)</c-s>
                is the <c-s>Option&lt;T&gt;::Some(t:T)</c-s> holding a mutable reference to a File instance.  So, we are matching
                <c-s>self.fl</c-s> with a pattern that requires the <c-s>Some</c-s> option rather than <c-s>None</c-s>.
                If the match is satisfied, e.g., the logger has a file reference, then we write to the file.
              </t-b>
              <t-b>
                The remainder of the function
                is a test to see if the user elected to use the console, and if so, writes to the console.  So, if both conditions match, the
                logger writes to both the console and the log file.
              </t-b>
              <t-b>
                The <c-s>ts_write</c-s> method uses code from the DateTime crate to generate the local system date and time, format it, and then write
                using the <c-s>write</c-s> method. It then repeats with its string argument.
              </t-b>
            </defn-body>
          </defn-block>
          </defn-outerblock>
        </details>
      </div>
    </t-b>
    <t-b class="mbz">
      Both <c-s>write</c-s> and <c-s>ts_write</c-s> return <c-s>&mut Self</c-s>, so they can be chained, e.g.,
      <c-s>l.write("first).write(", second");</c-s>
    </t-b>
    <t-b class="mbz">
      Logger also contains functions:
      <div class="pad5 indent">
        <c-s>open_file(file_name, open_mode)</c-s>, <c-s>remove_file(file_name)</c-s>,
        <c-s>file_contains(file_name, search_text)</c-s>, <c-s>file_contents(file_name)</c-s>, 
        and <c-s>file_exists(file_name)</c-s>.
      </div>
      These are helper files used during logger testing.  They will probably be useful for testing other projects.
    </t-b>
    <div class="clear"></div>

    <a id="unittest"></a>
    <s-halfEm></s-halfEm>
    <num-cont>
      <num-item1>3.2.1</num-item1><num-item4>Library Unit Tests:</num-item4>
    </num-cont>
    <t-b>
      when cargo creates a library project with <c-s>cargo new --lib</c-s>, it creates a src directory containing a <c-s>lib.rs</c-s> 
      file.  At the end of the file you will find a #[cfg(test)] directive that defines one or more tests to run.
    </t-b>
    <t-b>
      Each test starts with a #[test] directive containing a single test function.  The test function is expected to have one or more
      assertions.  The test passes if all assertions are satisfied, otherwise it fails.
    </t-b>
    <t-b>
      You run unit tests with the cargo command:
      <indent-block class="pad5">
        <c-s>cargo test</c-s>
      </indent-block>
    </t-b>
    <t-b>
      The details dropdown, below, lists all of the unit tests for the Logger library. 
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Logger Unit Tests:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Unit Test Code:</defn-head>
              <defn-code>
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_open_file() {
        let stest = "test_open.txt";
        let mut l = Logger::new();
        l.open(stest);
        open_file(stest, OpenMode::Truncate);
        assert_eq!(file_exists(stest),true);
        remove_file(stest);
        assert_eq!(file_exists(stest),false);
    }
    #[test]
    fn test_file_contains() {
        let stest = "test_contains.txt";
        let mut l = Logger::new();
        l.open(stest);
        assert_eq!(l.fl.is_some(), true);
        l.write("test contents with a short string");
        l.close();
        assert_eq!(file_exists(stest), true);
        assert_eq!(file_contains(stest, "a short"), true);
        remove_file(stest);
        assert_eq!(file_exists(stest),false);
    }
    #[test]
    fn test_remove_file() {
        let stest = "test_remove";
        open_file(stest, OpenMode::Truncate);
        remove_file(stest);
        assert_eq!(file_exists(stest),false);
    }
    #[test]
    fn test_file_exists() {
        assert_eq!(file_exists("foobar.fee"),false);
    }
    #[test]
    fn test_new() {
        let stest = "test_new";
        let mut l = Logger::new();
        l.open(stest);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_init() {
        let stest = "test_new";
        let opt = open_file(stest, OpenMode::Append);
        let mut l = Logger::init(opt.unwrap(), false);
        l.open(stest);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_console() {
        let mut l = Logger::new();
        assert_eq!(l.console == true, true);
        l.console(false);
        assert_eq!(l.console == false, true);
    }
    #[test]
    fn test_file() {
        let mut l = Logger::new();
        let stest = "test_file";
        l.file(open_file(stest, OpenMode::Append).unwrap());
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_opt() {
        let mut l = Logger::new();
        let stest = "test_file";
        let file_opt = open_file(stest, OpenMode::Append);
        l.opt(file_opt);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_open() {
        let mut l = Logger::new();
        let stest = "test_open";
        l.open(stest);
        assert_eq!(file_exists(stest), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_write() {
        let mut l = Logger::new();
        let stest = "test_write";
        l.open(stest);
        let stxt = "abc 012 xyz 789";
        let _ = l.write(stxt);
        assert_eq!(file_contains(stest, stxt), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_ts_write() {
        let mut l = Logger::new();
        let stest = "test_ts_write";
        l.open(stest);
        let sdt = "2020";  // change if year != 2020
        let stxt = "abc 012 xyz 789";
        let _ = l.ts_write(stxt);
        assert_eq!(file_contains(stest,sdt), true);
        assert_eq!(file_contains(stest, stxt), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
    #[test]
    fn test_close() {
        let mut l = Logger::new();
        let stest = "test_close.txt";
        l.open(stest);
        assert_eq!(l.fl.is_some(), true);
        l.close();
        assert_eq!(l.fl.is_none(), true);
        remove_file(stest);
        assert_eq!(file_exists(stest), false);
    }
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
C:\github\JimFawcett\RustBasicDemos\logger>
cargo test

   // compiler output elided

running 13 tests
test tests::test_console ... ok
test tests::test_file_exists ... ok
test tests::test_new ... ok
test tests::test_file ... ok
test tests::test_close ... ok
test tests::test_open ... ok
test tests::test_remove_file ... ok
test tests::test_file_contains ... ok
test tests::test_open_file ... ok
test tests::test_opt ... ok
test tests::test_init ... ok
test tests::test_write ... ok
test tests::test_ts_write ... ok

test result: ok. 
13 passed; 
0 failed; 
0 ignored; 
0 measured; 
0 filtered out    
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      Since cargo sets up the unit test configuration code for each library crate that it creates, 
      it is quite easy to write unit tests as we write functions.  When development is finished we
      have a robust test sequence that can be run any time maintenance changes are made to the library.
    </t-b>

    <a id="examples"></a>
    <s-halfEm></s-halfEm>
    <num-cont>
      <num-item1>3.2.2</num-item1><num-item4>Library Examples:</num-item4>
    </num-cont>
    <t-b>
      If you create an examples directory as a sibling of src, then you can put code there with a main function that
      exercises your library, perhaps to demonstrate its operations for new users.  If you do that then
      <indent-block class="pad5">
        <c-s>cargo run --example test1</c-s>
      </indent-block>
        will trigger cargo to attempt to build a binary crate from
        test1.rs and run its executable.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Examples:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Examples/test1.rs</defn-head>
              <defn-code>
  Demonstrating Logger
 ======================

  deleted previous log file
  writing to "Log.txt"
 ----------------------
  Thu, 19 Mar 2020 18:18:59
  starting log
  first entry, second entry, third entry

  contents of log.txt
 ---------------------
  Thu, 19 Mar 2020 18:18:59
  starting log
  first entry, second entry, third entry

  closing then reopening log
 ----------------------------
  Thu, 19 Mar 2020 18:18:59
  reopening log
  after reopen
  found "first entry" in "log.txt"

  That's all Folks!

              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
>cargo run --example test1

    // compiler output elided

  Demonstrating Logger
 ======================

  deleted previous log file
  writing to "Log.txt"
 ----------------------
  Wed, 18 Mar 2020 14:37:40
  starting log
  first entry, second entry, third entry
  Wed, 18 Mar 2020 14:37:40
  reopening log
  after reopen
  contents = 
  Wed, 18 Mar 2020 14:37:40
  starting log
  first entry, second entry, third entry
  Wed, 18 Mar 2020 14:37:40
  reopening log
  after reopen
  found first entry in log.txt

  That's all Folks!
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b class="mbz">
      You can have any number of example files in the examples directory, each with a main function that demonstrates some
      particular aspect of your library. You can also supply examples suitable for developer&apos;s with different levels
      of expertise with Rust.
    </t-b>

    <a id="docs"></a>
    <s-halfEm class="clear"></s-halfEm>
    <num-cont>
      <num-item1>3.2.3</num-item1><num-item4>Library Documentation:</num-item4>
    </num-cont>
    <t-b>
      <div style="width:calc(100vw - 12em);">
        <photosizer-block src="Pictures/RustDoc.JPG" width="600" class="photoSizerBlock right clear">
          <span style="font-family:'Comic Sans MS';">Figure 1. Logger Documentation</span>
        </photosizer-block>

      </div>
    </t-b>
    <t-b>
      You can endow your own libraries with the same kind of documentation provided for the std libraries.
      If you put comments above each method or function with the format:
      <indent-block class="pad5">
        <defn-code>
/// ```
/// let mut logr = Logger::new();
///
/// sets fl:None, console:true;
/// ```
pub fn new() -> Self {
    Self { fl:None, console:true, }
}
        </defn-code>
      </indent-block>
      That places your comments in the document below the function, as shown in Figure 1.  
    </t-b>
    <t-b>
      To create documentation, simply issue the cargo command:
      <indent-block class="pad5">
        <c-s>cargo doc --document-private-items</c-s>
      </indent-block>
      If you don&apos;t want to display private items, then leave off that option.
    </t-b>
    <t-b>
      The <c-s>doc</c-s> command builds documentation and deposites it in your <n-s>Target</n-s> folder.
      This creates documentation, not only for your code, but also for code it depends upon.
    </t-b>
    <t-b>
      Be aware that if you issue a <c-s>cargo clean</c-s> command that will delete all the
      documentation because clean deletes the <n-s>Target</n-s> folder.
    </t-b>
    <t-b>
      One more thing: if you put documentation comments in your code, you need to set 
      <c-s>doctest = false</c-s> in a <c-s>[lib]</c-s> section of your <c-s>cargo.toml</c-s> file.
      If you don&apos;t do this, the compiler attempts to compile your comments and emits a lot of
      errors and warnings.
    </t-b>
    <div>
      <details>
        <summary class="labelStyle lightItem">Cargo.toml</summary>
      <t-b>
        The <c-s>[lib]</c-s> section needs to come before <c-s>[dependencies]</c-s>
      </t-b>
      <t-b>
        <div>
          <defn-block>
            <defn-head>Logger Cargo File</defn-head>
            <defn-code>
[package]
name = "logger"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>
  "]
  edition = "2018"

  # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

  [lib]
  # prevents rustc from attempting to compile doc comments
  doctest = false

  [dependencies]
  chrono = "0.2.16"
  display = { path = "../display" }
            </defn-code>
          </defn-block>
        </div>
      </t-b>
        </details>
    </div>
    <t-b>
      This completes our discussion of the <n-s>Logger</n-s> project.  You can find the code and discussion
      in <a href="RustLogger.html">RustLogger</a> repository.
    </t-b>

    <a id="cmdlnproc"></a>
    <hr class="spread clear" />
    <num-cont>
      <num-item1>3.2</num-item1><num-item4>CmdLine Parser Library:</num-item4>
    </num-cont>
    <indent-blocks>
      RustCmdLine is a facility for parsing command line arguments.  Here&apos;s a sample:
      <div class="indent pad5">
        <c-s>/P "." /p "rs,txt" /s /H /r "abc"</c-s>
      </div>
      where:
      <div class="indent pad5">
        <c-s>/P "."&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- path<br />
        /p "rs,txt" - file patterns<br />
        /s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- recurse through directory tree rooted at path<br />
        /H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- hide directories that don&apos;t contain target files<br />
        /r "abc"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- regular expression</c-s>
      </div>
      <spacer-15></spacer-15>
      The intent is that a program creates an instance of CmdLineParser, uses that to parse its command line, then
      passes it to any code that needs to know about a pattern or an option.
    </indent-blocks>
    <h3>Design:</h3>
    <indent-blocks>
      <t-b>
        This library contains a single user-defined type: CmdLineParser.
        <s-5px></s-5px>
        <t-b class="left">
          <div style="padding-right:1em;">
            <defn-block>
              <defn-head style="margin-top:0px;">CmdLineParser Struct</defn-head>
              <defn-code>
pub struct CmdLineParse {
  opt_map : Options,
  patterns : CmdLinePatterns,
  help_str : String,
}
              </defn-code>
            </defn-block>
          </div>
        </t-b>
        <t-b>
          The opt_map field is a HashMap&lt;K, V&gt; of key-value pairs, where each key is a command line
          option; that is, a character from the command line that is preceeded by a '/' character.
          If an option, o, is succeeded by a non-option string, that becomes the value. If there is no value,
          then the opt_map contains &quot;true&quot; for the value of the key o.
        </t-b>
        <t-b>
          The field, patterns, is a vector of Strings where each string is expected to be a file extension,
          e.g., rs.  Note that using *.rs will not work as expected for applications like RustTextFinder.
        </t-b>
        <t-b>
          It is expected that applications using CmdLineParser will process only files with the specified
          extensions.  If none are supplied, then the application processes all files it encounters.
        </t-b>
        <t-b>
          The field, help_str, is a String containing information to supply to the user in response to an
          option /h.  In this library, the string contains the defaults, cited above, but an application
          can change the string with <c-s>replace_help(hs&str)</c-s>.
        </t-b>
      </t-b>
      <div class="clear"></div>
      <num-cont>
        <num-item1>3.2.1</num-item1><num-item4>CmdLine Parser Methods:</num-item4>
      </num-cont>
      <t-b>
        CmdLineParser implements the following methods and functions:
        <div class="indent">
          <ol class="tight">
            <li>
              <strong><c-s>new() -> Self</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Create new <c-s>CmdLineParser</c-s> which has an options hashmap, patterns vector, and help string.
              </div>
            </li>
            <li>
              <strong><c-s>parse(&self)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Builds internal options hashmap and patterns vector.
              </div>
            </li>
            <li>
              <strong><c-s>path(&self) -> String</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Return value of relative root path, held in options map.
              </div>
            </li>
            <li>
              <strong><c-s>abs_path(&self) -> String</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Return value of absolute root path, from canonicalized relative path.
              </div>
            </li>
            <li>
              <strong><c-s>set_path(&mut self, p:&str)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Replaces value of root path, held in options map.
              </div>
            </li>
            <li>
              <strong><c-s>set_regex(&mut self, re:&str)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Replaces value of regex string, held in options map.
              </div>
            </li>
            <li>
              <strong><c-s>get_regex(&mut self) -> &str</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Retrieves value of regex string, held in options map.
              </div>
            </li>
            <li>
              <strong><c-s>default_options(&mut self)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Sets values of some of the options in options map.
              </div>
            </li>
            <li>
              <strong><c-s>contains_option(&self, opt:char) -> bool</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                returns true if options map contains key opt, else returns false.
              </div>
            </li>
            <li>
              <strong><c-s>add_option(&mut self, opt:char, val:&str)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Inserts option in options hashmap, adding key if it does not exist, else overriding previous value.
              </div>
            </li>
            <li>
              <strong><c-s>value(&self, opt:char) -> &str</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Inserts option in options hashmap, adding key if it does not exist, else overriding previous value.
              </div>
            </li>
            <li>
              <strong><c-s>add_pattern(&mut self, patt:&str) -> &mut self</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Inserts patt into patterns vector.  Method can be chained.
              </div>
            </li>
            <li>
              <strong><c-s>patterns(&self) -> &CmdLinePatterns</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Returns reference to vector of patterns.
              </div>
            </li>
            <li>
              <strong><c-s>options(&self) -> &Options</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Returns reference to hashmap of options.
              </div>
            </li>
            <li>
              <strong><c-s>help(&self) -> &str</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Returns default help string.
              </div>
            </li>
            <li>
              <strong><c-s>replace_help(&mut self, hs:&str)</c-s></strong>
              <div style="padding:3px 10px 5px 10px;">
                Replace internal help string.
              </div>
            </li>
          </ol>
        </div>
      </t-b>
      <t-b>
        Code for CmdLineParser library and a demonstration program are provided in the dropdown, below.
      </t-b>
      <t-b>
        <div>
          <details>
            <summary class="labelStyle darkItem">CmdLineParser Implementation</summary>
            <defn-outerBlock>
              <defn-block>
                <defn-head>CmdLineParser lib.rs</defn-head>
                <defn-code>
/////////////////////////////////////////////////////////////
// rust_cmd_line::lib.rs                                   //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 19 Apr 2020  //
/////////////////////////////////////////////////////////////

use std::env::{args};
use std::collections::HashMap;
use std::fs::*;

/////////////////////////////////////////////////////////////
// sample command line with options
//-----------------------------------------------------------
// /P "." /p "rs,txt" /s [true] /r "abc" /h [true] /H [true]
//
// P - path in either absolute or relative form
// p - pattern, a file extension indicating file to process
// s - recurse directory tree rooted at P
// r - regular expression
// H - hide directories that don't contain any target files
// h - help: display this message
// custom option:
// /x [v] - x is application specific option which may
//          have value, v
// Note:
// Any attribute that has no value on command line will
// have value "true" in option map
/////////////////////////////////////////////////////////////
// CmdLineParse methods
//-----------------------------------------------------------
// new() -&gt; CmdLineParse
// parse(&amp;self)
// contains_option(&amp;self, opt: char) -&gt; bool
// value(&amp;self, char opt) -&gt; &amp;str
// options(&amp;self) -&gt; &amp;HashMap&lt;char, String&gt;
// - defaults are created with default_options():
//   - /P "."    - root search path is current directory
//   - /s "true" - recurse
//   - /r "."    - match all text
//   - /H "true" - hide unused directories
//   - no patterns are equivalent to all files
// path(&amp;self) -&gt; String
// abs_path(&amp;self) -&gt; String
// set_path(&amp;self, p:&amp;str)
// patterns(&amp;self) -&gt; &amp;Vec&lt;String&gt;
// add_pattern(&amp;mut self, p:&amp;str) -&gt; &amp;mut self
// set_regex(&amp;mut self, re:&amp;str)
// get_regex(&amp;self) -&gt; &amp;str
// help(&amp;self) -&gt; String
// replace_help(&amp;mut self, &amp;str) -&gt; String

/// display command line arguments
pub fn show_cmd_line() {
    print!("\n  {:?}\n  ", args().next());
    for arg in args().skip(1) {
        print!("{:?} ", arg)
    }
}

pub type Options = HashMap&lt;char, String&gt;;
pub type CmdLinePatterns = Vec&lt;String&gt;;

/// Parses command line into options and patterns
#[derive(Debug, Default)]
pub struct CmdLineParse {
    opt_map : Options,
    patterns : CmdLinePatterns,
    help_str : String,
}
impl CmdLineParse {
    /// create new instance of parser
    pub fn new() -&gt; Self {
        let help = CmdLineParse::help_txt();
        Self {
            opt_map: Options::default(),
            patterns: CmdLinePatterns::new(),
            help_str: help,
        }
    }
    /// returns string with command line arguments example
    fn help_txt() -&gt; String {
        let mut str =
        "\n  Help:\n  Options: /P . /p \"rs,txt\"".to_string();  
        str.push_str(" /s /r \"abc\" /H /h"); 
        str
    }
    /// does the command line argument start with '/'
    fn is_opt(&amp;self, s:&amp;str) -&gt; bool {
        let bytes = s.as_bytes();
        bytes[0] as char == '/'
    }
    /// returns path string with default value "."
    pub fn path(&amp;self) -&gt; String {
        if self.contains_option('P') {
            self.opt_map[&amp;'P'].clone()
        }
        else {
            ".".to_string()
        }
    }

    /// replace Win path separator "\\" with Linux "/"
    /// - use only with absolute paths for Windows 
    fn replace_sep(path: &amp;str) -&gt; String {
        let mut rtn = path.to_string();
        if rtn.contains("\\") {
            rtn = rtn.replace("\\", "/");
            rtn = rtn.chars().skip(4).collect();
        }
        rtn
    }
    /// convert relative to absolute path
    pub fn abs_path(&amp;self) -&gt; String {
        let abs = std::path::PathBuf::from(self.path());
        let rslt = canonicalize(&amp;abs);
        match rslt {
            Ok(path_buf) =&gt; {
                // print!("\n--path_buf = {:?}",path_buf);
                let ap = path_buf.to_string_lossy().to_string();
                let ap = CmdLineParse::replace_sep(&amp;ap);
                // print!("\n--abs_path = {:?}",ap);
                ap
            }
            Err(error) =&gt; error.to_string()
        }
    }
    /// set new root path
    pub fn set_path(&amp;mut self, p:&amp;str) {
        self.opt_map.insert('P', p.to_string());
    }
    /// set new regex string for matching
    pub fn set_regex(&amp;mut self, re:&amp;str) {
        self.opt_map.insert('r', re.to_string());
    }
    /// return current regex string
    pub fn get_regex(&amp;self) -&gt; &amp;str {
        let re_opt = self.opt_map.get(&amp;'r');
        match re_opt {
            Some(value) =&gt; value,
            None =&gt; ".",
        }
    }
    /// commonly used default options
    pub fn default_options(&amp;mut self) {
        self.opt_map.insert('P', ".".to_string());
        self.opt_map.insert('s', "true".to_string());  
        self.opt_map.insert('r', ".".to_string());     
        self.opt_map.insert('H', "true".to_string());  
    }
    /// does options contain opt char? 
    pub fn contains_option(&amp;self, opt:char) -&gt; bool {
        self.opt_map.contains_key(&amp;opt)
    }
    /// insert {o,v} if o key doesn't exist, else overwrite v
    pub fn add_option(&amp;mut self, o:char, v:&amp;str) {
        self.opt_map.insert(o, v.to_string());
    }
    /// return option value
    pub fn value(&amp;self, opt:char) -&gt; &amp;str {
        &amp;self.opt_map[&amp;opt]
    }
    /// add file ext (with no "*.")
    pub fn add_pattern(&amp;mut self, p:&amp;str)
           -&gt; &amp;mut Self {
        let s = String::from(p);
        if !self.patterns.contains(&amp;s) {
            self.patterns.push(s);
        }
        self
    }
    /// returns non-mutable reference to patterns
    pub fn patterns(&amp;self) -&gt; &amp;CmdLinePatterns {
        &amp;self.patterns
    }
    /// returns non-mutable reference to options
    pub fn options(&amp; self) -&gt; &amp;Options {
        &amp;self.opt_map
    }
    /// return help string
    pub fn help(&amp;self) -&gt; &amp;str {
        &amp;self.help_str
    }
    /// replace help string
    pub fn replace_help(&amp;mut self, s:&amp;str) {
        self.help_str = s.to_string();
    }
    /// parse command line arguments, provided by env()
    pub fn parse(&amp;mut self) {
    
        let cl_args:Vec&lt;String&gt; = args().collect();
        let end = cl_args.len();
        for i in 1..end {
            if self.is_opt(&amp;cl_args[i]) {
                let bytes = cl_args[i].as_bytes();
                let key = bytes[1] as char;
                if i &lt; end - 1 {
                    if !self.is_opt(&amp;cl_args[i+1]) {
                        self.opt_map.insert(
                            key,cl_args[i+1].to_string()
                        );
                    }
                    else {
                        self.opt_map.insert(
                            key, "true".to_string()
                        );
                    }
                }
                else {
                    self.opt_map.insert(
                        key, "true".to_string()
                    );
                }
            }
        }
        /*-- build patterns --*/
        if self.contains_option('p') {
            let pat_str = self.value('p').to_string();
            let split_iter = pat_str.split(',');
            for patt in split_iter {
                self.add_pattern(patt);
            }
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn cl_args() {
        let _mock_args = vec!["/P", ".", "/p", "rs,txt", "/s"];
        print!("\n  cl args: ");
        for arg in args() {
            print!("{:?} ", arg);
        }
        let mut parser = CmdLineParse::new();
        parser.parse();
        for arg in args() {
            let bytes = arg.as_bytes();
            if '/' == (bytes[0] as char) {
                assert!(
                    parser.opt_map.contains_key(
                        &amp;(bytes[1] as char)
                  )
                );
            }
        }
    }
}
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Example program</defn-head>
                <defn-code>
/////////////////////////////////////////////////////////////
// rust_cmd_line::test1.rs                                 //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 19 Apr 2020  //
/////////////////////////////////////////////////////////////

use rust_cmd_line::*;

fn main() {

    print!("\n  Command line arguments:");
    show_cmd_line();

    let mut parser = CmdLineParse::new();
    // let mut parser = CmdLineParse::default();
    parser.default_options();
    print!("\n  {}\n",parser.help());
    parser.parse();
    print!("\n  path     = {:?}", parser.path());
    print!("\n  abspath  = {:?}", parser.abs_path());
    let new_path = "C:/github/foo";
    parser.set_path(new_path);
    print!("\n  setting path to {:?}", new_path);
    print!("\n  path     = {:?}", parser.path());
    parser.add_pattern("rs");
    parser.add_pattern("rs");  // is not repeated
    parser.add_pattern("exe");
    let patts = parser.patterns();
    print!("\n  patts    = {:?}", patts);
    print!("\n  regex    = {:?}", parser.get_regex());
    let opts = parser.options();
    print!("\n  opts     = {:#?}", opts);
    print!("\n\n  adding option {{x,false}}");
    parser.add_option('x', "false");
    let opts = parser.options();
    print!("\n  opts     = {:#?}", opts);
    print!("\n\n  adding option {{x,true}}");
    parser.add_option('x', "true");
    let opts = parser.options();
    print!("\n  opts     = {:#?}", opts);

    print!("\n\n  That's all Folks!\n\n")
}
                </defn-code>
                <defn-head class="defnBorderTop">Output:</defn-head>
                <defn-code>
  Command line arguments:
  
  Help:
  Options: /P . /p "rs,txt" /s /r "abc" /H /h

  path     = "."
  abspath  = "C:/github/JimFawcett/RustCmdLine"
  setting path to "C:/github/foo"
  path     = "C:/github/foo"
  patts    = ["rs", "exe"]
  regex    = "."
  opts     = {
    'r': ".",
    'H': "true",
    's': "true",
    'P': "C:/github/foo",
}

  adding option {x,false}
  opts     = {
    'x': "false",
    'r': ".",
    'H': "true",
    's': "true",
    'P': "C:/github/foo",
}

  adding option {x,true}
  opts     = {
    'x': "true",
    'r': ".",
    'H': "true",
    's': "true",
    'P': "C:/github/foo",
}

  That's all Folks!
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </details>
        </div>
      </t-b>
      The CmdLineParser library is used in the <a href="RustTextFinder.html">RustTextFinder</a> application.
      I expect to use it for many more tools.
    </indent-blocks>

    <a id="dirnav"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.3</num-item1><num-item4>Directory Navigator Library:</num-item4>
    </num-cont>

    <a id="unittest"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.4</num-item1><num-item4>Unit Tests:</num-item4>
    </num-cont>

    <a id="examples"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.5</num-item1><num-item4>Library Demo Examples:</num-item4>
    </num-cont>

    <a id="docs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.6</num-item1><num-item4>Library Documentation:</num-item4>
    </num-cont>

    <a id="epilogue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.7</num-item1><num-item4>Epilogue:</num-item4>
    </num-cont>

    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>3.8</num-item1><num-item4>References:</num-item4>
    </num-cont>

  </bb-55>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>