<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_ClassRelationships.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>C++ Story-ClassRel</title>
  <script src="js/ScriptsUtilities.js"></script>
  <!--<script src="js/ScriptsTemplate.js"></script>-->
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Templates.html">N</a>
  <a id="Prev" href="CppStory_Classes.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #5 - C++ Class Relationships</h1>
      <h3 id="subtitle">inheritance, composition, aggregation, using</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <div>
    <num-cont>
      <num-item1>5.0</num-item1><num-item4>Class Relationships</num-item4>
    </num-cont>
    <t-b class="indents">
    Object-oriented design and implementation consists of constructing of classes and binding them together
    with class relationships.  There are five relations: inheritance, composition, aggregation, using, and friendship.
    Of these, all but the last are found in many implementations of C++ programs.
    </t-b>
    <hr class="spread" />
    <num-cont>
      <num-item1>5.1</num-item1><num-item4>Defining Class Relationships:</num-item4>
    </num-cont>
    <photosizer-block src="Pictures/ClassRelationships.JPG" width="500" class="photoSizerBlock right">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 1. Class Relationships
      </span>
    </photosizer-block>
    <t-b class="indents">
    It is surprising, that virtually all domain models can be represented by classes using these four relationships.
    <ol class="tight">
      <li>
        <strong>Inheritance:</strong>
        <div>
          Models an &quot;is-a&quot; relationship, e.g., a derived class is a specialization of its base.
          The base class is always an inner part of the derived - it resides within the memory footprint
          of the derived class.
        </div>
      </li>
      <li>
        <strong>Composition:</strong>
        <div>
          Represents a strong &quot;part-of&quot; relationship.  The composer always contains its composed parts.
          They have the same life-times, and the parts reside within the memory footprint of the composer.
        </div>
      </li>
      <li>
        <strong>Aggregation:</strong>
        <div>
          Represents a weaker &quot;part-of&quot; relationship.  The aggregator holds a reference to the
          aggregated, e.g., usually a pointer to an instance of the aggregated, created by the aggregator,
          in the native heap.  They do not have the same life-times, and the parts reside outside the memory
          footprint of their aggregator.
        </div>
      </li>
      <li>
        <strong>Using:</strong>
        <div>
          This is a non-owning relationship.  The user holds a reference to the
          used, e.g., a pointer to an instance of the used, passed as an argument of a user method.
          The used lifetime is independent of the user, but for correctness, it must be concurrent
          with the user's access.  Used resides outside the memory footprint of the user. 
        </div>
      </li>
    </ol>
    </t-b>
    <div class="clear"></div>
    <hr class="spread" />
    <num-cont>
      <num-item1>5.2</num-item1><num-item4>Object Layout:</num-item4>
    </num-cont>
    <photosizer-block src="Pictures/ObjectRelationships.JPG" width="500" class="photoSizerBlock right">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 2. Object Layout
      </span>
    </photosizer-block>
    <t-b class="indents">
    In Fig 2. we show a compound object, defined by the classes B, C, D, and U. The corresponding objects
    are shown in the bottom
    half of the Figure.  They are shown using two dimensions for clarity of presentations, but are actually 
    simply segments in a section of the process&apos;s virtual address space.
    <spacer-15></spacer-15>
    There are several things to note about the object layout:
    <ol class="tight">
      <li>
        class B composes C with the result that C lies inside the memory footprint of B.
      </li>
      <li>
        class D derives publically from B and B&apos;s memory footprint lies entirely inside that of D.
      </li>
      <li>
        D uses an instance of class U so U&apos;s footprint is disjoint from that of D.
      </li>
      <li>
        Client aggregates an instance of D and their footprints are disjoint.
      </li>
      <li>
        A friend class has access to D&apos;s private members but the footprints of friend and D are disjoint.
      </li>
      <li>
        The bumps on the top of the objects represent their public member functions. D shares all the member
        functions of B (unaffected by access specification) but may also declare new public functions.
      </li>
    </ol>
    <s-15px></s-15px>
    Consequences of this object structure are:
    <ol class="tight">
      <li>
        When <c-s>D</c-s>&apos;s constructor is called, it must construct its inner <c-s>B</c-s>, usually by 
        explicitly invoking a <c-s>B</c-s> constructor in its initialization sequence - more about that later.
      </li>
      <li>
        When <c-s>B</c-s> is constructed by <c-s>D</c-s> its first action is to construct its inner <c-s>C</c-s>, 
        usually in its initialization sequence.
      </li>
      <li>
        <c-s>D</c-s>&apos;s construction is independent of the lifetime of <c-s>u &epsilon; U</c-s>. That means
        that our design must insure that <c-s>u</c-s> is in a valid state when <c-s>D</c-s> invokes its methods.
      </li>
    </ol>
    </t-b>
    <div class="clear"></div>
    <hr class="spread" />
    <num-cont>
      <num-item1>5.3</num-item1><num-item4>Compound Object Layout Demonstration:</num-item4>
    </num-cont>
    <t-b class="indents">
    Demonstration code in the details dropdown, below, has the same structure as shown in Fig 2.  Each
    class instance displays its memory footprint on the console when its say() method is called.
    </t-b>
    <spacer-10px></spacer-10px>
    <details>
      <summary class="labelStyle lightItem">Demo - Class Layout</summary>
      <s-10px></s-10px>
      <div tabindex="0" class="autoX">
      <table class="codeTable">
        <tr>
          <td style="margin:0px; padding:0px; font-size:0.9em;">
        <defn-block style="margin:0px; border:none;">
          <defn-head style="border:none;">
            <span class="notice">Class Layout Code:</span>
          </defn-head>
          <defn-code tabindex="0" style="border:none; border-top:2px solid darkred;">
  /////////////////////////////////////////////////////////
  // Used class is used by Derived, shows its statistics

  class Used
  {
  public:
    Used(const std::string& msg) : msg_(msg)
    {
      std::cout << "\n  Used(const std::string&) called";
    }
    ~Used() { std::cout << "\n  ~Used() called"; }
    void say()
    {
      std::cout << "\n\n  Used::say()";
      showStatistics(this);
      showString("Used", msg_);
    }
  private:
    std::string msg_;
  };
  /////////////////////////////////////////////////////////
  // Composed class is a data member of Base, 
  // shows its statistics

  class Composed
  {
  public:
    Composed(const std::string& msg) : msg_(msg)
    {
      std::cout << "\n  Composed(const std::string&) called";
    }
    ~Composed() { std::cout << "\n  ~Composed() called"; }
    void say()
    {
      std::cout << "\n\n  Composed::say()";
      showStatistics(this);
      showString("Composed", msg_);
    }
  private:
    std::string msg_;
  };
  /////////////////////////////////////////////////////////
  // Base class holds Composed and displays 
  // its layout statistics

  class Base
  {
  public:
    Base(const std::string& msg) : composed_(msg)
    {
      std::cout << "\n  Base(const std::string&) called";
    }

    // If you remove virtual qualifier on ~Base() only 
    // Base destructor is called in main when created
    // on heap.  Both called if created on stack.

    virtual ~Base()
    {
      std::cout << "\n  ~Base() called";
    }
    virtual void say()
    {
      std::cout << "\n\n  Base::say()";
      showStatistics(this);
      std::cout << "\n\n  Base invoking my Composed::say(): ";
      composed_.say();
    }
  protected:
    Composed composed_;
  };
  /////////////////////////////////////////////////////////
  // Derived inherits from Base and displays 
  // its layout statistics.

  class Derived : public Base
  {
  public:
    Derived(const std::string& msg) : Base(msg)
    {
      std::cout << "\n  Derived(const std::string&) called";
    }
    ~Derived() { std::cout << "\n  ~Derived() called"; }
    virtual void say(Used& used)
    {
      std::cout << "\n\n  Derived::say()";
      showStatistics(this);

      std::cout << "\n\n  Derived calling Base::say(): ";
      Base::say();
      std::cout << std::endl;

      std::cout << "\n\n  Derived calling Used::say(): ";
      used.say();
      std::cout << std::endl;
    }
  private:
  };


          </defn-code>
        </defn-block>
          </td>
          <td style="margin:0px; padding:0px; font-size:0.9em;"">
        <defn-block style="margin:0px; border:none;">
          <defn-head style="border:none;">
            <span class="notice">Using Code:</span>
          </defn-head>
          <defn-code tabindex="1" style="border:none; border-top:2px solid darkred;">
  std::string arg = "string entered as constructor argument";
  std::cout << "\n  String, below, will be used in this demonstration:";
  std::cout << "\n    \"" << arg << "\"";
  std::cout << "\n  It's object size is " << sizeof(arg) << " bytes";
  std::cout << "\n  It contains " << arg.size() << " characters\n";

  std::cout << "\n  creating used object on stack";
  std::cout << "\n -------------------------------";
  Used u(arg);
  u.say();

  std::cout << std::endl;

  std::cout << "\n  creating base object on stack";
  std::cout << "\n -------------------------------";
  Base b(arg);
  b.say();

  std::cout << std::endl;

  /////////////////////////////////////////////////////////
  // Works same whether Derived created on stack or heap,
  // but you will notice differences in the region of
  // memory occupied
  
  std::cout << "\n  creating derived object on stack";
  std::cout << "\n ----------------------------------";
  Derived d(arg);
  d.say(u);

  std::cout << "\n  creating derived object on heap";
  std::cout << "\n ---------------------------------";
  Base* pB = new Derived(arg);
  pB->say();
  delete pB;
          </defn-code>
          <defn-head style="border:none; border-top:2px solid darkred;">
            <span class="notice">Output:</span>
          </defn-head>
          <defn-code tabindex="2" style=" border:none; border-top:2px solid darkred;">
  creating derived object on stack
 ----------------------------------
  Composed(const std::string&) called
  Base(const std::string&) called
  Derived(const std::string&) called

  Derived::say()
  class Derived
  my size is: 32 bytes -- holds Base and Composed
  my starting address is 6420740 (0x61F904)
  my ending address is   6420772 (0x61F924)

  Derived calling Base::say():

  Base::say()
  class Derived
  my size is: 32 bytes -- holds string and pointer to vtbl
  my starting address is 6420740 (0x61F904)
  my ending address is   6420772 (0x61F924)

  Base invoking my Composed::say():

  Composed::say()
  class Composed
  my size is: 28 bytes -- holds string
  my starting address is 6420744 (0x61F908)
  my ending address is   6420772 (0x61F924)
  "This Composed string entered as constructor argument" has 54 characters

  Derived calling Used::say():

  Used::say()
  class Used
  my size is: 28 bytes
  my starting address is 6420820 (0x61F954)
  my ending address is   6420848 (0x61F970)
  "This Used string entered as constructor argument" has 50 characters

  creating derived object on heap
 ---------------------------------
  Composed(const std::string&) called
  Base(const std::string&) called
  Derived(const std::string&) called

  Base::say()
  class Derived
  my size is: 32 bytes -- holds string and pointer to vtbl
  my starting address is 12524472 (0xBF1BB8)
  my ending address is   12524504 (0xBF1BD8)

  Base invoking my Composed::say():

  Composed::say()
  class Composed
  my size is: 28 bytes -- holds string
  my starting address is 12524476 (0xBF1BBC)
  my ending address is   12524504 (0xBF1BD8)
  "This Composed string entered as constructor argument" has 54 characters
          </defn-code>
        </defn-block>
          </td>
        </tr>
      </table>
      </div>
    </details>
    <spacer-10></spacer-10>
    <t-b class="indents">
    Looking at the demonstration output we see instance memory start and end points as shown in Table&nbsp;1.
    This data is consistant with the layout properties shown in Fig.&nbsp;1. This inclusion of bases and members
    is a fundamental part of the object model for C++ value types.
    </t-b>

    <spacer-10></spacer-10>
    <h4 class="indents">Table 1. - Memory Footprints of Class Layout Instances</h4>
    <table class="indent pad10">
      <tr>
        <th class="darkItem">class</th>
        <th class="darkItem">start</th>
        <th class="darkItem">end</th>
        <th class="darkItem">size</th>
        <th class="darkItem">parts</th>
      </tr>
      <tr>
        <td><c-s>Derived</c-s></td><td>2096532 (0x1FFD94)</td><td>2096564 (0x1FFDB4)</td><td>32 bytes</td>
        <td><c-s>Base</c-s> (32 bytes - including slot for VFPT pointer)</td>
      </tr>
      <tr>
        <td><c-s>Base</c-s></td><td>2096532 (0x1FFD94)</td><td>2096564 (0x1FFDB4)</td><td>32 bytes</td>
        <td><c-s>Composed</c-s> (28 bytes) + VFPT pointer</td>
      </tr>
      <tr>
        <td><c-s>Composed</c-s></td><td>2096536 (0x1FFD98)</td><td>2096564 (0x1FFDB4)</td><td>28 bytes</td>
        <td><c-s>std::string</c-s> (28 bytes)</td>
      </tr>
      <tr>
        <td>Used</td><td>2096612 (0x1FFDE4)</td><td>2096640 (0x1FFE00)</td><td>28 bytes</td>
        <td><c-s>std::string</c-s> (28 bytes)</td>
      </tr>
    </table>
    <spacer-15></spacer-15>
    <t-b class="indents">
    The <c-s>Composed</c-s> class instance holds a <c-s>std::string</c-s> which has a size of 28 bytes.
    The <c-s>Base</c-s> instance holds a composed instance plus a Virtual Function Pointer Table (VFPT) pointer
    which is 4 bytes.
    The <c-s>Derived</c-s> instance holds its inner <c-s>Base</c-s> instance plus its VFPT pointer, placed
    in the slot its inner <c-s>Base</c-s> provides.
    <spacer-15></spacer-15>
    If you look at the code you will see that each including class has constructors with initialization
    sequences.  Here&apos;s code snippets that show them. When the <c-s>Derived</c-s> class is constructed
    it calls the <c-s>Base</c-s> constructor for its inner <c-s>Base</c-s> part in its initialization sequence.  
    When the <c-s>Base</c-s> inner instance is constructed it calls the <c-s>Composed</c-s> constructor on
    its inner composed part.  Similarly, the <c-s>Composed</c-s> part constructs its inner <c-s>std::string</c-s>.
    </t-b>
    <spacer-15></spacer-15>
    <defn-block class="indents">
      <defn-head>
        <span class="notice">Constructor Initialization Sequences</span>
      </defn-head>
      <defn-code style="border-top:2px solid darkred;">
  Derived(const std::string& msg) : Base(msg)
  {
    std::cout << "\n  Derived(const std::string&) called";
  }

  Base(const std::string& msg) : composed_(msg)
  {
    std::cout << "\n  Base(const std::string&) called";
  }

  Composed(const std::string& msg) : msg_(msg)
  {
    std::cout << "\n  Composed(const std::string&) called";
  }
      </defn-code>
    </defn-block>
    <spacer-25></spacer-25>
    <t-b class="indents">
    We didn&apos;t have to implement copy constructors, copy assignment operators, and destructors because
    the compiler generated value methods are correct.  The <c-s>Composed</c-s> data member of <c-s>Base</c-s>
    is a <c-s>std::string</c-s> which has the value methods.  And the <c-s>Base</c-s> from which <c-s>Derived</c-s>
    inherits has correct compiler generated value methods.
    <spacer-15></spacer-15>
    We did implement destructors for each class to announce when each instance was destroyed.  Otherwise, we
    could have allowed the compiler to generate those too.
    </t-b>

    <hr class="spread clear" />
    <num-cont>
      <num-item1>5.4</num-item1><num-item4>Inheritance, Run-Time Polymorphism, and Virtual Dispatching:</num-item4>
    </num-cont>
    Inheritance relationships afford a very powerful sharing and reuse mechanism through substitution.
    <t-b>
      For any Base-Derived relationship:
      <i-b class="pad10">
        <c-s>class Derived : public Base { ... };</c-s>
      </i-b>
      Derived class instances have the properties:
      <s-10px></s-10px>
      <ul class="tight">
        <li>
          Any Derived instance can be bound to a Base pointer:
          <defn-block class="pad10-15 indent">
            <c-s>
              Derived d;<br />
              Base* pBase = &amp;d;
            </c-s>
          </defn-block>
        </li>
        <li>
          Any virtual function in the Base class can be redefined in the Derived class:
          <defn-block class="pad10-15 indent">
            <c-b>class Base {
public:
  virtual void f() { ... };
  ... 
};

class Derived : public Base {
public:
  void f() override { ... }
  ...
};</c-b>
          </defn-block>
        </li>
        <li>
          When dispatching calls:
          <defn-body class="pad10-15 indent">
            If <c-s>pBase</c-s> is bound to a Base instance, <c-s>pBase->f()</c-s> calls <c-s>Base::f()</c-s><br />
            If <c-s>pBase</c-s> is bound to a Derived instance, <c-s>pBase->f()</c-s> calls <c-s>Derived::f()</c-s>
          </defn-body>
        </li>
      </ul>
    </t-b>
    Now, suppose that we define a function:
    <t-b>
    <c-b>  void g(pBase* ptr) {
    ptr->f();
  }</c-b>
    </t-b>
    <t-b>
      If <c-s>ptr</c-s> is bound to a <c-s>Base</c-s> instance then <c-s>Base::f()</c-s> is called.
      If <c-s>ptr</c-s> is bound to a <c-s>Derived</c-s> instance, then <c-s>Derived::f()</c-s> is called.
    </t-b>
    <t-b>
      So <c-s>g(pBase* ptr)</c-s> invokes functions based on the type of the object reference, not the
      static type of ptr.  Function <c-s>g</c-s> doesn&apos;t need to know anything about the Base class
      hierarchy.  It only needs to know the public interface of the <c-s>Base</c-s> class.
    </t-b>
    <t-b>
      At any time, if we add a new class derived from <c-s>Base</c-s>, then <c-s>g</c-s>, with no changes,
      will process it correctly. This is a very important behavior. So important that it has been given
      a name: Liskov Substitution.
    </t-b>
    <s-5px></s-5px>
    <defn-block>
      <defn-head>
        <span class="notice">Liskov Substitution</span>
      </defn-head>
      <defn-body>
        Barbara Liskov authored a paper &quot;Data Abstraction&quot; in which she provided
        a useful model for polymorphism, which I&apos;ve paraphrased in a way appropriate for C++:
        <indent-block class="pad10">
          Functions that accept pointers or C++ references statically typed to some base class must be able
          to use objects of classes derived from the base through those pointers or references without any
          knowledge specialized to the derived classes.
        </indent-block>
        <t-b>
          That means that within the function any method invocation made through the base pointer will
          invoke that method based on the type of the derived class instance bound to that pointer.
        </t-b>
      </defn-body>
    </defn-block>
    <num-cont>
      <num-item1>5.41</num-item1><num-item4>Virtual Dispatching via Virtual Function Pointer Table:</num-item4>
    </num-cont>
    <photosizer-block src="Pictures/Polymorphism.jpg" width="500" class="photoSizerBlock right clear">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 3. Virtual Function Pointer Tables
      </span>
    </photosizer-block>
    <t-b>
      Virtual function dispatching, as described above, is implemented with 
      <span class="notice">virtual function pointer tables</span>.  Each class with one or more virtual methods
      has an associated Virtual Function Pointer Table (VFPT) and each instance of that class contains a pointer,
      <c-s>pVtbl</c-s>, pointing to its VFPT.
    </t-b>
    <t-b>
      In Fig 3., we&apos;ve shown a class hierarchy with base class <c-s>B</c-s> and derived class <c-s>D</c-s>.
      Comparing the class declarations we see that:
      <ol class="tight">
        <li>
          <c-s>D</c-s> does not override <c-s>B::mf1</c-s>, so its virtual function pointer, 
          <c-s>pMf1</c-s>, binds to <c-s>B::mf1</c-s>
        </li>
        <li>
          <c-s>D</c-s> does override <c-s>B::mf2</c-s>, so its virtual function pointer,
          <c-s>pMf2</c-s>, binds to <c-s>D::mf2</c-s>
        </li>
        <li>
          <c-s>D</c-s> adds a new virtual function, <c-s>mf3</c-s>.  This function cannot be invoked
          from a <c-s>B*</c-s> pointer, because it is not part of the public <c-s>B</c-s> interface.
        </li>
        <li>
          <c-s>D</c-s> overrides the <span class="notice">private</span> method <c-s>B::name</c-s>.
          That function is called only by the non-virtual <c-s>B::who</c-s>.  Since that function is
          public, but non-virtual, <c-s>D</c-s> inherits <c-s>who</c-s>, so clients of <c-s>D</c-s>
          can call it, but <c-s>D</c-s> should not change it (because it&apos;s non-virtual).
        </li>
        <li>
          Remember that a derived class holds an image of its base within its memory footprint.
          We see that here, as the <c-s>D</c-s> image holds <c-s>B</c-s>&apos;s virtual function table
          pointer slot, which it uses to hold a pointer to its own VFPT, and <c-s>B::name</c-s>.  
          To that it adds its own member data: <c-s>D::name</c-s>.
        </li>
      </ol>
      <s-10px></s-10px>
      The details dropdown, below, presents code for this demonstration and its output.
    </t-b>
    <div class="clear">
      <details>
        <summary class="labelStyle lightItem">
          <span class="notice">Polymorphism Demo</span>
        </summary>
          <s-10px></s-10px>
          <div tabindex="2" class="autoX">
            <h3>Table 2. - Polymorphism Demo</h3>
            <table class="codeTable">
              <tr>
                <td style="padding:0px;">
                  <defn-block style="border:none; margin:0px; padding:0px; font-size:0.9rem;">
                    <defn-head style="border:none;">
                      <span class="notice">Demo Code</span>
                    </defn-head>
                    <defn-code style="margin:0px; border:none; border-top:2px solid darkred;">
  class B {
  public:
    B(const std::string& name);
    virtual ~B() {}
    virtual void mf1();
    virtual void mf2();
    void who();
  private:
    virtual std::string name();
    std::string name_;
  };

  B::B(const std::string& name) : name_(name) {}

  void B::mf1() {
    std::cout << "\n  B::mf1() invoked";
  }

  void B::mf2() {
    std::cout << "\n  B::mf2() invoked";
  }

  std::string B::name() { return name_; }

  void B::who() { 
    std::cout << "\n  who returns name " << this->name(); 
  }

  class D : public B {
  public:
    D(const std::string& name);
    virtual ~D() {}
    virtual void mf2() override;
    virtual void mf3();
  private:
    virtual std::string name() override;
    std::string name_;
  };

  D::D(const std::string& name) : B("B"), name_(name) {}

  void D::mf2() {
    std::cout << "\n  D::mf2() invoked";
  }

  void D::mf3() {
    std::cout << "\n  D::mf3() invoked";
  }

  std::string D::name() { return name_; }
                    </defn-code>
                  </defn-block>
                </td>
                <td style="padding:0px;">
                  <defn-block style="border:none; margin:0px; padding:0px;">
                    <defn-head style="border:none;">
                      <span class="notice">Using Code</span>
                    </defn-head>
                    <defn-code style="margin:0px; border:none; border-top:2px solid darkred;">
  displayDemo("--- polymorphism demo ---");

  displayDemo("\n  create B and invoke its methods");
  B b{ "B" };
  b.who();
  b.mf1();
  b.mf2();

  displayDemo("\n  create D and invoke its methods");
  D d{ "D" };
  d.who();
  d.mf1();
  d.mf2();
  d.mf3();

  displayDemo(
    "\n  create B* pB = &b, and invoke methods"
  );
  B* pB = &b;
  pB->who();
  pB->mf1();
  pB->mf2();

  displayDemo(
    "\n  create B* pB = &d, and invoke methods"
  );
  pB = &d;
  pB->who();
  pB->mf1();
  pB->mf2();
  //pB->mf3();  
  //won't compile: mf2 not in base interface

  D* pD = dynamic_cast<D*>(pB);
  if (pD)
    pD->mf3();

                    </defn-code>
                    <defn-head style="border:none;">
                      <span class="notice">Output</span>
                    </defn-head>
                    <defn-code style="margin:0px; border:none; border-top:2px solid darkred;">
  --- polymorphism demo ---

  create B and invoke its methods
  who returns name B
  B::mf1() invoked
  B::mf2() invoked

  create D and invoke its methods
  who returns name D
  B::mf1() invoked
  D::mf2() invoked
  D::mf3() invoked

  create B* pB = &b, and invoke methods
  who returns name B
  B::mf1() invoked
  B::mf2() invoked

  create B* pB = &d, and invoke methods
  who returns name D
  B::mf1() invoked
  D::mf2() invoked
  D::mf3() invoked
                    </defn-code>
                  </defn-block>
                </td>
              </tr>
            </table>
          </div>
      </details>
    </div>
    


    <num-cont class="clear">
      <num-item1>5.5</num-item1><num-item4>Person Hierarhy Example:</num-item4>
    </num-cont>

        For the Person class hierarchy shown in Fig.3, if the base Person class provides a virtual method <c-s>void doWork()</c-s>,
        and the derived Dev, QA, TeamLead, and ProjectMgr classes each redefine that in a way appropriate for their job
        descriptions, Then any code that holds a Person pointer, bound to one of the derived classes, can invoke doWork()
        resulting in processing appropriate for the specific derived class.
        <indent-block class="pad10 codeStyle">
  Dev dev;<br />
  Person* pPerson = &dev;<br />
  pPerson->doWork();
        </indent-block>
        results in work done as a developer, and:
        <indent-block class="pad10 codeStyle">
  ProjectMgr pMgr;<br />
  pPerson = &pMgr;<br />
  pPerson->doWork();
        </indent-block>
        results in work done as a project manager.
        <spacer-10></spacer-10>
      </defn-body>
    </defn-block>
    <div style="margin-top:0px; padding-top:0px;">
      <photosizer-block src="Pictures/PersonInheritance.jpg" width="400" class="photoSizerBlock">
        <span style="font-family:'Comic Sans MS, Tahoma';">
          Fig 3. Inheritance Hierarchy
        </span>
      </photosizer-block>
      </div>
    </div>


    <hr class="spread clear" />
    <num-cont>
      <num-item1>5.5</num-item1><num-item4>Example - Person Class Hierarchy:</num-item4>
    </num-cont>
    <photosizer-block src="Pictures/PersonClassHierarchy.JPG" width="400" class="photoSizerBlock right">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 4. Person Class Hierarchy
      </span>
    </photosizer-block>
    You may recall, from Chapter1 - Survey, the Person class hierarchy, used for a quick look at class relationships.
    Figure 4. shows the diagram we used there.

    <hr class="spread clear" />
    <num-cont>
      <num-item1>5.6</num-item1><num-item4>Example - CppParser:</num-item4>
    </num-cont>

    <spacer-25></spacer-25>
    <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->
  </div>
  <info-bar></info-bar>
</body>
</html>