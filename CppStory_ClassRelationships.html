<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_ClassRelationships.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>C++ Story-ClassRel</title>
  <script src="js/ScriptsUtilities.js"></script>
  <!--<script src="js/ScriptsTemplate.js"></script>-->
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Templates.html">N</a>
  <a id="Prev" href="CppStory_Classes.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #5 - C++ Class Relationships</h1>
      <h3 id="subtitle">inheritance, composition, aggregation, using</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <div>
    <num-cont>
      <num-item1>5.0</num-item1><num-item4>Class Relationships</num-item4>
    </num-cont>
    <t-b class="indents">
    Object-oriented design and implementation consists of constructing of classes and binding them together
    with class relationships.  There are five relations: inheritance, composition, aggregation, using, and friendship.
    Of these, all but the last are found in many implementations of C++ programs.
    </t-b>
    <hr class="spread" />
    <num-cont>
      <num-item1>5.1</num-item1><num-item4>Defining Class Relationships:</num-item4>
    </num-cont>
    <photosizer-block src="Pictures/ClassRelationships.JPG" width="500" class="photoSizerBlock right">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 1. Class Relationships
      </span>
    </photosizer-block>
    <t-b class="indents">
    It is surprising, that virtually all domain models can be represented by classes using these four relationships.
    <ol class="tight">
      <li>
        <strong>Inheritance:</strong>
        <div>
          Models an &quot;is-a&quot; relationship, e.g., a derived class is a specialization of its base.
          The base class is always an inner part of the derived - it resides within the memory footprint
          of the derived class.
        </div>
      </li>
      <li>
        <strong>Composition:</strong>
        <div>
          Represents a strong &quot;part-of&quot; relationship.  The composer always contains its composed parts.
          They have the same life-times, and the parts reside within the memory footprint of the composer.
        </div>
      </li>
      <li>
        <strong>Aggregation:</strong>
        <div>
          Represents a weaker &quot;part-of&quot; relationship.  The aggregator holds a reference to the
          aggregated, e.g., usually a pointer to an instance of the aggregated, created by the aggregator,
          in the native heap.  They do not have the same life-times, and the parts reside outside the memory
          footprint of their aggregator.
        </div>
      </li>
      <li>
        <strong>Using:</strong>
        <div>
          This is a non-owning relationship.  The user holds a reference to the
          used, e.g., a pointer to an instance of the used, passed as an argument of a user method.
          The used lifetime is independent of the user, but for correctness, it must be concurrent
          with the user's access.  Used resides outside the memory footprint of the user. 
        </div>
      </li>
    </ol>
    </t-b>
    <div class="clear"></div>
    <hr class="spread" />
    <num-cont>
      <num-item1>5.2</num-item1><num-item4>Object Layout:</num-item4>
    </num-cont>
    <photosizer-block src="Pictures/ObjectRelationships.JPG" width="500" class="photoSizerBlock right">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 2. Object Layout
      </span>
    </photosizer-block>
    <t-b class="indents">
    In Fig 2. we show a compound object, defined by the classes B, C, D, and U. The corresponding objects
    are shown in the bottom
    half of the Figure.  They are shown using two dimensions for clarity of presentations, but are actually 
    simply segments in a section of the process&apos;s virtual address space.
    <spacer-15></spacer-15>
    There are several things to note about the object layout:
    <ol class="tight">
      <li>
        class B composes C with the result that C lies inside the memory footprint of B.
      </li>
      <li>
        class D derives publically from B and B&apos;s memory footprint lies entirely inside that of D.
      </li>
      <li>
        D uses an instance of class U so U&apos;s footprint is disjoint from that of D.
      </li>
      <li>
        Client aggregates an instance of D and their footprints are disjoint.
      </li>
      <li>
        A friend class has access to D&apos;s private members but the footprints of friend and D are disjoint.
      </li>
      <li>
        The bumps on the top of the objects represent their public member functions. D shares all the member
        functions of B (unaffected by access specification) but may also declare new public functions.
      </li>
    </ol>
    <s-15px></s-15px>
    Consequences of this object structure are:
    <ol class="tight">
      <li>
        When <c-s>D</c-s>&apos;s constructor is called, it must construct its inner <c-s>B</c-s>, usually by 
        explicitly invoking a <c-s>B</c-s> constructor in its initialization sequence - more about that later.
      </li>
      <li>
        When <c-s>B</c-s> is constructed by <c-s>D</c-s> its first action is to construct its inner <c-s>C</c-s>, 
        usually in its initialization sequence.
      </li>
      <li>
        <c-s>D</c-s>&apos;s construction is independent of the lifetime of <c-s>u &epsilon; U</c-s>. That means
        that our design must insure that <c-s>u</c-s> is in a valid state when <c-s>D</c-s> invokes its methods.
      </li>
    </ol>
    </t-b>
    <div class="clear"></div>
    <hr class="spread" />
    <num-cont>
      <num-item1>5.3</num-item1><num-item4>Compound Object Layout Demonstration:</num-item4>
    </num-cont>
    <t-b class="indents">
    Demonstration code in the details dropdown, below, has the same structure as shown in Fig 2.  Each
    class instance displays its memory footprint on the console when its say() method is called.
    </t-b>
    <spacer-10px></spacer-10px>
    <details>
      <summary class="labelStyle lightItem">Demo - Class Layout</summary>
      <s-10px></s-10px>
      <div tabindex="0" class="autoX">
      <table class="codeTable">
        <tr>
          <td style="margin:0px; padding:0px; font-size:0.9em;">
        <defn-block style="margin:0px; border:none;">
          <defn-head style="border:none;">
            <span class="notice">Class Layout Code:</span>
          </defn-head>
          <defn-code tabindex="0" style="border:none; border-top:2px solid darkred;">
  /////////////////////////////////////////////////////////
  // Used class is used by Derived, shows its statistics

  class Used
  {
  public:
    Used(const std::string& msg) : msg_(msg)
    {
      std::cout << "\n  Used(const std::string&) called";
    }
    ~Used() { std::cout << "\n  ~Used() called"; }
    void say()
    {
      std::cout << "\n\n  Used::say()";
      showStatistics(this);
      showString("Used", msg_);
    }
  private:
    std::string msg_;
  };
  /////////////////////////////////////////////////////////
  // Composed class is a data member of Base, 
  // shows its statistics

  class Composed
  {
  public:
    Composed(const std::string& msg) : msg_(msg)
    {
      std::cout << "\n  Composed(const std::string&) called";
    }
    ~Composed() { std::cout << "\n  ~Composed() called"; }
    void say()
    {
      std::cout << "\n\n  Composed::say()";
      showStatistics(this);
      showString("Composed", msg_);
    }
  private:
    std::string msg_;
  };
  /////////////////////////////////////////////////////////
  // Base class holds Composed and displays 
  // its layout statistics

  class Base
  {
  public:
    Base(const std::string& msg) : composed_(msg)
    {
      std::cout << "\n  Base(const std::string&) called";
    }

    // If you remove virtual qualifier on ~Base() only 
    // Base destructor is called in main when created
    // on heap.  Both called if created on stack.

    virtual ~Base()
    {
      std::cout << "\n  ~Base() called";
    }
    virtual void say()
    {
      std::cout << "\n\n  Base::say()";
      showStatistics(this);
      std::cout << "\n\n  Base invoking my Composed::say(): ";
      composed_.say();
    }
  protected:
    Composed composed_;
  };
  /////////////////////////////////////////////////////////
  // Derived inherits from Base and displays 
  // its layout statistics.

  class Derived : public Base
  {
  public:
    Derived(const std::string& msg) : Base(msg)
    {
      std::cout << "\n  Derived(const std::string&) called";
    }
    ~Derived() { std::cout << "\n  ~Derived() called"; }
    virtual void say(Used& used)
    {
      std::cout << "\n\n  Derived::say()";
      showStatistics(this);

      std::cout << "\n\n  Derived calling Base::say(): ";
      Base::say();
      std::cout << std::endl;

      std::cout << "\n\n  Derived calling Used::say(): ";
      used.say();
      std::cout << std::endl;
    }
  private:
  };


          </defn-code>
        </defn-block>
          </td>
          <td style="margin:0px; padding:0px; font-size:0.9em;"">
        <defn-block style="margin:0px; border:none;">
          <defn-head style="border:none;">
            <span class="notice">Using Code:</span>
          </defn-head>
          <defn-code tabindex="1" style="border:none; border-top:2px solid darkred;">
  std::string arg = "string entered as constructor argument";
  std::cout << "\n  String, below, will be used in this demonstration:";
  std::cout << "\n    \"" << arg << "\"";
  std::cout << "\n  It's object size is " << sizeof(arg) << " bytes";
  std::cout << "\n  It contains " << arg.size() << " characters\n";

  std::cout << "\n  creating used object on stack";
  std::cout << "\n -------------------------------";
  Used u(arg);
  u.say();

  std::cout << std::endl;

  std::cout << "\n  creating base object on stack";
  std::cout << "\n -------------------------------";
  Base b(arg);
  b.say();

  std::cout << std::endl;

  /////////////////////////////////////////////////////////
  // Works same whether Derived created on stack or heap,
  // but you will notice differences in the region of
  // memory occupied
  
  std::cout << "\n  creating derived object on stack";
  std::cout << "\n ----------------------------------";
  Derived d(arg);
  d.say(u);

  std::cout << "\n  creating derived object on heap";
  std::cout << "\n ---------------------------------";
  Base* pB = new Derived(arg);
  pB->say();
  delete pB;
          </defn-code>
          <defn-head style="border:none; border-top:2px solid darkred;">
            <span class="notice">Output:</span>
          </defn-head>
          <defn-code tabindex="2" style=" border:none; border-top:2px solid darkred;">
  creating derived object on stack
 ----------------------------------
  Composed(const std::string&) called
  Base(const std::string&) called
  Derived(const std::string&) called

  Derived::say()
  class Derived
  my size is: 32 bytes -- holds Base and Composed
  my starting address is 6420740 (0x61F904)
  my ending address is   6420772 (0x61F924)

  Derived calling Base::say():

  Base::say()
  class Derived
  my size is: 32 bytes -- holds string and pointer to vtbl
  my starting address is 6420740 (0x61F904)
  my ending address is   6420772 (0x61F924)

  Base invoking my Composed::say():

  Composed::say()
  class Composed
  my size is: 28 bytes -- holds string
  my starting address is 6420744 (0x61F908)
  my ending address is   6420772 (0x61F924)
  "This Composed string entered as constructor argument" has 54 characters

  Derived calling Used::say():

  Used::say()
  class Used
  my size is: 28 bytes
  my starting address is 6420820 (0x61F954)
  my ending address is   6420848 (0x61F970)
  "This Used string entered as constructor argument" has 50 characters

  creating derived object on heap
 ---------------------------------
  Composed(const std::string&) called
  Base(const std::string&) called
  Derived(const std::string&) called

  Base::say()
  class Derived
  my size is: 32 bytes -- holds string and pointer to vtbl
  my starting address is 12524472 (0xBF1BB8)
  my ending address is   12524504 (0xBF1BD8)

  Base invoking my Composed::say():

  Composed::say()
  class Composed
  my size is: 28 bytes -- holds string
  my starting address is 12524476 (0xBF1BBC)
  my ending address is   12524504 (0xBF1BD8)
  "This Composed string entered as constructor argument" has 54 characters
          </defn-code>
        </defn-block>
          </td>
        </tr>
      </table>
      </div>
    </details>
    <spacer-10></spacer-10>
    <t-b class="indents">
    Looking at the demonstration output we see instance memory start and end points as shown in Table&nbsp;1.
    This data is consistant with the layout properties shown in Fig.&nbsp;1. This inclusion of bases and members
    is a fundamental part of the object model for C++ value types.
    </t-b>

    <spacer-10></spacer-10>
    <h4 class="indents">Table 1. - Memory Footprints of Class Layout Instances</h4>
    <table class="indent pad10">
      <tr>
        <th class="darkItem">class</th>
        <th class="darkItem">start</th>
        <th class="darkItem">end</th>
        <th class="darkItem">size</th>
        <th class="darkItem">parts</th>
      </tr>
      <tr>
        <td><c-s>Derived</c-s></td><td>2096532 (0x1FFD94)</td><td>2096564 (0x1FFDB4)</td><td>32 bytes</td>
        <td><c-s>Base</c-s> (32 bytes - including slot for VFPT pointer)</td>
      </tr>
      <tr>
        <td><c-s>Base</c-s></td><td>2096532 (0x1FFD94)</td><td>2096564 (0x1FFDB4)</td><td>32 bytes</td>
        <td><c-s>Composed</c-s> (28 bytes) + VFPT pointer</td>
      </tr>
      <tr>
        <td><c-s>Composed</c-s></td><td>2096536 (0x1FFD98)</td><td>2096564 (0x1FFDB4)</td><td>28 bytes</td>
        <td><c-s>std::string</c-s> (28 bytes)</td>
      </tr>
      <tr>
        <td>Used</td><td>2096612 (0x1FFDE4)</td><td>2096640 (0x1FFE00)</td><td>28 bytes</td>
        <td><c-s>std::string</c-s> (28 bytes)</td>
      </tr>
    </table>
    <spacer-15></spacer-15>
    <t-b class="indents">
    The <c-s>Composed</c-s> class instance holds a <c-s>std::string</c-s> which has a size of 28 bytes.
    The <c-s>Base</c-s> instance holds a composed instance plus a Virtual Function Pointer Table (VFPT) pointer
    which is 4 bytes.
    The <c-s>Derived</c-s> instance holds its inner <c-s>Base</c-s> instance plus its VFPT pointer, placed
    in the slot its inner <c-s>Base</c-s> provides.
    <spacer-15></spacer-15>
    If you look at the code you will see that each including class has constructors with initialization
    sequences.  Here&apos;s code snippets that show them. When the <c-s>Derived</c-s> class is constructed
    it calls the <c-s>Base</c-s> constructor for its inner <c-s>Base</c-s> part in its initialization sequence.  
    When the <c-s>Base</c-s> inner instance is constructed it calls the <c-s>Composed</c-s> constructor on
    its inner composed part.  Similarly, the <c-s>Composed</c-s> part constructs its inner <c-s>std::string</c-s>.
    </t-b>
    <spacer-15></spacer-15>
    <defn-block class="indents">
      <defn-head>
        <span class="notice">Constructor Initialization Sequences</span>
      </defn-head>
      <defn-code style="border-top:2px solid darkred;">
  Derived(const std::string& msg) : Base(msg)
  {
    std::cout << "\n  Derived(const std::string&) called";
  }

  Base(const std::string& msg) : composed_(msg)
  {
    std::cout << "\n  Base(const std::string&) called";
  }

  Composed(const std::string& msg) : msg_(msg)
  {
    std::cout << "\n  Composed(const std::string&) called";
  }
      </defn-code>
    </defn-block>
    <spacer-25></spacer-25>
    <t-b class="indents">
    We didn&apos;t have to implement copy constructors, copy assignment operators, and destructors because
    the compiler generated value methods are correct.  The <c-s>Composed</c-s> data member of <c-s>Base</c-s>
    is a <c-s>std::string</c-s> which has the value methods.  And the <c-s>Base</c-s> from which <c-s>Derived</c-s>
    inherits has correct compiler generated value methods.
    <spacer-15></spacer-15>
    We did implement destructors for each class to announce when each instance was destroyed.  Otherwise, we
    could have allowed the compiler to generate those too.
    </t-b>

    <hr class="spread clear" />
    <num-cont>
      <num-item1>5.4</num-item1><num-item4>Inheritance, Run-Time Polymorphism, and Virtual Dispatching:</num-item4>
    </num-cont>
    Inheritance relationships afford a very powerful sharing and reuse mechanism through substitution.
    <t-b>
      For any Base-Derived relationship:
      <i-b class="pad10">
        <c-s>class Derived : public Base { ... };</c-s>
      </i-b>
      Derived class instances have the properties:
      <s-10px></s-10px>
      <ul class="tight">
        <li>
          Any Derived instance can be bound to a Base pointer:
          <defn-block class="pad10-15 indent">
            <c-s>
              Derived d;<br />
              Base* pBase = &amp;d;
            </c-s>
          </defn-block>
        </li>
        <li>
          Any virtual function in the Base class can be redefined in the Derived class:
          <defn-block class="pad10-15 indent">
            <c-b>class Base {
public:
  virtual void f() { ... };
  ... 
};

class Derived : public Base {
public:
  void f() override { ... }
  ...
};</c-b>
          </defn-block>
        </li>
        <li>
          When dispatching calls:
          <defn-body class="pad10-15 indent">
            If <c-s>pBase</c-s> is bound to a Base instance, <c-s>pBase->f()</c-s> calls <c-s>Base::f()</c-s><br />
            If <c-s>pBase</c-s> is bound to a Derived instance, <c-s>pBase->f()</c-s> calls <c-s>Derived::f()</c-s>
          </defn-body>
        </li>
      </ul>
    </t-b>
    Now, suppose that we define a function:
    <t-b>
    <c-b>  void g(pBase* ptr) {
    ptr->f();
  }</c-b>
    </t-b>
    <t-b>
      If <c-s>ptr</c-s> is bound to a <c-s>Base</c-s> instance then <c-s>Base::f()</c-s> is called.
      If <c-s>ptr</c-s> is bound to a <c-s>Derived</c-s> instance, then <c-s>Derived::f()</c-s> is called.
    </t-b>
    <t-b>
      So <c-s>g(pBase* ptr)</c-s> invokes functions based on the type of the object reference, not the
      static type of ptr.  Function <c-s>g</c-s> doesn&apos;t need to know anything about the Base class
      hierarchy.  It only needs to know the public interface of the <c-s>Base</c-s> class.
    </t-b>
    <t-b>
      At any time, if we add a new class derived from <c-s>Base</c-s>, then <c-s>g</c-s>, with no changes,
      will process it correctly. This is a very important behavior. So important that it has been given
      a name: Liskov Substitution.
    </t-b>
    <s-5px></s-5px>
    <defn-block>
      <defn-head>
        <span class="notice">Liskov Substitution</span>
      </defn-head>
      <defn-body>
        Barbara Liskov authored a paper &quot;Data Abstraction&quot; in which she provided
        a useful model for polymorphism, which I&apos;ve paraphrased in a way appropriate for C++:
        <indent-block class="pad10">
          Functions that accept pointers or C++ references statically typed to some base class must be able
          to use objects of classes derived from the base through those pointers or references without any
          knowledge specialized to the derived classes.
        </indent-block>
        <t-b>
          That means that within the function any method invocation made through the base pointer will
          invoke that method based on the type of the derived class instance bound to that pointer.
        </t-b>
      </defn-body>
    </defn-block>
    <s-quarterEm></s-quarterEm>
    <num-cont>
      <num-item1>5.41</num-item1><num-item4>Virtual Dispatching via Virtual Function Pointer Table:</num-item4>
    </num-cont>
    <photosizer-block src="Pictures/Polymorphism.jpg" width="500" class="photoSizerBlock right clear">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 3. Virtual Function Pointer Tables
      </span>
    </photosizer-block>
    <t-b>
      Virtual function dispatching, as described above, is implemented with 
      <span class="notice">virtual function pointer tables</span>.  Each class with one or more virtual methods
      has an associated Virtual Function Pointer Table (VFPT) and each instance of that class contains a pointer,
      <c-s>pVtbl</c-s>, pointing to its VFPT.
    </t-b>
    <t-b>
      In Fig 3., we&apos;ve shown a class hierarchy with base class <c-s>B</c-s> and derived class <c-s>D</c-s>.
      Comparing the class declarations we see that:
      <ol class="tight">
        <li>
          <c-s>D</c-s> does not override <c-s>B::mf1</c-s>, so its virtual function pointer, 
          <c-s>pMf1</c-s>, binds to <c-s>B::mf1</c-s>
        </li>
        <li>
          <c-s>D</c-s> does override <c-s>B::mf2</c-s>, so its virtual function pointer,
          <c-s>pMf2</c-s>, binds to <c-s>D::mf2</c-s>
        </li>
        <li>
          <c-s>D</c-s> adds a new virtual function, <c-s>mf3</c-s>.  This function cannot be invoked
          from a <c-s>B*</c-s> pointer, because it is not part of the public <c-s>B</c-s> interface.
        </li>
        <li>
          <c-s>D</c-s> overrides the <span class="notice">private</span> method <c-s>B::name</c-s>.
          That function is called only by the non-virtual <c-s>B::who</c-s>.  Since that function is
          public, but non-virtual, <c-s>D</c-s> inherits <c-s>who</c-s>, so clients of <c-s>D</c-s>
          can call it, but <c-s>D</c-s> should not change it (because it&apos;s non-virtual).
        </li>
        <li>
          Remember that a derived class holds an image of its base within its memory footprint.
          We see that here, as the <c-s>D</c-s> image holds <c-s>B</c-s>&apos;s virtual function table
          pointer slot, which it uses to hold a pointer to its own VFPT, and <c-s>B::name</c-s>.  
          To that it adds its own member data: <c-s>D::name</c-s>.
        </li>
      </ol>
      <s-10px></s-10px>
      The details dropdown, below, presents code for this demonstration and its output.
    </t-b>
    <div class="clear">
      <details>
        <summary class="labelStyle lightItem">
          <span class="notice">Polymorphism Demo</span>
        </summary>
          <s-10px></s-10px>
          <div tabindex="2" class="autoX">
            <h3>Table 2. - Polymorphism Demo</h3>
            <table class="codeTable">
              <tr>
                <td style="padding:0px;">
                  <defn-block style="border:none; margin:0px; padding:0px; font-size:0.9rem;">
                    <defn-head style="border:none;">
                      <span class="notice">Demo Code</span>
                    </defn-head>
                    <defn-code style="margin:0px; border:none; border-top:2px solid darkred;">
  class B {
  public:
    B(const std::string& name);
    virtual ~B() {}
    virtual void mf1();
    virtual void mf2();
    void who();
  private:
    virtual std::string name();
    std::string name_;
  };

  B::B(const std::string& name) : name_(name) {}

  void B::mf1() {
    std::cout << "\n  B::mf1() invoked";
  }

  void B::mf2() {
    std::cout << "\n  B::mf2() invoked";
  }

  std::string B::name() { return name_; }

  void B::who() { 
    std::cout << "\n  who returns name " << this->name(); 
  }

  class D : public B {
  public:
    D(const std::string& name);
    virtual ~D() {}
    virtual void mf2() override;
    virtual void mf3();
  private:
    virtual std::string name() override;
    std::string name_;
  };

  D::D(const std::string& name) : B("B"), name_(name) {}

  void D::mf2() {
    std::cout << "\n  D::mf2() invoked";
  }

  void D::mf3() {
    std::cout << "\n  D::mf3() invoked";
  }

  std::string D::name() { return name_; }
                    </defn-code>
                  </defn-block>
                </td>
                <td style="padding:0px;">
                  <defn-block style="border:none; margin:0px; padding:0px;">
                    <defn-head style="border:none;">
                      <span class="notice">Using Code</span>
                    </defn-head>
                    <defn-code style="margin:0px; border:none; border-top:2px solid darkred;">
  displayDemo("--- polymorphism demo ---");

  displayDemo("\n  create B and invoke its methods");
  B b{ "B" };
  b.who();
  b.mf1();
  b.mf2();

  displayDemo("\n  create D and invoke its methods");
  D d{ "D" };
  d.who();
  d.mf1();
  d.mf2();
  d.mf3();

  displayDemo(
    "\n  create B* pB = &b, and invoke methods"
  );
  B* pB = &b;
  pB->who();
  pB->mf1();
  pB->mf2();

  displayDemo(
    "\n  create B* pB = &d, and invoke methods"
  );
  pB = &d;
  pB->who();
  pB->mf1();
  pB->mf2();
  //pB->mf3();  
  //won't compile: mf2 not in base interface

  D* pD = dynamic_cast<D*>(pB);
  if (pD)
    pD->mf3();

                    </defn-code>
                    <defn-head style="border:none;">
                      <span class="notice">Output</span>
                    </defn-head>
                    <defn-code style="margin:0px; border:none; border-top:2px solid darkred;">
  --- polymorphism demo ---

  create B and invoke its methods
  who returns name B
  B::mf1() invoked
  B::mf2() invoked

  create D and invoke its methods
  who returns name D
  B::mf1() invoked
  D::mf2() invoked
  D::mf3() invoked

  create B* pB = &b, and invoke methods
  who returns name B
  B::mf1() invoked
  B::mf2() invoked

  create B* pB = &d, and invoke methods
  who returns name D
  B::mf1() invoked
  D::mf2() invoked
  D::mf3() invoked
                    </defn-code>
                  </defn-block>
                </td>
              </tr>
            </table>
          </div>
      </details>
    </div>
    
    <hr class="spread clear" />
    <num-cont>
      <num-item1>5.5</num-item1><num-item4>Example - Person Class Hierarchy:</num-item4>
    </num-cont>
    <t-b>
      You may recall, from Chapter1 - Survey, the Person class hierarchy, used for a quick look at class relationships.
      Figure 4. shows the diagram we used there. The example isn&apos;t very useful for professional code, but it makes
      a nice example of the class relationships. All of them, with the exception of friendship, are used
      here to build an effective model for a software developement project organization.
    </t-b>
    <photosizer-block src="Pictures/PersonClassHierarchy.JPG" width="400" class="photoSizerBlock right">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 4. Person Class Hierarchy
      </span>
    </photosizer-block>
    <t-b>
      The classes are:
      <ul class="tight">
        <li>
          <n-s>IPerson:</n-s>
          <tt-b>
            An interface for the Person class.
          </tt-b>
        </li>
        <li>
          <n-s>Person:</n-s> derives from IPerson
          <tt-b>
            Class that provides attributes: name, occupation, and age for all the other 
            concrete classes.
          </tt-b>
        </li>
        <li>
          <n-s>ISW_Eng:</n-s>
          <tt-b>
            Interface for all people who develop software.
          </tt-b>
        </li>
        <li>
          <n-s>SW-Eng:</n-s> derives from Person and ISW_Eng
          <tt-b>
            Abstract class that shares select code and a Person reference with all software engingeer classes.
          </tt-b>
        </li>
        <li>
          <n-s>Dev:</n-s> derives from SW_Eng and uses Baseline
          <tt-b>
            Class that represents software developers - those who focus on building and verifying software
            components.
          </tt-b>
        </li>
        <li>
          <n-s>TestLead:</n-s> derives from Dev and uses Baseline
          <tt-b>
            Class for people who lead software development teams and also develop software.
          </tt-b>
        </li>
        <li>
          <n-s>ProgMgr:</n-s> derives from SW_Eng and aggregates Project
          <tt-b>
            Represents people who manage software development product teams. 
          </tt-b>
        </li>
        <li>
          <n-s>Project:</n-s> composes Budget and aggregates Baseline
          <tt-b>
            Collection of Project Manager, TeamLeads, Devs that also includes Budget and Baseline.
          </tt-b>
        </li>
        <li>
          <n-s>Budget:</n-s>
          <tt-b>
            Class holding original budget, current budget, projected empty date.
          </tt-b>
        </li>
        <li>
          <n-s>BaseLine:</n-s>
          <tt-b>
            Class holding collections of code modules and documents.
          </tt-b>
        </li>
      </ul>
    </t-b>
    <t-b>
      Inheritance provides an &quot;is-a&quot; relationship, so <c-s>dev &epsilon; Dev</c-s> and 
      <c-s>projMgr &epsilon; ProjMgr</c-s>
      are <c-s>SW_Engs</c-s>, and a <c-s>teamLead &epsilon; TeamLead</c-s> is a <c-s>Dev</c-s>.
      Aggregation provides a temporary owner relationship, so <c-s>projMgr &epsilon; ProjMgr</c-s> owns, 
      temporarily the <c-s>project &epsilon; Project</c-s> instance.
      Some time later that manager will own another <c-s>Project</c-s>. Composition is a permanent owner 
      relationship. <c-s>Projects</c-s> always have a <c-s>budget &epsilon; Budget</c-s>, but only temporarily 
      have a <c-s>baseline &epsilon; Baseline</c-s>. When a project starts it has no code and no documents.
    </t-b>
    <t-b>
      <n-s>Notice</n-s> how effectively these four relationships model the workings of a software development
      organization.
    </t-b>
    <t-b>
      <div class="left" style="padding-right:1em;">
      <defn-block>
        <defn-head>
          Liskov Substitution at work:
        </defn-head>
        <defn-code>
  using ProjectName = std::string;
  using TeamName = std::string;
  using Team = std::pair&lt;TeamName, std::vector&lt;SW_Eng*&gt;&gt;
  using ProjectStaff = std::vector&lt;Team&gt;
  using Project = std::tuple&lt;ProjectName, ProjMgr, ProjectStaff&gt;

 --------------------------------------------------------------------
  // defined in SW_Eng
  // pPer_ is a pointer to the SW_Eng inner Person

  std::string SW_Eng::nameAndTitle() {
    return pPer_->name() + ", " + pPer_->occupation();
  }
 --------------------------------------------------------------------

  void showTeam(Team&amp; team) {
    std::cout &lt;&lt; "\n  Team " &lt;&lt; team.first;
    for (auto pSweng : team.second)
      std::cout &lt;&lt; "\n    " &lt;&lt; pSweng-&gt;nameAndTitle();
  }
  void showProject(Project&amp; prj) {
    auto [prjName, prjMgr, staff] = prj;
    std::cout &lt;&lt; "\n  " &lt;&lt; prjName;
    std::cout &lt;&lt; "\n  " &lt;&lt; prjMgr.nameAndTitle();
    for (auto team : staff) {
      showTeam(team);
    }
  }
        </defn-code>
      </defn-block>

      </div>
      <s-halfEm></s-halfEm>
      In the block at right we show a code fragment taken from the PeopleHierarchy example, below.
      There are using declarations for ProjectName, TeamName, Team, ProjectStaff, and Project.
    </t-b>
    <t-b>
      The <s-c>showTeam</s-c> function is passed a std::tuple representing team name and a vector
      of pointers to the abstract <c-s>SW_Eng</c-s> class. The range-based for is extracting individual pointers
      to each of the team members, as <c-s>SW_Eng</c-s>s.  The simplicity of this function comes from
      Liskov Substitution.  <c-s>pSweng->nameAndTitle()</c-s> calls that function as if called by each
      of the appropriate types, e.g., <c-s>TeamLead</c-s> and <c-s>Dev</c-s>.
    </t-b>
    <t-b>
      Using inheritance with Liskov Substitution is one very useful way of building flexible code.
      If we chose to add another <c-s>SW_Eng</c-s>, say <c-s>QA</c-s>, nothing would change in any of
      the other code because it is ignorant of the specialized types we are using, e.g., look at
      <c-s>showTeam</c-s> and <c-s>showProject</c-s> again.
    </t-b>
    <s-halfEm class="clear"></s-halfEm>
    <t-d>
      All of the code for this example is contained in the details dropdown, below. The example is
      worth a significant amount of your time to understand how it does what it does. If you go to
      the <a href="CppStoryRepo.html">CppStory Repository</a> and download that code, you can look
      at the example below and simultaneously look at and run the repository code.
    </t-d>
    <s-1em></s-1em>
    <div tabindex="2" class="autoX" style="margin:0px; padding:0px;">
      <details>
        <summary class="labelStyle darkItem">People Hierarchy Code Example</summary>
        <s-1Em></s-1Em>
        <table class="tdefn">
          <tr>
            <th class="tdefn">Person Interface and Header Code</th>
            <th class="tdefn">Person Implementation Code</th>
          </tr>
          <tr>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code style="width:100%;">
/////////////////////////////////////////////////////////////
// IPerson.h - declares interface for inner person         //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include <string>
#include <memory>

namespace Chap4 {

  struct IPerson {
    using Name = std::string;
    using Occupation = std::string;
    using Age = int;
    using Stats = std::tuple<Name, Occupation, Age>;

    virtual ~IPerson() {}
    virtual Stats stats() const = 0;
    virtual void stats(const Stats& sts) = 0;
    virtual Name name() const = 0;
    virtual Occupation occupation() const = 0;
    virtual void occupation(const Occupation& occup) = 0;
    virtual Age age() const = 0;
    virtual void age(const Age& ag) = 0;
    virtual bool isValid() const = 0;
  };

  std::unique_ptr<IPerson> createPerson(const IPerson::Stats& stats);
}

/////////////////////////////////////////////////////////////
// Person.h - defines inner person attributes              //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include "IPerson.h"

namespace Chap4 {

  class Person : public IPerson {
  public:
    virtual ~Person();
    Person();
    Person(const Stats& sts);
    virtual Stats stats() const;
    virtual void stats(const Stats& sts);
    virtual Name name() const;
    virtual Occupation occupation() const;
    virtual void occupation(const Occupation& occup);
    virtual Age age() const;
    virtual void age(const Age& ag);
    virtual bool isValid() const;
  private:
    Stats personStats;
  };
}

                </tdefn-code>
              </tdefn-block>
            </td>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code>
/////////////////////////////////////////////////////////////
// Person.cpp - defines inner person attributes            //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include "IPerson.h"
#include <tuple>
#include <string>
#include <iostream>
#include "Person.h"

namespace Chap4 {

  Person::Person() {}

  Person::Person(const Stats& sts) {
    personStats = sts;
  }

  Person::~Person() {
  }
  Person::Stats Person::stats() const {
    return personStats;
  }

  void Person::stats(const Stats& sts) {
    personStats = sts;
  }

  Person::Name Person::name() const {
    return std::get<0>(personStats);
  }

  Person::Occupation Person::occupation() const {
    return std::get<1>(personStats);
  }

  void Person::occupation(const Occupation& occup) {
    std::get<1>(personStats) = occup;
  }

  Person::Age Person::age() const {
    return std::get<2>(personStats);
  }

  void Person::age(const Age& ag) {
    std::get<2>(personStats) = ag;
  }

  bool Person::isValid() const {
    return name() != "" && age() >= 0;
  }

  std::unique_ptr<IPerson> createPerson(const IPerson::Stats& stats) {             
    return std::move(std::make_unique<Person>(*new Person(stats)));
  }

  template<typename P>
  void displayPerson(const P& person)
  {
    std::cout << "\n  " << person.name() << ", " 
              << person.age() << ", " << person.occupation();
  }

  template<typename P>
  void displayInvalid(const P& person) {
    std::cout << "\n  " << person.name() << " has invalid data";
  }

  template<typename P>
  void checkedDisplay(const P& person) {
    displayPerson(person);
    if (!person.isValid())
      displayInvalid(person);
  }
}
                </tdefn-code>
              </tdefn-block>
            </td>
          </tr>
          <tr>
            <th class="tdefn">SW_Eng Interface and Header</th>
            <th class="tdefn">SW_Eng Implementation</th>
          </tr>
          <tr>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code>
/////////////////////////////////////////////////////////////
// ISW_Eng.h - defines interface for all SW Eng's          //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include "IPerson.h"

namespace Chap4 {

  struct ISW_Eng {
    virtual ~ISW_Eng() {}
    virtual void doWork() = 0;
    virtual void attendMeeting() = 0;
    virtual IPerson* person() = 0;
  };
}

/////////////////////////////////////////////////////////////
// SW_Eng.h - defines attributes for all SW Eng's          //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include "Person.h"
#include "ISW_Eng.h"
#include <string>
#include <memory>

namespace Chap4 {

  class SW_Eng : public ISW_Eng, public Person {
  public:
    SW_Eng() {}
    SW_Eng(IPerson::Stats stats);
    virtual ~SW_Eng() {}
    virtual void doWork() = 0;
    virtual void attendMeeting() = 0;
    virtual IPerson* person();
    std::string nameAndTitle();
  protected:
    void getCoffee();
    void checkEmail();
    void developSoftware();
    void reviewTeamActivities();
    void performanceAppraisals();
    void introductions(const std::string& name);
    void presentStatus(const std::string& progress);
    void assignActionItems();
    IPerson* pPer_ = nullptr;
  };
}                </tdefn-code>
              </tdefn-block>
            </td>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code>
/////////////////////////////////////////////////////////////
// SW_Eng.cpp - defines attributes for all SW Eng's        //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include "SW_Eng.h"
#include "Person.h"
#include <iostream>
#include <string>

namespace Chap4 {

  /*--- initialize inner person ---*/

  SW_Eng::SW_Eng(IPerson::Stats stats) {
    Person::stats(stats);
    pPer_ = person();
  }

  /*--- return inner person ---*/

  IPerson* SW_Eng::person() {
    return dynamic_cast<IPerson*>(this);
  }

  std::string SW_Eng::nameAndTitle() {
    return pPer_->name() + ", " + pPer_->occupation();
  }

  void SW_Eng::getCoffee() {
    std::cout << "\n    go to cafetria for coffee, chat with friends";
  }

  void SW_Eng::checkEmail() {
    std::cout << "\n    open mail server and slog through messages";
  }

  void SW_Eng::developSoftware() {
    std::cout << "\n    pull current work from repository";
    std::cout << "\n    chase bugs";
    std::cout << "\n    design new module";
    std::cout << "\n    start module implementation";
    std::cout << "\n    push current work to repository";
  }

  void SW_Eng::reviewTeamActivities() {
    std::cout << "\n    review current work status";
    std::cout << "\n    review each individual's accomplishments";
  }

  void SW_Eng::performanceAppraisals() {
    std::cout << "\n    summarize and record individual accomplishments"; 
    std::cout << "\n    summarize areas needing improvement";
    std::cout << "\n    summarize contributions to the team";
  }

  void SW_Eng::introductions(const std::string& name) {
    std::cout << "\n    Hi everyone, my name is " << name 
              << " and I'm pleased to see you all";
  }
  void SW_Eng::presentStatus(const std::string& progress) {
    std::cout << "\n    I'm happy to report that " << progress;
  }
  void SW_Eng::assignActionItems() {
    std::cout << "\n    I will post action items for each of you "
              << "before the end of the day";
  }
}
                </tdefn-code>
              </tdefn-block>
            </td>
          </tr>
          <tr>
            <th class="tdefn">Dev Header</th>
            <th class="tdefn">Dev Implementation</th>
          </tr>
          <tr>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code>
/////////////////////////////////////////////////////////////
// Dev.h - defines attributes for developer                //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include "SW_Eng.h"
#include <iostream>

namespace Chap4 {

  class Dev : public SW_Eng {
  public:
    Dev(IPerson::Stats stats);
    virtual void doWork();
    virtual void attendMeeting();
  private:
    //IPerson* pPer_;
  };
}
                </tdefn-code>
              </tdefn-block>
            </td>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code>
/////////////////////////////////////////////////////////////
// Dev.cpp - defines attributes for developer              //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include "Dev.h"

namespace Chap4 {

  Dev::Dev(IPerson::Stats stats) : SW_Eng(stats) {
  }

  void Dev::doWork() {
    std::cout << "\n  " << pPer_->name() << " starting work";
    getCoffee();
    checkEmail();
    developSoftware();
    std::cout << std::endl;
  }

  void Dev::attendMeeting() {

    std::cout << "\n  " << pPer_->name() << " attending meeting";         
    introductions(pPer_->name());
    presentStatus(
      "I've completed 90% of my assigned tasks for this sprint"
    );
    std::cout << std::endl;
  }
}
                </tdefn-code>
              </tdefn-block>
            </td>
          </tr>
          <tr>
            <th class="tdefn">TeamLead Header</th>
            <th class="tdefn">TeamLead Implementation</th>
          </tr>
          <tr>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code>
/////////////////////////////////////////////////////////////
// TeamLead.h - defines attributes for Team Leaders        //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include "Dev.h"
#include <iostream>

namespace Chap4 {

  class TeamLead : public Dev {
  public:
    TeamLead(IPerson::Stats stats);
    virtual void doWork();
    virtual void attendMeeting();
  private:
    //IPerson* pPer_;
  };
}
                </tdefn-code>
              </tdefn-block>
            </td>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code>
/////////////////////////////////////////////////////////////
// TeamLead.cpp - defines attributes for Team Leaders      //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include "TeamLead.h"

namespace Chap4 {

  TeamLead::TeamLead(IPerson::Stats stats) : Dev(stats) {
  }

  void TeamLead::doWork() {
    std::cout << "\n  " << nameAndTitle() << ", starting work";
    getCoffee();
    checkEmail();
    reviewTeamActivities();
    developSoftware();
    std::cout << std::endl;
  }

  void TeamLead::attendMeeting() {

    std::cout << "\n  " << nameAndTitle() << ", attending meeting";
    introductions(pPer_->name());
    presentStatus(
      "our team has completed 95% of our assigned stories for this sprint"
    );
    std::cout << std::endl;
  }
}
                </tdefn-code>
              </tdefn-block>
            </td>
          </tr>
          <tr>
            <th class="tdefn">ProjMgr Header</th>
            <th class="tdefn">ProjMgr Implementation</th>
          </tr>
          <tr>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code>
/////////////////////////////////////////////////////////////
// ProjMgr.h - defines attributes for Project Managers     //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include "SW_Eng.h"
#include <iostream>

namespace Chap4 {

  class ProjMgr : public SW_Eng {
  public:
    ProjMgr(IPerson::Stats stats);
    virtual void doWork();
    virtual void attendMeeting();
  private:
    //IPerson* pPer_;
  };
}
                </tdefn-code>
              </tdefn-block>
            </td>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code>
/////////////////////////////////////////////////////////////
// ProjMgr.cpp - defines attributes for Project Managers   //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#include "ProjMgr.h"

namespace Chap4 {

  ProjMgr::ProjMgr(IPerson::Stats stats) : SW_Eng(stats) {
  }

  void ProjMgr::doWork() {
    std::cout << "\n  " << nameAndTitle() << ", starting work";
    getCoffee();
    checkEmail();
    reviewTeamActivities();
    performanceAppraisals();
    std::cout << std::endl;
  }

  void ProjMgr::attendMeeting() {

    std::cout << "\n  " << nameAndTitle() << ", attending meeting";
    introductions(pPer_->name());
    presentStatus(
      "My teams have completed 85% of their assigned work for this sprint"
    );
    std::cout << "\n  Take customer golfing - make sure he wins";
    std::cout << std::endl;
  }
}
                </tdefn-code>
              </tdefn-block>
            </td>
          </tr>
          <tr>
            <th class="tdefn">Using Code</th>
            <th class="tdefn">Output</th>
          </tr>
          <tr>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code>
/////////////////////////////////////////////////////////////
// TestPeopleHierarchy.cpp - demonstrates hierarchy        //
//                                                         //
// Jim Fawcett, Teaching Professor Emeritus, Syracuse Univ //
/////////////////////////////////////////////////////////////

#ifdef TEST_HIERARCHY

#include <vector>
#include "SW_Eng.h"
#include "Dev.h"
#include "TeamLead.h"
#include "ProjMgr.h"

namespace Chap4 {

  using ProjectName = std::string;
  using TeamName = std::string;
  using Team = std::pair&lt;TeamName, std::vector&lt;SW_Eng*&gt;&gt;
  using ProjectStaff = std::vector&lt;Team&gt;
  using Project = std::tuple&lt;ProjectName, ProjMgr, ProjectStaff&gt;

  void showTeam(Team&amp; team) {
    std::cout &lt;&lt; "\n  Team " &lt;&lt; team.first;
    for (auto pSweng : team.second)
      std::cout &lt;&lt; "\n    " &lt;&lt; pSweng-&gt;nameAndTitle();
  }
  void showProject(Project&amp; prj) {
    auto [prjName, prjMgr, staff] = prj;
    std::cout &lt;&lt; "\n  " &lt;&lt; prjName;
    std::cout &lt;&lt; "\n  " &lt;&lt; prjMgr.nameAndTitle();
    for (auto team : staff) {
      showTeam(team);
    }
  }
}

int main() {
  using namespace Chap4;

  ProjMgr Devin({ "Devin", "Project Manager", 45 });

  TeamLead Jill({ "Jill", "Team Lead & Web dev", 32 });
  Dev Jack({ "Jack", "UI dev", 28 });
  Dev Zhang({ "Zhang", "System dev", 37 });
  Dev Charley({ "Charley", "QA dev", 27 });
  Team FrontEnd{ "FrontEnd", { &Jill, &Jack, &Zhang, &Charley } };

  TeamLead Tom({ "Tom", "Team Lead & Backend Dev", 38 });
  Dev Ming({ "Ming", "Comm dev", 26 });
  Dev Sonal({ "Sonal", "Server dev", 27 });
  Team BackEnd{ "BackEnd", { &Tom, &Ming, &Sonal } };

  Project ProductX{ "ProductX", Devin, { FrontEnd, BackEnd } };

  showProject(ProductX);
  std::cout &lt;&lt; std::endl;

  std::cout &lt;&lt; "\n  Team " &lt;&lt; FrontEnd.first &lt;&lt; " at work";
  for (auto pDev : FrontEnd.second) {
    pDev-&gt;doWork();
    pDev-&gt;attendMeeting();
  }
  std::cout &lt;&lt; std::endl;

  std::cout &lt;&lt; "\n  Project Manager " &lt;&lt; Devin.nameAndTitle() 
            &lt;&lt; " at work";
  Devin.doWork();
  Devin.attendMeeting();

  std::cout &lt;&lt; "\n\n";
}

#endif
                </tdefn-code>
              </tdefn-block>
            </td>
            <td class="tdefn">
              <tdefn-block>
                <tdefn-code>
  ProductX
  Devin, Project Manager
  Team FrontEnd
    Jill, Team Lead & Web dev
    Jack, UI dev
    Zhang, System dev
    Charley, QA dev
  Team BackEnd
    Tom, Team Lead & Backend Dev
    Ming, Comm dev
    Sonal, Server dev

  Team FrontEnd at work
  Jill, Team Lead & Web dev, starting work
    go to cafetria for coffee, chat with friends
    open mail server and slog through messages
    review current work status
    review each individual's accomplishments
    pull current work from repository
    chase bugs
    design new module
    start module implementation
    push current work to repository

  Jill, Team Lead & Web dev, attending meeting
    Hi everyone, my name is Jill and I'm pleased to see you all
    I'm happy to report that our team has completed 95% of our 
    assigned stories for this sprint

  Jack starting work
    go to cafetria for coffee, chat with friends
    open mail server and slog through messages
    pull current work from repository
    chase bugs
    design new module
    start module implementation
    push current work to repository

  Jack attending meeting
    Hi everyone, my name is Jack and I'm pleased to see you all
    I'm happy to report that I've completed 90% of my assigned 
    tasks for this sprint

  Zhang starting work
    go to cafetria for coffee, chat with friends
    open mail server and slog through messages
    pull current work from repository
    chase bugs
    design new module
    start module implementation
    push current work to repository

  Zhang attending meeting
    Hi everyone, my name is Zhang and I'm pleased to see you all
    I'm happy to report that I've completed 90% of my assigned 
    tasks for this sprint

  Charley starting work
    go to cafetria for coffee, chat with friends
    open mail server and slog through messages
    pull current work from repository
    chase bugs
    design new module
    start module implementation
    push current work to repository

  Charley attending meeting
    Hi everyone, my name is Charley and I'm pleased to see you all
    I'm happy to report that I've completed 90% of my assigned 
    tasks for this sprint


  Project Manager Devin, Project Manager at work
  Devin, Project Manager, starting work
    go to cafetria for coffee, chat with friends
    open mail server and slog through messages
    review current work status
    review each individual's accomplishments
    summarize and record individual accomplishments
    summarize areas needing improvement
    summarize contributions to the team

  Devin, Project Manager, attending meeting
    Hi everyone, my name is Devin and I'm pleased to see you all
    I'm happy to report that My teams have completed 85% of their 
    assigned work for this sprint
  Take customer golfing - make sure he wins
                </tdefn-code>
              </tdefn-block>
            </td>
          </tr>
        </table>
      </details>
    </div>
    <s-1em></s-1em>
    <t-d>
      In the next section we will look at inheritance hierarchies from working code for
      a <c-s>Parser</c-s> used for static analysis.
    </t-d>
    <hr class="spread clear" />
    <num-cont>
      <num-item1>5.6</num-item1><num-item4>Example - CppParser:</num-item4>
    </num-cont>

    <spacer-25></spacer-25>
    <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->
  </div>
  <info-bar></info-bar>
</body>
</html>