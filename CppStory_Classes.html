<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_Classes.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Story-Classes</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_ClassRelationships.html">N</a>
  <a id="Prev" href="CppStory_Operations.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #4 - C++ Classes</h1>
      <h3 id="subtitle">classes, value types, class relationships</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <indent-blocks>
    <num-cont>
      <num-item1>4.0</num-item1><num-item4>Classes</num-item4>
    </num-cont>
    Classes and class relationships are the building blocks for object-oriented design.  The results
    are an collection of objects - instances of classes - that cooperate to conduct operations
    required of their program.
    <hr class="spread" />
    <num-cont>
      <num-item1>4.1</num-item1><num-item4>Basic Classes</num-item4>
    </num-cont>
    A class is like a &quot;cookie cutter&quot;.  It stamps out a section of memory in the stackframe
    of its local scope, and initializes that memory with data required to create a valid object.
    Each time it&apos;s used to declare an instance, another piece of memory is allocated and 
    initialized.
    <spacer-15></spacer-15>
    Each class has a set of methods - functions associated with that specific class - providing
    operations on its allocated data when invoked. Each has one set of code that is stored
    in static memory, and potentially many instances holding data usually stored in stackframe of the function
    wherer it is declared.
    <spacer-15></spacer-15>
    When an instance method is invoked, <c-s>x.fun(param); x&epsilon;X</c-s>, the address of <c-s>x</c-s> is sent to the
    code for class <c-s>X</c-s> to use if <c-s>fun</c-s> modifies <c-s>x</c-s>&apos;s data.  That address is identified
    by the reserved word &quot;<c-s>this</c-s>&quot;.  You may occasionally see references to <c-s>this</c-s> in
    methods of the class.  Most use is implicit, but occasionally it must be explicitly used, as in
    assignment operators that return <c-s>*this</c-s>.
    <spacer-15></spacer-15>
    In the example below, we implement a point class. That might be used in a drawing program to 
    define lines, rectangles, and other polygonal figures.  This Point example stores its 
    x, y, z coordinate information in an array of doubles composed by the class, along with a std::string
    to hold the Point&apos;s name.
    <spacer-15></spacer-15>
    <details>
      <summary class="labelStyle lightItem">Example1: Point</summary>
      <spacer-10></spacer-10>
    <div style="display:flex;">
      <defn-block>
        <defn-head class="pad10">
          First Class Example - Point:
        </defn-head>
        <defn-code style="border-top:2px solid darkred;">
  namespace Example1 {

    class Point {
    public:
      Point(const std::string& name = "none") 
        : name_(name), coordinates_{ 0.0, 0.0, 0.0 } {
      }
      std::string& name() {
        return name_;
      }
      double& operator[](size_t i) {
        if (i &lt; 0 || 3 &lt;= i)
          throw std::exception("invalid index");
        return coordinates_[i];
      }
      size_t size() const {
        return 3;
      }
    private:
      std::string name_;
      double coordinates_[3];
    };

    void show(Point p) {
      std::cout &lt;&lt; "\n  " &lt;&lt; p.name() &lt;&lt; "\n  ";
      for (size_t i = 0; i &lt; p.size(); ++i) {
        std::cout &lt;&lt; p[i] &lt;&lt; " ";
      }
      std::cout &lt;&lt; std::endl;
    }
  }
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head class="pad10" style="border-left:none;">
          Using code:
        </defn-head>
        <defn-code style="border-top:2px solid darkred; border-left:none;">
  displayDemo("--- Example1::Point ---");
  Example1::Point p1("p1");
  p1[0] = 1.0;
  p1[1] = 2.0;
  p1[2] = 3.0;
  show(p1);
  displayDemo("--- copy constr of p2 using src p1 ---");
  Example1::Point p2{ p1 };
  p2.name() = "p2";
  show(p2);
  displayDemo("--- copy assignment of p3 from src p2");
  Example1::Point p3("p3");
  p3 = p2;
  p3.name() = "p3";
  show(p3);
        </defn-code>
        <defn-head class="pad10" style="border-left:none; border-top:none;">
          Output:
        </defn-head>
        <defn-code style="border-top:2px solid darkred; border-left:none;">
  --- Example1::Point ---
  p1
  1 2 3
  --- copy construction of p2 using src p1 ---
  p2
  1 2 3
  --- copy assignment of p3 from src p2
  p3
  1 2 3
        </defn-code>
      </defn-block>
    </div>
    </details>
    <spacer-15></spacer-15>
    This class doesn&apos;t need to provide means to support copying and assignment.  The
    compiler will generate methods for that, doing member-wise copy and assignment.  The name_
    member has correct copy semantics, providing those as part of its class design.  The 
    coordinate array requires a memory copy operation, but that is provided by compiler generated
    copy construction and copy assignment operations. Look at sections 3.2 and 3.3 to see an
    example for a struct.
    <spacer-15></spacer-15>
    While this design works, and correctly supports locating points in three physical
    dimensions, there are two things I don&apos;t like about this code:
    <spacer-10></spacer-10>
    <ol class="tight">
      <li>
        Class methods are defined in-line in the body of the class declaration, Java style.
        That makes reading the interface harder than necessary.  It&apos;s better C++ style 
        to move the method definitions out of the class declaration.
      </li>
      <li>
        This is an unnecessarily inflexible design.  Defining the class&apos;s coordinate buffer 
        as a composed member means that we must define the array size at compile time, because 
        the array will be placed in static memory and the compiler does that. 
      </li>
    </ol>
    <spacer-15></spacer-15>
    If we wanted to use instances of this class in an air-traffic control system, we probably
    would want to store the time of observation as part of the point&apos;s coordinates, e.g.,
    location in both time and space, so there are now four coordinates. An effective way 
    to support configuring a class for needs
    of a specific application is to define its storage at run-time, based on some parameter
    passed to the class.  We can do that by creating the buffer in the native heap, providing
    the array size as needed.
    <spacer-15></spacer-15>
    One of the primary reasons for using the native heap is to allow allocating memory with 
    size determined by the application, at run-time.  In the revision, shown 
    below, we will will use std::vector that does that internally.
    <spacer-15></spacer-15>
    <details>
      <summary class="labelStyle lightItem">Example2: Revised Point</summary>
      <spacer-10></spacer-10>
    <div style="display:flex;">
      <defn-block>
        <defn-head class="pad10">
          Revised Class Example - Point:
        </defn-head>
        <defn-code style="border-top:2px solid darkred;">
  namespace Example2 {

    class Point {
    public:
      Point(const std::string& name = "none", size_t N = 3);
      std::string& name();
      double& operator[](size_t i);
      double operator[](size_t i) const;
      size_t size() const;
    private:
      std::string name_;
      std::vector&lt;double&gt; coordinates_;
    };
    /*--- constructor ---*/
    Point::Point(const std::string& name, size_t N)
      : name_(name), coordinates_(N) {
    }
    /*--- name accessor ---*/
    std::string& Point::name() {
      return name_;
    }
    /*--- indexer for non-const instances ---*/
    double& Point::operator[](size_t i) {
      if (i &lt; 0 || coordinates_.size() &lt;= i)
        throw std::exception("index out of range");
      return coordinates_[i];
    }
    /*--- indexer for const instances ---*/
    double Point::operator[](size_t i) const {
      if (i &lt; 0 || coordinates_.size() &lt;= i)
        throw std::exception("index out of range");
      return coordinates_[i];
    }
    /*--- buffer size accessor ---*/
    size_t Point::size() const {
      return coordinates_.size();
    }
  }

  /*--- generic display function ---*/
  template&lt;typename T&gt;
  void show(T t) {
    std::cout &lt;&lt; "\n  " &lt;&lt; t.name() &lt;&lt; "\n  ";
    for (size_t i = 0; i &lt; t.size(); ++i) {
      std::cout &lt;&lt; t[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
  }
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head class="pad10" style="border-left:none;">
          Using code:
        </defn-head>
        <defn-code style="border-top:2px solid darkred; border-left:none;">
  displayDemo("--- Example2::Point ---");
  Example2::Point p4("p4", 3);
  p4[0] = -1.0;
  p4[1] = 0.0;
  p4[2] = 1.0;
  show(p4);
  displayDemo("--- copy constr of p5 using src p4 ---");
  Example2::Point p5{ p4 };
  p5.name() = "p5";
  show(p5);
  displayDemo("--- copy assignment of p6 from src p5");
  Example2::Point p6("p6");
  p6 = p5;
  p6.name() = "p6";
  show(p6);
        </defn-code>
        <defn-head class="pad10" style="border-left:none; border-top:none;">
          Output:
        </defn-head>
        <defn-code style="border-top:2px solid darkred; border-left:none;">
 --- Example2::Point ---
  p4
  -1 0 1

  --- copy construction of p5 using src p4 ---
  p5
  -1 0 1

  --- copy assignment of p6 from src p5
  p6
  -1 0 1
        </defn-code>
      </defn-block>
    </div>
    </details>
    <spacer-15></spacer-15>
    The implementation of Example2::Point is better:
    <ol>
      <li>
        Method definitions are factored out of Example2::Point class declaration which makes
        the class interface easier to comprehend.  We&apos;ve also provided a prologue
        comment for each method.
      </li>
      <li>
        We&apos;ve added an index operator for constant points, as without that using
        code cannot index a const point.
      </li>
      <li>
        Like Example1::Point, this implementation doesn&apos;t need a copy constructor,
        copy assignment operator, or destructor since the compiler generated methods work
        correctly.  The reason for that is that all the data members have correct copy,
        assignment, and destruction semantics - all of the STL containers, like
        std::string and std::vector, have that property.
      </li>
    </ol>
    <spacer-5></spacer-5>
    This isn&apos;t the end of the Point story though; some applications may need very small,
    and fast components.  Suppose that we want to implement an air quality monitor, for things
    like temperature, humidity, carbon monoxide, radon emissions, and volatile organic
    compounds. This application will probably run on a controller chip or Arduno, with limited
    storage.  It will need to handle storage of an open ended number of measurements, each one
    a coordinate in the air quality space and do that relatively quickly to keep up with a
    specified logging cycle.
    <spacer-15></spacer-15>
    For this, we&apos;ve decided to go back to using a buffer as it will be slightly smaller
    and substantially faster than a <c-s>std::vector&lt;double&gt;</c-s>.  To provide the
    flexability to handle an open-ended number of measurements, we will store the coordinate
    buffer in heap memory, allowing us to specify buffer size at run-time.
    <spacer-15></spacer-15>
    <details>
      <summary class="labelStyle lightItem">Example3: Point Revised Again</summary>
      <spacer-10></spacer-10>
    <div style="display:flex;">
      <defn-block>
        <defn-head class="pad10">
          Revised again Example:
        </defn-head>
        <defn-code style="border-top:2px solid darkred;">
  namespace Example3 {

    class Point {
    public:
      Point(const std::string& name = "none", size_t N = 3);
      Point(const Point& x);
      ~Point();
      Point& operator=(const Point& x);
      std::string& name();
      double& operator[](size_t i);
      double operator[](size_t i) const;
      size_t size() const;
    private:
      std::string name_;
      double* pBuffer_ = nullptr;
      size_t bufSize_ = 0;
    };
    /*--- constructor ---*/
    Point::Point(const std::string& name, size_t N)
      : name_(name), bufSize_(N), pBuffer_(new double[N]) {
    }
    /*--- copy constructor ---*/
    Point::Point(const Point& x)
      : bufSize_(x.bufSize_), pBuffer_(new double[x.bufSize_]) {
      name_ = x.name_;
      memcpy(pBuffer_, x.pBuffer_, bufSize_ * sizeof(double));
    }
    /*--- destructor ---*/
    Point::~Point() {
      delete[] pBuffer_;
    }
    /*--- copy assignment operator ---*/
    Point& Point::operator=(const Point& x) {
      if (this != &x) {
        /* won't assign name */
        bufSize_ = x.bufSize_;
        delete pBuffer_;
        pBuffer_ = new double[bufSize_];
        memcpy(pBuffer_, x.pBuffer_, bufSize_ * sizeof(int));
      }
      return *this;
    }
    /*--- name accessor ---*/
    std::string& Point::name() {
      return name_;
    }
    /*--- indexer for non-const instances ---*/
    double& Point::operator[](size_t i) {
      if (i &lt; 0 || bufSize_ &lt;= i)
        throw std::exception("index out of range");
      return *(pBuffer_ + i);
    }
    /*--- indexer for const instances ---*/
    double Point::operator[](size_t i) const {
      if (i &lt; 0 || bufSize_ &lt;= i)
        throw std::exception("index out of range");
      return *(pBuffer_ + i);
    }
    /*--- buffer size accessor ---*/
    size_t Point::size() const {
      return bufSize_;
    }
  }
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head class="pad10" style="border-left:none;">
          Using code:
        </defn-head>
        <defn-code style="border-top:2px solid darkred; border-left:none;">
    displayDemo("--- Example3::Point ---");
    Example3::Point p7("p7", 3);
    p7[0] = -0.5;
    p7[1] = 0.0;
    p7[2] = 0.5;
    show(p7);
    displayDemo("--- copy constr of p8 using src p7 ---");
    Example3::Point p8{ p7 };
    p8.name() = "p8";
    show(p8);
    displayDemo("--- copy assignment of p9 from src p8");
    Example3::Point p9("p9");
    p9 = p8;
    show(p8);
        </defn-code>
        <defn-head class="pad10" style="border-left:none; border-top:none;">
          Output:
        </defn-head>
        <defn-code style="border-top:2px solid darkred; border-left:none;">
  --- Example3::Point ---
  p7
  -0.5 0 0.5

  --- copy construction of p8 using src p7 ---
  p8
  -0.5 0 0.5

  --- copy assignment of p9 from src p8
  p8
  -0.5 0 0.5
        </defn-code>
      </defn-block>
    </div>
    </details>
    <spacer-15></spacer-15>
    There are some things to note about this design:
    <ol>
      <li>
        Now, instead of composing the data buffer, as we did in Example1::Point, we aggregate
        it, e.g., we point to a heap-based buffer with the pointer pBuffer_.
      </li>
      <li>
        We are now obliged to provide a copy constructior, copy assignment operator, and 
        destructor.  The presence of the pointer, pBuffer_, means that all the class data
        members no longer have correct copy, assignment, and destruction semantics.  The
        class&apos;s generated methods would simply copy and assign  
        <span class="notice">pBuffer_</span>, not what it points to.  That would result
        in incorrect operation, as you can verify by commenting out those operations
        and running <a href="https://github.com/JimFawcett/CppStory">code</a>, in
        the Chapter4-classes folder.
      </li>
      <li>
        The example shows you how to implement copy, assignment, and destruction operations for
        this common scenario.
      </li>
      <li>
        The Point design is now more complex that either of the first two, due to the need for
        implementing copies, assignment, and destruction. We would probably do some performance testing to
        be sure that improvement was significant enought to warrant this choice.
      </li>
    </ol>
    If some of the implementation seems hard to understand, pause and look at 
    <a href="../JimFawcett.github.io/STRCode.html">STRCode.html</a> presentation.  It describes all the
    details of each of these methods, using a demonstration string class.  We will also look
    again at all these methods in section 4.4 Class Anatomy.
    <hr class="spread" />
    <num-cont>
      <num-item1>4.2</num-item1><num-item4>Value Types:</num-item4>
    </num-cont>
    All three of the example Point implementations, above, provide value types.
    <spacer-15></spacer-15>
    <defn-block>
      <defn-head class="notice" style="border:2px solid darkred;">Value Types:</defn-head>
      <defn-body class="pad10" style="border-top:none;">
        Value types can be copied and assigned.  When a copy or assignment operation completes
        there are two instances of the type which, immediately following the operation, have
        the same state values, but are independent. Should using code change the state
        of one, the other&apos;s state is not affected.  Note that this is not true for user-defined
        types built from classes in managed languages like C# and Java.
        <spacer-15></spacer-15>
        The C++ programming language was designed, from the ground up, to support value semantics.
        It does that by:
        <spacer-10></spacer-10>
        <ol class="tight">
          <li>
            Providing compiler generated copy constructors, copy assignment operators, and
            destructors, for cases where all the class&apos;s base classes and data members
            have correct copy, assignment, and destruction semantics. For those cases, e.g.,
            data members are fundamental types and/or STL containers, you should not implement
            those methods - the compiler will.
          </li>
          <li>
            When data members do not have correct copy, assignment, and destruction
            behaviours, the language supports definition of those operations as class
            methods, as we have done in Example3::Point.  In these cases, e.g., when
            the class holds a pointer member to data in the native heap, you either
            implement those methods or disallow them.
          </li>
          <li>
            The compiler will not generate constructors or assignment operators if you
            declare them and use a <c-s>= delete</c-s> suffix.
          </li>
        </ol>
        <spacer-10></spacer-10>
      </defn-body>
    </defn-block>
    <spacer-15></spacer-15>
    Because of its support for value types, C++ is very effective for scientific 
    and financial computing.
    Our libraries supporting those domains will need to be able
    to make copies and assign instances of library classes.  Matrix and vector operations are
    typical. 
    <spacer-15></spacer-15>
    <num-cont>
      <num-item1>4.3</num-item1><num-item4>Scope-based Resource Allocation:</num-item4>
    </num-cont>
    <h3>Class Anatomy</h3>
    <h3>Value Types</h3>
    <h3>Event Handlers</h3>
    <h3>Examples from the Repositories</h3>
    <indent-blocks>
    </indent-blocks>
    <spacer-25></spacer-25>
    <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

    <info-bar></info-bar>
</body>
</html>