<!DOCTYPE html>
<html>
<!--
  CppStory_Classes.html
-->
<head>
  <title>C++ Story Classes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeBlue.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesCppStory.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }


    .gray {
      background-color: #ddd;
    }

    .spread {
      margin: 1em;
    }

    .tightSpread {
      margin: 0.5em;
    }
    #github #pagetitle {
      background-color: #002147;
      color: #fafaff;
    }

    #github #title {
      background-color: #002147;
      color: #fafaff;
    }

    #github #subtitle {
      background-color: #002147;
      color: #fafaff;
    }

    #github a.repoLink {
      background-color: #002147;
      color: #fafaff;
    }

    #github a.repoLink:link {
      background-color: #002147;
      color: #fafaff;
    }
    #github c-s {
      font-size:small;
    }
    #github defn-code {
      font-size:small;
    }
    #github .codeStyle {
      font-family:Consolas;
      font-size:small;
      font-weight:bold;
    }
    #github h3 {
      margin-top: 1.0em;
      margin-bottom: 1.0em;
    }
    #github h4 {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }
    #github .normal {
      font-weight:normal;
      font-size:small;
    }
    #github .spreadup {
      margin-top:1em;
    }
    #github defn-block {
      max-width: 50em;
    }
  </style>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="CppStory_ClassRelationships.html">Next</a>
  <a id="Prev" href="CppStory_Operations.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="modified">10/20/2022</div>
      <div id="page">C++ Story Classes</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <header>
          <a class="repoLink" href="https://github.com/JimFawcett/CppStory">CppStory</a>
          <hgroup id="pagetitle">
            <h1 id="title">Chapter #5 - C++ Classes</h1>
            <h3 class="indent" id="subtitle">classes and value types</h3>
          </hgroup>
        </header>

        <h3 id="prologue">5.0  Prologue</h3>
        <t-b>
          Classes and class relationships are the building blocks for object-oriented design.  The results
          are a collection of objects - instances of classes - that cooperate to conduct operations
          required of their program. We structure the designs using:
          inheritance, composition, aggregation, using, and friend class relationships.
        </t-b>
        <details class="indent">
          <summary class="labelStyle darkItem">Quick Starter Example - Simple Logger</summary>
        <div>
        <t-b>
          This example creates and demonstrates a relatively simple logger, e.g., a class whose
          instances write messages into a stream.  It&apos;s here to illustrate techniques for 
          upcoming discussions:
          <div class="indent">
            <ol class="tight indent">
              <li>
                Use of the &quot;= delete&quot; suffix, discussed later in this chapter.
              </li>
              <li>
                Use of std::ostream pointer data member, but casting that to a derived std::fstream
                pointer with dynamic_cast in the open method and destructor. Doing this allows us
                to log to std::cout, a std::ostream instance, but also log to derived std::fstreams.
                We discuss this in chapter 5, and will refer back to this example at that time.
              </li>
            </ol>
          </div>
        </t-b>
        <t-b>
          We&apos;ve used some file stream operations in this demo.  If you aren&apos;t 
          comfortable with those, you can skip over them - those we discuss in detail in
          chapter 8.
        </t-b>
        <t-b>
          <defn-outerBlock class="indents">
          <defn-block>
            <defn-head>Code: Relatively Simple Logger</defn-head>
            <defn-code>
class Logger {
public:
  Logger() : pStream_(nullptr) {}
  Logger(std::ostream* pStr) 
    : pStream_(pStr) {}
  Logger(const Logger& logger) = delete;
  ~Logger() {
    std::ofstream* pFStrm = 
      dynamic_cast<std::ofstream*>(pStream_);
    if (pFStrm != nullptr)
      pFStrm->close();
  }
  Logger& operator=(const Logger& logger) 
    = delete;
  void open(const std::string& fileName) {
    std::ofstream* pFStrm =
      dynamic_cast<std::ofstream*>(pStream_);
    if (pFStrm != nullptr)
      pFStrm->open(fileName);
  }
  void write(const std::string& msg) {
    (*pStream_) << prefix_ << msg;
  }
private:
  std::string prefix_ = "\n  ";
  std::ostream* pStream_;
};

std::unique_ptr<std::ofstream> 
makeOutFileStream(
  const std::string& fileName
) {
  std::unique_ptr<std::ofstream> 
    pStrm(new std::ofstream(fileName));
  return pStrm;
}

std::unique_ptr<std::ifstream> 
makeInFileStream(
  const std::string& fileName
) {
  std::unique_ptr<std::ifstream> 
    pStrm(new std::ifstream(fileName));
  return pStrm;
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Using Code</defn-head>
            <defn-code>
int main() {

  displayDemo("-- simple logger --");

  std::string fileName = "log.txt";
  /*-----------------------------------------
     Create anonymous scope for logging so
     logger destructor will be called before
     trying to open log file.
  */
  {
    auto pOStrm = makeOutFileStream(fileName);
    if (!pOStrm->good()) {
      std::cout << "\n  couldn't open \"" 
                << fileName 
                << " for writing\n\n";
      return 1;
    }
    Logger logger(pOStrm.get());
    logger.write("first log item");
    logger.write("second log item");
    logger.write("last log item");
  }
  auto pIStrm = makeInFileStream(fileName);
  if (!pIStrm->good())
  {
    std::cout << "\n  couldn't open \"" 
              << fileName 
              << " for reading\n\n";
    return 1;
  }

  std::cout << "\n  " << pIStrm->rdbuf();
  putline(2);
}
            </defn-code>
            <defn-head class="defnBorderTop">Output</defn-head>
            <defn-code>
-- simple logger --

  first log item
  second log item
  last log item
            </defn-code>
          </defn-block>
          </defn-outerBlock>
        </t-b>
    <t-b>
      We&apos;ve seen a significantly more ambitious logger at the end of Chapter 3, in our
      discussion of testing.  This example lays out, in a simpler way, the basic mechanisms needed to build
      a logger.
    </t-b>
    <t-b>
      <defn-block class="indents" style="width:30em;">
        <defn-head>Conclusion:</defn-head>
        <defn-body>
          C++ classes bind together data members and methods to provide a useful facility.
          They should have a single focus and be as simple as it is practical to make them.
          That&apos;s true for this example.
          <t-b>
            To keep the class simple, we factored out file opening functions <c-s>makeOutFileStream</c-s>
            and <c-s>makeInFileStream</c-s>.  We don&apos;t need them if we just want to log to the
            console.
          </t-b>
        </defn-body>
      </defn-block>
    </t-b>
      </div>
     <s-1em></s-1em>
    </details>
    <t-b>
      This example presented one of three different logger classes discussed in this story. This one is intended
      to illustrate a more-than simple, but relatively small, useful class.  We will do the same thing again
      in Chapter 6 to illustrate template class specialization.
    </t-b>
    <t-b>
      In the Epilogue of chapter 6, we present a fairly complete implementation of a useful logging facility.
      I intend to merge the best features of these three examples and put that in 
      <a href="logger.html">Logger repository</a>.
    </t-b>
    <h3 id="basiccl">5.1  Basic Classes</h3>
    <div style="width:calc(100vw - 12rem);">
      <photosizer-block src="Pictures/ClassLayout.jpg" width="300" class="photoSizerBlock right">
        <span style="font-family:'Comic Sans MS', Tahoma;">
          Fig 1. Class X Layout
        </span>
      </photosizer-block>
    </div>
    <t-b>
      A class is like a &quot;cookie cutter&quot;.  It stamps out a section of memory in the stackframe
      of its local scope, and initializes that memory with data required to create a valid object.
      Each time it&apos;s used to declare an instance, another piece of memory is allocated and
      initialized.
    </t-b>
    <t-b>
      Each class has a set of methods - functions associated with that specific class - providing
      operations on its allocated data when invoked. Each has code that is stored
      in static memory, and potentially many instances holding data usually stored in the stackframe of the function
      where it is declared.
    </t-b>
    <t-b>
      When an instance method is invoked, <c-s>x.fun(param); x&epsilon;X</c-s>, the address of <c-s>x</c-s> is sent to the
      code for class <c-s>X</c-s> to use if <c-s>fun</c-s> modifies <c-s>x</c-s>&apos;s data.  That address is identified
      by the reserved word &quot;<c-s>this</c-s>&quot;.  You may occasionally see references to <c-s>this</c-s> in
      methods of the class.  Most use is implicit, but occasionally it must be used explicitly, as in
      assignment operators that return <c-s>*this</c-s>.
    </t-b>

    <h4 id="method">5.1.1  Class Methods</h4>
    <t-b>
      C++ classes define special methods: constructors, assignment operators, and destructors.  Constructor
      method names are all the name of the class. Assignment operators use the <c-s>operator=</c-s> name and
      destructor names are the class name prepended with a <c-s>~</c-s> character.
    </t-b>
    <h4>Table 1. - Special Class Methods for Class X</h4>
        <table>
          <tr>
            <th class="darkItem">Method&nbsp;Syntax</th><th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <c-s>X()</c-s>
            </td>
            <td>
              Default constructor builds instance of X with default state values.
            </td>
          </tr>
          <tr>
            <td>
              <c-s>X(const X&amp; x)</c-s>
            </td>
            <td>Copy constructor builds instance of X with copy of the state of an existing instance.
            </td>
          </tr>
          <tr>
            <td>
              <c-s>X(X&amp;&amp; x)</c-s>
            </td>
            <td>Move constructor builds an instance and transfers ownership of a source object&apos;s state.
            </td>
          </tr>
          <tr>
            <td style="white-space:nowrap;">
              <c-s>X&amp;&nbsp;operator=(const&nbsp;X&amp;&nbsp;x)</c-s>
            </td>
            <td>
              Copy assignment copies the state of a source instance to the state of an existing destination instance.
            </td>
          </tr>
          <tr>
            <td>
              <c-s>X&amp; operator=(X&amp;&amp; x)</c-s>
            </td>
            <td>
              Move assignment transfers ownership of a source instance&apos;s state to the destination instance.
              Source object becomes invalid.
            </td>
          </tr>
          <tr>
            <td>
              <c-s>~X()</c-s>
            </td>
            <td>Destructor returns class resources when instance goes out of scope.
            </td>
          </tr>
        </table>
    <t-b>
      Classes almost always provide additional custom methods appropriate for the class&apos;s role.
      Each of the special methods in Table 1. will be used and explained in the examples that follow.
    </t-b>

    <h4 id="ptclass">5.1.2  Point Class Examples</h4>
    <t-b>
      We will explore here three example variations of a &quot;simple&quot; <c-s>Point</c-s> class,
      considering class data structure and its consequences on flexibility, complexity, and performance.
      Point is an abstraction of a physical point in some space with coordinates and name.  There are
      choices for how we represent Point&apos;s state and the results of those choices are significant.
    </t-b>
    <t-b>
      In Example1::Point we store coordinates in a composed buffer and name in a composed string, as
      shown in Figure 1, below. This turns out to be rather inflexible, as explained below, so we design Example2::Point
      to compose a <c-s>std::vector&lt;double&gt;</c-s> to hold coordinate information and a string
      for its name. The third design, Example3::Point, uses an array of doubles, for performance,
      created on the heap this time, to configure the number of coordinates held by a <c-s>Point</c-s>.
    </t-b>
    <div style="display:flex; margin-top:0px; width:calc(100vw - 6rem);" class="autoX">
      <photosizer-block src="Pictures/Example1Layout.jpg" width="200" class="photoSizerBlock">
        <span style="font-family:'Comic Sans MS', Tahoma;">
          Fig 1. Example1 Class Layout
        </span>
      </photosizer-block>
      <photosizer-block src="Pictures/Example2Layout.jpg" width="200" class="photoSizerBlock">
        <span style="font-family:'Comic Sans MS', Tahoma;;">
          Fig 2. Example2 Class Layout
        </span>
      </photosizer-block>
      <photosizer-block src="Pictures/Example3Layout.jpg" width="200" class="photoSizerBlock">
        <span style="font-family:'Comic Sans MS', Tahoma;">
          Fig 3. Example3 Class Layout
        </span>
      </photosizer-block>
    </div>
        <h4 id="ptexam">5.1.3  Point Examples Code</h4>
    <t-b>
      In the example below, we implement the first point class. That might be used in a drawing program to
      define lines, rectangles, and other polygonal figures.  This Point example stores its
      x, y, z coordinate information in an array of doubles composed by the class, along with a std::string
      to hold the Point&apos;s name.
    </t-b>
    <details>
      <summary class="labelStyle darkItem">Example1: Point</summary>
      <spacer-10></spacer-10>
    <defn-outerBlock>
      <defn-block>
        <defn-head>
          First Class Example - Point:
        </defn-head>
        <defn-code>
namespace Example1 {

  class Point {
  public:
    Point(const std::string& name = "none") 
      : name_(name), coordinates_{ 0.0, 0.0, 0.0 } {
    }
    std::string& name() {
      return name_;
    }
    double& operator[](size_t i) {
      if (i &lt; 0 || 3 &lt;= i)
        throw std::exception("invalid index");
      return coordinates_[i];
    }
    size_t size() const {
      return 3;
    }
  private:
    std::string name_;
    double coordinates_[3];
  };

  void show(Point p) {
    std::cout &lt;&lt; "\n  " &lt;&lt; p.name() &lt;&lt; "\n  ";
    for (size_t i = 0; i &lt; p.size(); ++i) {
      std::cout &lt;&lt; p[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
  }
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>
          Using code:
        </defn-head>
        <defn-code>
displayDemo("--- Example1::Point ---");
Example1::Point p1("p1");
p1[0] = 1.0;
p1[1] = 2.0;
p1[2] = 3.0;
show(p1);
displayDemo("--- copy constr of p2 using src p1 ---");
Example1::Point p2{ p1 };
p2.name() = "p2";
show(p2);
displayDemo("--- copy assignment of p3 from src p2");
Example1::Point p3("p3");
p3 = p2;
p3.name() = "p3";
show(p3);
        </defn-code>
        <defn-head class="defnBorderTop">
          Output:
        </defn-head>
        <defn-code>
--- Example1::Point ---
p1
1 2 3
--- copy construction of p2 using src p1 ---
p2
1 2 3
--- copy assignment of p3 from src p2
p3
1 2 3
        </defn-code>
      </defn-block>
    </defn-outerBlock>
    </details>
    <t-b>
      This class doesn&apos;t need to provide means to support copying and assignment.  The
      compiler will generate methods for that, doing member-wise copy and assignment.  The name_
      member has correct copy semantics, providing those as part of its class design.  The
      coordinate array requires a memory copy operation, but that is provided by compiler generated
      copy construction and copy assignment operations. Look at sections 3.2 and 3.3 to see an
      example for a struct.
    </t-b>
    <t-b>
      While this design works, and correctly supports locating points in three physical
      dimensions, there are two things I don&apos;t like about this code:
    </t-b>
    <t-b class="indent">
      <ol class="tight">
        <li>
          Class methods are defined in-line in the body of the class declaration, Java style.
          That makes reading the interface harder than necessary.  It&apos;s better C++ style
          to move method definitions out of the class declaration.
        </li>
        <li>
          This is an unnecessarily inflexible design.  Defining the class&apos;s coordinate buffer
          as a composed member means that we must define the array size at compile time, because
          the array will be placed in static memory and the compiler does that.
        </li>
      </ol>
    </t-b>
    <t-b>
      If we wanted to use instances of this class in an air-traffic control system, we probably
      would want to store the time of observation as part of the point&apos;s coordinates, e.g.,
      location in both time and space, so there are now four coordinates. An effective way
      to support configuring a class for needs
      of a specific application is to define its storage at run-time, based on some parameter
      passed to the class.  We can do that by creating the buffer in the native heap, providing
      the array size as needed.
    </t-b>
    <t-b>
      One of the primary reasons for using the native heap is to allow allocating memory with
      size determined by the application, at run-time.  In the revision, shown
      below, we will use std::vector&lt;double&gt; that does that buffer management internally for us.
    </t-b>
    <details>
      <summary class="labelStyle darkItem">Example2: Revised Point</summary>
      <spacer-10></spacer-10>
    <defn-outerBlock>
      <defn-block>
        <defn-head>
          Revised Class Example - Point:
        </defn-head>
        <defn-code>
namespace Example2 {

  class Point {
  public:
    Point(const std::string& name = "none", size_t N = 3);
    std::string& name();
    double& operator[](size_t i);
    double operator[](size_t i) const;
    size_t size() const;
  private:
    std::string name_;
    std::vector&lt;double&gt; coordinates_;
  };
  /*--- constructor ---*/
  Point::Point(const std::string& name, size_t N)
    : name_(name), coordinates_(N) {
  }
  /*--- name accessor ---*/
  std::string& Point::name() {
    return name_;
  }
  /*--- indexer for non-const instances ---*/
  double& Point::operator[](size_t i) {
    if (i &lt; 0 || coordinates_.size() &lt;= i)
      throw std::exception("index out of range");
    return coordinates_[i];
  }
  /*--- indexer for const instances ---*/
  double Point::operator[](size_t i) const {
    if (i &lt; 0 || coordinates_.size() &lt;= i)
      throw std::exception("index out of range");
    return coordinates_[i];
  }
  /*--- buffer size accessor ---*/
  size_t Point::size() const {
    return coordinates_.size();
  }
}

/*--- generic display function ---*/
template&lt;typename T&gt;
void show(T t) {
  std::cout &lt;&lt; "\n  " &lt;&lt; t.name() &lt;&lt; "\n  ";
  for (size_t i = 0; i &lt; t.size(); ++i) {
    std::cout &lt;&lt; t[i] &lt;&lt; " ";
  }
  std::cout &lt;&lt; std::endl;
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>
          Using code:
        </defn-head>
        <defn-code>
displayDemo("--- Example2::Point ---");
Example2::Point p4("p4", 3);
p4[0] = -1.0;
p4[1] = 0.0;
p4[2] = 1.0;
show(p4);
displayDemo("--- copy constr of p5 using src p4 ---");
Example2::Point p5{ p4 };
p5.name() = "p5";
show(p5);
displayDemo("--- copy assignment of p6 from src p5");
Example2::Point p6("p6");
p6 = p5;
p6.name() = "p6";
show(p6);
        </defn-code>
        <defn-head class="defnBorderTop">
          Output:
        </defn-head>
        <defn-code>
--- Example2::Point ---
p4
-1 0 1

--- copy construction of p5 using src p4 ---
p5
-1 0 1

--- copy assignment of p6 from src p5
p6
-1 0 1
        </defn-code>
      </defn-block>
    </defn-outerBlock>
    </details>
    <t-b>
      The implementation of Example2::Point is better:
      <ol>
        <li>
          Method definitions are factored out of Example2::Point class declaration which makes
          the class interface easier to comprehend.  We&apos;ve also provided a prologue
          comment for each method.
        </li>
        <li>
          We&apos;ve added an index operator for constant points, as without that, using
          code cannot index a const point.
        </li>
        <li>
          Like Example1::Point, this implementation doesn&apos;t need a copy constructor,
          copy assignment operator, or destructor since the compiler generated methods work
          correctly.  The reason for that is that all the data members have correct copy,
          assignment, and destruction semantics - all of the STL containers, like
          std::string and std::vector, have those properties.
        </li>
      </ol>
    </t-b>
    <t-b>
      This isn&apos;t the end of the Point story though; some applications may need very small,
      and fast components.  Suppose that we want to implement an air quality monitor, for things
      like temperature, humidity, carbon monoxide, radon emissions, and volatile organic
      compounds. This application will probably run on a controller chip or Arduno, with limited
      storage.  It will need to handle storage of an open-ended number of measurements, each one
      a coordinate in the air quality space, and do that relatively quickly to keep up with a
      specified logging cycle.
    </t-b>
    <t-b>
      For this, we&apos;ve decided to go back to using a buffer as it will be slightly smaller
      and substantially faster than a <c-s>std::vector&lt;double&gt;</c-s>.  To provide the
      flexability to handle an open-ended number of measurements, we will store the coordinate
      buffer in heap memory, allowing us to specify buffer size at run-time. This assumes that
      the instrument&apos;s operating system supports heap memory.
    </t-b>
    <details>
      <summary class="labelStyle darkItem">Example3: Point Revised Again</summary>
      <spacer-10></spacer-10>
    <defn-outerBlock>
      <defn-block>
        <defn-head>
          Revised again Example:
        </defn-head>
        <defn-code>
namespace Example3 {

  class Point {
  public:
    Point(const std::string& name = "none", size_t N = 3);
    Point(const Point& x);
    ~Point();
    Point& operator=(const Point& x);
    std::string& name();
    double& operator[](size_t i);
    double operator[](size_t i) const;
    size_t size() const;
  private:
    std::string name_;
    double* pBuffer_ = nullptr;
    size_t bufSize_ = 0;
  };
  /*--- constructor ---*/
  Point::Point(const std::string& name, size_t N)
    : name_(name), 
      bufSize_(N), pBuffer_(new double[N]) {
  }
  /*--- copy constructor ---*/
  Point::Point(const Point& x)
    : bufSize_(x.bufSize_), 
      pBuffer_(new double[x.bufSize_]) {
    name_ = x.name_;
    memcpy(pBuffer_, x.pBuffer_, bufSize_ * sizeof(double));
  }
  /*--- destructor ---*/
  Point::~Point() {
    delete[] pBuffer_;
  }
  /*--- copy assignment operator ---*/
  Point& Point::operator=(const Point& x) {
    if (this != &x) {
      /* won't assign name */
      bufSize_ = x.bufSize_;
      delete pBuffer_;
      pBuffer_ = new double[bufSize_];
      memcpy(pBuffer_, x.pBuffer_, bufSize_ * sizeof(double));
    }
    return *this;
  }
  /*--- name accessor ---*/
  std::string& Point::name() {
    return name_;
  }
  /*--- indexer for non-const instances ---*/
  double& Point::operator[](size_t i) {
    if (i &lt; 0 || bufSize_ &lt;= i)
      throw std::exception("index out of range");
    return *(pBuffer_ + i);
  }
  /*--- indexer for const instances ---*/
  double Point::operator[](size_t i) const {
    if (i &lt; 0 || bufSize_ &lt;= i)
      throw std::exception("index out of range");
    return *(pBuffer_ + i);
  }
  /*--- buffer size accessor ---*/
  size_t Point::size() const {
    return bufSize_;
  }
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>
          Using code:
        </defn-head>
        <defn-code>
displayDemo("--- Example3::Point ---");
Example3::Point p7("p7", 3);
p7[0] = -0.5;
p7[1] = 0.0;
p7[2] = 0.5;
show(p7);
displayDemo("--- copy constr p8 using src p7 ---");
Example3::Point p8{ p7 };
p8.name() = "p8";
show(p8);
displayDemo("--- copy assign p9 from src p8 ---");
Example3::Point p9("p9");
p9 = p8;
show(p8);
        </defn-code>
        <defn-head class="defnBorderTop">
          Output:
        </defn-head>
        <defn-code>
--- Example3::Point ---
p7
-0.5 0 0.5

--- copy construction of p8 using src p7 ---
p8
-0.5 0 0.5

--- copy assignment of p9 from src p8
p8
-0.5 0 0.5
        </defn-code>
      </defn-block>
    </defn-outerBlock>
    </details>
    <t-b>
      There are some things to note about this design:
      <ol>
        <li>
          Now, instead of composing the data buffer, as we did in Example1::Point, we aggregate
          it, e.g., we point to a heap-based buffer with the pointer pBuffer_.
        </li>
        <li>
          We are now obliged to provide a copy constructior, copy assignment operator, and
          destructor.  The presence of the pointer, pBuffer_, means that all the class data
          members no longer have correct copy, assignment, and destruction semantics.  The
          class&apos;s generated methods would simply copy and assign
          <span class="notice">pBuffer_</span>, not what it points to.  That would result
          in incorrect operation, as you can verify by commenting out those operations
          and running <a href="https://github.com/JimFawcett/CppStory">code</a>, in
          the Chapter4-classes folder.
        </li>
        <li>
          The example shows you how to implement copy, assignment, and destruction operations for
          this common scenario.
        </li>
        <li>
          The Point design is now more complex that either of the first two, since we now must
          implement copies, assignment, and destruction. We would probably do some performance testing to
          be sure the improvement over Example2::Point was significant enough to warrant this choice.
        </li>
      </ol>
    </t-b>
    <t-b>
      If some of the implementation seems hard to understand, pause and look at
      <a href="../JimFawcett.github.io/STRCode.html">STRCode.html</a> presentation.  It describes all the
      details of each of these methods, using a demonstration string class.  We will also look
      again at all these methods in section 4.4 Class Anatomy.
    </t-b>

    <h3 id="valtype">5.2  Value Types</h3>
    <t-b>
      All three of the example Point implementations, above, have value type semantics.
    </t-b>
    <div class="indent">
      <defn-block class="t-b">
        <defn-head>Value Types:</defn-head>
        <defn-body>
          <t-b>
            Value types can be copied and assigned.  When a copy or assignment operation completes
            there are two instances of the type which, immediately following the operation, have
            the same state values, but are independent. Should using code change the state
            of one, the other&apos;s state is not affected.  Note that this is not true for user-defined
            types built from classes in managed languages like C# and Java.
          </t-b>
          <t-b>
            The C++ programming language was designed, from the ground up, to support value semantics.
            It does that by:
          </t-b>
          <t-b>
            <ol>
              <li style="padding:0;margin-top:0.5rem;margin-bottom:0.5rem;">
                Providing compiler generated copy constructors, copy assignment operators, and
                destructors, for cases where all the class&apos;s base classes and data members
                have correct copy, assignment, and destruction semantics. For those cases, e.g.,
                data members are fundamental types and/or STL containers, you should not implement
                those methods - the compiler will implement them correctly.
              </li>
              <li style="padding:0;margin-top:0.5rem;margin-bottom:0.5rem;">
                When data members do not have correct copy, assignment, and destruction
                behaviours, the language supports definition of those operations as class
                methods, as we have done in Example3::Point.  In these cases, e.g., when
                the class holds a pointer member to data in the native heap, you either
                implement those methods or disallow them, preventing the compiler from
                generating them.
              </li>
              <li style="padding:0;margin-top:0.5rem;margin-bottom:0.5rem;">
                The compiler will not generate constructors or assignment operators if you
                declare them and use a <c-s>= delete</c-s> suffix.
              </li>
            </ol>
          </t-b>
          <t-b>
            C++ value types can be used in inheritance hierarchies.  There is no other modern
            language that supports polymorphic value types.  This is not a &quot;show stopper&quot;.
            There are other ways to create designs that don&apos;t require polymorphic value types,
            but it is nice to have that design option.
          </t-b>
        </defn-body>
      </defn-block>
    </div>
    <t-b>
      Make sure you look at the reference below. It walks you through the implementation of all of the
      class methods required to implement value types:
      <div style="height:0.5em;"></div>
      <indent-block>
        <div class="pad10-15" style="border:2px solid var(--dark); width:max-content;">
          <a href="STRCode.html">Value Type Example - STRCode.html</a>
        </div>
      </indent-block>
      <div style="height:0.25em;"></div>
    </t-b>
    <t-b>
      Because of its support for value types, C++ is very effective for scientific
      and financial computing.
      Libraries supporting those domains will need to be able
      to make copies and assign instances of library classes.  Matrix and vector operations are
      typical examples.
    </t-b>
    <h3 id="RAII">5.3  Scope-based Resource Allocation</h3>
    <t-b>
      The C++ language provides a very elegant mechanism, also known as &quot;Resource Allocation Is Initialization&quot;
      <span class="notice">(RAII)</span>, for managing class resources based on local scope.
    </t-b>
    <div class="indent" style="max-width:45rem;">
      <defn-block>
        <defn-head>
          Scoped-based Resource Management
        </defn-head>
        <defn-body>
          <t-b>
            Instances of classes allocate resources they need in constructors and, occasionally,
            in other member functions. All resources are deallocated in the class destructor.
          </t-b>
          <t-b>
            The C++ language guarantees that the destructor will be called when an instance goes out
            of scope, e.g., when the thread of program execution leaves the scope in which the instance was
            declared.  This includes abnormal exit when an exception is thrown.
          </t-b>
        </defn-body>
      </defn-block>
    </div>    <t-b>
      This mechanism makes handling
      pointer-based operations safe and simple.  We wrap all heap operations in classes and handle
      pointer and heap interactions in class constructors and destructor.  That avoids memory leaks
      and invalid memory access.  Only one person has to get that right - the class designer - and
      since that processing happens only in the wrapping class it is easy to do that correctly.
    </t-b>
    <t-b>
      For those rare cases when we elect to access the heap outside confines of a class, C++
      provides <c-s>std::unique_ptr&lt;T&gt;</c-s> and <c-s>std::shared_ptr&lt;T&gt;</c-s>
      that automatically delete heap allocations when they go out of scope, or the last reference
      becomes invalid, respectively.
    </t-b>
    <t-b>
      Users of a class can be blissfully ignorant of resource management details.  They just
      create and use instances of the class and don&apos;t have to participate in management of
      resources it needs to function.
    </t-b>
    <t-b>
      Compare that to the resource management process for managed languages like Java and C#.
      Managed languages return allocated resources with garbage collection.  That usually works
      well, but is non-deterministic.  To ensure that shared resources like database readers and file
      streams are deallocated in a timely fashion every user has to know which classes are disposable
      and remember to call dispose on instances when their processing is done.
    </t-b>

    <h3 id="anatexam">5.4  Class Anatomy Example</h3>
    <t-b>
      Class Anatomy is a demonstration of the most common and important parts of a C++ class.
      Its only purpose is to demonstrate syntax for the common operations and to illustrate
      when they are invoked. Each of these important methods announces to the console when it
      has been invoked, so you can correlate the syntax of invocation with the method syntax.
    </t-b>
    <t-b>
      We will see, for example, that the statement below:
    </t-b>
    <pre>
    <c-s>X x2 = x1;</c-s>
</pre>
    <t-b>
      is not an assignment.  Only the X copy constructor is invoked.  Because that can be confusing
      to those new to C++, I prefer to use the equivalent syntax:
    </t-b>
    <pre>
    <c-s>X x2{ x1 };</c-s>
</pre>
    <t-b>
      When you expand the Class Anatomy Code details dropdown, below, you will see that Anatomy output
      shows you what occurred for each method invocation.
    </t-b>
    <details>
      <summary class="labelStyle darkItem">Class Anatomy Code</summary>
      <spacer-10></spacer-10>
      <defn-outerBlock>
      <defn-block>
        <defn-head>Anatomy Class</defn-head>
        <defn-code>
class Anatomy {
public:
  Anatomy();                                 // default
  Anatomy(const std::string& nameStr);       // promo
  Anatomy(const Anatomy& a);                 // copy
  Anatomy(Anatomy&& a) noexcept;             // move
  Anatomy& operator=(const Anatomy& a);      // copy
  Anatomy& operator=(Anatomy&& a) noexcept;  // move
  ~Anatomy();                                // dtor
  void name(const std::string& nameStr);
  std::string name() const;
  size_t objNumber() const;
  template&lt;typename T&gt;
  void setValue(const T& t);
  template&lt;typename T&gt;
  T getValue() const;
  void showMsg(
    size_t n, const std::string& msg
  );
private:
  std::string name_;
  static size_t count;
  size_t myCount = 0;
  std::any value;
  constexpr static size_t MaxMsg = 6;
  std::string invMsg[MaxMsg]{
    "default ctor invoked",
    "copy ctor invoked",
    "move ctor invoked",
    "copy assignment invoked",
    "move assignment invoked",
    "dtor invoked"
  };
};

size_t Anatomy::count = 0;

void Anatomy::showMsg(
  size_t n, const std::string& msg
) {
  if (Assert(0 &lt;= n && n &lt; MaxMsg))
    return;
  std::string localMsg = invMsg[n];
  std::cout &lt;&lt; "\n  " &lt;&lt; localMsg;
  if (msg.size() &gt; 0)
    std::cout &lt;&lt; ", " &lt;&lt; msg;
}
/*--- default constructor ---*/
Anatomy::Anatomy() 
  : value(std::any()), name_("unknown") {
  myCount = ++count;
  showMsg(0, "obj #" + std::to_string(myCount));
}
/*--- promotion constructor ---*/
Anatomy::Anatomy(const std::string& nameStr)
  : value(std::any()), name_(nameStr) {
  myCount = ++count;
  showMsg(0, "obj #" + std::to_string(myCount));
}
/*--- copy constructor ---*/
Anatomy::Anatomy(const Anatomy& a)
  : value(a.value), name_(a.name_) {
  myCount = ++count;
  showMsg(1, "obj #" + std::to_string(myCount));
}
/*--- move constructor ---*/
Anatomy::Anatomy(Anatomy&& a) noexcept
  : value(std::move(a.value)), 
    name_(std::move(a.name_)) {
  myCount = ++count;
  showMsg(2, "obj #" + std::to_string(myCount));
}
/*--- copy assignment operator ---*/
Anatomy& Anatomy::operator=(const Anatomy& a) {
  if (this != &a) {
    // don't want to rename, so no copy
    value = a.value;
  }
  showMsg(3, "obj #" + std::to_string(myCount));
  return *this;
}
/*--- move assignment operator ---*/
Anatomy& Anatomy::operator=(Anatomy&& a) noexcept {
  if (this != &a) {
    // don't want to rename, so no copy
    value = std::move(a.value);
  }
  showMsg(4, "obj #" + std::to_string(myCount));
  return *this;
}
/*--- destructor ---*/
Anatomy::~Anatomy() {
  showMsg(5, "obj #" + std::to_string(myCount));
  // name_ & value are composed, so their dtors
  // are called here
}
/*--- name setter ----*/
void Anatomy::name(const std::string& nameStr) {
  name_ = nameStr;
}
/*--- name getter ---*/
std::string Anatomy::name() const {
  return name_;
}
/*--- objNumber getter ---*/
size_t Anatomy::objNumber() const {
  return myCount;
}
/*--- value setter ---*/
template&lt;typename T&gt;
void Anatomy::setValue(const T& t) {
  value = t;
}
/*--- value getter ---*/
template&lt;typename T&gt;
T Anatomy::getValue() const {
  try {
    return std::any_cast&lt;T&gt;(value);
  }
  catch (...) {
    std::cout &lt;&lt; " --- can't retrieve value for " 
              &lt;&lt; name_ &lt;&lt; " ---";
    return T();
  }
}
/*--- Anatomy object factory ---*/
template&lt;typename T&gt;
Anatomy makeAnatomy(const T& t = T()) {
  Anatomy temp("created");
  temp.setValue(t);
  return temp;
}
/*--- show Anatomy state ---*/
template&lt;typename T&gt;
void showAnatomy(const Anatomy& a, size_t line = 0) {
  if (line &gt; 0)
    std::cout &lt;&lt; "\n  at line #" &lt;&lt; line;
  std::cout &lt;&lt; "\n  " &lt;&lt; a.name() 
            &lt;&lt; ", obj#" &lt;&lt; a.objNumber()
            &lt;&lt; ", has value " 
            &lt;&lt; a.getValue&lt;T&gt;() 
            &lt;&lt; std::endl;
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>
          Using Code:
        </defn-head>
        <defn-code>
362  std::cout &lt;&lt; 
       "\n  Demonstrate Class Anatomy";
363  std::cout &lt;&lt; 
       "\n ===========================\n";
364
365  Anatomy a1;
366  a1.setValue(1.5);
367  showAnatomy&lt;double>(a1, __LINE__ - 2);
368
369  Anatomy a2{ a1 };
370  a2.name("a2");
371  showAnatomy&lt;double>(a2, __LINE__ - 2);
372
373  a1 = a2;
374  showAnatomy&lt;double>(a1, __LINE__ - 1);
375
376  Anatomy a3 = makeAnatomy(
       std::string("some string")
     );
377  showAnatomy&lt;std::string>(
       a3, __LINE__ - 1
     );
378
379  Anatomy a4;
380  a4 = makeAnatomy(5);
381  showAnatomy&lt;int>(a4, __LINE__ - 1);
        </defn-code>
        <defn-head class="defnBorderTop">
          Output:
        </defn-head>
        <defn-code>
Demonstrate Class Anatomy
===========================

default ctor invoked, obj #1
at line #365
unknown, obj#1, has value 1.5

copy ctor invoked, obj #2
at line #369
a2, obj#2, has value 1.5

copy assignment invoked, obj #1
at line #373
unknown, obj#1, has value 1.5

default ctor invoked, obj #3
move ctor invoked, obj #4
dtor invoked, obj #3
at line #376
created, obj#4, has value some string

default ctor invoked, obj #5
default ctor invoked, obj #6
move ctor invoked, obj #7
dtor invoked, obj #6
move assignment invoked, obj #5
dtor invoked, obj #7
at line #380
unknown, obj#5, has value 5

dtor invoked, obj #5
dtor invoked, obj #4
dtor invoked, obj #2
dtor invoked, obj #1
        </defn-code>
      </defn-block>
      </defn-outerBlock>
    </details>
    <t-b>
      This is the first time we&apos;ve seen move operations in action. The move constructor,
      <c-s class="noWrap">Anatomy(Anatomy&& a)</c-s>, and move assignment operator,
      <c-s class="noWrap">Anatomy&amp; Anatomy(Anatomy&& a)</c-s>, transfer ownership of the source
      instance state to the destination instance.
    </t-b>
    <t-b class="indent" style="max-width:45rem;">
      <defn-block>
        <defn-head>
          Move Construction : <c-s>X(X&& x)</c-s>
        </defn-head>
        <defn-body>
          <t-b>
            <c-s>X&&</c-s> is an rvalue reference bound to input <c-s>x</c-s>. Rvalue references accept
            either lvalues - named variables - or rvalues - temporaries like <c-s>X()</c-s>.
          </t-b>
          <t-b>
            Move construction transfers ownership of the state of a temporary X to state for a new X as part of its construction,
            e.g.:
            <indent-block class="pad10">
              <c-s>X x2 = std::move(x1);</c-s>
            </indent-block>
            Usually we won&apos;t see a move construction written that way. Instead, the move happens when
            a temporary is returned from a function:
          </t-b>
          <indent-block>
            <c-s>
              X makeAnX() {<br />
              &nbsp;&nbsp;X temp;<br />
              &nbsp;&nbsp;// configure temp<br />
              &nbsp;&nbsp;return temp;<br />
              }
              <div style="height:0.25em;"></div>
              X x = makeAnX();
            </c-s>
          </indent-block>
          <t-b>
            Ownership transfer often amounts to a pointer swap.  If we <c-s>std::move(str)</c-s>,
            where <c-s>str</c-s> is a <c-s>std::string</c-s>, ownership transfer passes
            <c-s>str</c-s>&apos;s character pointer to the destination string rather than copying
            all of its characters, and replaces <c-s>str</c-s>&apos;s character pointer with
            <c-s>nullptr</c-s>.  
          </t-b>
          <t-b>
            For the <c-s>makeAnX()</c-s> example above, the temporary is
            destroyed immediately after the return, so the <c-s>str</c-s> destructor calls
            <c-s>delete</c-s> on its character pointer, causing no harm (because it is nullptr).
            The compiler will use a copy constructor if the source object is not a temporary
            or if the source does not define move construction.
          </t-b>
          <t-b>
            Move construction allows us to build functions that define complex data structures
            and return them efficiently, with moves, to the using code.
          </t-b>
        </defn-body>
        <defn-head class="defnBorderTop">
          Move Assignment : <c-s>X&amp; operator=(X&& x)</c-s>
        </defn-head>
        <defn-body>
          <t-b>
            Move assignment works just like move construction, but is used to transfer ownership
            to an existing instance:
            <indent-block class="pad10">
              <c-s>
                X x;<br />
                x = makeAnX();
              </c-s>
            </indent-block>
          </t-b>
          <hr class="spreadup" />
          <t-b class="footnote">
            <ol>
              <li>
                lvalue and rvalue references were part of the C language lore. An lvalue is a
                named instance that would be defined on the left side of a declaration, e.g.:
                <indent-block class="pad5">
                  <c-s>int i{5};</c-s>
                </indent-block>
                Here i is an lvalue.  An rvalue is an anonymous instance that would appear on the right side of an
                expression, e.g.:
                <indent-block class="pad5">
                  <c-s>i = 7;</c-s>
                </indent-block>
                Here the literal 7 is an rvalue.
                <spacer-10></spacer-10>
                These classifications become slightly more complicated for C++.  See
                <a href="https://accu.org/index.php/journals/227">Lvalues and Rvalues</a>
              </li>
            </ol>
          </t-b>
        </defn-body>
      </defn-block>
    </t-b>
    <t-b>
      If we return by value a temporary instance of Anatomy
      from a function that creates it, as in <c-s>makeAnatomy</c-s>, the compiler uses
      move construction to return to a newly created instance, as in line 376 of the Anatomy output,
      above. If we return to an existing instance, as in line 380, the compiler uses move assignment.
    </t-b>
    <t-b>
      The <c-s class="noWrap">std::move(a.name_)</c-s> in Anatomy&apos;s move constructor
      simply copies the a.name_ character pointer to name_ instead of copying all its characters.
      The source instance is a temporary and will be destroyed as soon as the return has
      completed, so that loss of ownership has no effect.
    </t-b>
    <t-b>
      We&apos;ve used, in the Anatomy class, std::any to hold a value it uses.  Std::any,
      added in C++17, will hold an instance of any type.  When we call
      <c-s class="noWrap">std::move(a.value)</c-s> that uses the move constructor of the type
      held by any.  If that type does not provide a move constructor, the compiler simply uses
      the value&apos;s copy constructor.
      Move assigning to an already existing instance works the same way, e.g., transferring
      ownership of the temporary Anatomy&apos;s resource, inside <c-s>makeAnatomy</c-s>, to
      the destination via a move assignment operation.
    </t-b>

    <h3 id="genmeth">5.5  Compiler-Generated Methods</h3>
    <t-b>
      C++ compilers are required to generate certain methods if needed to support the C++
      object model. Compilers may generate:
    </t-b>
    <t-b class="indent">
      <ol class="tight">
        <li>
          copy constructor and copy assignment operator to support value behavior
        </li>
        <li>
          move constructor and move assignment operator to improve return value performance
        </li>
        <li>
          destructor to support release of resources
        </li>
        <li>
          default constructor to support basic creation
        </li>
      </ol>
    </t-b>
        <div style="height:0.25em;"></div>
    <t-b style="max-width:45rem;">
      <div class="indents">
        <defn-block>
          <defn-head>
            <span class="notice">How Compiler-Generated Methods Work:</span>
          </defn-head>
          <defn-body class="pad10">
            All of the compiler-generated methods do member-wise operations on each member of the
            class and its base classes, e.g., a compiler generated copy constructor simply copies
            each data member of the class and each data member inherited from its base classes.
          </defn-body>
        </defn-block>
      </div>    </t-b>
    <t-b>
      For a large fraction of the classes we write, class syntax is really quite simple, because
      the compiler implicitly generates a lot of methods for us.

      When that happens is described in Table 2.
    </t-b>
    <h4>Table 2. - Compiler generated methods</h4>
        <table>
          <tr>
            <th class="darkItem">Syntax</th><th class="darkItem">Conditions</th>
          </tr>
          <tr>
            <td>
              <c-s>X()</c-s>
            </td>
            <td>
              Default Constructor: Compiler will generate if, and only if, no constructors are declared. 
            </td>
          </tr>
          <tr>
            <td>
              <c-s>X(const X&amp; x)</c-s>
            </td>
            <td>
              Copy Constructor: Compiler will always generate as needed if not declared by class. 
            </td>
          </tr>
          <tr>
            <td>
              <c-s>X(X&amp;&amp; x)</c-s>
            </td>
            <td>
              Move Constructor: Compiler will generate if, and only if, no copy and no move constructors<br /> 
              and assignment operators are declared.
            </td>
          </tr>
          <tr>
            <td style="white-space:nowrap;">
              <c-s>X&amp;&nbsp;operator=(const&nbsp;X&amp;&nbsp;x)</c-s>
            </td>
            <td>
              Copy Assignment: Compiler will always generate as needed if not declared by class.
            </td>
          </tr>
          <tr>
            <td>
              <c-s>X&amp; operator=(X&amp;&amp; x)</c-s>
            </td>
            <td>
              Move Assignment: Compiler will generate if, and only if, no copy and no move constructors<br /> 
              and assignment operators are declared. 
            </td>
          </tr>
          <tr>
            <td>
              <c-s>~X()</c-s>
            </td>
            <td>
              Destructor: Compiler will always generate if not declared. 
            </td>
          </tr>
        </table>

    <t-b>
      The only difficulty with this process is to remember when you should or should not let
      the compiler generate those methods.  That isn&apos;t to difficult - the conditions are
      presented in Table 3., below.
    </t-b>
    <h4>Table 3. - When Value Methods should (not) be implemented</h4>
        <table>
          <tr>
            <th class="darkItem">Define Value Methods</th>
            <th class="darkItem">When</th>
            <th class="darkItem">Examples</th>
          </tr>
          <tr>
            <td>Allow compiler to generate methods</td>
            <td>
              Bases and member data have correct copy,
              assignment, and destruction semantics.
            </td>
            <td>
              All data members in class and its base classes are
              fundamental types, arrays of fundamental types, or
              any of the STL container classes.
            </td>
          </tr>
          <tr>
            <td>
              Designer provides methods
            </td>
            <td>
              At least one base class is not a value type
              or at least one data member does not have
              correct copy, assignment, and destruction semantics.
            </td>
            <td>
              Class contains pointer to resources stored on heap.
            </td>
          </tr>
          <tr>
            <td style="white-space:nowrap;">
              Designer disables value methods:<br />
              &nbsp;&nbsp;<c-s>X(const X&X x) = delete;</c-s><br />
              &nbsp;&nbsp;<c-s>X& operator=(const X& x) = delete;</c-s>
            </td>
            <td>
              A data member is not copyable or assignable.
            </td>
            <td>
              Data member is <c-s>const</c-s> or reference, <c-s>Y& y</c-s>.
              Other examples: data member is mutex, condition variable,
              database reader, file stream.
            </td>
          </tr>
        </table>

    <t-b>
      You need to (almost always) obey the <span class="notice">law of threes</span>: if you provide any one of the three methods:
      copy constructor, copy assignment operator, and destructor, you should provide all three.
    </t-b>
    <t-b>
      There are three cases, as cited in Table 3:
    </t-b>
    <t-b>
      <ul class="tight">
        <li>Let the compiler generate methods - true for a large fraction of the classes we design.</li>
        <li>Provide the methods, as we did in Example3::Point.</li>
        <li>Disable copy and assignment with the <c-s>= delete</c-s> suffix.</li>
      </ul>
    </t-b>

    <h3 id="classexmp">5.6  Class Examples from the Repositories</h3>
    <t-b>
      In Table 4., below, you will find many more examples of classes. They are listed in order
      of relevance to the material in this chapter. For Windows, download code you want to study, and,
      using Windows explorer, open the solution (*.sln) in Visual Studio Community Edition, 2019 or
      later.  Each project needs to be built with the C++17 option set.  That should already be
      set in each project&apos;s properties, but if not, simply, right-click on the project
      properties and select:
      <indent-block class="pad10">
        Properties > C/C++ > language > C++ Language Standard > ISO C++17 Standard
      </indent-block>
      Eventually, setup for Visual Studio Code will be included in most of the repositories.
      That will allow you to run this code in Linux or MacOS.  But that won&apos;t appear for
      awhile.
    </t-b>
    <h4>Table 4. - Examples from C++ Repositories</h4>
        <table>
          <tr class="darkItem">
            <th>Code Source</th><th>Description</th>
          </tr>
          <tr>
            <td><a href="CppStoryRepo.html">CppStoryRepo.html</a></td>
            <td>
              Contains all code used for illustration in the chapter.
            </td>
          </tr>
          <tr>
            <td><a href="STRCode.html">STRCode.html</a></td>
            <td>
              Shows how to implement all of the methods needed to make a value type.  The documentation
              page provides a lot of that information.
            </td>
          </tr>
          <tr>
            <td><a href="CppBasicDemos.html">CppBasicDemos.html</a></td>
            <td>
              Demonstrates: pointers and references, lambdas, callable objects, storage sizes, modern casts,
              alternate constructor syntax (Equiv), and class layout.
            </td>
          </tr>
          <tr>
            <td><a href="FileManager.html">FileManager.html</a></td>
            <td>
              Contains five projects that illustrate alternate ways of building a directory explorer.
              Much like the Point projects in <a href="#point">Section 4.1</a>, they explore ways of
              making code flexible and effective.
            </td>
          </tr>
          <tr>
            <td><a href="CppGraph.html">CppGraph.html</a></td>
            <td>
              Builds a directed graph and provides methods for processing data in each vertex and edge.
            </td>
          </tr>
          <tr>
            <td><a href="ObjectFactories.html">ObjectFactories.html</a></td>
            <td>
              Demonstrates code for Dependency Inversion: Interfaces and Object Factories.
            </td>
          </tr>
          <tr>
            <td><a href="STL-Containers.html">STL-Containers.html</a></td>
            <td>
              Simple demonstrations of use for each of the STL containers and adapters.
            </td>
          </tr>
          <tr>
            <td><a href="CppConcurrentFileAccess.html">CppConcurrentFileAccess.html</a></td>
            <td>
              This component attempts to open a file for either reading or writing.  If open fails, the component
              sleeps for a while, then attempts to open again, trying a finite number of times.
            </td>
          </tr>
        </table>
    <h3 id="epilogue">5.7  Epilogue</h3>
    <t-b>
      We&apos;ve looked, in some detail, at C++ classes, the way they are implemented and used, and the
      support the language provides for building value types.
    </t-b>
    <t-b>
      This concludes our study of classes.  In the next chapter we explore class
      relationships - the glue that holds object-oriented programs together. Ciao.
    </t-b>
    <h3 id="exer">5.8  Programming Exercises</h3>
      <indent-blocks>
    <div style="width:80%">
      <ol>
        <li>
          Write a class that has a single implemented method,
          <code-span>void title(const std::string&amp; msg)</code-span>.
          The method should format the title, as in Exercises-1:7.
          <hr />
          How many methods does this class have? Remember that the compiler will generate certain
          constructors, a copy assignment operator, and a destructor.  The answer depends on whether
          you stored the msg string as a member of the class - no need to do that for a title, but
          you might want to add other functionality to the class later.
          Should you implement the compiler generated methods?
        </li>
        <li>
          For the class you created in the first exercise, add a method called
          <code-span>add(const std::string&amp; text)</code-span> that
          accepts a std::string and appends it to a private std::string member.  Also, add a method
          to return the std::string member by value.
          <hr />
          How should you initialize the std::string member?  Can you write the &quot;add&quot; method
          so that it returns a reference an invoking instance of the class?  That will allow you to
          chain calls, e.g., <code-span>x.add(":&nbsp;one").add(",&nbsp;two")</code-span>.
        </li>
        <li>
          Build a class with method <code-span>bool top(const std::string&amp; fileSpec, size_t n)</code-span>.
          Attempt to open the file, and if that succeeds, display the first N lines.
          <hr />
          Please handle file opening errors in some meaningful way.
        </li>
        <li>
          Using code from the <a href="https://github.com/JimFawcett/FileDates">FileDates</a> repository,
          build a class that finds all the files within a specified range of dates.
          <hr />
          What you are asked to do is fairly easy to implement, so take the time to look carefully
          at the design of the FileDates compound object.
        </li>
      </ol>
    </div>
  </indent-blocks>


    <h3 id="refs">5.9  References</h3>
    <indent-block>
      <a href="cpppatterns.com">cpppatterns.com</a><br />
      <a href="https://www.fluentcpp.com/posts/">Posts on Fluent C++</a><br />
      <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms">C++ Idioms</a><br />
      <a href="https://www.youtube.com/playlist?list=PLs3KjaCtOwSZ2tbuV1hx8Xz-rFZTan2J1">C++ weekly videos</a><br /> 
    </indent-block>
  </div>
        <spacer-25></spacer-25>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <sec-elem style="width:0.0em">&nbsp;</sec-elem>
        <menu-elem class="secElem"><a href="#bottom">bot</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#exer">exer</a></menu-elem>
        <menu-elem class="secElem"><a href="#epilogue">epil</a></menu-elem>
        <menu-elem class="secElem"><a href="#classexmp">classexmp</a></menu-elem>
        <menu-elem class="secElem"><a href="#genmeth">genmeth</a></menu-elem>
        <menu-elem class="secElem"><a href="#anatexam">anatexam</a></menu-elem>
        <menu-elem class="secElem"><a href="#RAII">RAII</a></menu-elem>
        <menu-elem class="secElem"><a href="#valtype">valtype</a></menu-elem>
        <menu-elem class="secElem"><a href="#ptexam">ptexam</a></menu-elem>
        <menu-elem class="secElem"><a href="#ptclass">ptclass</a></menu-elem>
        <menu-elem class="secElem"><a href="#method">methods</a></menu-elem>
        <menu-elem class="secElem"><a href="#basiccl">basiccl</a></menu-elem>
        <menu-elem class="secElem"><a href="#prologue">prol</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
</body>
</html>