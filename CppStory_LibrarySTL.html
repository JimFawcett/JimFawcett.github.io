<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Libraries.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Story-Libs</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    /*#github .pad10-15 {
      padding: 10px 15px;
    }

    #github .codeStyle {
      overflow: hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github .labelStyle {
      font-family: sans-serif;
      /*font-weight:bold;*/
      font-size: 1.0em;
    }

    #github .normal {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github summary {
      padding: 3px 0px 5px 0px;
      font-weight: bold;
      width: max-content;
    }

      #github summary ~ div {
        width: max-content;
        max-width: 95%;
      }

      #github summary ~ indent-block {
        width: max-content;
        max-width: 95%;
        padding-left: 20px;
        padding-right: 20px;
        /*background-color: #eee;*/
      }

    #github photosizer-block {
      position: relative;
      z-index: 2;
      background-color: white;
    }

    #github comment-block {
      width: max-content;
      max-width: 95%;
      padding: 10px 15px;
      background-color: #eee;
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github c-s {
      overflow: hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github t-s {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github .notice {
      font-size: 1.1em;
      font-weight: bolder;
      font-style: italic;
      font-family: Consolas, sans-serif;
      border: none;
      color: darkred;
    }

    #github background-block {
      display: block;
      background-color: #ddd;
      max-width: 90%;
      width: max-content;
      padding: 10px 15px;
    }

    #github .footnote {
      font-size: 0.85em;
    }*/

    #github ol.footnote li {
      padding-bottom: 0px;
    }
    #github th, td {
      padding: 5px 15px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Interesting.html">N</a>
  <a id="Prev" href="CppStory_LibraryStreams.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #8B - Standard Template Libraries (STL)</h1>
      <h3 id="subtitle">example code</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="CppStory_Prologue.html">Prologue</a><br />
       <a href="CppStory_Survey.html">Survey</a><br />
       <a href="CppStory_Data.html">Data</a><br />
       <a href="CppStory_Operations.html">Operations</a><br />
       <a href="CppStory_Classes.html">Classes</a><br />
       <a href="CppStory_ClassRelationships.html">ClassRel</a><br />
       <a href="CppStory_Templates.html">Templates</a><br />
       <a href="CppStory_TemplateMetaprog.html">TMP</a><br />
       <a href="CppStory_Libraries.html">Libraries</a><br />
       <a href="CppStory_LibraryStreams.html">Streams Libraries</a><br />
       <a href="CppStory_LibrarySTL.html">STL Libraries</a><br />
       <a href="CppStory_Interesting.html">Interesting</a>
     </up-b>
     <rt-b id="sects">
      <a href="#top">Top</a>, <a href="#libs">STL Libraries</a>, 
     <a href="#stl">STL</a>, <a href="#containers">Containers</a>, 
     <a href="#algor">Algorithms</a>, <a href="#examples">Code Examples</a>, 
     <a href="#epilog">Epilogue</a>,  
      <a href="#refs">References</a>, 
     </rt-b>
   </toc-b>

  <a id="libs"></a>
  <hr class="spread" />
  <bb-55>
    <num-cont>
      <num-item1>8B.0</num-item1><num-item4>STL Libraries Prologue:</num-item4>
    </num-cont>
    <t-b>
      The C++ language comes with a great collection of standard libraries. There are scores of very
      well designed facilities and more are coming with the next standardization in C++20.
      In this part we will be discussing the Standard Template Libraries (STL).
    </t-b>
    <a id="stl"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8B.1</num-item1><num-item4>STL Libraries:</num-item4>
    </num-cont>
    <div style="width:calc(100vw - 12rem);">
      <hidephotosizer-block src="Pictures/Iterators.jpg" width="400" class="photoSizerBlock right" style="margin-top:0;">
        <span style="font-family:'Comic Sans MS, Tahoma';">
          Fig 1. String Layout
        </span>
      </hidephotosizer-block>
    </div>
    <t-b>
      The STL consists of a fairly large collection of containers, scores of algorithms, and iterators.
      Iterators are the glue that binds algorithms to containers.
    </t-b>
    <t-b>
      Iterators are a special form of smart pointer.  Each container defines a set of iterators that
      know how to traverse its structure.  That may be a simple process for contiguous memory containers like
      <c-s>std::vector</c-s>, but significantly more detailed for containers like <c-s>std::unordered_map</c-s>.
      For the map, an iterator must be able to traverse a hash table, stepping over empty slots, and walk up
      bucket lists.
    </t-b>
    <t-b>
      Containers each have a set of iterators, e.g., <c-s>C::iterator</c-s>, <c-s>C::const_iterator</c-s>,
      <c-s>C::reverse_iterator</c-s>, etc. They also define traits like <c-s>C::value_type</c-s>. 
      <c-s>value_type</c-s>s are aliases for the type of value defined for an application&apos;s instantiation
      of a container.  So, for <c-s>std::vector&lt;std::pair&lt;int, double&gt;&gt;</c-s> the value type
      would be <c-s>std::pair&lt;int, double&gt;</c-s>.
    </t-b>
    <div class="clear"></div>
    <a id="containers"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8A.3</num-item1><num-item4>Containers:</num-item4>
    </num-cont>
    <t-b>
      There are three groups of STL containers: sequential, associative, and adaptors. The sequential
      containers arrange their elements in a linear sequence. All of the sets and maps are associative
      containers based on binary trees or hash tables.  The <c-s>std::stack</c-s>, <c-s>std::queue</c-s>, 
      and <c-s>std::priority_queue</c-s> are adapters, built on top of another container. All the other 
      containers are sequential.
    </t-b>
    <t-b>
      <h3 style="display:inline-block">List of STL Containers</h3> - <a href="STL-Containers.html">Simple code demos for each container</a>
      <table style="width:calc(100vw - 12rem);">
        <tr>
          <th class="darkItem">Container</th>
          <th class="darkItem">Description</th>
        </tr>
        <tr>
          <td>std::array&lt;T,N&gt;</td>
          <td>
            Fixed size array residing entirely in the local stackframe.  This is the only container,
            other than native arrays, that
            manages its data in the stack.  All others place their data in the native heap.
          </td>
        </tr>
        <tr>
          <td>std::deque&lt;T&gt;</td>
          <td>
            Indexable container with FIFO semantics constructed from three blocks of contiguous memory
            for fast access to the front and back.
          </td>
        </tr>
        <tr>
          <td>std::list&lt;T&gt;</td>
          <td>
            doubly-linked list, iterable but not indexable, can be traversed in either direction.
          </td>
        </tr>
        <tr>
          <td>std::map&lt;K,V&gt;</td>
          <td>
            Balanced binary tree with associative lookup: <c-s>myMap[key]</c-s> returns <c-s>value</c-s>.
            Duplicate <c-s>key</c-s>s are not allowed.
          </td>
        </tr>
        <tr>
          <td>std::multi_map&lt;K,V&gt;</td>
          <td>
            Same as <c-s>std::map</c-s> but duplicate keys are allowed.
          </td>
        </tr>
        <tr>
          <td>T t[N]</td>
          <td>
            Native array is indexable and iterable with native <c-s>T*</c-s> pointer. The functions
            <c-s>std::begin</c-s> and <c-s>std::end</c-s> allow native arrays to be iterated with
            range-based for loops.
          </td>
        </tr>
        <tr>
          <td>std::priority_queue&lt;T&gt;</td>
          <td>
            Heap structure that returns the largest of its elements.
          </td>
        </tr>
        <tr>
          <td>std::queue&lt;T&gt;</td>
          <td>
            An adapter, by default based on <c-s>std::deque</c-s>, has FIFO semantics.  It is not
            iterable or indexable.
          </td>
        </tr>
        <tr>
          <td>std::set&lt;T&gt;</td>
          <td>
            Based on balanced binary tree, does not allow duplicate keys.
          </td>
        </tr>
        <tr>
          <td>std::multi_set&lt;T&gt;</td>
          <td>
            Same as <c-s>std::set</c-s> except that it does allow duplicate keys.
          </td>
        </tr>
        <tr>
          <td>std::singlelist&lt;T&gt;</td>
          <td>
            Singly linked list, is iterable with forward iterator but not indexable.
          </td>
        </tr>
        <tr>
          <td>std::stack&lt;T&gt;</td>
          <td>
            An adapter, by default implemented using <c-s>std::deque</c-s>, has LIFO semantics,
            is not iterable or indexable.
          </td>
        </tr>
        <tr>
          <td>std::string&lt;Char&gt;</td>
          <td>
            Has all of the attributes of the other containers, is iterable and indexable.
          </td>
        </tr>
        <tr>
          <td>std::unordered_map&lt;K,V&gt;</td>
          <td>
            Hashed associative container with unique keys. Has a set of hash functions supplied by default
            for the primative types and strings.
          </td>
        </tr>
        <tr>
          <td>std::unordered_multimap&lt;K,V&gt;</td>
          <td>
            Same as <c-s>std::unordered_map</c-s> except that duplicate keys are allowed.
          </td>
        </tr>
        <tr>
          <td>std::unordered_set&lt;K&gt;</td>
          <td>
            Hashed set with unique keys.
          </td>
        </tr>
        <tr>
          <td>std::unordered_multiset&lt;K&gt;</td>
          <td>
            Same as <c-s>std::set</c-s> except that keys do not have to be unique.
          </td>
        </tr>
        <tr>
          <td>std::vector&lt;T&gt;</td>
          <td>
            Expandable array that is iterable and indexable.
          </td>
        </tr>
      </table>
    </t-b>
    <t-b>
      All of the containers have value semantics: they can be copied, assigned, and moved. That means that
      classes that have only numeric type and/or STL container members will have value semantics, using compiler
      generated methods.  So they tend to be small and simple because the STL containers do most of the heavy
      lifting.
    </t-b>
    <a id="algor"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8A.4</num-item1><num-item4>Algorithms:</num-item4>
    </num-cont>
    <t-b>
      The algorithms in the STL are not engineering or scientific algorithms, e.g., optimization or 
      fast Fourier transforms. They are relatively simple processes on collections of data held in
      an STL container.
    </t-b>
    <t-b>
      <h3 style="display:inline-block">Table 2. - Partial List of Algorithnms</h3> 
      - <a href="https://en.cppreference.com/w/cpp/algorithm">complete list</a>
      <table>
        <tr>
          <th class="darkItem">Algorithms</th><th class="darkItem">Description</th>
        </tr>
        <tr>
          <td class="defn"><c-s>for_each</c-s></td>
          <td class="defn">applies operation to each element</td>
        </tr>
        <tr>
          <td class="defn"><c-s>all_of</c-s>, <c-s>any_of</c-s>, <c-s>non_of</c-s></td>
          <td class="defn">checks if a predicate is true for all, any, or none of the elements</td>
        </tr>
        <tr>
          <td class="defn"><c-s>count</c-s>, <c-s>count_if</c-s></td>
          <td class="defn">returns numver of elements satisfying predicate</td>
        </tr>
        <tr>
          <td class="defn"><c-s>find</c-s>, <c-s>find_if</c-s>, <c-s>find_if_not</c-s></td>
          <td class="defn">finds first element satisfying a predicate</td>
        </tr>
        <tr>
          <td class="defn"><c-s>find_first_of</c-s></td>
          <td class="defn">searches for any one of a set of elements</td>
        </tr>
        <tr>
          <td class="defn"><c-s>search</c-s></td>
          <td class="defn">searches for a range of elements</td>
        </tr>
        <tr>
          <td class="defn"><c-s>copy</c-s>, <c-s>copy_if</c-s></td>
          <td class="defn">copies a range of elements to a new location</td>
        </tr>
        <tr>
          <td class="defn"><c-s>move</c-s></td>
          <td class="defn">moves a range of elements to a new location</td>
        </tr>
        <tr>
          <td class="defn"><c-s>fill</c-s></td>
          <td class="defn">copies value to every element in a range</td>
        </tr>
        <tr>
          <td class="defn"><c-s>transform</c-s></td>
          <td class="defn">
            applies operation to a range of elements, storing results in a destination range
          </td>
        </tr>
        <tr>
          <td class="defn"><c-s>generate</c-s></td>
          <td class="defn">applies results of operation to every element of a range</td>
        </tr>
        <tr>
          <td class="defn"><c-s>remove</c-s>, <c-s>remove_if</c-s></td>
          <td class="defn">remove elements satisfying predicate</td>
        </tr>
        <tr>
          <td class="defn"><c-s>replace</c-s>, <c-s>replace_if</c-s></td>
          <td class="defn">replaces all values satisfying predicate with new value</td>
        </tr>
        <tr>
          <td class="defn"><c-s>swap_ranges</c-s></td>
          <td class="defn">swaps two ranges of elements</td>
        </tr>
        <tr>
          <td class="defn"><c-s>reverse</c-s></td>
          <td class="defn">reverses order of elements in range</td>
        </tr>
        <tr>
          <td class="defn"><c-s>rotate</c-s></td>
          <td class="defn">rotates order of elements in range</td>
        </tr>
        <tr>
          <td class="defn"><c-s>shift_left</c-s>, <c-s>shift_right</c-s></td>
          <td class="defn">shifts elements in a range</td>
        </tr>
        <tr>
          <td class="defn"><c-s>unique</c-s></td>
          <td class="defn">removes consecutive duplicates in range</td>
        </tr>
        <tr>
          <td class="defn"><c-s>partition</c-s></td>
          <td class="defn">divides elements of a range into two groups</td>
        </tr>
        <tr>
          <td class="defn"><c-s>sort</c-s></td>
          <td class="defn">sorts a range into ascending order</td>
        </tr>
        <tr>
          <td class="defn"><c-s>stable_sort</c-s></td>
          <td class="defn">sorts a range of elements while preserving order of equal elements</td>
        </tr>
        <tr>
          <td class="defn"><c-s>merge</c-s></td>
          <td class="defn">merges two sorted ranges</td>
        </tr>
        <tr>
          <td class="defn"><c-s>max_element</c-s>, <c-s>min_element</c-s></td>
          <td class="defn">returns largest or smallest element in range</td>
        </tr>
        <tr>
          <td class="defn"><c-s>equal</c-s></td>
          <td class="defn">determines if two ranges are equal</td>
        </tr>
        <tr>
          <td class="defn"><c-s>lexicographical_compare</c-s></td>
          <td class="defn">returns true if one range is alphabetically less than another</td>
        </tr>
        <tr>
          <td class="defn"><c-s>accumulate</c-s></td>
          <td class="defn">finds sum of a range of elements</td>
        </tr>
      </table>
    </t-b>
    <t-b>
      As provided in C++17, the code using standard algorithms tends to be fairly complicated, littered 
      with iterators and can&apos;t easily be composed.  That will get better in C++20 with the new
      STL range technology.  In the mean-time, there are some things we can do to beautify our algorithm
      codes as illustrated in the examples below.
    </t-b>
    <a id="examples"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8B.5</num-item1><num-item4>Examples:</num-item4>
    </num-cont>
    <t-b>
      <details>
        <summary class="labelStyle darkItem">Examples: Simple Uses</summary>
        <t-b>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Definitions: Op, show, and Vec, Lst, iterator</defn-head>
              <defn-code>
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;unordered_map&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include "../Chapter7-Display/Chap7Display.h"

template&lt;typename V&gt;
class Op {
public:
  void operator()(V v) {
    if (first) {
      std::cout &lt;&lt; "\n  " &lt;&lt; v;
      first = false;
    }
    else {
      std::cout &lt;&lt; ", " &lt;&lt; v;
    }
  }
private:
  bool first = true;
};

template&lt;typename C&gt;
bool contains(C c, typename C::value_type v) {
  typename C::iterator iter = 
    std::find(c.begin(), c.end(), v);
  return iter != c.end();
}

template&lt;typename C&gt;
void show(C&amp; c) {
  std::cout &lt;&lt; "  ";
  for_each(
    c.begin(), c.end(), 
    Op&lt;typename C::value_type&gt;()
  );
}

template&lt;typename T&gt;
using Vec = std::vector&lt;T&gt;;

template&lt;typename T&gt;
using Lst = std::list&lt;T&gt;;

template&lt;typename T&gt;
using iterator = 
  typename std::vector&lt;T&gt;::iterator;
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
int main() {

  displayDemo("-- traditional algo use --");
  Vec&lt;int&gt; vecInt{ 1, 2, 3, 4, 5 };
  std::for_each(
    vecInt.begin(), vecInt.end(), 
    Op&lt;int&gt;()
  );

  int val = 3;
  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; "\n  vecInt contains " 
            &lt;&lt; val &lt;&lt; ": " 
            &lt;&lt; contains(vecInt, val);
  
  iterator&lt;int&gt; iter = 
    std::find(
      vecInt.begin(), vecInt.end(), val
    );
  std::cout &lt;&lt; "\n  found " &lt;&lt; val 
            &lt;&lt; " at location " 
            &lt;&lt; iter - vecInt.begin();
  val = 0;
  std::cout &lt;&lt; "\n  vecInt contains " 
            &lt;&lt; val &lt;&lt; ": " 
            &lt;&lt; contains(vecInt, val);

  displayDemo(
    "\n  -- copy with ostream_inserter --"
  );
  auto outIter = 
    std::ostream_iterator&lt;int&gt;(
      std::cout, " "
    );
  putline(1, "  ");
  std::copy(
    vecInt.begin(), vecInt.end(), outIter
  );

  displayDemo(
    "\n  -- copy with back_inserter --"
  );
  Vec&lt;int&gt; dstVec;
  auto binserter = std::back_inserter(dstVec);
  auto begin = [&amp;vecInt]() { 
    return vecInt.begin(); 
  };
  auto end = [&amp;vecInt]() { 
    return vecInt.end(); 
  };
  
  std::copy(begin(), --end(), binserter);
  show(dstVec);

  displayDemo("\n  -- copy with inserter --");
  auto inserter = 
    std::inserter(dstVec, ++++dstVec.begin());
  std::copy(begin(), end(), inserter);
  show(dstVec);

  putline(2);
}
              </defn-code>
              <defn-head class="defnBorderTop">Output</defn-head>
              <defn-code>
  -- traditional algo use --
  1, 2, 3, 4, 5

  vecInt contains 3: true
  found 3 at location 2
  vecInt contains 0: false

  -- copy with ostream_inserter --
  1 2 3 4 5

  -- copy with back_inserter --
  1, 2, 3, 4

  -- copy with inserter --
  1, 2, 1, 2, 3, 4, 5, 3, 4
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </t-b>
      </details>
    </t-b>

    <a id="eplilog"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8B.6</num-item1><num-item4>Epilogue:</num-item4>
    </num-cont>
    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>8.10</num-item1><num-item4>References:</num-item4>
    </num-cont>
    <indent-block>
      <a href="https://cplusplus.github.io/networking-ts/draft.pdf">C++ Networking TS draft</a><br />
      <a href="https://blog.ybalrid.info/2018/12/no-nonsense-networking-for-c-introducing-kissnet-a-k-i-s-s-socket-library/">KissNet</a><br />
      <a href="https://github.com/boostcon/cppnow_presentations_2018/blob/master/05-08-2018_tuesday/smart_output_iterators__jonathan_boccara__cppnow_05082018.pdf">Smart Output Iterators - Jonathan Boccara</a><br />
      <a href="https://www.fluentcpp.com/2019/08/13/smart-output-iterators-become-pipes/">Smart output iterators become pipes - Jonathan Boccara</a>
      <a href="https://www.youtube.com/watch?v=qH6sSOr-yk8">C++ Seasoning (video) - Sean Parent - Going Native 2013</a><br />
      <a href="https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf">string formatting (see answer 15) - stackoverflow</a><br />
    </indent-block>
    <spacer-25></spacer-25>
    <spacer-25></spacer-25>
    <spacer-25></spacer-25>
    <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->
  </bb-55>
    <info-bar></info-bar>
</body>
</html>