<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_Data.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Story-Data</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    #github .pad10-15 {
      padding: 10px 15px;
    }

    #github .codeStyle {
      overflow:hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github .labelStyle {
      font-family: sans-serif;
      /*font-weight:bold;*/
      font-size: 1.0em;
    }

    #github .normal {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github summary {
      padding: 3px 0px 5px 0px;
      font-weight:bold;
      width: max-content;
    }

      #github summary ~ div {
        width: max-content;
        max-width: 95%;
      }

      #github summary ~ indent-block {
        width: max-content;
        max-width: 95%;
        padding-left: 20px;
        padding-right: 20px;
        /*background-color: #eee;*/
      }

      #github photosizer-block {
        position: relative;
        z-index:2;
        background-color:white;
      }

      #github comment-block {
        width:max-content;
        max-width: 95%;
        padding:10px 15px;
        background-color:#eee;
        font-weight: normal;
        font-size: 1.0em;
        font-family: Tahoma;
      }
      #github c-s {
        overflow:hidden;
        font-family: Consolas, monospace;
        font-weight: bold;
        font-size: 1.0em;
      }
      #github t-s {
        font-weight: normal;
        font-size: 1.0em;
        font-family: Tahoma;
      }

      #github .notice {
        font-size:1.1em;
        font-weight:bolder;
        font-style:italic;
        font-family:Consolas, sans-serif;
        border:none;
        color:darkred;
      }
      #github background-block {
        display:block;
        background-color:#ddd;
        max-width:90%;
        width:max-content;
        padding:10px 15px;
      }
      #github .footnote {
        font-size:0.85em;
      }
      #github ol.footnote li {
        padding-bottom:0px;
      }
      #github defn-block {
        display:flex;
        flex-direction:column;
        width:max-content;
        max-width:95%;
        /*border:1px solid darkred;*/
      }
      #github defn-head {
        padding:3px 15px;
        border:1px solid darkred;
        border-bottom:none;
      }
      #github defn-body {
        padding:3px 15px;
        border:1px solid darkred;
      }
      #github defn-body ul {
        margin-top:3px;
        padding: 0px 15px;
      }
      #github defn-body ul > li {
        padding-bottom: 3px;
      }
      #github defn-example {
        font-family:Consolas, monospace;
        padding:3px 15px;
        border:1px solid darkred;
        border-top:none;
      }
      #github pre-b {
        display:block;
        white-space:pre;
        font-size:0.9em;
      }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Operations.html">N</a>
  <a id="Prev" href="CppStory_Survey.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #2 - C++ Data</h1>
      <h3 id="subtitle">sizes, initialization, standard types</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <indent-blocks>
    <h3>Data:</h3>
    This chapter focuses on data, e.g., types, type qualifiers, type conversions, data values, initialization, value conversions, and memory layout.

    <h3>Types:</h3>
    C++ is a statically typed language.  All data is defined with a type and name, using a declaration statement,
    and the language enforces a definition first rule: variable use must occur after its definition, in compiler scan order.

    <defn-block class="indent pad10">
      <defn-head>
        Type
      </defn-head>
      <defn-body>
        <ul>
          <li>A set of allowed values</li>
          <li>Operations that may be applied to these values</li>
        </ul>
      </defn-body>
    </defn-block>
    A collection of fundamental types are built into the C++ language.
    <defn-block class="indent pad10">
      <defn-head>
        Fundamental Data Types
      </defn-head>
      <defn-body>
        <ul>
          <li>
            integral: byte, bool, int, char, char16_t, char32_t, wchar_t
          </li>
          <li>
            floating point: float, double
          </li>
          <li>
            derived types: array, pointer, reference
          </li>
        </ul>
      </defn-body>
    </defn-block>
    These are augmented with an open-ended collection of library and user defined types:
    <defn-block class="pad10 indent">
      <defn-head>
        User defined types
      </defn-head>
      <defn-body>
        <ul>
          <li><c-s>struct S { ... }</c-s></li>
          <li><c-s>class C { ... }</c-s></li>
          <li><c-s>enum class E { ... }</c-s></li>
          <li>alias: <c-s>using [NewName] = [TypeName]</c-s></li>
        </ul>
      </defn-body>
    </defn-block>
    <h3>Type Qualifiers:</h3>
    The C++ language defines qualifiers that modify how an instance of a type may be used: const, constexpr, and volatile.  
    It also defines qualifiers that affect storage of data: short, long, signed, unsigned, and extern.
    <spacer-10></spacer-10>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">const qualifier - <c-s>const int i;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">const</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              The const qualifier affects what operations apply and what methods may be applied 
              to a data item.
            </div>
            <ul>
              <li>
                const prepended on a type declaration
                <indent-block>
                  <c-s>const int ci;</c-s>
                </indent-block>
                makes <c-s>ci</c-s> immutable
              </li>
              <li>
                function and method parameters
                <indent-block>
                  <c-s>void f(const std:string&amp; s)</c-s>
                </indent-block>
                prevent&apos;s the user variable s from being changed in f
              </li>
              <li>
                const postpended to a method declaration and definition
                <indent-block>
                  <c-s>void X::f(int i) const { ... }</c-s>
                </indent-block>
                prevents changes to an instance, <c-s>x &epsilon; X</c-s>, when invoked as x.f(i);
              </li>
              <li>
                const applied to pointers
                <indent-block>
                  <c-s>const X* pX = &amp;x</c-s>
                </indent-block>
                prevents x from being changed via pX, e.g., *pX = x2; will fail to compile
                <indent-block>
                  <c-s>X* const pX = &amp;x</c-s>
                </indent-block>
                prevents pX being assigned a new address
              </li>
            </ul>
          </defn-body>
          <defn-example>
            <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
            <pre-b>
  void f(const std::string&amp; s) {
    if(s.size() > 0) {
      char first = s[0];  // ok
      // s[0] = 'z'; -- fails to compile since s is const
    }
  }
            </pre-b>
          </defn-example>
          <defn-example>
            <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
            <pre-b>
  X x{3};
  const X* pX = &amp;x;
  X x1 = *pX;   // ok
  *pX = 2;      // fails to compile
            </pre-b>
          </defn-example>
        </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">volatile qualifier - <c-s>volatile int i;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">volatile</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              The qualifier volatile affects what compiler optimizers may do with a data storage.  Note that,
              unlike Java and C#, volatile qualification does not affect flushing of the cache for reads and writes.
            </div>
            <ul>
              <li>
                volatile prepended on a type definition
                <indent-block>
                  volatile int i;
                </indent-block>
                instructs compiler that variable i may be changed by an event external to the program
                and so should not be optimized to a compile-time constant.
              </li>
            </ul>
          </defn-body>
        </defn-block>
        <spacer-15></spacer-15>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">short and long Qualifiers - <c-s>short int;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">short and long</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              Qualifiers short and long affect amount of storage allocated and range of
              values a qualified data item may hold.
            </div>
            <ul>
              <li>
                short prepended on a type definition for int
                <indent-block>
                  <c-s>short int i;</c-s>
                </indent-block>
                guarantees that <c-s>sizeof(short int) <= sizeof(int);</c-s>
              </li>
              <li>
                long prepended on a type definition for int or double
                <indent-block>
                  <c-s>long double d;</c-s>
                </indent-block>
                guarantees that <c-s>sizeof(double) <= sizeof(long double) <= sizeof(long long double)</c-s>
              </li>
            </ul>
          </defn-body>
          <defn-example>
            <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
            <pre-b>
  short int iArrs[5]{ 1, 2, 3, 4, 5 };      // size of iArrs is 10 bytes
  int iArr[5]{ 1, 2, 3, 4, 5 };             // size of iArr is 20 bytes
  long int iArrl[5]{ 1, 2, 3, 4, 5 };       // size of iArrl is 20 bytes
  long long int iArrll[5]{ 1, 2, 3, 4, 5 }  // size of iArrll is 40 bytes
            </pre-b>
          </defn-example>
        </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">signed and unsigned Qualifiers - <c-s>unsigned int;</c-s></span></summary>
    <defn-block class="pad10 indent">
      <defn-head>
        <span class="notice">signed and unsigned</span>
      </defn-head>
      <defn-body>
        <div class="pad10">
          Qualifiers signed and unsigned affect placement of ranges of values an int may hold.
        </div>
        <ul>
          <li>
            signed (default) may be prepended on a type definition for int or char
            <indent-block>
              signed int i;
            </indent-block>
            acceptable values of i occupy a range symetric around the value 0
          </li>
          <li>
            unsigned may be prepended on a type definition for int or char
            <indent-block>
              unsigned int j;
            </indent-block>
            acceptible values of j lie in a range bounded at the bottom with 0
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  signed int i = -25;         // range is -2,147,483,648 to 2,147,483,647
  unsigned int j = 15;        // range is 0 to 4,294,967,295 
  unsigned int k = UINT_MAX;  // UINT_MAX is defined in &lt;limits&gt;
  k + 1 == 0;                 // value roll-over, statement is true, no compiler warning
        </pre-b>
      </defn-example>
    </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">extern Qualifier - <c-s>extern int;</c-s></span></summary>
    <defn-block class="pad10 indent">
      <defn-head>
        <span class="notice">extern</span>
      </defn-head>
      <defn-body>
        <div class="pad10">
          The extern qualifier disables allocation of storage.
        </div>
        <ul>
          <li>
            extern prepended on a type definition at namespace or global scope
            <indent-block>
              extern int i;
            </indent-block>
            provides a declaration, but instructs the compiler that another compilation unit (.cpp file) provides storage
            so it should not be provided in this compilation unit.
          </li>
        </ul>
      </defn-body>
        <spacer-10></spacer-10>
    </details>
  </indent-block>
  <indent-block>
    <details>
      <summary><span class="labelStyle lightItem">constexpr qualifier - <c-s>constexpr int N = 10;</c-s></span></summary>
    <defn-block class="pad10 indent">
      <defn-head>
        <span class="notice">constexpr</span>
      </defn-head>
      <defn-body>
        <div class="pad10">
          Qualifer constexpr makes initialized value known at compile-time. 
        </div>
        <ul>
          <li>
            constexpr prepended on a const integral type definition initialized with constant instance
            <indent-block>
              <c-s>constexpr int N = 10;</c-s>
            </indent-block>
            allows N to be used for compile time constructs like native arrays and templates.
            <spacer-10></spacer-10>
            we will discuss use of constexpr with an if selection when we discuss template meta programming.
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  constexpr unsigned int N = 10;
  double dArr[N] { 0.5, 1.0, 1.5 };  // compiles because N and initializers are known at compile-time
        </pre-b>
      </defn-example>
    </defn-block>
        <spacer-15></spacer-15>
  </details>
  </indent-block>
    <div class="pad10">
      Since C++11, the language has provided special declarations that use type deduction to establish the
      type of a variable: auto and decltype.  One important use is to provide a declaration for
      a lambda.  Lambdas types are constructed by the compiler and the names of those types are
      not public.  Auto is a type placeholder for that construction.
      <spacer-15></spacer-15>
      The decltype specifier evaluates the type of an expression which then may be used to declare
      a variable of that type.
    </div>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">auto and decltype specifiers - <c-s>auto d{ 1.5 };</c-s></span></summary>
    <defn-block class="pad10 indent">
      <defn-head><span class="notice">auto</span></defn-head>
      <defn-body>
        <div class="pad10">
          auto is not a declaration qualifer, it is a declaration.
        </div>
        <ul>
          <li>
            auto as a type definition
            <indent-block>
              <c-s>auto r{ 3 }; auto s{ 1.5 }</c-s>
            </indent-block>
            instructs compiler to use type deduction to suppy the type, so <c-s>r</c-s> is type int and <c-s>s</c-s> is type double.
          </li>
          <li>
            auto is frequently used to deduce the type of a function return value or as the type of a variable enumerated in
            a range-based for:
            <indent-block>
              <c-s>auto r = f();</c-s><br />
              <c-s>for(auto item : container) { ... }</c-s>
            </indent-block>
            auto type deduction is similar to the type deduction process used for templates.
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  std::vector&lt;int&gt; vecInt { 1, 2, 3 };
  for(auto& item : vecInt) {
    item *= 2;
  }
        </pre-b>
      </defn-example>
      <defn-head>
        <span class="notice">decltype</span>
      </defn-head>
      <defn-body>
        <div class="pad10">
          Like auto, decltype is a declaration.
        </div>
        <ul>
          <li>
            decltype as a type definition
            <indent-block>
              <c-s>
                decltype(make_lambda()) x;
              </c-s>
            </indent-block>
            x is a lambda of the same type as created by the function make_lambda
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  decltype(vecInt) vecInt2;  // results in std::vector&lt;int&gt; instance, named vecInt2, with default initialization
        </pre-b>
      </defn-example>
    </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <h3>Sizes and Layout</h3>
    Occasionally it is important to know the sizes of variables in our designs.  For example, if
    we need to serialize an object into a byte array to pass over a socket, we need to know the
    size of the object.
    <spacer-15></spacer-15>
    The operator <c-s>sizeof(arg)</c-s> returns the size of the arg parameter in bytes. 
    <h3>Initialization</h3>
    <h3>New Types</h3>
    <h3>Building Data Structures with STL</h3>
    <h3>Serialization</h3>
    <h3>Persistance</h3>
  </indent-blocks>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>