<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_Data.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Story-Data</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    #github .pad10-15 {
      padding: 10px 15px;
    }

    #github .codeStyle {
      overflow:hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github .labelStyle {
      font-family: sans-serif;
      /*font-weight:bold;*/
      font-size: 1.0em;
    }

    #github .normal {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github summary {
      padding: 3px 0px 5px 0px;
      font-weight:bold;
      width: max-content;
    }

      #github summary ~ div {
        width: max-content;
        max-width: 95%;
      }

      #github summary ~ indent-block {
        width: max-content;
        max-width: 95%;
        padding-left: 20px;
        padding-right: 20px;
        /*background-color: #eee;*/
      }

      #github photosizer-block {
        position: relative;
        z-index:2;
        background-color:white;
      }

      #github comment-block {
        width:max-content;
        max-width: 95%;
        padding:10px 15px;
        background-color:#eee;
        font-weight: normal;
        font-size: 1.0em;
        font-family: Tahoma;
      }
      #github c-s {
        overflow:hidden;
        font-family: Consolas, monospace;
        font-weight: bold;
        font-size: 1.0em;
      }
      #github t-s {
        font-weight: normal;
        font-size: 1.0em;
        font-family: Tahoma;
      }

      #github .notice {
        font-size:1.1em;
        font-weight:bolder;
        font-style:italic;
        font-family:Consolas, sans-serif;
        border:none;
        color:darkred;
      }
      #github .background-block {
        display:block;
        background-color:#ddd;
        max-width:90%;
        width:max-content;
        padding:10px 15px;
      }
      #github background-block {
        display:block;
        background-color:#ddd;
        max-width:90%;
        width:max-content;
        padding:10px 15px;
      }
      #github .footnote {
        font-size:0.85em;
      }
      #github ol.footnote li {
        padding-bottom:0px;
      }
      #github defn-block {
        display:flex;
        flex-direction:column;
        width:max-content;
        max-width:95%;
        /*border:1px solid darkred;*/
      }
      #github defn-head {
        padding:3px 15px;
        border:1px solid darkred;
        border-bottom:none;
      }
      #github defn-body {
        padding:3px 15px;
        border:1px solid darkred;
      }
      #github defn-body ul {
        margin-top:3px;
        padding: 0px 15px;
      }
      #github defn-body ul > li {
        padding-bottom: 3px;
      }
      #github defn-example {
        font-family:Consolas, monospace;
        padding:3px 15px;
        border:1px solid darkred;
        border-top:none;
      }
      #github pre-b {
        display:block;
        white-space:pre;
        font-size:0.9em;
      }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Operations.html">N</a>
  <a id="Prev" href="CppStory_Survey.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #2 - C++ Data Types and Data</h1>
      <h3 id="subtitle">sizes, initialization, standard types</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <indent-blocks>
    <h3>Data:</h3>
    This chapter focuses on data, e.g., types, type qualifiers, type conversions, data values, initialization, value conversions, and memory layout.

    <h3>Types:</h3>
    C++ is a statically typed language.  All data is defined with a type and name, using a declaration statement,
    and the language enforces a definition first rule: variable use must occur after its definition, in compiler scan order.

    <defn-block class="indent pad10">
      <defn-head>
        Type
      </defn-head>
      <defn-body>
        <ul>
          <li>A set of allowed values</li>
          <li>Operations that may be applied to these values</li>
        </ul>
      </defn-body>
    </defn-block>
    A collection of fundamental types are built into the C++ language.
    <defn-block class="indent pad10">
      <defn-head>
        Fundamental Data Types
      </defn-head>
      <defn-body>
        <ul>
          <li>
            integral: byte, bool, int, char, char16_t, char32_t, wchar_t
          </li>
          <li>
            floating point: float, double
          </li>
          <li>
            derived types: array, pointer, reference
          </li>
        </ul>
      </defn-body>
    </defn-block>
    These are augmented with an open-ended collection of library and user defined types:
    <defn-block class="pad10 indent">
      <defn-head>
        User defined types
      </defn-head>
      <defn-body>
        <ul>
          <li><c-s>struct S { ... }</c-s></li>
          <li><c-s>class C { ... }</c-s></li>
          <li><c-s>enum class E { ... }</c-s></li>
          <li>alias: <c-s>using [NewName] = [TypeName]</c-s></li>
        </ul>
      </defn-body>
    </defn-block>
    <h3>Type Qualifiers:</h3>
    The C++ language defines qualifiers that modify how an instance of a type may be used: const, constexpr, and volatile.  
    It also defines qualifiers that affect storage of data: short, long, signed, unsigned, and extern.
    <spacer-10></spacer-10>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">const qualifier - <c-s>const int i;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">const</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              The const qualifier affects what operations apply and what methods may be applied 
              to a data item.
            </div>
            <ul>
              <li>
                const prepended on a type declaration
                <indent-block>
                  <c-s>const int ci;</c-s>
                </indent-block>
                makes <c-s>ci</c-s> immutable
              </li>
              <li>
                function and method parameters
                <indent-block>
                  <c-s>void f(const std:string&amp; s)</c-s>
                </indent-block>
                prevent&apos;s the user variable s from being changed in f
              </li>
              <li>
                const postpended to a method declaration and definition
                <indent-block>
                  <c-s>void X::f(int i) const { ... }</c-s>
                </indent-block>
                prevents changes to an instance, <c-s>x &epsilon; X</c-s>, when invoked as x.f(i);
              </li>
              <li>
                const applied to pointers
                <indent-block>
                  <c-s>const X* pX = &amp;x</c-s>
                </indent-block>
                prevents x from being changed via pX, e.g., *pX = x2; will fail to compile
                <indent-block>
                  <c-s>X* const pX = &amp;x</c-s>
                </indent-block>
                prevents pX being assigned a new address
              </li>
            </ul>
          </defn-body>
          <defn-example>
            <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
            <pre-b>
  void f(const std::string&amp; s) {
    if(s.size() > 0) {
      char first = s[0];  // ok
      // s[0] = 'z'; -- fails to compile since s is const
    }
  }
            </pre-b>
          </defn-example>
          <defn-example>
            <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
            <pre-b>
  X x{3};
  const X* pX = &amp;x;
  X x1 = *pX;   // ok
  *pX = 2;      // fails to compile
            </pre-b>
          </defn-example>
        </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">volatile qualifier - <c-s>volatile int i;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">volatile</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              The qualifier volatile affects what compiler optimizers may do with a data storage.  Note that,
              unlike Java and C#, volatile qualification does not affect flushing of the cache for reads and writes.
            </div>
            <ul>
              <li>
                volatile prepended on a type definition
                <indent-block>
                  volatile int i;
                </indent-block>
                instructs compiler that variable i may be changed by an event external to the program
                and so should not be optimized to a compile-time constant.
              </li>
            </ul>
          </defn-body>
        </defn-block>
        <spacer-15></spacer-15>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">short and long Qualifiers - <c-s>short int;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">short and long</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              Qualifiers short and long affect amount of storage allocated and range of
              values a qualified data item may hold.
            </div>
            <ul>
              <li>
                short prepended on a type definition for int
                <indent-block>
                  <c-s>short int i;</c-s>
                </indent-block>
                guarantees that <c-s>sizeof(short int) <= sizeof(int);</c-s>
              </li>
              <li>
                long prepended on a type definition for int or double
                <indent-block>
                  <c-s>long double d;</c-s>
                </indent-block>
                guarantees that <c-s>sizeof(double) <= sizeof(long double) <= sizeof(long long double)</c-s>
              </li>
            </ul>
          </defn-body>
          <defn-example>
            <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
            <pre-b>
  short int iArrs[5]{ 1, 2, 3, 4, 5 };      // size of iArrs is 10 bytes
  int iArr[5]{ 1, 2, 3, 4, 5 };             // size of iArr is 20 bytes
  long int iArrl[5]{ 1, 2, 3, 4, 5 };       // size of iArrl is 20 bytes
  long long int iArrll[5]{ 1, 2, 3, 4, 5 }  // size of iArrll is 40 bytes
            </pre-b>
          </defn-example>
        </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">signed and unsigned Qualifiers - <c-s>unsigned int;</c-s></span></summary>
    <defn-block class="pad10 indent">
      <defn-head>
        <span class="notice">signed and unsigned</span>
      </defn-head>
      <defn-body>
        <div class="pad10">
          Qualifiers signed and unsigned affect placement of ranges of values an int may hold.
        </div>
        <ul>
          <li>
            signed (default) may be prepended on a type definition for int or char
            <indent-block>
              signed int i;
            </indent-block>
            acceptable values of i occupy a range symetric around the value 0
          </li>
          <li>
            unsigned may be prepended on a type definition for int or char
            <indent-block>
              unsigned int j;
            </indent-block>
            acceptible values of j lie in a range bounded at the bottom with 0
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  signed int i = -25;         // range is -2,147,483,648 to 2,147,483,647
  unsigned int j = 15;        // range is 0 to 4,294,967,295 
  unsigned int k = UINT_MAX;  // UINT_MAX is defined in &lt;limits&gt;
  k + 1 == 0;                 // value roll-over, statement is true, no compiler warning
        </pre-b>
      </defn-example>
    </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">extern Qualifier - <c-s>extern int;</c-s></span></summary>
    <defn-block class="pad10 indent">
      <defn-head>
        <span class="notice">extern</span>
      </defn-head>
      <defn-body>
        <div class="pad10">
          The extern qualifier disables allocation of storage.
        </div>
        <ul>
          <li>
            extern prepended on a type definition at namespace or global scope
            <indent-block>
              extern int i;
            </indent-block>
            provides a declaration, but instructs the compiler that another compilation unit (.cpp file) provides storage
            so it should not be provided in this compilation unit.
          </li>
        </ul>
      </defn-body>
        <spacer-10></spacer-10>
    </details>
  </indent-block>
  <indent-block>
    <details>
      <summary><span class="labelStyle lightItem">constexpr qualifier - <c-s>constexpr int N = 10;</c-s></span></summary>
    <defn-block class="pad10 indent">
      <defn-head>
        <span class="notice">constexpr</span>
      </defn-head>
      <defn-body>
        <div class="pad10">
          Qualifer constexpr makes initialized value known at compile-time. 
        </div>
        <ul>
          <li>
            constexpr prepended on a const integral type definition initialized with constant instance
            <indent-block>
              <c-s>constexpr int N = 10;</c-s>
            </indent-block>
            allows N to be used for compile time constructs like native arrays and templates.
            <spacer-10></spacer-10>
            we will discuss use of constexpr with an if selection when we discuss template meta programming.
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  constexpr unsigned int N = 10;
  double dArr[N] { 0.5, 1.0, 1.5 };  // compiles because N and initializers are known at compile-time
        </pre-b>
      </defn-example>
    </defn-block>
        <spacer-15></spacer-15>
  </details>
  </indent-block>
    <div class="pad10">
      Since C++11, the language has provided special declarations that use type deduction to establish the
      type of an expression: auto and decltype.  One important use is to provide a declaration for
      a lambda.  Lambdas types are constructed by the compiler and the names of those types are
      not public.  Auto is a type placeholder for that construction.
      The decltype specifier evaluates the type of an expression which then may be used to declare
      a variable of that type.
    </div>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">auto and decltype specifiers - <c-s>auto d{ 1.5 };</c-s></span></summary>
    <defn-block class="pad10 indent">
      <defn-head><span class="notice">auto</span></defn-head>
      <defn-body>
        <div class="pad10">
          auto is not a declaration qualifer, it is a declaration.
        </div>
        <ul>
          <li>
            auto as a type definition
            <indent-block>
              <c-s>auto r{ 3 }; auto s{ 1.5 }</c-s>
            </indent-block>
            instructs compiler to use type deduction to suppy the type, so <c-s>r</c-s> is type int and <c-s>s</c-s> is type double.
          </li>
          <li>
            auto is frequently used to deduce the type of a function return value or as the type of a variable enumerated in
            a range-based for:
            <indent-block>
              <c-s>auto r = f();</c-s><br />
              <c-s>for(auto item : container) { ... }</c-s>
            </indent-block>
            auto type deduction is similar to the type deduction process used for templates.
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  std::vector&lt;int&gt; vecInt { 1, 2, 3 };
  for(auto& item : vecInt) {
    item *= 2;
  }
        </pre-b>
      </defn-example>
      <defn-head>
        <span class="notice">decltype</span>
      </defn-head>
      <defn-body>
        <div class="pad10">
          Like auto, decltype is a declaration.
        </div>
        <ul>
          <li>
            decltype as a type definition
            <indent-block>
              <c-s>
                decltype(make_lambda()) x;
              </c-s>
            </indent-block>
            x is a lambda of the same type as created by the function make_lambda
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  decltype(vecInt) vecInt2;  // results in std::vector&lt;int&gt; instance, named vecInt2, with default initialization
        </pre-b>
      </defn-example>
    </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <h3>Exploring Types:</h3>
    Occasionally it is important to know the sizes of variables in our designs.  For example, if
    we need to serialize an object into a byte array to pass over a socket, we need to know the
    size of the object. Also, knowing the sizes of types may help us understand how they work.
    That&apos;s illustrated in the lambda example, below.
    <spacer-15></spacer-15>
    The operator <c-s>sizeof</c-s> can be applied to a type or an expression: 
    <indent-block class="pad10">
      <c-s>size_t sz = sizeof(arg);</c-s>
    </indent-block>
    It returns the size of the arg parameter in bytes for all types
    except references.  For references sizeof(X&) returns the size of the referenced type, not the
    size of the reference. The size of a reference equals the size of a pointer, which, on my work
    machine, is 4 bytes, e.g., 32 bits.
    You can verify this by constructing a class Xref with a single reference member and evaluating
    sizeof(Xref).
    <spacer-15></spacer-15>
    The operator <c-s>typeid</c-s> can be applied to a type or an expression as:
    <indent-block class="pad10">
    <c-s>std::type_info ti = typeid(CT)</c-s>
    </indent-block>
    where CT is any complete type. In order to use <c-s>typeid</c-s> you need to include
    <c-s>&lt;typeinfo&gt;</c-s>.  There is much less information in <c-s>type_info</c-s> 
    instances like <c-s>ti</c-s> than you would get from 
    reflection results with languages like C# and Java. 
    <spacer-15></spacer-15>
    However, <c-s>type_info</c-s> has  
    useful methods: <c-s>operator==(const type_info&)</c-s> and 
    <c-s>operator!=(const type_info&)</c-s> to query whether two instances belong to the same type, 
    and <c-s>name()</c-s>.  So we can discover the full name of the type of
    some instance.
    <spacer-15></spacer-15>
    <indent-block class="pad10">
      <details>
        <summary>
          <span class="labelStyle darkItem">
            Example: Using <c-s>sizeof</c-s> and <c-s>typeid</c-s> to explain how lambdas work
          </span>
        </summary>
        <indent-block class="pad10">
    Here is a template function, useful for exploring types that uses both <c-s>sizeof</c-s>
    and <c-s>typeid</c-s>:
    <pre class="background-block">
  <c-s>template&lt;typename T&gt;
  void displayType(const T&amp; t, const std::string&amp; msg = "", bool showSize = true)
  {
    std::cout &lt;&lt; "\n  ";
    if (showSize)
      std::cout &lt;&lt; sizeof(t) &lt;&lt; " = size of ";
    std::string typeName = typeid(t).name();
    if (typeName.size() &gt; 75)
      typeName = typeName.substr(0, 75) + "...";
    std::cout &lt;&lt; typeName;
    if (msg.size() &gt; 0)
      std::cout &lt;&lt; msg;
  }</c-s>
</pre>
    It provides one way to begin understanding how lambdas work:
    <pre class="background-block">
  <c-s>int i{ 42 };
  auto f = [i](const std::string& s) {  
    std::cout << s << i;
  };
  f("\n  The meaning of life is ");
  displayType(f);</c-s>
</pre>
    Here, f is a lambda, declared with auto because we don&apos;t know the lambda type.
    the <c-s>[i]</c-s> part of the expression says that this lambda captures the value of i, e.g., 42.
    The <c-s>(const std::string&amp; s)</c-s> defines a string parameter, passed to the lambda code
    by const reference. The body <c-s>{ ... }</c-s> simply displays the parameter and the
    captured integer value.
    <spacer-15></spacer-15>
    The output of this code is:
    <pre class="background-block">
  <c-s>The meaning of life is 42
  4 = size of class &lt;lambda_1bed100c18f4584a5d93f1a5d7e27280&gt;</c-s>
</pre>
    So, the displayType function has informed us that the lambda is a class, it disclosed the
    lambda&apos;s type name, obviously not intended for human consumption, and showed us that its
    size is just the size of the captured int value.
    <spacer-15></spacer-15>
    It&apos;s highly likely that the compiler created a functor, something like this:
    <pre>
  <c-s>class lambda_1bed1... {
  public:
    void operator() {
      std::cout << s << i;    
    }
  private:
    int i = 42;
  };</c-s>
</pre>
    So lambdas can capture data, be passed into or returned from functions, taking their data
    with them (as long as they hold a value, not a reference). We say that the lambda and its
    local scope are a closure.  A lambda can use any data in its closure as part of its
    operation. 
    <spacer-15></spacer-15>
    Essentially, a lambda has two sets of inputs: from its capture list <c-s>[i, j, x]</c-s> 
    which come from the lambda&apos;s closure, and <c-s>(T1 arg1, T2 arg2, ... )</c-s>
    which are passed in from the scope where the lambda is invoked. The lambda&apos;s designer
    provides the capture inputs and the lambda user provides the arguments.
        </indent-block>
      </details>
    </indent-block>

    <h3>Type Structure:</h3>

    <hidephotosizer-block src="Pictures/StringLayout.JPG" width="400" class="photoSizerBlock right" style="margin-top:0;">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 1. String Layout
      </span>
    </hidephotosizer-block>
    There is also an issue of type structure we need to think about.  The fundamental types place
    all their value information in one place, in the stack frame where they are declared.
    However, not all types are structured that way. A std::string, for example, stores its
    control state, iterator, character count, etc., in the stack frame where it is declared, 
    but all its user state, e.g., its character sequence, is stored in the heap.
    <spacer-15></spacer-15>
    The <c-s>sizeof</c-s> operator measures only the stack allocation.  So, for example, it will
    return the same size for an empty string and a string with 100 characters.  For all of the
    STL sequential containers with contiguous memory, e.g., <c-s>string</c-s>, <c-s>vector</c-s>,
    and <c-s>deque</c-s>, you can call their <c-s>capacity()</c-s> method to measure that allocation.
    Here&apos;s an example:
    <pre class="background-block"><c-s>  std::string str("content of a std::string");
  std::cout << "\n  " << str;
  std::cout << "\n  string size = " << (str.size() + 1) * sizeof(char);
  std::cout << "\n  allocation size = " << str.capacity() * sizeof(char);</c-s>
</pre>
    When this code executes you get:
    <pre class="background-block"><c-s>  content of a std::string
  string size = 25  // counts terminating null
  allocation size = 31</c-s>
</pre>
    For all the other containers measuring heap allocation is much more effort, but the ideas
    will be about the same.  You would have to iterate through the container, measuring each of
    the elements, accessed by the container&apos;s iterator.

    <h3>Initialization</h3>
    <h3>New Standard Types</h3>
    <h3>Building Data Structures with STL</h3>
    <h3>Serialization</h3>
    <h3>Persistance</h3>
  </indent-blocks>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>