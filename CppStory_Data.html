<!DOCTYPE html>
<html>
<!--
  CppStory_Data.html
-->
<head>
  <title>C++ Story Data</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeBlue.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrameCppStory.js"></script>
  <script src="js/ScriptsPageFramePagesCppStory.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }


    .gray {
      background-color: #ddd;
    }

    .spread {
      margin: 1em;
    }

    .tightSpread {
      margin: 0.5em;
    }

    #github #pagetitle {
      background-color: #002147;
      color: #fafaff;
    }

    #github #title {
      background-color: #002147;
      color: #fafaff;
    }

    #github #subtitle {
      background-color: #002147;
      color: #fafaff;
    }

    #github a.repoLink {
      background-color: #002147;
      color: #fafaff;
    }

      #github a.repoLink:link {
        background-color: #002147;
        color: #fafaff;
      }

    #github c-s {
      font-size: small;
    }

    #github defn-code {
      font-size: small;
    }

    #github .codeStyle {
      font-family: Consolas;
      font-size: small;
      font-weight: bold;
    }

    #github h3 {
      margin-top: 1.0em;
      margin-bottom: 1.0em;
    }

    #github h4 {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }

    #github .normal {
      font-weight: normal;
      font-size: small;
    }

    #github .spreadup {
      margin-top: 1em;
    }

    #github defn-block {
      max-width: 50em;
    }
  </style>
  <script>
    window.onmessage = function () {
      // alert('msg received');
      bottomMenu.sections();
    }
  </script>
  <script>
    function loadifcpp() {
      var loc = window.location.href;
      if (window.self === window.top) {
        /*alert('top');*/
        window.location.href = 'TOCCpp.html?src=' + loc;
      }
      else {
        /*alert('not top');*/
        /*window.top.location.href = loc;*/
        window.top.location.href = loc;
      }
    }
  </script>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="CppStory_Operations.html">Next</a>
  <a id="Prev" href="CppStory_Survey.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="modified">10/18/2022</div>
      <div id="page">C++ Story Data</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <header>
          <a class="repoLink" target="_blank" href="https://github.com/JimFawcett/CppStory" style="margin:2.0em 1.0em; font-size:0.9em;">C++ Story Code</a>
          <!-- <a class="repoLink" style="margin-right:8.05em;" href="../../CppStoryRepo.html">C++ Story Docs</a> -->
          <hgroup id="pagetitle" onclick="loadifcpp()" style="cursor:pointer;">
            <h1 id="title">Chapter #3&nbsp;-&nbsp;C++ Data Types and Data</h1>
            <h3 class="indent" id="subtitle">sizes, initialization, standard types</h3>
          </hgroup>
        </header>

        <div class="indent">
          <h3 id="data">3.0  Data Prologue</h3>
          <t-b>
            This chapter focuses on data, e.g., types, type qualifiers, type conversions, data values, initialization,
            value conversions, and memory layout.
          </t-b>
          <t-b>
            Most of the code examples used in this Chapter have complete working demonstrations in
            <a href="CppStoryRepo.html">CppStoryRepo</a>.
            You may wish to download and run the code while you are studying this Chapter.
          </t-b>
          <details class="indent">
            <summary class="labelStyle darkItem">Quick Starter Example - Easy Data In &amp; Out with std::tuple</summary>
            <s-halfEm></s-halfEm>
            <div class="defnBorder" style="padding:0em 3em 2em 2em; max-width:50em;">
              <t-b>
                This example uses <c-s>std::tuple</c-s>, a simple data aggregator, introduced with C++11.
                It holds an arbitrary number of items, each with arbitrary types.  We could have declared
                the tuple as shown in the  output pane, below.
              </t-b>
              <t-b>
                In this example we simply initialize it with literal data items, as shown in  the code pane, and
                allow template type deduction<sup>1</sup> to determine types of our tuple&apos;s items.
              </t-b>
              <t-b>
                <defn-outerBlock class="indents" style="width:100%;">
                  <defn-block>
                    <defn-head>Code: Gathering Data with std::tuple</defn-head>
                    <defn-code>
std::tuple tp{ 1, 1.5, "two" }; /* easy in  */
auto [ta, tb, tc] = tp;         /* easy out */

displayType(
  tp,
  " &lt;= std::tuple tp{ 1, 1.5, \"two\" }",
  false
);
displayValues(ta, tb, tc);

/* code only compiles with C++17 option */
                    </defn-code>
                  </defn-block>
                  <defn-block>
                    <defn-head>Output</defn-head>
                    <defn-code>
class std::tuple&lt;int,double,char const *&gt;
&lt;= std::tuple tp { 1, 1.5, "two" }
1
1.5
two
                    </defn-code>
                  </defn-block>
                </defn-outerBlock>
              </t-b>
              <t-b>
                std::tuple holds a linear sequence of instances. In the first line of
                code std::tuple tp has been initialized with a brace initializer. In the second line each item
                is extracted with a structured binding.
              </t-b>
              <t-b>
                That declared one variable for each item in the tuple,
                with type deduced with template-style type deduction induced by the auto declaration. So, our
                code has an <c-s>int ta</c-s>, a <c-s>double tb</c-s>, and a <c-s>const char * tc</c-s>.
              </t-b>
              <t-b>
                <span class="notice">Note: </span> structured binding only
                works for containers holding public data, as is the case for std::tuple, std::pair, and
                structs with public data members.
              </t-b>
              <t-b>
                <defn-block class="indents" style="width:30em;">
                  <defn-head>Conclusion:</defn-head>
                  <defn-body>
                    With additions to C++ since C++11 it is easy to gather data into collections and easy
                    to extract that back into its individual items.
                  </defn-body>
                </defn-block>
              </t-b>
              <hr class="spreadup" />
              <ol class="footnote">
                <li>
                  Template type deduction will be covered in Chapter6 - templates.
                </li>
              </ol>
            </div>
            <s-1em></s-1em>
          </details>
          <t-b>
            This chapter presents the first part of a two-part story about the C language-like facilities provided
            by C++, excluding classes and templates. The second part is about operations provided by the language,
            with the same exclusions.
          </t-b>
          <t-b>
            We will, of course, cover classes and templates in a &quot;modern C++&quot; part, starting with Chapter 4.
          </t-b>
          <h3 id="types">3.1  Types</h3>
          <t-b>
            C++ is a statically typed language.  All data is defined with a type and name, using a declaration statement,
            and the language enforces a definition first rule: variable use must occur after its definition, in compiler scan order.
          </t-b>

          <defn-block class="indent">
            <defn-head>
              Type
            </defn-head>
            <defn-body>
              <ul class="tight indent">
                <li>A set of allowed values</li>
                <li>Operations that may be applied to these values</li>
              </ul>
            </defn-body>
          </defn-block>
          <t-b>
            A collection of fundamental types are built into the C++ language.
          </t-b>
          <defn-block class="indent">
            <defn-head>
              Fundamental Data Types
            </defn-head>
            <defn-body>
              <ul class="tight indent">
                <li>
                  integral: byte, bool, int, char, char16_t, char32_t, wchar_t
                </li>
                <li>
                  floating point: float, double
                </li>
                <li>
                  derived types: array, pointer, reference
                </li>
              </ul>
            </defn-body>
          </defn-block>
          <t-b>
            These are augmented with an open-ended collection of library and user defined types:
          </t-b>
          <defn-block class="indent">
            <defn-head>
              User defined types
            </defn-head>
            <defn-body>
              <ul class="tight indent">
                <li><c-s>struct S { ... }</c-s></li>
                <li><c-s>class C { ... }</c-s></li>
                <li><c-s>enum class E { ... }</c-s></li>
                <li>alias: <c-s>using [NewName] = [TypeName]</c-s></li>
              </ul>
            </defn-body>
          </defn-block>
          <div style="height:0.5em;"></div>
          <h4 id="TypeQual">3.1.1  Type Qualifiers</h4>
          <t-b>
            The C++ language defines qualifiers that modify how an instance of a type may be used: const, constexpr, and volatile.
            It also defines qualifiers that affect storage of data: short, long, signed, unsigned, and extern.
          </t-b>
          <spacer-10></spacer-10>
          <indent-block>
            <details>
              <summary class="labelStyle darkItem">const qualifier - <c-s>const int i;</c-s></summary>
              <div style="max-width:60rem;">
                <defn-block>
                  <defn-head>
                    const
                  </defn-head>
                  <defn-body>
                    The const qualifier affects what operations apply and what methods may be applied
                    to a data item.
                    <ol class="indent">
                      <li>
                        const prepended on a type declaration
                        <indent-block>
                          <c-s>const int ci;</c-s>
                        </indent-block>
                        makes <c-s>ci</c-s> immutable
                      </li>
                      <li>
                        function and method parameters
                        <indent-block>
                          <c-s>void f(const std:string&amp; s)</c-s>
                        </indent-block>
                        prevent&apos;s the user variable s from being changed in f
                      </li>
                      <li>
                        const postpended to a method declaration and definition
                        <indent-block>
                          <c-s>void X::f(int i) const { ... }</c-s>
                        </indent-block>
                        prevents changes to an instance, <c-s>x &epsilon; X</c-s>, when invoked as x.f(i);
                      </li>
                      <li>
                        const applied to pointers
                        <indent-block>
                          <c-s>const X* pX = &amp;x</c-s>
                        </indent-block>
                        prevents x from being changed via pX, e.g., *pX = x2; will fail to compile
                        <indent-block>
                          <c-s>X* const pX = &amp;x</c-s>
                        </indent-block>
                        prevents pX being assigned a new address
                      </li>
                    </ol>
                  </defn-body>
                  <defn-head class="defnBorderTop">
                    Code example:
                  </defn-head>
                  <defn-code>
void f(const std::string&amp; s) {
  if(s.size() > 0) {
    char first = s[0];  // ok
    // s[0] = 'z'; -- fails to compile since s is const
  }
}
                  </defn-code>
                  <defn-head class="defnBorderTop">
                    Code example:
                  </defn-head>
                  <defn-code>
X x{3};
const X* pX = &amp;x;
X x1 = *pX;   // ok
*pX = 2;      // fails to compile
                  </defn-code>
                </defn-block>
              </div>
              <s-1em></s-1em>
            </details>
          </indent-block>
          <indent-block>
            <details>
              <summary class="labelStyle darkItem">short and long Qualifiers - <c-s>short int;</c-s></summary>
              <defn-block>
                <defn-head>
                  short and long
                </defn-head>
                <defn-body>
                  Qualifiers short and long affect amount of storage allocated and range of
                  values a qualified data item may hold.
                  <ol class="indent">
                    <li>
                      short prepended on a type definition for int
                      <indent-block>
                        <c-s>short int i;</c-s>
                      </indent-block>
                      guarantees that <c-s>sizeof(short int) <= sizeof(int);</c-s>
                    </li>
                    <li>
                      long prepended on a type definition for int or double
                      <indent-block>
                        <c-s>long double d;</c-s>
                      </indent-block>
                      guarantees that <c-s>sizeof(double) <= sizeof(long double) <= sizeof(long long double)</c-s>
                    </li>
                  </ol>
                </defn-body>
                <defn-head class="defnBorderTop">
                  Code example:
                </defn-head>
                <defn-code>
short int iArrs[5]{ 1, 2, 3, 4, 5 };      // size of iArrs is 10 bytes
int iArr[5]{ 1, 2, 3, 4, 5 };             // size of iArr is 20 bytes
long int iArrl[5]{ 1, 2, 3, 4, 5 };       // size of iArrl is 20 bytes
long long int iArrll[5]{ 1, 2, 3, 4, 5 }  // size of iArrll is 40 bytes
                </defn-code>
              </defn-block>
              <s-1em></s-1em>
            </details>
          </indent-block>
          <indent-block>
            <details>
              <summary class="labelStyle darkItem">signed and unsigned Qualifiers - <c-s>unsigned int;</c-s></summary>
              <defn-block>
                <defn-head>
                  signed and unsigned
                </defn-head>
                <defn-body>
                  Qualifiers signed and unsigned affect placement of ranges of values an int may hold.
                  <ol class="indent">
                    <li>
                      signed (default) may be prepended on a type definition for int or char
                      <indent-block>
                        signed int i;
                      </indent-block>
                      acceptable values of i occupy a range symetric around the value 0
                    </li>
                    <li>
                      unsigned may be prepended on a type definition for int or char
                      <indent-block>
                        unsigned int j;
                      </indent-block>
                      acceptible values of j lie in a range bounded at the bottom with 0
                    </li>
                  </ol>
                </defn-body>
                <defn-head class="defnBorderTop">
                  Code example:
                </defn-head>
                <defn-code>
signed int i = -25;         // range is -2,147,483,648 to 2,147,483,647
unsigned int j = 15;        // range is 0 to 4,294,967,295
unsigned int k = UINT_MAX;  // UINT_MAX is defined in &lt;limits&gt;
k + 1 == 0;                 // value roll-over, statement is true, no compiler warning
                </defn-code>
              </defn-block>
              <s-1em></s-1em>
            </details>
          </indent-block>
          <indent-block>
            <details>
              <summary class="labelStyle darkItem">static Qualifier - <c-s>static int;</c-s></summary>
              <div style="max-width:55rem;">
                <defn-block>
                  <defn-head>
                    static
                  </defn-head>
                  <defn-body>
                    The static qualifier allocations storage in static memory.
                    <ol class="indent">
                      <li>
                        static prepended on a local type definition (in a function)
                        <indent-block>
                          static int i = 3;
                        </indent-block>
                        instructs the compiler to place storage for this named entity in static memory
                        initialized to the value 3.
                        <spacer-10></spacer-10>
                        That means that it will be initialized exactly once, no later than the first time
                        the function is entered.  It will not be re-initialized again on subsequent entries
                        so its value persists across function calls, only changing when the function&apos;s
                        code assigns to it.
                      </li>
                      <li>
                        static prepended on a member variable of a class or struct places that variable
                        in static memory, so every instance of the class or struct shares the same value.
                      </li>
                    </ol>
                  </defn-body>
                </defn-block>
              </div>
              <s-1em></s-1em>
            </details>
          </indent-block>
          <indent-block>
            <details>
              <summary class="labelStyle darkItem">extern Qualifier - <c-s>extern int;</c-s></summary>
              <div style="max-width:60rem;">
                <defn-block class="t-b mtz mbz">
                  <defn-head>
                    extern
                  </defn-head>
                  <defn-body>
                    The extern qualifier disables allocation of storage.
                    <ol class="indent">
                      <li>
                        extern prepended on a type definition at namespace or global scope
                        <indent-block>
                          extern int i;
                        </indent-block>
                        provides a declaration, but instructs the compiler that another compilation unit (.cpp file) provides storage
                        so it should not be provided in this compilation unit.
                      </li>
                    </ol>
                  </defn-body>
                </defn-block>
              </div>
              <s-1em></s-1em>
            </details>
          </indent-block>
          <indent-block>
            <details>
              <summary class="labelStyle darkItem">inline Qualifier - <c-s>inline const int = 3;</c-s></summary>
              <div style="max-width:55rem;">
                <defn-block style="max-width:50em;">
                  <defn-head>
                    inline
                  </defn-head>
                  <defn-body>
                    The inline qualifier for global variables was introduced with C++17.
                    <ol class="indent">
                      <li>
                        inline prepended on a type definition in a header file
                        <indent-block>
                          inline const double pi = 3.14159;
                        </indent-block>
                        instructs the linker to provide storage only once, even if the header file is included
                        in multiple cpp files used to build one image.
                        <spacer-10></spacer-10>
                        This eliminates one source of multiple definition linker errors.
                      </li>
                    </ol>
                  </defn-body>
                </defn-block>
              </div>
              <s-1em></s-1em>
            </details>
          </indent-block>
          <indent-block>
            <details>
              <summary class="labelStyle darkItem">volatile qualifier - <c-s>volatile int i;</c-s></summary>
              <div style="max-width:55rem;">
                <defn-block style="max-width:50em;">
                  <defn-head>
                    volatile
                  </defn-head>
                  <defn-body>
                    The qualifier volatile affects what compiler optimizers may do with a data storage.  Note that,
                    unlike Java and C#, volatile qualification does not affect flushing of the cache for reads and writes.
                    <ol class="indent">
                      <li>
                        volatile prepended on a type definition
                        <indent-block>
                          volatile int i;
                        </indent-block>
                        instructs compiler that variable i may be changed by an event external to the program
                        and so should not be optimized to a compile-time constant.
                      </li>
                    </ol>
                  </defn-body>
                </defn-block>
              </div>
              <s-1em></s-1em>
            </details>
          </indent-block>
          <indent-block>
            <details>
              <summary class="labelStyle darkItem">constexpr qualifier - <c-s>constexpr int N = 10;</c-s></summary>
              <defn-block style="max-width:50em;">
                <defn-head>
                  constexpr
                </defn-head>
                <defn-body>
                  Qualifer constexpr makes initialized value known at compile-time.
                  <ol class="indent">
                    <li>
                      constexpr prepended on a const integral type definition initialized with constant instance
                      <indent-block>
                        <c-s>constexpr int N = 10;</c-s>
                      </indent-block>
                      allows N to be used for compile time constructs like native arrays and templates.
                      <spacer-10></spacer-10>
                      we will discuss use of constexpr with an if selection when we discuss template meta programming.
                    </li>
                  </ol>
                </defn-body>
                <defn-head class="defnBorderTop">
                  Code example:
                </defn-head>
                <defn-code>
constexpr unsigned int N = 10;
double dArr[N] { 0.5, 1.0, 1.5 };
// compiles because N and initializers are known at compile-time
                </defn-code>
              </defn-block>
              <s-1em></s-1em>
            </details>
          </indent-block>
          <div style="height:0.5em;"></div>
          <h4 id="TypeSpec">3.1.2  Type Specifiers</h4>
          <div class="t-b mbz">
            Since C++11, the language has provided special declarations, <c-s>auto</c-s> and <c-s>decltype</c-s>
            that use type deduction to establish the type of an expression.  One important use is to provide a declaration for
            a lambda.  Lambda types are constructed by the compiler and the names of those types are
            not public.  Auto is a type placeholder for that construction.
            The decltype specifier evaluates the type of an expression which then may be used to declare
            a variable of that type.
          </div>
          <spacer-15></spacer-15>
          <indent-block>
            <details>
              <summary class="labelStyle darkItem">auto and decltype specifiers - <c-s>auto d{ 1.5 };</c-s></summary>
              <div style="max-width:55rem;">
                <defn-block>
                  <defn-head>auto</defn-head>
                  <defn-body>
                    auto is not a declaration qualifer, it is a declaration.
                    <ol>
                      <li>
                        auto as a type definition
                        <indent-block>
                          <c-s>auto r{ 3 }; auto s{ 1.5 }</c-s>
                        </indent-block>
                        instructs compiler to use type deduction to suppy the type, so <c-s>r</c-s> is type int and <c-s>s</c-s> is type double.
                      </li>
                      <li>
                        auto is frequently used to deduce the type of a function return value or as the type of a variable enumerated in
                        a range-based for:
                        <indent-block>
                          <c-s>auto r = f();</c-s><br />
                          <c-s>for(auto item : container) { ... }</c-s>
                        </indent-block>
                        auto type deduction is similar to the type deduction process used for templates.
                      </li>
                    </ol>
                  </defn-body>
                  <defn-head class="defnBorderTop">
                    Code example:
                  </defn-head>
                  <defn-code>
std::vector&lt;int&gt; vecInt { 1, 2, 3 };
for(auto& item : vecInt) {
  item *= 2;
}
                  </defn-code>
                  <defn-head class="defnBorderTop">
                    decltype
                  </defn-head>
                  <defn-body>
                    Like auto, decltype is a declaration.
                    <ol>
                      <li>
                        decltype as a type definition
                        <indent-block>
                          <c-s>
                            decltype(make_lambda()) x;
                          </c-s>
                        </indent-block>
                        x is a lambda of the same type as created by the function make_lambda
                      </li>
                    </ol>
                  </defn-body>
                  <defn-head class="defnBorderTop">
                    Code example:
                  </defn-head>
                  <defn-code>
decltype(vecInt) vecInt2;
// results in std::vector&lt;int&gt; instance, named vecInt2,
// with default initialization
                  </defn-code>
                </defn-block>
              </div>
              <s-1em></s-1em>
            </details>
          </indent-block>

          <h3 id="explore">3.2  Exploring Types</h3>
          <t-b class="mbz">
            Occasionally it is important to know the sizes of variables in our designs.  For example, if
            we need to serialize an object into a byte array to pass over a socket, we need to know the
            size of the object. Also, knowing the sizes of types may help us understand how they work.
            That&apos;s illustrated in the lambda example, below.
          </t-b>
          <spacer-15></spacer-15>
          The operator <c-s>sizeof</c-s> can be applied to a type or an expression:
          <indent-block class="pad10">
            <c-s>size_t sz = sizeof(arg);</c-s>
          </indent-block>
          <t-b class="mbz mtz">
            It returns the size of the arg parameter in bytes for all types
            except references.  For references sizeof(X&) returns the size of the referenced type, not the
            size of the reference. The size of a reference equals the size of a pointer, which, on my work
            machine, is 4 bytes, e.g., 32 bits.
            You can verify this by constructing a class Xref with a single reference member and evaluating
            sizeof(Xref).
          </t-b>
          <spacer-15></spacer-15>
          The operator <c-s>typeid</c-s> can be applied to a type or an expression as:
          <indent-block class="pad10">
            <c-s>std::type_info ti = typeid(CT)</c-s>
          </indent-block>
          <t-b class="mbz mtz">
            where CT is any complete type. In order to use <c-s>typeid</c-s> you need to include
            <c-s>&lt;typeinfo&gt;</c-s>.  There is much less information in <c-s>type_info</c-s>
            instances like <c-s>ti</c-s> than you would get from
            reflection results with languages like C# and Java.
          </t-b>
          <spacer-15></spacer-15>
          <t-b class="mbz mtz">
            However, <c-s>type_info</c-s> has
            useful methods: <c-s>operator==(const type_info&)</c-s> and
            <c-s>operator!=(const type_info&)</c-s> to query whether two instances belong to the same type,
            and <c-s>name()</c-s>, so we can discover the full type name of some instance.
          </t-b>
          <spacer-15></spacer-15>
          <indent-block class="pad10">
            <details>
              <summary class="labelStyle darkItem">
                Example: Using <c-s>sizeof</c-s> and <c-s>typeid</c-s> to explain how lambdas work
              </summary>
              <div class="pad10">
                Here is a template function, useful for exploring types, that uses both <c-s>sizeof</c-s>
                and <c-s>typeid</c-s>:
              </div>
              <defn-block class="bb-full">
                <defn-body class="pad10">
                  <pre>
 <c-s>template&lt;typename T&gt;
  void displayType(const T&amp; t, const std::string&amp; msg = "", bool showSize = true)
  {
    std::cout &lt;&lt; "\n  ";
    if (showSize)
      std::cout &lt;&lt; sizeof(t) &lt;&lt; " = size of ";
    std::string typeName = typeid(t).name();
    if (typeName.size() &gt; 75)
      typeName = typeName.substr(0, 75) + "...";
    std::cout &lt;&lt; typeName;
    if (msg.size() &gt; 0)
      std::cout &lt;&lt; msg;
  }</c-s>
</pre>
                </defn-body>
              </defn-block>
              <div class="pad20">
                It provides one way to begin understanding how lambdas work:
              </div>
              <defn-block>
                <defn-body>
                  <pre>
 <c-s>int i{ 42 };
  auto f = [i](const std::string& s) {  
    std::cout << s << i;
  };
  f("\n  The meaning of life is ");
  displayType(f);</c-s>
</pre>
                </defn-body>
              </defn-block>
              <div class="pad20">
                Here, f is a lambda, declared with auto because we don&apos;t know the lambda type.
                the <c-s>[i]</c-s> part of the expression says that this lambda captures the value of i, e.g., 42.
                The <c-s>(const std::string&amp; s)</c-s> defines a string parameter, passed to the lambda code
                by const reference. The body <c-s>{ ... }</c-s> simply displays the parameter and the
                captured integer value.
                <spacer-15></spacer-15>
                The output of this code is:
              </div>
              <defn-block>
                <defn-body>
                  <pre>
 <c-s>The meaning of life is 42
  4 = size of class &lt;lambda_1bed100c18f4584a5d93f1a5d7e27280&gt;</c-s>
</pre>
                </defn-body>
              </defn-block>
              <div class="pad20">
                So, the displayType function has informed us that the lambda is a class, it disclosed the
                lambda&apos;s type name, obviously not intended for human consumption, and showed us that its
                size is just the size of the captured int value.
                <spacer-15></spacer-15>
                It&apos;s highly likely that the compiler created a functor, something like this:
              </div>
              <spacer-10></spacer-10>
              <defn-block>
                <defn-body class="pad10">
                  <pre>
 <c-s>class lambda_1bed1... {
  public:
    void operator()(const std::string&amp; s) {
      std::cout << s << i;    
    }
  private:
    int i = 42;
  };</c-s>
</pre>
                </defn-body>
              </defn-block>
              <div class="pad20" style="width:100%;">
                So lambdas can capture data, be passed into or returned from functions, taking their data
                with them (as long as they hold a value, not a reference). We say that the lambda and its
                local scope are a closure.  A lambda can use any data in its closure as part of its
                operation.
                <spacer-15></spacer-15>
                Essentially, a lambda has two sets of inputs: from its capture list <c-s>[i, j, x]</c-s>
                which come from the lambda&apos;s closure, and <c-s>(T1 arg1, T2 arg2, ... )</c-s>
                which are passed in from the scope where the lambda is invoked. The lambda&apos;s designer
                provides the capture inputs and the lambda user provides the arguments.
              </div>
            </details>
          </indent-block>
          In the next section, we continue exploring types by looking at their layout in memory.

          <h3 id="typestr">3.3  Type Structure</h3>
          <photosizer-block src="Pictures/StringLayout.JPG" width="400" class="photoSizerBlock right" style="margin-top:-1em;">
            <span style="font-family:'Comic Sans MS', Tahoma;">
              Fig 1. String Layout
            </span>
          </photosizer-block>
          <t-b>
            There are also issues of type structure we need to think about.  The fundamental types place
            all their value information in one place, in the stack frame where they are declared.
            However, not all types are structured that way. A std::string, for example, stores its
            control state, iterator, character count, etc., in the stack frame where it is declared,
            but all its user state, e.g., its character sequence, is stored in the heap.
            <spacer-15></spacer-15>
            The <c-s>sizeof</c-s> operator measures only the stack allocation.  So, for example, it will
            return the same size for an empty string and a string with 100 characters.  For all of the
            STL sequential containers with contiguous heap memory, e.g., <c-s>string</c-s>, <c-s>vector</c-s>,
            and <c-s>deque</c-s>, you can call their <c-s>capacity()</c-s> method to measure that allocation.
            Here&apos;s an example:
          </t-b>
          <defn-block>
            <defn-code class="noBorder">
std::string str("content of a std::string");
std::cout &lt;&lt; "\n  " &lt;&lt; str;
std::cout &lt;&lt; "\n  string size = " &lt;&lt; (str.size() + 1) * sizeof(char);
std::cout &lt;&lt; "\n  allocation size = " &lt;&lt; str.capacity() * sizeof(char);
            </defn-code>
          </defn-block>
          <t-b>
            When this code executes you get:
          </t-b>
          <defn-block>
            <defn-code class="noBorder">
content of a std::string
string size = 25
allocation size = 31
            </defn-code>
          </defn-block>
          <t-b>
            For all the other containers measuring heap allocation is much more effort, but the ideas
            will be about the same.  You would have to iterate through the container, measuring each of
            the elements, accessed by the container&apos;s iterator.
          </t-b>
          Even the fundamental types differ in structure:
          <t-b class="indent">
            <ol class="tights">
              <li>
                All of the fundamental types except floats have a simple structure consisting of
                a sequence of bytes in one location.
              </li>
              <li>
                The float type partitions its storage into:
                <ul class="tight">
                  <li>1 bit sign</li>
                  <li>8 bit exponent</li>
                  <li>23 bit fraction</li>
                </ul>
              </li>
              <li>
                The double type has the partitions:
                <ul class="tight">
                  <li>1 bit sign</li>
                  <li>11 bit exponent</li>
                  <li>52 bit fraction</li>
                </ul>
              </li>
            </ol>
          </t-b>    <t-b>
            This float/double structure has consequences:
          </t-b>
          <t-b class="indent">
            <ol class="tights">
              <li>
                The majority of values don&apos;t have an exact representation.  All of the intergers
                have exact floating representations, but numbers like 1.0/3.0 have an infinite number
                of trailing digits, e.g., 0.33333333333333...., and will be stored imprecisely.
              </li>
              <li>
                So these values have granularity with differences within granules that can&apos;t be
                represented.
              </li>
              <li>
                The size of the granularity depends on the magnitude of the float.  The fractional value
                of one float may be the same as the fractional value of another, but if the exponent of
                one is larger than the other, the absolute values of granularity will differ.
              </li>
              <li>
                It is entirely possible for two floats that are conceptually distinct to have the same
                floating representation, so you need to be careful with equality comparisons.
              </li>
              <li>
                Repeating operations on a float in a loop may exhibit increasing error in computed
                results due to the accumulation of granularity errors.
              </li>
            </ol>
          </t-b>
          <t-b>
            Here&apos;s data from an experiment with floats:
          </t-b>
          <defn-outerBlock>
            <defn-block>
              <defn-code>
--- demo float granularity ---

float f =             1.00000
f = (f + 1.0)/3.0 ==> 0.666667
f = (f + 1.0)/3.0 ==> 0.555556
f = (f + 1.0)/3.0 ==> 0.518519
f = (f + 1.0)/3.0 ==> 0.506173
f = (f + 1.0)/3.0 ==> 0.502058
f = (f + 1.0)/3.0 ==> 0.500686
f = (f + 1.0)/3.0 ==> 0.500229
f = (f + 1.0)/3.0 ==> 0.500076
f = (f + 1.0)/3.0 ==> 0.500025
f = (f + 1.0)/3.0 ==> 0.500008

Reversing process:

f = 3.0 * f - 1.0 ==> 0.500025
f = 3.0 * f - 1.0 ==> 0.500076
f = 3.0 * f - 1.0 ==> 0.500229
f = 3.0 * f - 1.0 ==> 0.500686
f = 3.0 * f - 1.0 ==> 0.502057
f = 3.0 * f - 1.0 ==> 0.506170
f = 3.0 * f - 1.0 ==> 0.518510
f = 3.0 * f - 1.0 ==> 0.555531
f = 3.0 * f - 1.0 ==> 0.666594
f = 3.0 * f - 1.0 ==> 0.999782
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-body>
                <s-halfEm></s-halfEm>
                There are many domains where float granularity matters:
                <ul>
                  <li>
                    Scientific computing, e.g., processing models for particles, gravity,<br />
                    super-conductors, gene expression, climate dynamics, ...
                  </li>
                  <li>
                    Processing financial models for derivative and currency trading
                  </li>
                  <li>
                    Graphics processing using projections and ray-tracing
                  </li>
                  <li>
                    Medical imaging
                  </li>
                  <li>
                    Radar and Sonar signal processing
                  </li>
                  <li>
                    Finite-element analysis for fluid flow
                  </li>
                  <li>
                    Navigation computing for aircraft and spacecraft
                  </li>
                  <li>
                    Autonomous vehicle control.
                  </li>
                  <li>
                    Neural network modeling
                  </li>
                  <li>
                    Marketing models
                  </li>
                  <li>
                    Control of machine tools used to create manufactured products
                  </li>
                  <li>....</li>
                </ul>
                The point is that you may well, during the course of your career,<br />
                work in domains where floating point granularity matters.
              </defn-body>
            </defn-block>
          </defn-outerBlock>
          <div style="height:1em;"></div>

          <h3 id="casts">3.4  Managing C++ Type System with Casts</h3>
          <t-b>
            Cast operations are a mechanism for mapping an instance of one type into an instance of another
            type or modifying the type rules applied to a given instance.
            Since the introduction of C++11 we&apos;ve had four modern cast forms:
          </t-b>
          <spacer-15></spacer-15>
          <div class="pad10">
            <table width="80%">
              <tr>
                <th>static_cast Syntax</th>
                <th>static_cast Symantics</th>
              </tr>
              <tr>
                <td><c-s>T<sub>2</sub> t<sub>2</sub> = static_cast&lt;T<sub>2</sub>&gt;(t<sub>1</sub>);</c-s></td>
                <td>
                  Convert <c-s>t<sub>1</sub> &epsilon; T<sub>1</sub></c-s> to an instance of
                  <c-s>T<sub>2</sub></c-s> usually by
                  constructing a new <c-s>T<sub>2</sub></c-s> instance using data from <c-s>t<sub>1</sub></c-s>.
                </td>
              </tr>
            </table>
            <spacer-15></spacer-15>
            <indent-blocks>
              <details>
                <summary class="labelStyle darkItem">Example: static_cast&lt;T&gt;</summary>
                <spacer-10></spacer-10>
                <defn-block class="defnBorder pad10 bb-full">
                  <pre><c-s> /*--------------------------------------------------------------------------------------
  purpose of static_cast is to create a new instance of a destination type, based on
  data stored in the source type.
 --------------------------------------------------------------------------------------*/  

  int i = 1.75;  // i = 1, with compiler warning of loss of significance
  int j = static_cast&lt;int&gt;(1.75);  // j = 1, no compiler warning</c-s>
</pre>
                </defn-block>
              </details>
            </indent-blocks>
            <spacer-15></spacer-15>
            <table width="80%">
              <tr>
                <th>const_cast Syntax</th>
                <th>const_cast Symantics</th>
              </tr>
              <tr>
                <td>
                  <c-s>T&amp;&nbsp;tRef&nbsp;=&nbsp;const_cast&lt;T&amp;&gt;(t);</c-s>
                </td>
                <td>
                  Strip off const qualifier from a const type.  Intent is to pass const variable to platform API functions
                  which can&apos;t inform compiler that they won&apos;t change variable, but designer knows they
                  won&apos;t.<br />
                </td>
              </tr>
            </table>
            <spacer-15></spacer-15>
            <indent-blocks>
              <details>
                <summary class="labelStyle darkItem">Example: const_cast&lt;T&gt;</summary>
                <spacer-10></spacer-10>
                <defn-block class="defnBorder pad10 bb-full">
<pre><c-s> /*--------------------------------------------------------------------------------------
  purpose of const_cast is to allow passing const data to functions that won't change
  value even though not declared as const functions, OS API calls for example.
 --------------------------------------------------------------------------------------*/   

  void mockAPIfunction(std::string* pStr) {
    std::cout &lt;&lt; "\n  inside mock API function: " &lt;&lt; *pStr;
  }

  void demoConstCast(const std::string&amp; str) {

    displaySubtitle("const_cast");

    std::cout &lt;&lt; "\n  " &lt;&lt; str;
    //mockAPIfunction(&amp;str);  fails to compile since str is const

    /*--- useful operation using sRef ---*/

    std::string&amp; sRef = const_cast&lt;std::string&amp;&gt;(str);
    // created non-const reference to const str

    mockAPIfunction(&amp;sRef);  // succeeds since sRef is not const

    /*--- evil operation on sRef, violates contract of function interface ---*/
    /* don't do this */
    sRef = "changed";
    std::cout &lt;&lt; "\n  " &lt;&lt; str;  // now has changed value
    std::cout &lt;&lt; "\n";
  }</c-s>
</pre>
                </defn-block>
                <spacer-10></spacer-10>
                <defn-block class="defnBorder">
                  <div class="pad10">
<pre><c-s>  const_cast
 ------------
  const string
  inside mock API function: const string   
  changed</c-s></pre>
                  </div>
                </defn-block>
                <div class="pad10 indent">
                  This illustrates that the compiler will let you change the source of the const_cast
                  but you should never do that.
                </div>
              </details>
            </indent-blocks>
            <spacer-15></spacer-15>
            <table width="80%">
              <tr>
                <th>dynamic_cast Syntax</th>
                <th>dynamic_cast Symantics</th>
              </tr>
              <tr>
                <td>
                  <c-s style="white-space:nowrap;">Derived* pDer = dynamic_cast&lt;Derived*&gt;(pBase)</c-s><br />
                  <c-s>
                    if(pDer != nullptr) {<br />
                    &nbsp;&nbsp;pDer->Derived::memFun();<br />
                    }
                  </c-s>
                </td>
                <td>
                  Intent is to call, starting with <c-s>Base</c-s> pointer, <c-s>Derived</c-s> member function,
                  not in <c-s>Base</c-s> interface.
                  If <c-s>Base</c-s> pointer does point to instance of the requested type, the cast returns
                  <c-s>pBase</c-s>
                  address, typed as a <c-s>Derived</c-s> pointer, otherwise it returns <c-s>nullptr</c-s>.
                </td>
              </tr>
            </table>
            <spacer-15></spacer-15>
            <indent-blocks>
              <details>
                <summary class="labelStyle darkItem">Example: dynamic_cast&lt;T&gt;</summary>
                <spacer-10></spacer-10>
                <defn-block class="defnBorder pad10 bb-full">
<pre><c-s> /*--------------------------------------------------------------------------------------
  dynamic_cast grants access to derived class interfaces starting with base pointer
 --------------------------------------------------------------------------------------*/   

  class Base {
  public:
    virtual ~Base() {}
    virtual void say() {
      std::cout &lt;&lt; "\n  hello from Base::say() via " &lt;&lt; typeid(*this).name();
    }
  };

  class Derived1 : public Base {
  public:
    virtual ~Derived1() {}
    void say1() {
      std::cout &lt;&lt; "\n  hello from Derived1::say1() via " &lt;&lt; typeid(*this).name();
    }
  };

  class Derived2 : public Base {
  public:
    virtual ~Derived2() {}
    void say2() {
      std::cout &lt;&lt; "\n  hello from Derived2::say2() via " &lt;&lt; typeid(*this).name();
    }
  };

  auto putline = [](int n=1) { 
    for(int i=0; i&lt;n; ++i)
      std::cout &lt;&lt; std::endl; 
  };

  void demoDynamicCast() {

    displaySubtitle("dynamic_cast");

    std::cout &lt;&lt; "\n --- calls from objects ---\n";
    Base b; b.say();
    putline();
    Derived1 d1; d1.say(); d1.say1();
    putline();
    Derived2 d2; d2.say(); d2.say2();
    putline();

    std::cout &lt;&lt; "\n --- call via base pointer ---\n";
    Base* pBase = &amp;d1; pBase-&gt;say(); // pBase-&gt;say1(); not accessible from B*
    putline();

    std::cout &lt;&lt; "\n --- call via dynamic_cast derived pointer ---\n";

    Derived1* pDer1 = dynamic_cast&lt;Derived1*&gt;(pBase);
    if (pDer1) {
      pDer1-&gt;say1();
    }
    putline();
  }</c-s>
</pre>
                </defn-block>
                <spacer-10></spacer-10>
                <defn-block class="defnBorder pad10">
                  <pre><c-s>  dynamic_cast
 --------------

 --- calls from objects ---
  hello from Base::say() via class Base

  hello from Base::say() via class Derived1
  hello from Derived1::say1() via class Derived1

  hello from Base::say() via class Derived2
  hello from Derived2::say2() via class Derived2    

 --- call via base pointer ---
  hello from Base::say() via class Derived1

 --- call via dynamic_cast derived pointer ---
  hello from Derived1::say1() via class Derived1
          </c-s></pre>
                </defn-block>
              </details>
            </indent-blocks>
            <spacer-15></spacer-15>
            <table width="80%">
              <tr>
                <th>
                  <div>
                    reinterpret_cast Syntax
                  </div>
                </th>
                <th>reinterpret_cast Symantics</th>
              </tr>
              <tr>
                <td>
                  <c-s>
                    T<sub>dst</sub>* pT<sub>dst</sub> =
                    reinterpret_cast&lt;T<sub>dst</sub>*&gt;(pT<sub>src</sub>);
                  </c-s>
                </td>
                <td>
                  Apply type rules of <c-s>T<sub>dst</sub></c-s> to <c-s>t<sub>src</sub> &epsilon; T<sub>src</sub></c-s>.<br />
                  Usually used for packing data into byte arrays and unpacking back to original type.
                </td>
              </tr>
            </table>
          </div>
          <spacer-15></spacer-15>
          <indent-block>
            <details>
              <summary class="labelStyle darkItem">Example: reinterpret_cast&lt;T&gt;</summary>
              <spacer-10></spacer-10>
              <defn-block class="defnBorder pad10 bb-full">
                <pre><c-s> /*--------------------------------------------------------------------------------------
  purpose of reinterpret_cast is to apply new type rules to an existing instance.
  - packing double's bytes into byte array
  - unpacking byte array into another double
  - illustrates how data might be marshalled over a socket channel, where the
    byte array pretends to be the socket channel
  --------------------------------------------------------------------------------------*/    

  void demoReinterpretCast() {

    displaySubtitle("reinterpret_cast");

    double d1{ 3.5 };
    double d2;
    size_t Max = sizeof(d1);

    /* create byte array on heap referenced by std::unique_ptr&lt;std::byte&gt; */

    std::unique_ptr&lt;std::byte&gt; pBuffer(new std::byte[Max]);  // owning pointer
    std::byte* pBuffIndex = pBuffer.get();                   // non-owning pointer

    /* pack double d1 into byte array */

    std::byte* pByteSrc = reinterpret_cast&lt;std::byte*&gt;(&amp;d1);
    std::byte* pSrcIndex = pByteSrc;  			   // non-owning pointers

    for (size_t i = 0; i &lt; Max; ++i) {
      *pBuffIndex++ = *pSrcIndex++;
    }

    /* unpack byte array into double d2 */

    if (sizeof(d2) == sizeof(d1)) {
      std::byte* pByteDst = reinterpret_cast&lt;std::byte*&gt;(&amp;d2);
      std::byte* pDstIndex = pByteDst;  			   // non-owning pointers
      pBuffIndex = pBuffer.get();
      for (size_t i = 0; i &lt; Max; ++i) {
        *pDstIndex++ = *pBuffIndex++;
      }
    }

    /* show that src and dst have the same values */

    std::cout &lt;&lt; "\n  src double = " &lt;&lt; d1;
    std::cout &lt;&lt; "\n  dst double = " &lt;&lt; d2;

    // byte array on heap will be deallocated here
    // as std::unique_ptr goes out of scope
  }
              </c-s>
</pre>
              </defn-block>
              <spacer-10></spacer-10>
              <defn-block class="defnBorder pad10">
                <pre><c-s>    reinterpret_cast
   ------------------     
    src double = 3.5
    dst double = 3.5
            </c-s>
</pre>
              </defn-block>
            </details>
          </indent-block>
          <s-halfEm></s-halfEm>
          <t-b>
            C++ also defines a member function cast operator that supports creating an instance of a
            specified destination type from an instance of the casting class:
          </t-b>
          <defn-block class="indent">
            <defn-head class="pad5">C++ cast operator</defn-head>
            <defn-body>
              <indent-block class="pad5">
                <c-s>
                  class X {<br />
                  public:<br />
                  &nbsp;&nbsp;operator Y () { ... }<br />
                  };
                </c-s>
              </indent-block>
              <spacer-15></spacer-15>
              which supports expressions like:
              <indent-block class="pad10">
                <c-s>
                  X x;<br />
                  Y y = x;
                </c-s>
              </indent-block>
              If we declared the cast as explicit:
              <indent-block class="pad10">
                <c-s>
                  class X {<br />
                  public:<br />
                  &nbsp;&nbsp;explicit operator Y () { ... }<br />
                  };
                </c-s>
              </indent-block>
              then we would have to explicitly use static_cast:
              <indent-block class="pad10">
                <c-s>
                  X x;<br />
                  Y y = static_cast&lt;Y&gt;(x);
                </c-s>
              </indent-block>
            </defn-body>
          </defn-block>
          <h3 id="newtypes">3.5  New Standard Types</h3>
          <t-b>
            The std::pair container has been part of standard C++ libraries prior to C++11.
            The remaining containers were all introduced with or after C++11.  You&apos;ll see
            std::pair and std::tuple used in the examples below. All of the rest have been used
            in sample code that accompanies this chapter.
          </t-b>
          <t-b>
            <defn-block class="indent">
              <defn-head style="border:none;">
                Special Containers
              </defn-head>
              <defn-body style="border:none;">
                <table>
                  <tr>
                    <td>pair</td>
                    <td class="normal">contains two elements which may have distinct types</td>
                  </tr>
                  <tr>
                    <td>tuple</td>
                    <td class="normal">contains finite number of elements with distinct types</td>
                  </tr>
                  <tr>
                    <td>initializer_list</td>
                    <td class="normal">
                      contains sequence of elements, all of the same type
                      normally filled with initialization list, e.g., { 1, 2, 3, ... }
                    </td>
                  </tr>
                  <tr>
                    <td>any</td>
                    <td class="normal">holds value of any type, provides std::any_cast for retrieval</td>
                  </tr>
                  <tr>
                    <td>optional</td>
                    <td class="normal">used to return values or signal failure to return</td>
                  </tr>
                  <tr>
                    <td>variant</td>
                    <td class="normal">similar to any, but only holds values from a specified set of types</td>
                  </tr>
                </table>
                <s-1Em></s-1Em>
              </defn-body>
            </defn-block>
          </t-b>
          <t-b>
            These new standard types are not essential, but are very effective &quot;friction&quot; reducers.
            They make routine code we write easier to produce and to understand. We will see examples
            of their use throughout the remainder of this story.
          </t-b>

          <h3 id="init">3.6  Initialization</h3>
          <t-b>
            We&apos;ve already encountered initialization of data.  The section will take a closer look
            to see how it works.
            For the fundamental types, there are four sets of syntax:
          </t-b>
          <t-b class="indent">
            <c-s>
              <ol class="tight">
                <li>
                  T t = u
                </li>
                <li>
                  T t(u);
                </li>
                <li>
                  T t = { u };
                </li>
                <li>
                  T t{ u };
                </li>
              </ol>
            </c-s>
          </t-b>
          <t-b>
            Where u &epsilon; U is some type that can be coerced to a T type or
            promoted through a <c-s>T(U&nbsp;u)</c-s> constructor.  The first two are equivalent,
            invoking <c-s>T(U&nbsp;u)</c-s>.  Note that there is no assignment in the first.  The
            syntax is completely equivalent to the second.
            <spacer-15></spacer-15>
            The third and fourth are also equivalent to each other, but not to the first two.
            The difference is that narrowing conversions like:
            <indent-block class="pad10">
              <c-s>int i = 1.75;  // size of int is 4 bytes, size of double is 8 bytes</c-s>
            </indent-block>
            will succeed with either of the first two, with a compiler warning.
            But that is not true for braced initialization:
            <indent-block class="pad10">
              <c-s>int j{ 1.75 };  // fails to compile</c-s>
            </indent-block>
            <spacer-10></spacer-10>
            Braced initialization, like case 4, above, applies for most data definitions, and
            has been named "uniform initialization".
            <div style="padding-top:15px; padding-bottom:5px;">
              Examples of <strong>&quot;uniform initialization&quot;</strong>
            </div>
            <div style="height:0.5em;"></div>
            <defn-block class="indent">
              <defn-body>
                <c-s>
                  std::string s4{ "four" };
                  <div style="height:0.5em;"></div>
                  double pi{ 3.1415729 };<br />
                  double* pDouble{ &pi };<br />
                  double& rDouble{ pi };
                  <div style="height:0.5em;"></div>
                  std::pair&lt;int, double&gt; pair1{ 4, 4.5 };
                  <div style="height:0.5em;"></div>
                  std::vector&lt;std::pair&lt;int, double&gt;&gt; pVec{ pair1, pair2, pair3, pair4 };&nbsp;&nbsp;
                  <div style="height:0.5em;"></div>
                  std::tuple&lt;int, double, std::string&gt; aTuple{ 1, 3.1415927, "some string" };
                  <div style="height:0.5em;"></div>
                  std::unordered_map&lt;std::string, int&gt; umap{ { "two", 2}, {"three", 3} };
                  <div style="height:0.5em;"></div>
                  std::unique_ptr&lt;double&gt; uPtr1{ std::make_unique&lt;double&gt;(pi) };<br />
                  std::shared_ptr&lt;double&gt; sPtr1{ std::make_shared&lt;double&gt;(pi) };
                </c-s>
              </defn-body>
            </defn-block>
            <t-b>
              Uniform initialization makes putting data into containers easy.  Since C++17 it&apos;s
              been just as easy to extract data using structured bindings.
            </t-b>
            <div style="padding:10px 0px 10px 0px;">
              Examples of <strong>&quot;structured binding&quot;</strong>
            </div>
            <defn-block class="indent">
              <defn-body>
                <c-s>
                  auto [i5, i6] = std::pair{ 5, 6 };<br />
                  auto [d, i, s] = std::tuple&lt;double, int, std::string&gt;{ 2.5, 3, "four" };
                  <div style="height:0.5em;"></div>
                  struct S { int i; char c; std::string s; };<br />
                  S foobar{ 2, 'Z', "a string" };<br />
                  auto [fee, fie, foe] = foobar;
                </c-s>
              </defn-body>
            </defn-block>
            <div style="height:0.5em;"></div>
            The identifiers: <c-s>i5, i6, d, i, s, fee, fie, foe</c-s> are all instances with
            types deduced by auto, based on the types in the containers to which they are bound.
            You can use them, just like any other identifier, after the binding statement.
            <div style="height:0.5em;"></div>
            <div style="padding:15px 0px 5px 0px;">
              Note that these are declarations, so the identifier names must be different than
              any used before the binding statement in the same scope.
            </div>
            <div style="height:0.5em;"></div>
            <div>
              <span class="notice">Note:</span> Structured binding only works for public data in the source entity.
            </div>
            <div style="padding:10px 0px 10px 0px;">
              Example of where <strong>&quot;structured binding&quot;</strong> does not work.
            </div>
            <defn-block class="indent">
              <defn-body>
                <c-s>
                  class C {<br />
                  public:<br />
                  &nbsp;&nbsp;C(const std::string& str) : str_(str) {}     // promotion ctor&nbsp;&nbsp;<br />
                  &nbsp;&nbsp;void say() { std::cout << "\n  " << str_; }<br />
                  &nbsp;&nbsp;operator std::string() { return str_; }      // cast operator<br />
                  private:<br />
                  &nbsp;&nbsp;std::string str_;<br />
                  };
                  <div style="height:0.5em;"></div>
                  /* uniform initialization works with promotion ctors */<br />
                  C c{ "hello world" };<br />
                  <div style="height:0.5em;"></div>
                  /* these fail to compile: can only bind to public data */<br />
                  //auto [gotit] {c};<br />
                  //auto [gotit] = { static_cast<std::string>
                    (c) };
                    <div style="height:0.5em;"></div>
                    auto gotit = c;  // this works via the cast operator, but is not structured binding
                    <spacer-10></spacer-10>
                </c-s>
              </defn-body>
            </defn-block>
          </t-b>
          <div style="height:0.25em;"></div>
          <h3 id="smartptrs">3.7  Managing Allocation with Smart Pointers</h3>
          <t-b>
            C++ has a large collection of containers in the Standard Template Library that manage allocations
            very effectively. They are our first choice for managing data on the native heap<sup>1</sup>.
            When building our own data managers and creational functions, using smart pointers,
            <c-s>std::unique_ptr</c-s> and <c-s>std::shared_ptr</c-s>, is preferred over working with raw
            pointers.
          </t-b>
          <t-b>
            There are two benefits of doing that:
            <indent-block>
              <ol class="tight">
                <li>
                  There are no memory leaks because smart pointers delete their allocations when they
                  go out of scope.
                </li>
                <li>
                  Users of creational funtions that return smart pointers can ignore allocation management.
                  The smart pointers do that for them.
                </li>
              </ol>
            </indent-block>
          </t-b>
          <t-b>
            The demonstration, below, illustrates use of smart pointers and also illustrates the
            <span class="notice">Dependency Inversion Principle</span>.  The demo provides
            factory functions that return <c-s>std::unique_ptr&lt;IWidget&gt;</c-s> to provide access
            to <c-s>Widget</c-s> instances on the heap.  Because the user gets access only through an interface,
            <c-s>IWidget</c-s>, she doesn&apos;t depend on any of the implementation details for processing in the
            <c-s>Widget</c-s> class.  Because she uses a factory, she doesn&apos;t depend on the details
            of creation, so she is completely isolated from the Widget implemenation.
          </t-b>
          <t-b>
            <details>
              <summary class="labelStyle darkItem">Smart Pointers</summary>
              <t-b>
                <defn-outerBlock>
                  <defn-block>
                    <defn-head>Chap2SmartPtrs.cpp</defn-head>
                    <defn-code>
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include "../Chapter7-Display/Chap7Display.h"

std::string displayHelper(
  const std::string&amp; str
)
{
  std::string insert =
  (str.size() &gt; 0 ? " " + str + " " : " ");
  return insert;
}
/*-- interface for Widget class --*/

struct IWidget {
  virtual ~IWidget() {}
  virtual void say() = 0;
  virtual std::string name() = 0;
  virtual void name(const std::string&amp; nm) = 0;
};
/*-- Widget class --*/

class Widget : public IWidget {
public:
  Widget() = default;
  Widget(const std::string&amp; nm) {
    name_ = nm;
  }
  ~Widget() {
    std::cout &lt;&lt; "\n  destroying "
    &lt;&lt; displayHelper(name_);
  }
  virtual void say() override {
    std::cout &lt;&lt; "\n  Widget instance"
    &lt;&lt; displayHelper(name_)
    &lt;&lt; "here";
    std::cout &lt;&lt; "\n  my address is "
    &lt;&lt; reinterpret_cast&lt;long long&gt;(this);
  }
  virtual std::string name() override {
    return name_;
  }
  virtual void name(const std::string&amp; nm) {
    name_ = nm;
  }
private:
  std::string name_;
};
                    </defn-code>
                    <defn-head class="defnBorderTop">Smart Pointer Factories:</defn-head>
                    <defn-code>
/*-------------------------------------------
first factory function uses unique_ptr
*/

std::unique_ptr&lt;IWidget&gt; createWidget1() {
  return std::unique_ptr&lt;Widget&gt;(new Widget);
}
/*--------------------------------------------
second factory function uses make_unique
*/

std::unique_ptr&lt;IWidget&gt; createWidget2() {
  return std::make_unique&lt;Widget&gt;();
}
/*-------------------------------------------
third factory function uses initialized
make_unique
*/
std::unique_ptr&lt;IWidget&gt;
createWidget3(const std::string&amp; name) {
  return std::make_unique&lt;Widget&gt;(
    Widget(name)
  );
}

/*-------------------------------------------
fourth factory function uses static Widget
for make_unique avoiding repeated constr.
*/
std::unique_ptr&lt;IWidget&gt;
createWidget4(const std::string&amp; name) {
  static Widget widget;
  widget.name(name);
  return std::make_unique&lt;Widget&gt;(
    widget
  );
}
                    </defn-code>
                  </defn-block>
                  <defn-block>
                    <defn-head>Using Code:</defn-head>
                    <defn-code>
int main() {

  displayTitle("Demonstrating Smart Pointers");

  displayDemo(
    "--- createWidget1 with std::unique_ptr ---"
  );
  std::unique_ptr&lt;IWidget&gt; pWidget = createWidget1();
  pWidget-&gt;say();
  pWidget-&gt;name("Joe");
  pWidget-&gt;say();
  putline();

  displayDemo(
    "--- createWidget2 with std::make_unique ---"
  );
  pWidget = createWidget2();
  pWidget-&gt;name("Zhang");
  pWidget-&gt;say();
  putline();

  displayDemo(
    "--- createWidget3 with initialized "
    "std::make_unique ---"
  );
  pWidget = createWidget3("Ashok");
  pWidget-&gt;say();
  putline();

  displayDemo(
    "--- createWidget4 with "
    "static initialized "
    "std::make_unique ---"
  );
  pWidget = createWidget4("Priyaa");
  pWidget-&gt;say();
  putline();

  displayDemo(
    "--- std::shared_ptr ---"
  );
  std::shared_ptr&lt;IWidget&gt; pS1Widget =
    std::make_shared&lt;Widget&gt;(Widget("Mike"));
  pS1Widget-&gt;say();
  std::shared_ptr&lt;IWidget&gt;
  pS2Widget = pS1Widget;
  pS2Widget-&gt;say();
  putline();

  displayDemo(
    "--- std::shared_ptr via factory---"
  );
  std::shared_ptr&lt;IWidget&gt;
  pS3Widget = createWidget4("Sally");
  pS3Widget-&gt;say();
  std::shared_ptr&lt;IWidget&gt;
  pS4Widget = pS3Widget;
  pS4Widget-&gt;say();
  putline();
}
                    </defn-code>
                    <defn-head class="defnBorderTop">Output:</defn-head>
                    <defn-code>
 Demonstrating Smart Pointers
==============================

--- createWidget1 with std::unique_ptr ---
Widget instance here
my address is 2786941491616
Widget instance Joe here
my address is 2786941491616

--- createWidget2 with std::make_unique ---
destroying  Joe
Widget instance Zhang here
my address is 2786941490384

--- createWidget3 with
initialized std::make_unique ---
destroying  Ashok
destroying  Zhang
Widget instance Ashok here
my address is 2786941490272

--- createWidget4 with static
initialized std::make_unique ---
destroying  Ashok
Widget instance Priyaa here
my address is 2786941491504

--- std::shared_ptr ---
destroying  Mike
Widget instance Mike here
my address is 2786941451616
Widget instance Mike here
my address is 2786941451616

--- std::shared_ptr via factory---
Widget instance Sally here
my address is 2786941491280
Widget instance Sally here
my address is 2786941491280

destroying  Sally
destroying  Mike
destroying  Priyaa
destroying  Sally
                    </defn-code>
                  </defn-block>
                </defn-outerBlock>
              </t-b>
            </details>
          </t-b>
          <hr class="spreadup" />
          <div class="footnote indent">
            <ol class="tight">
              <li>
                All of the STL containers manage data with heap allocations except for the <c-s>std::array</c-s>.
                That class uses stack allocation for a fixed number of data items.
              </li>
            </ol>
          </div>
          <h3 id="datastr">3.8  Building Data Structures with STL Containers</h3>
          <t-b>
            In this section we will see how easy it is to &quot;snap together&quot; STL containers
            into complex, useful data structures. Details of the STL will be deferred to Chapter 6.
            <div style="height:0.5em;"></div>
            In this example we want to save file and path information from a directory tree, starting
            with a specified root path.  Our goal is to save each distinct filename and each distinct
            path only once.  We accomplish that by using several STL container classes.
            <div style="height:0.5em;"></div>
            Each file name encountered may appear in more than one directory. Instead of saving multiple
            path names, we save multiple iterators (much smaller than the path names) into a path set.
            <div style="height:0.5em;"></div>
            We&apos;ve simply connected them together, as shown in the using declarations, below.
            The structure of the STL, using iterators to point to specific contents, works very well.
            The complete declaration of the file information container is:
            <indent-block class="pad10">
              <c-s>
                std::map&lt;std::string,std::vector&lt;std::set&lt;std::string&gt;::iterator&gt;&gt;
                &nbsp;-->&nbsp;std::set&lt;std::string&gt;
              </c-s>
            </indent-block>
            The using declarations make that much more readable:
            <indent-block class="pad10">
              <c-s>
                FileInfo&lt;File, PathRefs&gt;&nbsp;-->&nbsp;PathSet&lt;Path&gt;
              </c-s>
            </indent-block>
            The class diagram and declaration are show in the blocks, below.
          </t-b>
          <div style="height:0.5em;"></div>
          <defn-outerBlock>
            <defn-block>
              <photosizer-block src="Pictures/FileInfoDataStructure.JPG" width="350" class="photoSizerBlock">
                <span style="font-family:'Comic Sans MS' Tahoma;">
                  Fig 1. FileInfo Data Structure
                </span>
              </photosizer-block>
            </defn-block>
            <defn-block>
              <defn-code>
class FileInfoContainer {
public:
  // file to path structure
  using File = std::string;
  using Path = std::string;
  using PathSet = std::set&lt;Path&gt;;
  using PathRef = PathSet::iterator;
  using PathRefs = std::vector&lt;PathRef&gt;;
  using FileInfo = std::map&lt;File, PathRefs&gt;;
  using iterator = FileInfo::iterator;
  using PathInfo = FileInfo;

  FileInfoContainer& add(const File& file, const Path& path);
  FileInfoContainer invertFileInfo(FileInfoContainer* pFIC);
  FileInfo fileInfo();
  iterator begin() { return fileInfo_.begin(); }
  iterator end() { return fileInfo_.end(); }
  size_t fileCount();
  size_t pathCount();

private:
  FileInfo fileInfo_;
  PathSet pathSet_;
  PathInfo pathInfo_;
};
              </defn-code>
            </defn-block>
          </defn-outerBlock>
          <div style="height:0.75em;"></div>
          <t-b class="mbz mtz">
            Output from a directory navigator that stores its file and directory information in a FileInfo
            container is shown below.  There are two collections of output.  The one on the left uses
            the FileInfo container.  The one of the right uses another FileInfo container to hold the
            results of inverting the path and file relationships.
            <div style="height:0.5em;"></div>
            Instead of using file names as keys and sets of path names as values, we swap the roles of
            file and path.  Instead of using
            <c-s>fileInfoContainer.add(file, path)</c-s> we invert that to
            <c-s>fileInfoContainer.add(path, file)</c-s>.
            Both sets of output are useful.  The one on the left, showing for each file name all the paths
            where it is found, can be used to find the latest version of a file, or older files to be
            discarded.
            <div style="height:0.5em;"></div>
            The output on the right would be useful for understanding how files are grouped into applications.
          </t-b>
          <div style="height:0.5em;"></div>
          <div class="autoX viewWidth">
            <table class="tdefn bb-full" style="font-size:0.9rem; border:none;">
              <tr>
                <td class="tableCode defn" style="white-space:nowrap;">
                  <span class="notice">
                    FileInfo from path ".."<br />
                    -------------------------<br />
                  </span>
                  CallableObjects.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter3-CallableObjects<br />
                  Chap1.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1<br />
                  Chap1.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1<br />
                  Classes.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter4-classes<br />
                  Coercion.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter3-Coercion<br />
                  Cpp11-BlockingQueue.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter3-Logger<br />
                  CustomTraits.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\CustomTraits<br />
                  Data.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter2-Data<br />
                  DateTime.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter2-STL<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter3-Logger<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\DirWalker<br />
                  DateTime.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter2-STL<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter3-Logger<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\DirWalker<br />
                  Dev.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Dev<br />
                  Dev.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Dev<br />
                  DirWalker.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter2-STL<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\DirWalker<br />
                  DirWalker.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter2-STL<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\DirWalker<br />
                  Display.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter3-Logger<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Display<br />
                  Functions.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter3-functions<br />
                  Functions1.cpp.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter3-functions<br />
                  IDev.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Dev<br />
                  IPerson - Copy.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  IPerson.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Dev<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Person<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  IPerson1.h.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  IPerson2.h.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  IPerson3.h.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  IPerson4.h.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  IPerson5.h.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  IPerson6.h.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  IPerson7.h.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  IPerson8.h.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  IPerson9.h.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  Init.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter2-Init<br />
                  Logger.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter3-Logger<br />
                  Logger.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter3-Logger<br />
                  Overloading.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-overloading<br />
                  Overriding.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Overriding<br />
                  Overriding.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Overriding<br />
                  Person.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Dev<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Person<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  Person.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Dev<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Person<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  PersonDisplay.h<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Person<br />
                  PersonTest.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-PersonTest<br />
                  STL.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter3-STL<br />
                  STL_DataStructures.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter2-STL<br />
                  Sizes.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter2-sizes<br />
                  Survey.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-Survey<br />
                  TestDev.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter1-DevTest<br />
                  TestPerson.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Chapter4-classes<br />
                  ToHTML.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  const_cast.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory<br />
                  const_cast1.cpp.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory<br />
                  const_cast1.txt.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory<br />
                  dynamic_cast.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory<br />
                  dynamic_cast1.cpp.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory<br />
                  dynamic_cast2.cpp.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory<br />
                  reinterpret_cast.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory<br />
                  reinterpret_cast1.cpp.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory<br />
                  static_cast.cpp<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory<br />
                  static_cast1.cpp.html<br />
                  &nbsp;&nbsp;C:\github\JimFawcett\CppStory<br /><br />

                  number of files: 56<br />
                  number of paths: 23<br />
                </td>
                <td class="tableCode defn" style="white-space:nowrap;">
                  <span class="notice">
                    PathInfo from path ".."<br />
                    -------------------------<br />
                  </span>
                  C:\github\JimFawcett\CppStory<br />
                  &nbsp;&nbsp;const_cast.cpp<br />
                  &nbsp;&nbsp;const_cast1.cpp.html<br />
                  &nbsp;&nbsp;const_cast1.txt.html<br />
                  &nbsp;&nbsp;dynamic_cast.cpp<br />
                  &nbsp;&nbsp;dynamic_cast1.cpp.html<br />
                  &nbsp;&nbsp;dynamic_cast2.cpp.html<br />
                  &nbsp;&nbsp;reinterpret_cast.cpp<br />
                  &nbsp;&nbsp;reinterpret_cast1.cpp.html<br />
                  &nbsp;&nbsp;static_cast.cpp<br />
                  &nbsp;&nbsp;static_cast1.cpp.html<br />
                  C:\github\JimFawcett\CppStory\Chapter1<br />
                  &nbsp;&nbsp;Chap1.cpp<br />
                  &nbsp;&nbsp;Chap1.h<br />
                  C:\github\JimFawcett\CppStory\Chapter1-Dev<br />
                  &nbsp;&nbsp;Dev.cpp<br />
                  &nbsp;&nbsp;Dev.h<br />
                  &nbsp;&nbsp;IDev.h<br />
                  &nbsp;&nbsp;IPerson.h<br />
                  &nbsp;&nbsp;Person.cpp<br />
                  &nbsp;&nbsp;Person.h<br />
                  C:\github\JimFawcett\CppStory\Chapter1-DevTest<br />
                  &nbsp;&nbsp;TestDev.cpp<br />
                  C:\github\JimFawcett\CppStory\Chapter1-Overriding<br />
                  &nbsp;&nbsp;Overriding.cpp<br />
                  &nbsp;&nbsp;Overriding.h<br />
                  C:\github\JimFawcett\CppStory\Chapter1-Person<br />
                  &nbsp;&nbsp;IPerson.h<br />
                  &nbsp;&nbsp;Person.cpp<br />
                  &nbsp;&nbsp;Person.h<br />
                  &nbsp;&nbsp;PersonDisplay.h<br />
                  C:\github\JimFawcett\CppStory\Chapter1-PersonTest<br />
                  &nbsp;&nbsp;PersonTest.cpp<br />
                  C:\github\JimFawcett\CppStory\Chapter1-Survey<br />
                  &nbsp;&nbsp;Survey.cpp<br />
                  C:\github\JimFawcett\CppStory\Chapter1-overloading<br />
                  &nbsp;&nbsp;Overloading.cpp<br />
                  C:\github\JimFawcett\CppStory\Chapter2-Data<br />
                  &nbsp;&nbsp;Data.cpp<br />
                  C:\github\JimFawcett\CppStory\Chapter2-Init<br />
                  &nbsp;&nbsp;Init.cpp<br />
                  C:\github\JimFawcett\CppStory\Chapter2-STL<br />
                  &nbsp;&nbsp;DateTime.cpp<br />
                  &nbsp;&nbsp;DateTime.h<br />
                  &nbsp;&nbsp;DirWalker.cpp<br />
                  &nbsp;&nbsp;DirWalker.h<br />
                  &nbsp;&nbsp;STL_DataStructures.cpp<br />
                  C:\github\JimFawcett\CppStory\Chapter2-sizes<br />
                  &nbsp;&nbsp;Sizes.cpp<br />
                  C:\github\JimFawcett\CppStory\Chapter3-CallableObjects<br />
                  &nbsp;&nbsp;CallableObjects.cpp<br />
                  C:\github\JimFawcett\CppStory\Chapter3-Coercion<br />
                  &nbsp;&nbsp;Coercion.cpp<br />
                  C:\github\JimFawcett\CppStory\Chapter3-Logger<br />
                  &nbsp;&nbsp;Cpp11-BlockingQueue.h<br />
                  &nbsp;&nbsp;DateTime.cpp<br />
                  &nbsp;&nbsp;DateTime.h<br />
                  &nbsp;&nbsp;Display.h<br />
                  &nbsp;&nbsp;Logger.cpp<br />
                  &nbsp;&nbsp;Logger.h<br />
                  C:\github\JimFawcett\CppStory\Chapter3-STL<br />
                  &nbsp;&nbsp;STL.cpp<br />
                  C:\github\JimFawcett\CppStory\Chapter3-functions<br />
                  &nbsp;&nbsp;Functions.cpp<br />
                  &nbsp;&nbsp;Functions1.cpp.html<br />
                  C:\github\JimFawcett\CppStory\Chapter4-classes<br />
                  &nbsp;&nbsp;Classes.cpp<br />
                  &nbsp;&nbsp;TestPerson.cpp<br />
                  C:\github\JimFawcett\CppStory\CustomTraits<br />
                  &nbsp;&nbsp;CustomTraits.h<br />
                  C:\github\JimFawcett\CppStory\DirWalker<br />
                  &nbsp;&nbsp;DateTime.cpp<br />
                  &nbsp;&nbsp;DateTime.h<br />
                  &nbsp;&nbsp;DirWalker.cpp<br />
                  &nbsp;&nbsp;DirWalker.h<br />
                  C:\github\JimFawcett\CppStory\Display<br />
                  &nbsp;&nbsp;Display.h<br />
                  C:\github\JimFawcett\CppStory\Webber\ToHTML<br />
                  &nbsp;&nbsp;IPerson - Copy.h<br />
                  &nbsp;&nbsp;IPerson.h<br />
                  &nbsp;&nbsp;IPerson1.h.html<br />
                  &nbsp;&nbsp;IPerson2.h.html<br />
                  &nbsp;&nbsp;IPerson3.h.html<br />
                  &nbsp;&nbsp;IPerson4.h.html<br />
                  &nbsp;&nbsp;IPerson5.h.html<br />
                  &nbsp;&nbsp;IPerson6.h.html<br />
                  &nbsp;&nbsp;IPerson7.h.html<br />
                  &nbsp;&nbsp;IPerson8.h.html<br />
                  &nbsp;&nbsp;IPerson9.h.html<br />
                  &nbsp;&nbsp;Person.cpp<br />
                  &nbsp;&nbsp;Person.h<br />
                  &nbsp;&nbsp;ToHTML.cpp<br /><br />

                  number of files: 56<br />
                  number of paths: 23<br />
                </td>
              </tr>
            </table>
          </div>
          <div style="height:0.5em;"></div>
          <t-b class="mtz">
            Directory navigator <c-s>DirWalk&lt;App&gt;</c-s> was built using the C++17 std::filesystem.  It
            gets access to a <c-s>FileInfoContainer</c-s> from an <c-s>App</c-s> template parameter that supplies it methods
            <c-s>doDir(...)</c-s> and <c-s>doFile(...)</c-s>.  Those methods simply add files with their paths into a FileInfoContainer
            member of the <c-s>App</c-s> class.
            <div style="height:0.5em;"></div>
            This example should give us an idea of how useful the STL types are.  We will dig into the
            details in Chapter 6.
          </t-b>
          <h3 id="epilogue">3.9  Data Epilogue</h3>
          <t-b>
            There are two parts to the data story, types and values.  We&apos;ve explored in some detail the C++ type
            system and mechanisms to declare and initialize instances of those types.
          </t-b>
          <t-b>
            As with many programming languages, C++ employs a fairly strict type system. Violating the type rules
            almost always results in compile failure.  We will see later that templates manage types in a more nuanced way.
          </t-b>
          <t-b>
            Our interpretation of data, in this story, entails much more than the fundamental types provided by the language.
            We also include, in our definition of data, instances of standard library types and user-defined types.
          </t-b>
          <t-b>
            This concludes Chapter 2.  In Chapter 3 we will look at C++ operations: functions, methods,
            functors, lambdas, ...
          </t-b>
          <h3 id="exercises">3.10  Data - Programming Exercises</h3>
          <indent-blocks>
            <div style="width:80%">
              <ol>
                <li>
                  Write code that declares two floating point numbers and initializes one to a known value.
                  Write a function that, using pointers, copies each byte of the intialized number into
                  the other.  Verify that after the copy both numbers hold the same value. Write another
                  function that compares the two numbers, byte by byte, using pointers.
                  <hr />
                  You will want to ensure that no buffer overruns occur, by using the sizeof operator.
                </li>
                <li>
                  Write a function that accepts a string and returns a count of the number of words in the
                  string. For this exercise assume that words always begin and end adjacent to whitespace characters
                  excluding the beginning and end of the string.
                </li>
                <li>
                  Expand on the last exercise by building a key-value pair collection where the keys are
                  discovered words and the value is the number of times it occurs in the input string.
                  You may wish to look at <c-s>std::map&lt;std::string, size_t&gt;</c-s>. Note that the first time
                  you encounter a word your map will contain <c-s>{&nbsp;word,&nbsp;1&nbsp;}</c-s>. If you encounter
                  that word again you don&apos;t try to add as a new key.  Instead you increment the value, e.g.,
                  <c-s>{&nbsp;word,&nbsp;2&nbsp;}</c-s>.
                </li>
                <li>
                  Extend this exercise one more time by creating a black-list of words not entered, e.g., articals
                  and conjuctions: the, and, or, when, ...  Look up each discovered word and enter into the map only
                  if it is not on the black-list.  That means you will look up every word, so you want to use a
                  data structure that does look-ups efficiently.
                </li>
              </ol>
            </div>
          </indent-blocks>

          <h3 id="refs">3.11  References</h3>
          <t-b class="indent">
            <a href="http://www.cplusplus.com/doc/tutorial/variables/">Variables and Types - cplusplus.com</a><br />
            <a href="https://docs.microsoft.com/en-us/cpp/cpp/fundamental-types-cpp?view=vs-2019">Built-in types (C++) - MSDN</a><br />
            <a href="https://www.austincc.edu/akochis/cosc1320/dataTypes">Types - austincc.edu/akochis</a>
          </t-b>
        </div>
        <div style="height:5em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <sec-elem style="width:0.0em">&nbsp;</sec-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#exercises">exercises</a></menu-elem>
        <menu-elem class="secElem"><a href="#epilogue">epilogue</a></menu-elem>
        <menu-elem class="secElem"><a href="#datastr">datastr</a></menu-elem>
        <menu-elem class="secElem"><a href="#smartptrs">smartptrs</a></menu-elem>
        <menu-elem class="secElem"><a href="#init">init</a></menu-elem>
        <menu-elem class="secElem"><a href="#newtypes">newtypes</a></menu-elem>
        <menu-elem class="secElem"><a href="#casts">casts</a></menu-elem>
        <menu-elem class="secElem"><a href="#typestr">typestr</a></menu-elem>
        <menu-elem class="secElem"><a href="#explore">explore</a></menu-elem>
        <menu-elem class="secElem"><a href="#types">types</a></menu-elem>
        <menu-elem class="secElem"><a href="#data">prologue</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
        <div style='margin:0em -1em; padding:0.25em 2em 0.5em 2em; text-align:center' class='darkItem'>Sections</div>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
</body>
</html>