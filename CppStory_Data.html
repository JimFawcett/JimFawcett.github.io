<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_Data.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Story-Data</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    #github .pad10-15 {
      padding: 10px 15px;
    }

    #github .codeStyle {
      overflow:hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github .labelStyle {
      font-family: sans-serif;
      /*font-weight:bold;*/
      font-size: 1.0em;
    }

    #github .normal {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github summary {
      padding: 3px 0px 5px 0px;
      font-weight:bold;
      width: max-content;
    }

      #github summary ~ div {
        width: max-content;
        max-width: 95%;
      }

      #github summary ~ indent-block {
        width: max-content;
        max-width: 95%;
        padding-left: 20px;
        padding-right: 20px;
        /*background-color: #eee;*/
      }

      #github photosizer-block {
        position: relative;
        z-index:2;
        background-color:white;
      }

      #github comment-block {
        width:max-content;
        max-width: 95%;
        padding:10px 15px;
        background-color:#eee;
        font-weight: normal;
        font-size: 1.0em;
        font-family: Tahoma;
      }
      #github c-s {
        overflow:hidden;
        font-family: Consolas, monospace;
        font-weight: bold;
        font-size: 1.0em;
      }
      #github t-s {
        font-weight: normal;
        font-size: 1.0em;
        font-family: Tahoma;
      }

      #github .notice {
        font-size:1.1em;
        font-weight:bolder;
        font-style:italic;
        font-family:Consolas, sans-serif;
        border:none;
        color:darkred;
      }
      #github background-block {
        display:block;
        background-color:#ddd;
        max-width:90%;
        width:max-content;
        padding:10px 15px;
      }
      #github .footnote {
        font-size:0.85em;
      }
      #github ol.footnote li {
        padding-bottom:0px;
      }
      #github defn-block {
        display:flex;
        flex-direction:column;
        width:max-content;
        max-width:95%;
        /*border:1px solid darkred;*/
      }
      #github defn-head {
        padding:3px 15px;
        border:1px solid darkred;
        border-bottom:none;
      }
      #github defn-body {
        padding:3px 15px;
        border:1px solid darkred;
      }
      #github defn-body ul {
        margin-top:3px;
        padding: 0px 15px;
      }
      #github defn-body ul > li {
        padding-bottom: 3px;
      }
      #github defn-example {
        font-family:Consolas, monospace;
        padding:3px 15px;
        border:1px solid darkred;
        border-top:none;
      }
      #github pre-b {
        display:block;
        white-space:pre;
        font-size:0.9em;
      }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Operations.html">N</a>
  <a id="Prev" href="CppStory_Survey.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #2 - C++ Data</h1>
      <h3 id="subtitle">sizes, initialization, standard types</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <indent-blocks>
    <h3>Data:</h3>
    This chapter focuses on data, e.g., types, type qualifiers, type conversions, data values, initialization, value conversions, and memory layout.

    <h3>Types:</h3>
    C++ is a statically typed language.  All data is defined with a type and name, using a declaration statement,
    and the language enforces a definition first rule: variable use must occur after its definition, in compiler scan order.

    <defn-block class="indent pad10">
      <defn-head>
        Type
      </defn-head>
      <defn-body>
        <ul>
          <li>A set of allowed values</li>
          <li>Operations that may be applied to these values</li>
        </ul>
      </defn-body>
    </defn-block>
    A collection of fundamental types are built into the C++ language.
    <defn-block class="indent pad10">
      <defn-head>
        Fundamental Data Types
      </defn-head>
      <defn-body>
        <ul>
          <li>
            integral: byte, bool, int, char, char16_t, char32_t, wchar_t
          </li>
          <li>
            floating point: float, double
          </li>
          <li>
            derived types: array, pointer, reference
          </li>
        </ul>
      </defn-body>
    </defn-block>
    These are augmented with an open-ended collection of library and user defined types:
    <defn-block class="pad10 indent">
      <defn-head>
        User defined types
      </defn-head>
      <defn-body>
        <ul>
          <li><c-s>struct S { ... }</c-s></li>
          <li><c-s>class C { ... }</c-s></li>
          <li><c-s>enum class { ... }</c-s></li>
          <li>alias: <c-s>using [NewName] = [TypeName]</c-s></li>
        </ul>
      </defn-body>
    </defn-block>
    <h3>Type Qualifiers:</h3>
    The C++ language defines qualifiers that modify how an instance of a type may be used: const, constexpr, and volatile.  
    It also defines qualifiers that affect storage of data: short, long, signed, unsigned, and extern.
    <spacer-15></spacer-15>
    The const qualifier affects what operations apply and what methods may be applied to a data item.
    The qualifier volatile affects what compiler optimizers may do with a data storage.  Note that,
    unlike Java and C#, volatile qualification does not affect flushing of the cache for reads and writes.
    <indent-block class="pad10">
      <details>
        <summary><span>const and volatile qualifiers</span></summary>
    <defn-block class="pad10 indent">
      <defn-head>
        Qualifiers affecting allowable operations
      </defn-head>
      <defn-body>
        <div class="pad10"><span class="notice">const</span> qualifier</div>
        <ul>
          <li>
            const prepended on a type declaration
            <indent-block>
              <c-s>const int ci;</c-s>
            </indent-block>
            makes <c-s>ci</c-s> immutable
          </li>
          <li>
            function and method parameters
            <indent-block>
              <c-s>void f(const std:string&amp; s)</c-s>
            </indent-block>
            prevent&apos;s the user variable s from being changed in f
          </li>
          <li>
            const postpended to a method declaration and definition
            <indent-block>
              <c-s>void X::f(int i) const { ... }</c-s>
            </indent-block>
            prevents changes to an instance, <c-s>x &epsilon; X</c-s>, when invoked as x.f(i);
          </li>
          <li>
            const applied to pointers
            <indent-block>
              <c-s>const X* pX = &amp;x</c-s>
            </indent-block>
            prevents x from being changed via pX, e.g., *pX = x2; will fail to compile
            <indent-block>
              <c-s>X* const pX = &amp;x</c-s>
            </indent-block>
            prevents pX being assigned a new address
          </li>
        </ul>
        <div class="pad10"><span class="notice">volatile</span> qualifier</div>
        <ul>
          <li>
            volatile prepended on a type definition
            <indent-block>
              volatile int i;
            </indent-block>
            instructs compiler that variable i may be changed by an event external to the program
            and so should not be optimized to a compile-time constant.
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  void f(const std::string&amp; s) {
    if(s.size() > 0) {
      char first = s[0];  // ok
      // s[0] = 'z'; -- fails to compile since s is const
    }
  }
        </pre-b>
      </defn-example>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  X x{3};
  const X* pX = &amp;x;
  X x1 = *pX;   // ok
  *pX = 2;      // fails to compile
        </pre-b>
      </defn-example>
    </defn-block>
      </details>
    </indent-block>
    Qualifiers short and long affect the amount of storage allocated and hence the range of
    values a qualified data item may hold.
    <spacer-10></spacer-10>
    <indent-block>
      <details>
        <summary><span>short and long Qualifiers</span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            Qualifiers compressing or expanding range of values
          </defn-head>
          <defn-body>
            <div class="pad10"><span class="notice">short and long</span> qualifiers may affect storage sizes</div>
            <ul>
              <li>
                short prepended on a type definition for int
                <indent-block>
                  <c-s>short int i;</c-s>
                </indent-block>
                guarantees that <c-s>sizeof(short int) <= sizeof(int);</c-s>
              </li>
              <li>
                long prepended on a type definition for int or double
                <indent-block>
                  <c-s>long double d;</c-s>
                </indent-block>
                guarantees that <c-s>sizeof(double) <= sizeof(long double) <= sizeof(long long double)</c-s>
              </li>
            </ul>
          </defn-body>
          <defn-example>
            <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
            <pre-b>
  short int iArrs[5]{ 1, 2, 3, 4, 5 };      // size of iArrs is 10 bytes
  int iArr[5]{ 1, 2, 3, 4, 5 };             // size of iArr is 20 bytes
  long int iArrl[5]{ 1, 2, 3, 4, 5 };       // size of iArrl is 20 bytes
  long long int iArrll[5]{ 1, 2, 3, 4, 5 }  // size of iArrll is 40 bytes
            </pre-b>
          </defn-example>
        </defn-block>
      </details>
    </indent-block>
    <spacer-5></spacer-5>
    Qualifiers signed and unsigned affect the placement of ranges of values an int may hold.
    <spacer-10></spacer-10>
    <indent-block>
      <details>
        <summary><span>signed and unsigned Qualifiers</span></summary>
    <defn-block class="pad10 indent">
      <defn-head>
        Qualifiers affecting limit values
      </defn-head>
      <defn-body>
        <div class="pad10"><span class="notice">signed and unsigned</span> qualifiers</div>
        <ul>
          <li>
            signed and unsigned may be prepended on a type definition for int or char
            <indent-block>
              signed int i;
            </indent-block>
            acceptable values of i occupy a range symetric around the value 0
            <indent-block>
              unsigned int j;
            </indent-block>
            acceptible values of j lie in a range bounded at the bottom with 0
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  signed int i = -25;         // range is -2,147,483,648 to 2,147,483,647
  unsigned int j = 15;        // range is 0 to 4,294,967,295 
  unsigned int k = UINT_MAX;  // UINT_MAX is defined in &lt;limits&gt;
  k + 1 == 0;                 // value roll-over, statement is true, no compiler warning
        </pre-b>
      </defn-example>
    </defn-block>
      </details>
    </indent-block>
    <spacer-10></spacer-10>
    The extern qualifier disables allocation of storage.  Qualifer constexpr makes initialized
    value known at compile-time.
    <spacer-10></spacer-10>
    <indent-block>
      <details>
        <summary><span>extern and constexpr Qualifiers</span></summary>
    <defn-block class="pad10 indent">
      <defn-head>
        Other qualifiers
      </defn-head>
      <defn-body>
        <div class="pad10"><span class="notice">extern</span> qualifier</div>
        <ul>
          <li>
            extern prepended on a type definition
            <indent-block>
              extern int i;
            </indent-block>
            provides a declaration, but instructs the compiler that another compilation unit (.cpp file) provides storage
            so it should not be provided in this compilation unit.
          </li>
        </ul>
        <div class="pad10"><span class="notice">constexpr</span> qualifier</div>
        <ul>
          <li>
            constexpr prepended on a const integral type definition initialized with constant variable
            <indent-block>
              <c-s>constexpr int N = 10;</c-s>
            </indent-block>
            allows N to be used for compile time constructs like native arrays and templates.
            <spacer-10></spacer-10>
            we will discuss use of constexpr with an if selection when we discuss template meta programming.
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  constexpr unsigned int N = 10;
  double dArr[N] { 0.5, 1.0, 1.5 };  // compiles because N and initializers are known at compile-time
        </pre-b>
      </defn-example>
    </defn-block>
      </details>
    </indent-block>
    <spacer-10></spacer-10>
    auto and decltype don&apos;t qualify declarations, they are declarations.
    <spacer-10></spacer-10>
    <indent-block>
      <details>
        <summary><span>auto and decltype specifiers</span></summary>
    <defn-block class="pad10 indent">
      <defn-head>Computed declarations</defn-head>
      <defn-body>
        <div class="pad10"><span class="notice">auto</span> specifier</div>
        <ul>
          <li>
            auto as a type definition
            <indent-block>
              <c-s>auto r{ 3 }; auto s{ 1.5 }</c-s>
            </indent-block>
            instructs compiler to use type deduction to suppy the type, so <c-s>r</c-s> is type int and <c-s>s</c-s> is type double.
          </li>
          <li>
            auto is frequently used to deduce the type of a function return value or as the type of a variable enumerated in
            a range-based for:
            <indent-block>
              <c-s>auto r = f();</c-s><br />
              <c-s>for(auto item : container) { ... }</c-s>
            </indent-block>
            auto type deduction is similar to the type deduction process used for templates.
          </li>
        </ul>
        <div class="pad10"><span class="notice">decltype</span> specifier</div>
        <ul>
          <li>
            decltype as a type definition
            <indent-block>
              <c-s>
                decltype(make_lambda()) x;
              </c-s>
            </indent-block>
            x is a lambda of the same type as created by the function make_lambda
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  std::vector&lt;int&gt; vecInt { 1, 2, 3 };
  for(auto& item : vecInt) {
    item *= 2;
  }
        </pre-b>
      </defn-example>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  decltype(vecInt) vecInt2;  // results in std::vector&lt;int&gt; instance, named vecInt2, with default initialization
        </pre-b>
      </defn-example>
    </defn-block>
      </details>
    </indent-block>
    <h3>Sizes and Layout</h3>
    <h3>Initialization</h3>
    <h3>New Types</h3>
    <h3>Building Data Structures with STL</h3>
    <h3>Serialization</h3>
    <h3>Persistance</h3>
  </indent-blocks>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>