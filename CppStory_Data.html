<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_Data.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Story-Data</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
  <style>
    #github .pad10-15 {
      padding: 10px 15px;
    }

    #github .codeStyle {
      overflow:hidden;
      font-family: Consolas, monospace;
      font-weight: bold;
      font-size: 1.0em;
    }

    #github .labelStyle {
      font-family: sans-serif;
      /*font-weight:bold;*/
      font-size: 1.0em;
    }

    #github .normal {
      font-weight: normal;
      font-size: 1.0em;
      font-family: Tahoma;
    }

    #github summary {
      padding: 3px 0px 5px 0px;
      font-weight:bold;
      width: max-content;
    }

      #github summary ~ div {
        width: max-content;
        max-width: 95%;
      }

      #github summary ~ indent-block {
        width: max-content;
        max-width: 95%;
        padding-left: 20px;
        padding-right: 20px;
        /*background-color: #eee;*/
      }

      #github photosizer-block {
        position: relative;
        z-index:2;
        background-color:white;
      }

      #github comment-block {
        width:max-content;
        max-width: 95%;
        padding:10px 15px;
        background-color:#eee;
        font-weight: normal;
        font-size: 1.0em;
        font-family: Tahoma;
      }
      #github c-s {
        overflow:hidden;
        font-family: Consolas, monospace;
        font-weight: bold;
        font-size: 1.0em;
      }
      #github t-s {
        font-weight: normal;
        font-size: 1.0em;
        font-family: Tahoma;
      }

      #github .notice {
        font-size:1.1em;
        font-weight:bolder;
        font-style:italic;
        font-family:Consolas, sans-serif;
        border:none;
        color:darkred;
      }
      #github .background-block {
        display:block;
        background-color:#ddd;
        max-width:90%;
        width:max-content;
        padding:10px 15px;
        overflow-x:auto;
      }
      #github background-block {
        display:block;
        background-color:#ddd;
        max-width:90%;
        width:max-content;
        padding:10px 15px;
        overflow-x:auto;
      }
      #github .footnote {
        font-size:0.85em;
      }
      #github ol.footnote li {
        padding-bottom:0px;
      }
      #github defn-block {
        display:flex;
        flex-direction:column;
        width:max-content;
        max-width:95%;
        /*border:1px solid darkred;*/
      }
      #github defn-head {
        padding:3px 15px;
        border:1px solid darkred;
        border-bottom:none;
      }
      #github defn-body {
        padding:3px 15px;
        border:1px solid darkred;
      }
      #github defn-body ul {
        margin-top:3px;
        padding: 0px 15px;
      }
      #github defn-body ul > li {
        padding-bottom: 3px;
      }
      #github defn-example {
        font-family:Consolas, monospace;
        padding:3px 15px;
        border:1px solid darkred;
        border-top:none;
      }
      #github pre-b {
        display:block;
        white-space:pre;
        font-size:0.9em;
      }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Operations.html">N</a>
  <a id="Prev" href="CppStory_Survey.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #2 - C++ Data Types and Data</h1>
      <h3 id="subtitle">sizes, initialization, standard types</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <indent-blocks>
    <h3>Data:</h3>
    This chapter focuses on data, e.g., types, type qualifiers, type conversions, data values, initialization, value conversions, and memory layout.
    <spacer-15></spacer-15>
    Most of the code examples used in this Chapter have complete working demonstrations in
    <a href="CppStoryRepo.html">CppStoryRepo</a>.
    You may wish to download and run the code while you are studying this Chapter.
    <hr class="spreadup" />
    <h3>Types:</h3>
    C++ is a statically typed language.  All data is defined with a type and name, using a declaration statement,
    and the language enforces a definition first rule: variable use must occur after its definition, in compiler scan order.

    <defn-block class="indent pad10">
      <defn-head>
        Type
      </defn-head>
      <defn-body>
        <ul>
          <li>A set of allowed values</li>
          <li>Operations that may be applied to these values</li>
        </ul>
      </defn-body>
    </defn-block>
    A collection of fundamental types are built into the C++ language.
    <defn-block class="indent pad10">
      <defn-head>
        Fundamental Data Types
      </defn-head>
      <defn-body>
        <ul>
          <li>
            integral: byte, bool, int, char, char16_t, char32_t, wchar_t
          </li>
          <li>
            floating point: float, double
          </li>
          <li>
            derived types: array, pointer, reference
          </li>
        </ul>
      </defn-body>
    </defn-block>
    These are augmented with an open-ended collection of library and user defined types:
    <defn-block class="pad10 indent">
      <defn-head>
        User defined types
      </defn-head>
      <defn-body>
        <ul>
          <li><c-s>struct S { ... }</c-s></li>
          <li><c-s>class C { ... }</c-s></li>
          <li><c-s>enum class E { ... }</c-s></li>
          <li>alias: <c-s>using [NewName] = [TypeName]</c-s></li>
        </ul>
      </defn-body>
    </defn-block>
    <h3>Type Qualifiers:</h3>
    The C++ language defines qualifiers that modify how an instance of a type may be used: const, constexpr, and volatile.  
    It also defines qualifiers that affect storage of data: short, long, signed, unsigned, and extern.
    <spacer-10></spacer-10>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">const qualifier - <c-s>const int i;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">const</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              The const qualifier affects what operations apply and what methods may be applied 
              to a data item.
            </div>
            <ul>
              <li>
                const prepended on a type declaration
                <indent-block>
                  <c-s>const int ci;</c-s>
                </indent-block>
                makes <c-s>ci</c-s> immutable
              </li>
              <li>
                function and method parameters
                <indent-block>
                  <c-s>void f(const std:string&amp; s)</c-s>
                </indent-block>
                prevent&apos;s the user variable s from being changed in f
              </li>
              <li>
                const postpended to a method declaration and definition
                <indent-block>
                  <c-s>void X::f(int i) const { ... }</c-s>
                </indent-block>
                prevents changes to an instance, <c-s>x &epsilon; X</c-s>, when invoked as x.f(i);
              </li>
              <li>
                const applied to pointers
                <indent-block>
                  <c-s>const X* pX = &amp;x</c-s>
                </indent-block>
                prevents x from being changed via pX, e.g., *pX = x2; will fail to compile
                <indent-block>
                  <c-s>X* const pX = &amp;x</c-s>
                </indent-block>
                prevents pX being assigned a new address
              </li>
            </ul>
          </defn-body>
          <defn-example>
            <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
            <pre-b>
  void f(const std::string&amp; s) {
    if(s.size() > 0) {
      char first = s[0];  // ok
      // s[0] = 'z'; -- fails to compile since s is const
    }
  }
            </pre-b>
          </defn-example>
          <defn-example>
            <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
            <pre-b>
  X x{3};
  const X* pX = &amp;x;
  X x1 = *pX;   // ok
  *pX = 2;      // fails to compile
            </pre-b>
          </defn-example>
        </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">short and long Qualifiers - <c-s>short int;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">short and long</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              Qualifiers short and long affect amount of storage allocated and range of
              values a qualified data item may hold.
            </div>
            <ul>
              <li>
                short prepended on a type definition for int
                <indent-block>
                  <c-s>short int i;</c-s>
                </indent-block>
                guarantees that <c-s>sizeof(short int) <= sizeof(int);</c-s>
              </li>
              <li>
                long prepended on a type definition for int or double
                <indent-block>
                  <c-s>long double d;</c-s>
                </indent-block>
                guarantees that <c-s>sizeof(double) <= sizeof(long double) <= sizeof(long long double)</c-s>
              </li>
            </ul>
          </defn-body>
          <defn-example>
            <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
            <pre-b>
  short int iArrs[5]{ 1, 2, 3, 4, 5 };      // size of iArrs is 10 bytes
  int iArr[5]{ 1, 2, 3, 4, 5 };             // size of iArr is 20 bytes
  long int iArrl[5]{ 1, 2, 3, 4, 5 };       // size of iArrl is 20 bytes
  long long int iArrll[5]{ 1, 2, 3, 4, 5 }  // size of iArrll is 40 bytes
            </pre-b>
          </defn-example>
        </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">signed and unsigned Qualifiers - <c-s>unsigned int;</c-s></span></summary>
    <defn-block class="pad10 indent">
      <defn-head>
        <span class="notice">signed and unsigned</span>
      </defn-head>
      <defn-body>
        <div class="pad10">
          Qualifiers signed and unsigned affect placement of ranges of values an int may hold.
        </div>
        <ul>
          <li>
            signed (default) may be prepended on a type definition for int or char
            <indent-block>
              signed int i;
            </indent-block>
            acceptable values of i occupy a range symetric around the value 0
          </li>
          <li>
            unsigned may be prepended on a type definition for int or char
            <indent-block>
              unsigned int j;
            </indent-block>
            acceptible values of j lie in a range bounded at the bottom with 0
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  signed int i = -25;         // range is -2,147,483,648 to 2,147,483,647
  unsigned int j = 15;        // range is 0 to 4,294,967,295 
  unsigned int k = UINT_MAX;  // UINT_MAX is defined in &lt;limits&gt;
  k + 1 == 0;                 // value roll-over, statement is true, no compiler warning
        </pre-b>
      </defn-example>
    </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">static Qualifier - <c-s>static int;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">static</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              The static qualifier allocations storage in static memory.
            </div>
            <ul>
              <li>
                static prepended on a local type definition (in a function)
                <indent-block>
                  static int i = 3;
                </indent-block>
                instructs the compiler to place storage for this named entity in static memory
                initialized to the value 3.
                <spacer-10></spacer-10>
                That means that it will be initialized exactly once, no later than the first time
                the function is entered.  It will not be re-initialized again on subsequent entries
                so its value persists across function calls, only changing when the function&apos;s
                code assigns to it.
              </li>
              <li>
                static prepended on a member variable of a class or struct places that variable
                in static memory, so every instance of the class or struct shares the same value.
              </li>
            </ul>
          </defn-body>
        </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">extern Qualifier - <c-s>extern int;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">extern</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              The extern qualifier disables allocation of storage.
            </div>
            <ul>
              <li>
                extern prepended on a type definition at namespace or global scope
                <indent-block>
                  extern int i;
                </indent-block>
                provides a declaration, but instructs the compiler that another compilation unit (.cpp file) provides storage
                so it should not be provided in this compilation unit.
              </li>
            </ul>
          </defn-body>
        </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">inline Qualifier - <c-s>inline const int = 3;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">inline</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              The inline qualifier for global variables was introduced with C++17.
            </div>
            <ul>
              <li>
                inline prepended on a type definition in a header file
                <indent-block>
                  inline const double pi = 3.14159;
                </indent-block>
              instructs the linker to provide storage only once, even if the header file is included
              in multiple cpp files used to build one image.
              <spacer-10></spacer-10>
              This eliminates one source of multiple definition linker errors.
              </li>
            </ul>
          </defn-body>
        </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">volatile qualifier - <c-s>volatile int i;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">volatile</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              The qualifier volatile affects what compiler optimizers may do with a data storage.  Note that,
              unlike Java and C#, volatile qualification does not affect flushing of the cache for reads and writes.
            </div>
            <ul>
              <li>
                volatile prepended on a type definition
                <indent-block>
                  volatile int i;
                </indent-block>
                instructs compiler that variable i may be changed by an event external to the program
                and so should not be optimized to a compile-time constant.
              </li>
            </ul>
          </defn-body>
        </defn-block>
        <spacer-15></spacer-15>
      </details>
    </indent-block>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">constexpr qualifier - <c-s>constexpr int N = 10;</c-s></span></summary>
        <defn-block class="pad10 indent">
          <defn-head>
            <span class="notice">constexpr</span>
          </defn-head>
          <defn-body>
            <div class="pad10">
              Qualifer constexpr makes initialized value known at compile-time. 
            </div>
            <ul>
              <li>
                constexpr prepended on a const integral type definition initialized with constant instance
                <indent-block>
                  <c-s>constexpr int N = 10;</c-s>
                </indent-block>
                allows N to be used for compile time constructs like native arrays and templates.
                <spacer-10></spacer-10>
                we will discuss use of constexpr with an if selection when we discuss template meta programming.
              </li>
            </ul>
          </defn-body>
          <defn-example>
            <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
            <pre-b>
      constexpr unsigned int N = 10;
      double dArr[N] { 0.5, 1.0, 1.5 };  // compiles because N and initializers are known at compile-time
            </pre-b>
          </defn-example>
        </defn-block>
        <spacer-15></spacer-15>
      </details>
    </indent-block>
    <h3>Type Specifiers:</h3>
    <div>
      Since C++11, the language has provided special declarations, <c-s>auto</c-s> and <c-s>decltype</c-s>
      that use type deduction to establish the type of an expression.  One important use is to provide a declaration for
      a lambda.  Lambda types are constructed by the compiler and the names of those types are
      not public.  Auto is a type placeholder for that construction.
      The decltype specifier evaluates the type of an expression which then may be used to declare
      a variable of that type.
    </div>
    <spacer-15></spacer-15>
    <indent-block>
      <details>
        <summary><span class="labelStyle lightItem">auto and decltype specifiers - <c-s>auto d{ 1.5 };</c-s></span></summary>
    <defn-block class="pad10 indent">
      <defn-head><span class="notice">auto</span></defn-head>
      <defn-body>
        <div class="pad10">
          auto is not a declaration qualifer, it is a declaration.
        </div>
        <ul>
          <li>
            auto as a type definition
            <indent-block>
              <c-s>auto r{ 3 }; auto s{ 1.5 }</c-s>
            </indent-block>
            instructs compiler to use type deduction to suppy the type, so <c-s>r</c-s> is type int and <c-s>s</c-s> is type double.
          </li>
          <li>
            auto is frequently used to deduce the type of a function return value or as the type of a variable enumerated in
            a range-based for:
            <indent-block>
              <c-s>auto r = f();</c-s><br />
              <c-s>for(auto item : container) { ... }</c-s>
            </indent-block>
            auto type deduction is similar to the type deduction process used for templates.
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  std::vector&lt;int&gt; vecInt { 1, 2, 3 };
  for(auto& item : vecInt) {
    item *= 2;
  }
        </pre-b>
      </defn-example>
      <defn-head>
        <span class="notice">decltype</span>
      </defn-head>
      <defn-body>
        <div class="pad10">
          Like auto, decltype is a declaration.
        </div>
        <ul>
          <li>
            decltype as a type definition
            <indent-block>
              <c-s>
                decltype(make_lambda()) x;
              </c-s>
            </indent-block>
            x is a lambda of the same type as created by the function make_lambda
          </li>
        </ul>
      </defn-body>
      <defn-example>
        <div style="padding-top:10px;"><span class="notice">Code example:</span></div>
        <pre-b>
  decltype(vecInt) vecInt2;
  // results in std::vector&lt;int&gt; instance, named vecInt2, with default initialization
        </pre-b>
      </defn-example>
    </defn-block>
        <spacer-10></spacer-10>
      </details>
    </indent-block>
    <h3>Exploring Types:</h3>
    Occasionally it is important to know the sizes of variables in our designs.  For example, if
    we need to serialize an object into a byte array to pass over a socket, we need to know the
    size of the object. Also, knowing the sizes of types may help us understand how they work.
    That&apos;s illustrated in the lambda example, below.
    <spacer-15></spacer-15>
    The operator <c-s>sizeof</c-s> can be applied to a type or an expression: 
    <indent-block class="pad10">
      <c-s>size_t sz = sizeof(arg);</c-s>
    </indent-block>
    It returns the size of the arg parameter in bytes for all types
    except references.  For references sizeof(X&) returns the size of the referenced type, not the
    size of the reference. The size of a reference equals the size of a pointer, which, on my work
    machine, is 4 bytes, e.g., 32 bits.
    You can verify this by constructing a class Xref with a single reference member and evaluating
    sizeof(Xref).
    <spacer-15></spacer-15>
    The operator <c-s>typeid</c-s> can be applied to a type or an expression as:
    <indent-block class="pad10">
    <c-s>std::type_info ti = typeid(CT)</c-s>
    </indent-block>
    where CT is any complete type. In order to use <c-s>typeid</c-s> you need to include
    <c-s>&lt;typeinfo&gt;</c-s>.  There is much less information in <c-s>type_info</c-s> 
    instances like <c-s>ti</c-s> than you would get from 
    reflection results with languages like C# and Java. 
    <spacer-15></spacer-15>
    However, <c-s>type_info</c-s> has  
    useful methods: <c-s>operator==(const type_info&)</c-s> and 
    <c-s>operator!=(const type_info&)</c-s> to query whether two instances belong to the same type, 
    and <c-s>name()</c-s>, so we can discover the full type name of some instance.
    <spacer-15></spacer-15>
    <indent-block class="pad10">
      <details>
        <summary>
          <span class="labelStyle darkItem">
            Example: Using <c-s>sizeof</c-s> and <c-s>typeid</c-s> to explain how lambdas work
          </span>
        </summary>
        <indent-block class="pad10">
    Here is a template function, useful for exploring types, that uses both <c-s>sizeof</c-s>
    and <c-s>typeid</c-s>:
    <defn-block>
    <pre class="defnBorder pad10-15">
  <c-s>template&lt;typename T&gt;
  void displayType(const T&amp; t, const std::string&amp; msg = "", bool showSize = true)
  {
    std::cout &lt;&lt; "\n  ";
    if (showSize)
      std::cout &lt;&lt; sizeof(t) &lt;&lt; " = size of ";
    std::string typeName = typeid(t).name();
    if (typeName.size() &gt; 75)
      typeName = typeName.substr(0, 75) + "...";
    std::cout &lt;&lt; typeName;
    if (msg.size() &gt; 0)
      std::cout &lt;&lt; msg;
  }</c-s>
</pre>
    </defn-block>
    It provides one way to begin understanding how lambdas work:
    <defn-block>
    <pre class="defnBorder pad10-15">
  <c-s>int i{ 42 };
  auto f = [i](const std::string& s) {  
    std::cout << s << i;
  };
  f("\n  The meaning of life is ");
  displayType(f);</c-s>
</pre>
    </defn-block>
    Here, f is a lambda, declared with auto because we don&apos;t know the lambda type.
    the <c-s>[i]</c-s> part of the expression says that this lambda captures the value of i, e.g., 42.
    The <c-s>(const std::string&amp; s)</c-s> defines a string parameter, passed to the lambda code
    by const reference. The body <c-s>{ ... }</c-s> simply displays the parameter and the
    captured integer value.
    <spacer-15></spacer-15>
    The output of this code is:
    <defn-block>
    <pre class="defnBorder pad10-15">
  <c-s>The meaning of life is 42
  4 = size of class &lt;lambda_1bed100c18f4584a5d93f1a5d7e27280&gt;</c-s>
</pre>
    </defn-block>
    So, the displayType function has informed us that the lambda is a class, it disclosed the
    lambda&apos;s type name, obviously not intended for human consumption, and showed us that its
    size is just the size of the captured int value.
    <spacer-15></spacer-15>
    It&apos;s highly likely that the compiler created a functor, something like this:
    <spacer-10></spacer-10>
    <defn-block>
    <div class="defnBorder pad10-15">
    <pre>
  <c-s>class lambda_1bed1... {
  public:
    void operator() {
      std::cout << s << i;    
    }
  private:
    int i = 42;
  };</c-s>
</pre>
    </div>
    </defn-block>
    <spacer-10></spacer-10>
    So lambdas can capture data, be passed into or returned from functions, taking their data
    with them (as long as they hold a value, not a reference). We say that the lambda and its
    local scope are a closure.  A lambda can use any data in its closure as part of its
    operation. 
    <spacer-15></spacer-15>
    Essentially, a lambda has two sets of inputs: from its capture list <c-s>[i, j, x]</c-s> 
    which come from the lambda&apos;s closure, and <c-s>(T1 arg1, T2 arg2, ... )</c-s>
    which are passed in from the scope where the lambda is invoked. The lambda&apos;s designer
    provides the capture inputs and the lambda user provides the arguments.
        </indent-block>
      </details>
    </indent-block>
    <spacer-10></spacer-10>
    In the next section, we continue exploring types by looking at their layout in memory.

    <h3>Type Structure:</h3>
    <hr />
    <spacer-10></spacer-10>
    <hidephotosizer-block src="Pictures/StringLayout.JPG" width="400" class="photoSizerBlock right" style="margin-top:0;">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 1. String Layout
      </span>
    </hidephotosizer-block>
    There are also issues of type structure we need to think about.  The fundamental types place
    all their value information in one place, in the stack frame where they are declared.
    However, not all types are structured that way. A std::string, for example, stores its
    control state, iterator, character count, etc., in the stack frame where it is declared, 
    but all its user state, e.g., its character sequence, is stored in the heap.
    <spacer-15></spacer-15>
    The <c-s>sizeof</c-s> operator measures only the stack allocation.  So, for example, it will
    return the same size for an empty string and a string with 100 characters.  For all of the
    STL sequential containers with contiguous memory, e.g., <c-s>string</c-s>, <c-s>vector</c-s>,
    and <c-s>deque</c-s>, you can call their <c-s>capacity()</c-s> method to measure that allocation.
    Here&apos;s an example:
    <defn-block>
      <defn-code class="noBorder">
 std::string str("content of a std::string");
 std::cout &lt;&lt; "\n  " &lt;&lt; str;
 std::cout &lt;&lt; "\n  string size = " &lt;&lt; (str.size() + 1) * sizeof(char);
 std::cout &lt;&lt; "\n  allocation size = " &lt;&lt; str.capacity() * sizeof(char);
      </defn-code>
    </defn-block>
    When this code executes you get:
    <defn-block>
      <defn-code class="noBorder">
 content of a string::string
 string size = 25
 allocation size = 31
      </defn-code>
    </defn-block>
    <spacer-10></spacer-10>
    For all the other containers measuring heap allocation is much more effort, but the ideas
    will be about the same.  You would have to iterate through the container, measuring each of
    the elements, accessed by the container&apos;s iterator.
    <hr class="spread" />
    Even the fundamental types differ in structure:
    <ul>
      <li>
        All of the fundamental types except floats have a simple structure consisting of
        a sequence of bytes in one location.
      </li>
      <li>
        The float type partitions its storage into:
        <ul class="tight">
          <li>1 bit sign</li>
          <li>8 bit exponent</li>
          <li>23 bit fraction</li>
        </ul>
      </li>
      <li>
        The double type has the partitions:
        <ul class="tight">
          <li>1 bit sign</li>
          <li>11 bit exponent</li>
          <li>52 bit fraction</li>
        </ul>
      </li>
    </ul>
    This float/double structure has consequences:
    <ul>
      <li>
        The majority of values don&apos;t have an exact representation.  All of the intergers
        have exact floating representations, but numbers like 1.0/3.0 have an infinite number
        of trailing digits, e.g., 0.33333333333333...., and will be stored imprecisely.
      </li>
      <li>
        So these values have granularity with differences within granules that can&apos;t be
        represented.
      </li>
      <li>
        The size of the granularity depends on the magnitude of the float.  The fractional value
        of one float may be the same as the fractional value of another, but if the exponent of 
        one is larger than the other, the absolute values of granularity will differ. 
      </li>
      <li>
        It is entirely possible for two floats that are conceptually distinct to have the same
        floating representation, so you need to be careful with equality comparisons.
      </li>
      <li>
        Repeating operations on a float in a loop may exhibit increasing error in computed
        results due to the accumulation of granularity errors.
      </li>
    </ul>
    Here&apos;s data from an experiment with floats:
    <spacer-10></spacer-10>
    <div class="defnBorder lightItem indent" style="display:flex;">
    <pre><c-s>  --- demo float granularity ---  

  float f =             1.00000
  f = (f + 1.0)/3.0 ==> 0.666667
  f = (f + 1.0)/3.0 ==> 0.555556
  f = (f + 1.0)/3.0 ==> 0.518519
  f = (f + 1.0)/3.0 ==> 0.506173
  f = (f + 1.0)/3.0 ==> 0.502058
  f = (f + 1.0)/3.0 ==> 0.500686
  f = (f + 1.0)/3.0 ==> 0.500229
  f = (f + 1.0)/3.0 ==> 0.500076
  f = (f + 1.0)/3.0 ==> 0.500025
  f = (f + 1.0)/3.0 ==> 0.500008

  Reversing process:

  f = 3.0 * f - 1.0 ==> 0.500025
  f = 3.0 * f - 1.0 ==> 0.500076
  f = 3.0 * f - 1.0 ==> 0.500229
  f = 3.0 * f - 1.0 ==> 0.500686
  f = 3.0 * f - 1.0 ==> 0.502057
  f = 3.0 * f - 1.0 ==> 0.506170
  f = 3.0 * f - 1.0 ==> 0.518510
  f = 3.0 * f - 1.0 ==> 0.555531
  f = 3.0 * f - 1.0 ==> 0.666594
  f = 3.0 * f - 1.0 ==> 0.999782
      </c-s>
</pre>
      <div class="indent">
        <spacer-25></spacer-25>
        There are many domains where float granularity matters:
        <ul>
          <li>
            Scientific computing, e.g., processing models for particles, gravity,
            super-conductors, gene expression, climate dynamics, ...
          </li>
          <li>
            Processing financial models for derivative and currency trading
          </li>
          <li>
            Graphics processing using projections and ray-tracing
          </li>
          <li>
            Medical imaging
          </li>
          <li>
            Radar and Sonar signal processing
          </li>
          <li>
            Finite-element analysis for fluid flow
          </li>
          <li>
            Navigation computing for aircraft and spacecraft
          </li>
          <li>
            Autonomous vehicle control.
          </li>
          <li>
            Neural network modeling
          </li>
          <li>
            Marketing models
          </li>
          <li>
            Control of machine tools used to create manufactured products
          </li>
          <li>....</li>
        </ul>
        The point is that you may well, during the course of your career, work in domains
        where floating point granularity matters.
      </div>
      </div>
    <spacer-15></spacer-15>
    <hr class="spread" />
    <h3>Managing C++ Type System with Casts</h3>

    Cast operations are a mechanism for mapping an instance of one type into an instance of another
    type or modifying the type rules applied to a given instance.
    Since the introduction of C++11 we&apos;ve had four modern cast forms:
    <spacer-15></spacer-15>
    <indent-block class="pad10">
      <table width="100%">
        <tr>
          <th>static_cast Syntax</th>
          <th>static_cast Symantics</th>
        </tr>
        <tr>
          <td><c-s>T<sub>2</sub> t<sub>2</sub> = static_cast&lt;T<sub>2</sub>&gt;(t<sub>1</sub>);</c-s></td>
          <td>
            Convert <c-s>t<sub>1</sub> &epsilon; T<sub>1</sub></c-s> to an instance of
            <c-s>T<sub>2</sub></c-s> usually by
            constructing a new <c-s>T<sub>2</sub></c-s> instance using data from <c-s>t<sub>1</sub></c-s>.
          </td>
        </tr>
      </table>
      <spacer-15></spacer-15>
    <indent-blocks>
      <details>
        <summary><span class="labelStyle darkItem">Example: static_cast&lt;T&gt;</span></summary>
        <spacer-10></spacer-10>
        <defn-block class="defnBorder indent pad10-15">
          <pre><c-s>/*--------------------------------------------------------------------------------------
 purpose of static_cast is to create a new instance of a destination type, based on
 data stored in the source type.
--------------------------------------------------------------------------------------*/  

  int i = 1.75;  // i = 1, with compiler warning of loss of significance
  int j = static_cast&lt;int&gt;(1.75);  // j = 1, no compiler warning</c-s>
</pre>
        </defn-block>
      </details>
    </indent-blocks>
      <spacer-15></spacer-15>
      <table width="100%">
        <tr>
          <th>const_cast Syntax</th>
          <th>const_cast Symantics</th>
        </tr>
        <tr>
          <td>
            <c-s>T&amp;&nbsp;tRef&nbsp;=&nbsp;const_cast&lt;T&amp;&gt;(t);</c-s>
          </td>
          <td>
            Strip off const qualifier from a const type.  Intent is to pass const variable to platform API functions
            which can&apos;t inform compiler that they won&apos;t change variable, but designer knows they
            won&apos;t.<br />
          </td>
        </tr>
      </table>
      <spacer-15></spacer-15>
    <indent-blocks>
      <details>
        <summary><span class="labelStyle darkItem">Example: const_cast&lt;T&gt;</span></summary>
        <spacer-10></spacer-10>
        <defn-block class="defnBorder indent pad10-15">
<pre><c-s>/*--------------------------------------------------------------------------------------
 purpose of const_cast is to allow passing const data to functions that won't change
 value even though not declared as const functions, OS API calls for example.
--------------------------------------------------------------------------------------*/

void mockAPIfunction(std::string* pStr) {
  std::cout &lt;&lt; "\n  inside mock API function: " &lt;&lt; *pStr;
}

void demoConstCast(const std::string&amp; str) {

  displaySubtitle("const_cast");

  std::cout &lt;&lt; "\n  " &lt;&lt; str;
  //mockAPIfunction(&amp;str);  fails to compile since str is const

  /*--- useful operation using sRef ---*/

  std::string&amp; sRef = const_cast&lt;std::string&amp;&gt;(str);
  // created non-const reference to const str

  mockAPIfunction(&amp;sRef);  // succeeds since sRef is not const

  /*--- evil operation on sRef, violates contract of function interface ---*/
  /* don't do this */
  sRef = "changed";
  std::cout &lt;&lt; "\n  " &lt;&lt; str;  // now has changed value
  std::cout &lt;&lt; "\n";
}</c-s>
</pre>
          </defn-block>
        <defn-block class="defnBorder indent">
        <div class="pad10">
<pre><c-s>  const_cast
 ------------
  const string
  inside mock API function: const string   
  changed</c-s></pre>
        </div>
          </defn-block>
        <div class="pad10 indent">
          This illustrates that the compiler will let you change the source of the const_cast
          but you should never do that.
        </div>
      </details>
    </indent-blocks>
      <spacer-15></spacer-15>
      <table width="100%">
        <tr>
          <th>dynamic_cast Syntax</th>
          <th>dynamic_cast Symantics</th>
        </tr>
        <tr>
          <td>
            <c-s style="white-space:nowrap;">Derived* pDer = dynamic_cast&lt;Derived*&gt;(pBase)</c-s><br />
            <c-s>if(pDer != nullptr) {<br />
            &nbsp;&nbsp;pDer->Derived::memFun();<br />
            }</c-s>
          </td>
          <td>
            Intent is to call, starting with <c-s>Base</c-s> pointer, <c-s>Derived</c-s> member function, 
            not in <c-s>Base</c-s> interface.<br />
            If <c-s>Base</c-s> pointer does point to instance of the requested type, the cast returns 
            <c-s>pBase</c-s>
            address, typed as a <c-s>Derived</c-s> pointer, otherwise it returns <c-s>nullptr</c-s>.
          </td>
        </tr>
      </table>
      <spacer-15></spacer-15>
    <indent-blocks>
      <details>
        <summary><span class="labelStyle darkItem">Example: dynamic_cast&lt;T&gt;</span></summary>
        <spacer-10></spacer-10>
        <defn-block class="defnBorder pad10-15 indent">
<pre><c-s>/*--------------------------------------------------------------------------------------
 dynamic_cast grants access to derived class interfaces starting with base pointer
--------------------------------------------------------------------------------------*/

class Base {
public:
  virtual ~Base() {}
  virtual void say() {
    std::cout &lt;&lt; "\n  hello from Base::say() via " &lt;&lt; typeid(*this).name();
  }
};

class Derived1 : public Base {
public:
  virtual ~Derived1() {}
  void say1() {
    std::cout &lt;&lt; "\n  hello from Derived1::say1() via " &lt;&lt; typeid(*this).name();
  }
};

class Derived2 : public Base {
public:
  virtual ~Derived2() {}
  void say2() {
    std::cout &lt;&lt; "\n  hello from Derived2::say2() via " &lt;&lt; typeid(*this).name();
  }
};

auto putline = [](int n=1) { 
  for(int i=0; i&lt;n; ++i)
    std::cout &lt;&lt; std::endl; 
};

void demoDynamicCast() {

  displaySubtitle("dynamic_cast");

  std::cout &lt;&lt; "\n --- calls from objects ---\n";
  Base b; b.say();
  putline();
  Derived1 d1; d1.say(); d1.say1();
  putline();
  Derived2 d2; d2.say(); d2.say2();
  putline();

  std::cout &lt;&lt; "\n --- call via base pointer ---\n";
  Base* pBase = &amp;d1; pBase-&gt;say(); // pBase-&gt;say1(); not accessible from B*
  putline();

  std::cout &lt;&lt; "\n --- call via dynamic_cast derived pointer ---\n";

  Derived1* pDer1 = dynamic_cast&lt;Derived1*&gt;(pBase);
  if (pDer1) {
    pDer1-&gt;say1();
  }
  putline();
}</c-s>
</pre>
        </defn-block>
        <spacer-10></spacer-10>
        <defn-block class="defnBorder pad10-15 indent"><pre><c-s>  dynamic_cast
 --------------

 --- calls from objects ---
  hello from Base::say() via class Base

  hello from Base::say() via class Derived1
  hello from Derived1::say1() via class Derived1

  hello from Base::say() via class Derived2
  hello from Derived2::say2() via class Derived2    

 --- call via base pointer ---
  hello from Base::say() via class Derived1

 --- call via dynamic_cast derived pointer ---
  hello from Derived1::say1() via class Derived1
          </c-s></pre>
        </defn-block>
      </details>
    </indent-blocks>
      <spacer-15></spacer-15>
      <table width="100%">
        <tr>
          <th>
            <div>
              reinterpret_cast Syntax
            </div>
          </th>
          <th>reinterpret_cast Symantics</th>
        </tr>
        <tr>
          <td>
            <c-s>T<sub>dst</sub>* pT<sub>dst</sub> = 
            reinterpret_cast&lt;T<sub>dst</sub>*&gt;(pT<sub>src</sub>);</c-s>
          </td>
          <td>
            Apply type rules of <c-s>T<sub>dst</sub></c-s> to <c-s>t<sub>src</sub> &epsilon; T<sub>src</sub></c-s>.<br />
            Usually used for packing data into byte arrays and unpacking back to original type.
          </td>
        </tr>
      </table>
    </indent-block>
    <spacer-15></spacer-15>
    <indent-block>
      <details>
        <summary><span class="labelStyle darkItem">Example: reinterpret_cast&lt;T&gt;</span></summary>
        <spacer-10></spacer-10>
        <defn-block class="defnBorder indent pad10-15">
            <pre><c-s>/*--------------------------------------------------------------------------------------
  purpose of reinterpret_cast is to apply new type rules to an existing instance.
  - packing double's bytes into byte array
  - unpacking byte array into another double
  - illustrates how data might be marshalled over a socket channel, where the
    byte array pretends to be the socket channel
  --------------------------------------------------------------------------------------*/

void demoReinterpretCast() {

  displaySubtitle("reinterpret_cast");

  double d1{ 3.5 };
  double d2;
  size_t Max = sizeof(d1);

  /* create byte array on heap referenced by std::unique_ptr&lt;std::byte&gt; */

  std::unique_ptr&lt;std::byte&gt; pBuffer(new std::byte[Max]);  // owning pointer
  std::byte* pBuffIndex = pBuffer.get();                   // non-owning pointer

  /* pack double d1 into byte array */

  std::byte* pByteSrc = reinterpret_cast&lt;std::byte*&gt;(&amp;d1);
  std::byte* pSrcIndex = pByteSrc;  			   // non-owning pointers

  for (size_t i = 0; i &lt; Max; ++i) {
    *pBuffIndex++ = *pSrcIndex++;
  }

  /* unpack byte array into double d2 */

  if (sizeof(d2) == sizeof(d1)) {
    std::byte* pByteDst = reinterpret_cast&lt;std::byte*&gt;(&amp;d2);
    std::byte* pDstIndex = pByteDst;  			   // non-owning pointers
    pBuffIndex = pBuffer.get();
    for (size_t i = 0; i &lt; Max; ++i) {
      *pDstIndex++ = *pBuffIndex++;
    }
  }

  /* show that src and dst have the same values */

  std::cout &lt;&lt; "\n  src double = " &lt;&lt; d1;
  std::cout &lt;&lt; "\n  dst double = " &lt;&lt; d2;

  // byte array on heap will be deallocated here
  // as std::unique_ptr goes out of scope
}</c-s>
</pre>
        </defn-block>
        <spacer-10></spacer-10>
        <defn-block class="defnBorder indent pad10-15">
          <pre><c-s>  reinterpret_cast
 ------------------
  src double = 3.5
  dst double = 3.5</c-s></pre>
        </defn-block>
      </details>
    </indent-block>
    <spacer-25></spacer-25>
    C++ also defines a member function cast operator that supports creating an instance of a
    specified destination type from an instance of the casting class:
    <spacer-10></spacer-10>
    <indent-block class="pad10">
      <c-s>
        class X {<br />
        public:<br />
        &nbsp;&nbsp;operator Y () { ... }<br />
        };
      </c-s>
    </indent-block>
    <spacer-15></spacer-15>
    which supports expressions like:
    <indent-block class="pad10">
      <c-s>
        X x;<br />
        Y y = x;
      </c-s>
    </indent-block>
    If we declared the cast as explicit:
    <indent-block class="pad10">
      <c-s>
        class X {<br />
        public:<br />
        &nbsp;&nbsp;explicit operator Y () { ... }<br />
        };
      </c-s>
    </indent-block>
    then we would have to explicitly use static_cast:
    <indent-block class="pad10">
      <c-s>
        X x;<br />
        Y y = static_cast&lt;Y&gt;(x);
      </c-s>
    </indent-block>
    <h3>New Standard Types</h3>
    The std::pair container has been part of standard C++ libraries prior to C++11.
    The remaining containers were all introduced with or after C++11.  You&apos;ll see
    std::pair and std::tuple used in the examples below. All of the rest have been used
    in sample code that accompanies this chapter.
    <spacer-15></spacer-15>
    <indent-blocks>
      <defn-block>
        <defn-head style="border:none;">
          Special Containers
        </defn-head>
        <defn-body style="border:none;">
          <table>
            <tr>
              <td>pair</td>
              <td class="normal">contains two elements which may have distinct types</td>
            </tr>
            <tr>
              <td>tuple</td>
              <td class="normal">contains finite number of elements with distinct types</td>
            </tr>
            <tr>
              <td>initializer_list</td>
              <td class="normal">
                contains sequence of elements, all of the same type
                normally filled with initialization list, e.g., { 1, 2, 3, ... }
              </td>
            </tr>
            <tr>
              <td>any</td>
              <td class="normal">holds value of any type, provides std::any_cast for retrieval</td>
            </tr>
            <tr>
              <td>optional</td>
              <td class="normal">used to return values or signal failure to return</td>
            </tr>
            <tr>
              <td>variant</td>
              <td class="normal">similar to any, but only holds values from a specified set of types</td>
            </tr>
          </table>
        </defn-body>
      </defn-block>
      <spacer-15></spacer-15>
      These new standard types are not essential, but are very effective &quot;friction&quot; reducers.
      They make routine code we write easier to produce and to understand. We will see examples
      of their use throughout the remainder of this story.
    </indent-blocks>

    <h3>Initialization</h3>
    We&apos;ve already encountered initialization of data.  The section will take a closer look
    to see how it works.
    For the fundamental types, there are four sets of syntax:
    <indent-block class="pad10">
      <c-s>
        <ol>
          <li>
            T t = u
          </li>
          <li>
            T t(u);
          </li>
          <li>
            T t = { u };
          </li>
          <li>
            T t{ u };
          </li>
        </ol>
      </c-s>
      Where u &epsilon; U is some type that can be coerced to a T type or
      promoted through a <c-s>T(U&nbsp;u)</c-s> constructor.  The first two are equivalent,
      invoking <c-s>T(U&nbsp;u)</c-s>.  Note that there is no assignment in the first.  The
      syntax is completely equivalent to the second.
      <spacer-15></spacer-15>
      The third and fourth are also equivalent to each other, but not to the first two.
      The difference is that narrowing conversions like:
      <indent-block class="pad10">
        <c-s>int i = 1.75;  // size of int is 4 bytes, size of double is 8 bytes</c-s>
      </indent-block>
      will succeed with either of the first two, with a compiler warning.  
      But that is not true for braced initialization:
      <indent-block class="pad10">
        <c-s>int j{ 1.75 };  // fails to compile</c-s>
      </indent-block>
      <spacer-10></spacer-10>
      Braced initialization, like case 4, above, applies for most data definitions, and 
      has be named uniform initialization.  
      <div style="padding-top:15px; padding-bottom:5px;">
        Examples of <strong>&quot;uniform initialization&quot;</strong>
      </div>
      <spacer-5></spacer-5>
      <defn-block class="pad10-15 indent defnBorder" style="overflow-x:auto;">
        <c-s>
          std::string s4{ "four" };
          <spacer-10></spacer-10>
          double pi{ 3.1415729 };<br />
          double* pDouble{ &pi };<br />
          double& rDouble{ pi };
          <spacer-10></spacer-10>
          std::pair&lt;int, double&gt; pair1{ 4, 4.5 };
          <spacer-10></spacer-10>
          std::vector&lt;std::pair&lt;int, double&gt;&gt; pVec{ pair1, pair2, pair3, pair4 };&nbsp;&nbsp;
          <spacer-10></spacer-10>
          std::tuple&lt;int, double, std::string&gt; aTuple{ 1, 3.1415927, "some string" }; 
          <spacer-10></spacer-10>
          std::unordered_map&lt;std::string, int&gt; umap{ { "two", 2}, {"three", 3} };
          <spacer-10></spacer-10>
          std::unique_ptr&lt;double&gt; uPtr1{ std::make_unique&lt;double&gt;(pi) };<br />
          std::shared_ptr&lt;double&gt; sPtr1{ std::make_shared&lt;double&gt;(pi) };
        </c-s>
      </defn-block>
      <div style="padding:15px 0px 5px 0px;">
        Uniform initialization makes putting data into containers easy.  Since C++17 it&apos;s
        been just as easy to extract data using structured bindings.
      </div>
      <div style="padding:10px 0px 10px 0px;">
        Examples of <strong>&quot;structured binding&quot;</strong>
      </div>
      <defn-block class="pad10-15 indent defnBorder" style="overflow-x:auto;">
        <c-s>
          auto [i5, i6] = std::pair{ 5, 6 };<br />
          auto [d, i, s] = std::tuple&lt;double, int, std::string&gt;{ 2.5, 3, "four" };
          <spacer-10></spacer-10>
          struct S { int i; char c; std::string s; };<br />
          S foobar{ 2, 'Z', "a string" };<br />
          auto [fee, fie, foe] = foobar;
        </c-s>
      </defn-block>
      <spacer-15></spacer-15>
      The identifiers: <c-s>i5, i6, d, i, s, fee, fie, foe</c-s> are all instances with 
      types deduced by auto, based on the types in the containers to which they are bound.
      You can use them, just like any other identifier, after the binding statement.
      <spacer-15></spacer-15>
      <comment-block style="border:1px solid darkred;">
        Structured binding only works for public data in the source entity.
      </comment-block>
      <spacer-5></spacer-5>
      <div style="padding:15px 0px 5px 0px;">
        Note that these are declarations, so the identifier names must be different than
        any used before the binding statement in the same scope.
      </div>
      <div style="padding:10px 0px 10px 0px;">
        Example of where <strong>&quot;structured binding&quot;</strong> does not work.
      </div>
      <defn-block class="pad10-15 indent defnBorder">
      <c-s>
        class C {<br />
        public:<br />
        &nbsp;&nbsp;C(const std::string& str) : str_(str) {}     // promotion ctor&nbsp;&nbsp;<br />
        &nbsp;&nbsp;void say() { std::cout << "\n  " << str_; }<br />
        &nbsp;&nbsp;operator std::string() { return str_; }      // cast operator<br />
        private:<br />
        &nbsp;&nbsp;std::string str_;<br />
        };
        <spacer-10></spacer-10>
        /* uniform initialization works with promotion ctors */<br />
        C c{ "hello world" };<br />
        <spacer-10></spacer-10>
        /* these fail to compile: can only bind to public data */<br />
        //auto [gotit] {c};<br />
        //auto [gotit] = { static_cast<std::string>(c) };
        <spacer-10></spacer-10>
        auto gotit = c;  // this works via the cast operator,<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        &nbsp;&nbsp;&nbsp;// but is not structured binding
        <spacer-10></spacer-10>
      </c-s>
    </defn-block>
    </indent-block>
    <h3>Building Data Structures with the STL</h3>
    In this section we will see how easy it is to &quot;snap together&quot; STL containers 
    into complex, useful data structures. Details of the STL will be deferred to Chapter 6.
    <spacer-15></spacer-15>
    In this example we want to save file and path information from a directory tree, starting
    with a specified root path.  Our goal is to save each distinct filename and each distinct
    path only once.  We accomplish that by using several STL container classes.
    <spacer-15></spacer-15>
    Each file name encountered may appear in more than one directory. Instead of saving multiple
    path names, we save multiple iterators (much smaller than the path names) into a path set.
    <spacer-15></spacer-15>
    We&apos;ve simply connected them together, as shown in the using declarations, below.
    The structure of the STL, using iterators to point to specific contents, works very well.
    The complete declaration of the file information container is:
    <indent-block class="pad10">
    <c-s>
      std::map&lt;std::string,std::vector&lt;std::set&lt;std::string&gt;::iterator&gt;&gt;
      &nbsp;-->&nbsp;std::set&lt;std::string&gt;
    </c-s>
    </indent-block>
    The using declarations make that much more readable:
    <indent-block class="pad10">
      <c-s>
        FileInfo&lt;File, PathRefs&gt;&nbsp;-->&nbsp;PathSet&lt;Path&gt;
      </c-s>
    </indent-block>
    The class declaration and class diagram are show in Fig 1., below.
    <spacer-25></spacer-25>
    <div class="defnBorder defn" style="display:flex;">
    <pre><c-s>  class FileInfoContainer {
  public:
    // file to path structure
    using File = std::string;
    using Path = std::string;
    using PathSet = std::set&lt;Path&gt;;
    using PathRef = PathSet::iterator;
    using PathRefs = std::vector&lt;PathRef&gt;;
    using FileInfo = std::map&lt;File, PathRefs&gt;;
    using iterator = FileInfo::iterator;
    using PathInfo = FileInfo;

    FileInfoContainer& add(const File& file, const Path& path);
    FileInfoContainer invertFileInfo(FileInfoContainer* pFIC);
    FileInfo fileInfo();
    iterator begin() { return fileInfo_.begin(); }
    iterator end() { return fileInfo_.end(); }
    size_t fileCount();
    size_t pathCount();

  private:
    FileInfo fileInfo_;
    PathSet pathSet_;
    PathInfo pathInfo_;
  };

</c-s></pre>
    <hidephotosizer-block src="Pictures/FileInfoDataStructure.JPG" width="400" class="photoSizerBlock" style="margin-top:25px; overflow-x:auto;">
      <span style="font-family:'Comic Sans MS, Tahoma';">
        Fig 1. FileInfo Data Structure
      </span>
    </hidephotosizer-block>
    </div>
    <spacer-25></spacer-25>
    Output from a directory navigator that stores its file and directory information in a FileInfo
    container is shown below.  There are two collections of output.  The one on the left uses
    the FileInfo container.  The one of the right uses another FileInfo container to hold the
    results of inverting the path and file relationships.  
    <spacer-15></spacer-15>
    Instead of using file names as keys and sets of path names as values, we swap the roles of 
    file and path.  Instead of using
    <c-s>fileInfoContainer.add(file, path)</c-s> we invert that to 
    <c-s>fileInfoContainer.add(path, file)</c-s>.
    Both sets of output are useful.  The one on the left, showing for each file name all the paths
    where it is found, can be used to find the latest version of a file, or older files to be 
    discarded.
    <spacer-15></spacer-15>
    The output on the right would be useful for understanding how files are grouped into applications.
    <spacer-15></spacer-15>
    <div style="overflow-x:auto;">
    <table class="defn">
      <tr>
        <td class="tableCode defn"><span class="notice">
  FileInfo from path ".."
 -------------------------</span>
  Chap1.cpp
    c:\github\JimFawcett\CppStory\Chapter1
  Chap1.h
    c:\github\JimFawcett\CppStory\Chapter1
  Classes.cpp
    c:\github\JimFawcett\CppStory\Chapter4-classes
  CustomTraits.h
    c:\github\JimFawcett\CppStory\CustomTraits
  Data.cpp
    c:\github\JimFawcett\CppStory\Chapter2-Data
  DateTime.cpp
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker
  DateTime.h
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker
  Dev.cpp
    c:\github\JimFawcett\CppStory\Chapter1-Dev
  Dev.h
    c:\github\JimFawcett\CppStory\Chapter1-Dev
  DirWalker.cpp
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker
  DirWalker.h
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker

      -- output data elided --

  TestPerson.cpp
    c:\github\JimFawcett\CppStory\Chapter4-classes
  ToHTML.cpp
    c:\github\JimFawcett\CppStory\Webber\ToHTML
  const_cast.cpp
    c:\github\JimFawcett\CppStory
  const_cast1.cpp.html
    c:\github\JimFawcett\CppStory
  const_cast1.txt.html
    c:\github\JimFawcett\CppStory
  dynamic_cast.cpp
    c:\github\JimFawcett\CppStory
  dynamic_cast1.cpp.html
    c:\github\JimFawcett\CppStory
  dynamic_cast2.cpp.html
    c:\github\JimFawcett\CppStory
  reinterpret_cast.cpp
    c:\github\JimFawcett\CppStory
  reinterpret_cast1.cpp.html
    c:\github\JimFawcett\CppStory
  static_cast.cpp
    c:\github\JimFawcett\CppStory
  static_cast1.cpp.html
    c:\github\JimFawcett\CppStory

  number of files: 46
  number of paths: 17
        </td>
        <td class="tableCode defn"><span class="notice">
  FileInfo from path ".."
 -------------------------</span>
  Chap1.cpp
    c:\github\JimFawcett\CppStory\Chapter1
  Chap1.h
    c:\github\JimFawcett\CppStory\Chapter1
  Classes.cpp
    c:\github\JimFawcett\CppStory\Chapter4-classes
  CustomTraits.h
    c:\github\JimFawcett\CppStory\CustomTraits
  Data.cpp
    c:\github\JimFawcett\CppStory\Chapter2-Data
  DateTime.cpp
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker
  DateTime.h
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker
  Dev.cpp
    c:\github\JimFawcett\CppStory\Chapter1-Dev
  Dev.h
    c:\github\JimFawcett\CppStory\Chapter1-Dev
  DirWalker.cpp
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker
  DirWalker.h
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker

      -- output data elided --

  TestPerson.cpp
    c:\github\JimFawcett\CppStory\Chapter4-classes
  ToHTML.cpp
    c:\github\JimFawcett\CppStory\Webber\ToHTML
  const_cast.cpp
    c:\github\JimFawcett\CppStory
  const_cast1.cpp.html
    c:\github\JimFawcett\CppStory
  const_cast1.txt.html
    c:\github\JimFawcett\CppStory
  dynamic_cast.cpp
    c:\github\JimFawcett\CppStory
  dynamic_cast1.cpp.html
    c:\github\JimFawcett\CppStory
  dynamic_cast2.cpp.html
    c:\github\JimFawcett\CppStory
  reinterpret_cast.cpp
    c:\github\JimFawcett\CppStory
  reinterpret_cast1.cpp.html
    c:\github\JimFawcett\CppStory
  static_cast.cpp
    c:\github\JimFawcett\CppStory
  static_cast1.cpp.html
    c:\github\JimFawcett\CppStory

  number of files: 46
  number of paths: 17
        </td>
      </tr>
    </table>
      </div>
    <!--<indent-block class="defnBorder lightItem" style="display:flex; user-select:none; overflow-x:auto;">
    <pre><c-s>  FileInfo from path ".."
 -------------------------
  Chap1.cpp
    c:\github\JimFawcett\CppStory\Chapter1
  Chap1.h
    c:\github\JimFawcett\CppStory\Chapter1
  Classes.cpp
    c:\github\JimFawcett\CppStory\Chapter4-classes
  CustomTraits.h
    c:\github\JimFawcett\CppStory\CustomTraits
  Data.cpp
    c:\github\JimFawcett\CppStory\Chapter2-Data
  DateTime.cpp
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker
  DateTime.h
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker
  Dev.cpp
    c:\github\JimFawcett\CppStory\Chapter1-Dev
  Dev.h
    c:\github\JimFawcett\CppStory\Chapter1-Dev
  DirWalker.cpp
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker
  DirWalker.h
    c:\github\JimFawcett\CppStory\Chapter2-STL
    c:\github\JimFawcett\CppStory\DirWalker

      -- output data elided --

  TestPerson.cpp
    c:\github\JimFawcett\CppStory\Chapter4-classes
  ToHTML.cpp
    c:\github\JimFawcett\CppStory\Webber\ToHTML
  const_cast.cpp
    c:\github\JimFawcett\CppStory
  const_cast1.cpp.html
    c:\github\JimFawcett\CppStory
  const_cast1.txt.html
    c:\github\JimFawcett\CppStory
  dynamic_cast.cpp
    c:\github\JimFawcett\CppStory
  dynamic_cast1.cpp.html
    c:\github\JimFawcett\CppStory
  dynamic_cast2.cpp.html
    c:\github\JimFawcett\CppStory
  reinterpret_cast.cpp
    c:\github\JimFawcett\CppStory
  reinterpret_cast1.cpp.html
    c:\github\JimFawcett\CppStory
  static_cast.cpp
    c:\github\JimFawcett\CppStory
  static_cast1.cpp.html
    c:\github\JimFawcett\CppStory

  number of files: 46
  number of paths: 17
</pre>
      <pre class="indent" style="border-left:1px solid darkred;"><c-s>
  PathInfo from path ".."
 -------------------------
  c:\github\JimFawcett\CppStory
    const_cast.cpp
    const_cast1.cpp.html
    const_cast1.txt.html
    dynamic_cast.cpp
    dynamic_cast1.cpp.html
    dynamic_cast2.cpp.html
    reinterpret_cast.cpp
    reinterpret_cast1.cpp.html
    static_cast.cpp
    static_cast1.cpp.html

     -- output data elided

  c:\github\JimFawcett\CppStory\Chapter2-STL
    DateTime.cpp
    DateTime.h
    DirWalker.cpp
    DirWalker.h
    STL_DataStructures.cpp
  c:\github\JimFawcett\CppStory\Chapter4-classes
    Classes.cpp
    TestPerson.cpp
  c:\github\JimFawcett\CppStory\CustomTraits
    CustomTraits.h
  c:\github\JimFawcett\CppStory\DirWalker
    DateTime.cpp
    DateTime.h
    DirWalker.cpp
    DirWalker.h
  c:\github\JimFawcett\CppStory\Display
    Display.h
  c:\github\JimFawcett\CppStory\Webber\ToHTML
    IPerson - Copy.h
    IPerson.h
    IPerson1.h.html
    IPerson2.h.html
    IPerson3.h.html
    IPerson4.h.html
    IPerson5.h.html
    IPerson6.h.html
    IPerson7.h.html
    IPerson8.h.html
    IPerson9.h.html
    Person.cpp
    Person.h
    ToHTML.cpp

  number of files: 46
  number of paths: 17
</c-s>
</pre>
    </indent-block>-->
  </indent-blocks>
  <spacer-25></spacer-25>
  Directory navigator <c-s>DirWalk&lt;App&gt;</c-s> was built using the C++17 std::filesystem.  It
  gets access to a <c-s>FileInfoContainer</c-s> from an <c-s>App</c-s> template parameter that supplies it methods
  <c-s>doDir(...)</c-s> and <c-s>doFile(...)</c-s>.  Those methods simply add files with their paths into a FileInfoContainer
  member of the <c-s>App</c-s> class.
  This example should give us an idea of how useful the STL types are.  We will dig into the
  details in Chapter 6.
  <spacer-15></spacer-15>
  This concludes Chapter 2.  In Chapter 3 we will look at C++ operations: functions, methods,
  functors, lambdas, ...
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>