<!DOCTYPE html>
<html>
<head>
  <!--
   - CppStory_Templates.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Story-Templates</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_Libraries.html">N</a>
  <a id="Prev" href="CppStory_ClassRelationships.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #6 - C++ Templates</h1>
      <h3 id="subtitle">template functions and classes</h3>
    </hgroup>
  </header>

  <hr class="spread" />
  <bb-55 class="indent">
  <num-cont>
    <num-item1>6.0</num-item1><num-item4>Templates</num-item4>
  </num-cont>
  <t-b>
    Templates support building parameterized types and functions that accept an unspecified type which gets 
    resolved only when an application instantiates the code with a concrete type. Parameterized code will 
    accept, without compilation error, arbitrary calls on instances of the template type. When an application 
    instantiates the parameterized code with a concrete type, compilation of the instantiated code succeeds 
    if the type supports specified operations, else it fails.
  </t-b>
  <t-b>
    So there are two C++ template compilation phases:
    <ol class="tight">
      <li>
        Compilation of the template library code does a syntax check to identify known errors. No object code 
        is generated since the type of the template parameter is not specified.
      </li>
      <li>
        Compilation of instantiated application code generates an object file if instantiated syntax is correct, 
        otherwise it fails.
      </li>
    </ol>
    This lazy syntax checking is very useful. C# and Java generics do eagar type checking so many operations 
    that would succeed for useful types are not allowed because the compiler can't ensure that they will 
    succeed.
  </t-b>
  <t-b>
    An implication of lazy compilation is that all of the template definition code must go in a 
    header file, because the application that uses the template definition has to see all of it's code 
    to compile successfully, and it gets that only by including a header file.
  </t-b>
  <hr class="spread" />
  <num-cont>
    <num-item1>6.1</num-item1><num-item4>Template Functions</num-item4>
  </num-cont>
  <t-b>
    <t-b>
      Template function syntax may take one of several forms:
    </t-b>    <defn-outerBlock>
      <defn-block>
        <defn-code>
template&lt;typename T&gt;
void f(T t) { ... }
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-code>
template&lt;class R, class A1, class A2, class A3&gt;
R g(A1 a1, A2& a2, A3&& a3) { ... }
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-code>
template&lt;typename T&gt;
T h() {
  // t &epsilon; T defined in function scope 
  // then returned
}
        </defn-code>
      </defn-block>
    </defn-outerBlock>
    <t-b>
      For the first two forms using code provides arguments and the compiler will infer the types and compile
      a function using those types. In the second form function <c-s>g</c-s> takes arguments: <c-s>a1</c-s> by value,
      <c-s>a2</c-s> by lvalue reference (&amp;), and <c-s>a3</c-s> by rvalue reference (&amp;&amp;).
      In that second form we&apos;ve used &quot;<c-s>class</c-s>&quot; instead of &quot;<c-s>typename</c-s>&quot;.
      Both forms are supported, but <c-s>typename</c-s> is preferred syntax.
    </t-b>
    <t-b>
      Passing by value makes a copy of the argument in the function&apos;s stackframe.  Passing with an lvalue
      reference creates a reference in the function&apos;s stackframe, bound to the argument in the caller&apos;s
      scope.  lvalue references will not bind to non-const temporaries. rvalue references behave like lvalue
      references except that they can bind to a temporary, e.g., an rvalue, and are used most frequently with
      move operations.
    </t-b>
    <t-b>
      For the
      third case, type inference is not possible from the arguments and the compiler does not attempt to
      analyze the body code to figure that out, so we have to help by providing the type we want, as shown
      in the last line of code, below.
    </t-b>
    <defn-outerBlock class="indent">
      <defn-block>
        <defn-code>
int i{ 3 };
f(i);</defn-code>
        <defn-code>
double d{ 3.1415927 };
const std::string s = "a demo string";
int j = g&lt;int&gt;(d, s, 'z');</defn-code>
        <defn-code>
std::string s = h&lt;std::string&gt;();
        </defn-code>
      </defn-block>
    </defn-outerBlock>
  <t-b>
    For the first case the compiler knows the type of <c-s>i</c-s> 
    and will compile <c-s>f</c-s> as if the
    function was defined as:
    <t-b>
      <c-b>  void f(int i) { ... }</c-b>
    </t-b>    and does the same thing with the remaining two cases.
  </t-b>
  <hr class="spread" />
  <num-cont>
    <num-item1>6.2</num-item1><num-item4>Overloading Template Functions</num-item4>
  </num-cont>
  <t-b>
    Template functions provide generic recipes for their operation.  That is often all we need
    for a program we are implementing.  However, frequently we need to handle a range of types,
    some of which may not compile or operate correctly with the generic pattern.  In those cases we
    look for a function overload that will work correctly.
  </t-b>
  <t-b>
    In the code below, we&apos;ve expanded the <c-s>T max(T t1,T t2)</c-s> example from Chapter #1
    by allowing the two arguments to have different types. That results in some interesting
    processing activities.
  </t-b>
  <t-b>
    Looking at the output of the using code, we see that:
    <i-b>
      <ol class="tight">
        <li>
          In the first use case, the arguments are 4 and 2, each inferred to be int and the generic
          version is compiled for that case.
        </li>
        <li>
          In the second case, the arguments are 3.5, a double, and 2L, a long int. The C++ language
          supports comparing a value of double with an integral value, so the generic template is compiled.
        </li>
        <li>
          For the third case the arguments are 3.5 and 4L. When compared, the 4L is promoted to a double
          with value 4 and that is returned.  Note that the return type is double, not long int.  Since
          there is only one type for the return value, that is inferred to be the more inclusive type.
        </li>
        <li>
          The fourth case matches the overload, and the C++ language guarantees that if an overload
          matches it will be the form compiled.
        </li>
        <li>
          The fifth and last case has arguments of std::string and const char*.  That cannot match the
          overload, but the generic version works correctly.  The string is compared to the const char*
          value by promoting the const char* to a std::string using a string constructor, and the two
          strings are compared.
          The larger value, passed as the const char*, is returned as a std::string.
        </li>
      </ol>
    </i-b>  </t-b>
  <t-b>
    Using two unique parameter types allows <c-s>max</c-s> to compile successfully in cases that would
    fail if we required both arguments to be the same type.  Only the first and fourth examples, below, will 
    compile for the original <c-s>T max(T t1, T t2)</c-s> function.
  </t-b>
  <t-b>
    Returning the result as an auto gets around
    the problem of how to state the return type if more than one type could be returned, e.g., 
    <c-s>T1</c-s> or <c-s>T2</c-s>.
  </t-b>
  <div class="autoX viewWidth">
  <table class="tdefn">
    <tr>
      <th class="tdefn" style="border-right:2px solid darkred; font-size:1rem;">Template Code</th>
      <th class="tdefn" style="font-size:1rem;">Output</th>
    </tr>
    <tr>
      <td class="tdefn" style="border-bottom:2px solid darkred; border-right:2px solid darkred;">
        <tdefn-block>
          <tdefn-code>
template&lt;typename T1, typename T2&gt;
auto max(T1 t1, T2 t2) {
  displayDemo("--- using generic template ---");
  return t1 &gt; t2 ? t1 : t2;
}

using pChar = const char*;
auto max(pChar s1, pChar s2) {
  displayDemo("--- using overload for const char* ---");
  return ((strcmp(s1, s2) &gt; 0) ? s1 : s2);
}
          </tdefn-code>
        </tdefn-block>
      </td>
      <td class="tdefn" style="border-bottom:2px solid darkred;">
        <tdefn-block>
          <tdefn-code>
Demonstrate Template Functions
================================
--- using generic template ---
max(4,2) returns 4
the return type of the last statement is: int
--- using generic template ---
max(3.5, 2L) returns 3.5
the return type of the last statement is: double
--- using generic template ---
max(3.5, 4L) returns 4
the return type of the last statement is: double
--- using overload for const char* ---
max("aardvark", "zebra") returns zebra
the return type of the last statement is: char const *
--- using generic template ---
max(std::string("a string"), "b string") returns "b string"
the return type of the last statement is:
class std::basic_string&lt;
  char,struct std::char_traits&lt;char&gt;, 
  class std::allocator&lt;char&gt; 
&gt;

          </tdefn-code>
        </tdefn-block>
      </td>
    </tr>
    <!--<tr>
      <th class="tdefn" colspan="2">Using Code</th>
    </tr>-->
    <tr style="border:2px solid #fefefa;">
      <td class="tdefn" colspan="2" style="border:none;">
        <details>
          <summary class="labelStyle, darkItem">Using Code</summary>
          <s-halfEm></s-halfEm>
        <tdefn-block class="defnBorder">
          <tdefn-code>
auto test1 = max(4, 2);
std::cout &lt;&lt; "\n  max(4,2) returns " &lt;&lt; test1;

auto test2 = max(3.5, 2L);
std::cout &lt;&lt; "\n  max(3.5, 2L) returns " &lt;&lt; test2;
std::cout &lt;&lt; "\n  the return type of the last statement is: ";
std::cout &lt;&lt; typeid(test2).name();
  
auto test3 = max(3.5, 4L);
std::cout &lt;&lt; "\n  max(3.5, 4L) returns " &lt;&lt; test3;
std::cout &lt;&lt; "\n  the return type of the last statement is: ";
std::cout &lt;&lt; typeid(test3).name();

auto test4 = max("aardvark", "zebra");
std::cout &lt;&lt; "\n  max(\"aardvark\", \"zebra\") returns " &lt;&lt; test4;
std::cout &lt;&lt; "\n  the return type of the last statement is: ";
std::cout &lt;&lt; typeid(test4).name();

auto test5 = max(std::string("a string"), "b string");
std::cout &lt;&lt; "\n  max(std::string(\"a string\"), \"b string\") returns " 
          &lt;&lt; "\"" &lt;&lt; test5 &lt;&lt; "\"";
decltype(test5) what;
std::cout &lt;&lt; "\n  the return type of the last statement is:";
std::cout &lt;&lt; "\n  " &lt;&lt; typeid(what).name();
          </tdefn-code>
        </tdefn-block>
        </details>
      </td>
    </tr>
  </table>
  </div>
  <t-b>
    To understand how template functions work, we need to look at type categories and type inference, the process
    compilation uses to establish the types that arguments take after being passed to template functions.
  </t-b>
   <num-cont>
    <num-item1>6.21</num-item1><num-item4>Type Categories</num-item4>
  </num-cont>
  <t-b>
    Before C++11, there were only two type categories, lvalue and rvalue:
    <ol class="tight">
      <li>
        lvalue refers to any named variable, e.g., anything for which we can evaluate an address.
        It was called lvalue because it could by used on the left side of an assignment expression:
        <c-b class="indent pad5">char ch = 'z';</c-b>
        Here, ch is an lvalue.
      </li>
      <li>
        rvalue refers to any entity for which you cannot evaluate an address, as it has no name
        and is usually a temporary.  rvalues can only appear on the right side of an assignment
        expression, e.g., the 'z' of the previous item.
      </li>
    </ol>
  </t-b>
  <t-b>
    Things are now, with C++17, somewhat more complicated.  rvalues split into xvalues and prvalues:
    <ol class="tight">
      <li>
        An xvalue is an entity that can be the source of a move operation.  These are almost always
        values of temporary objects created in the scope of some function, and are syntactically returned
        by value.  An xvalue is not copied, but instead moved by transferring its resources to the
        entity that is the target of the return operation.   
      </li>
      <li>
        A prvalue is an expression that defines the initialization of the destination.  Under return
        value optimization the prvalue initializes the creation of a target instance.  When rvo does
        not apply, the prvalue initializes an xvalue as part of a move operation, provided the
        returned object has a move constructor and move assignment operator.
      </li>
    </ol>
  </t-b>
  <t-b>
    You don&apos;t need to think about these categories when designing, but knowing about them helps
    you understand how the process works.
  </t-b>
   <num-cont>
    <num-item1>6.22</num-item1><num-item4>Type Transformations</num-item4>
  </num-cont>
  <t-b>
    When passing arguments to functions, the result of template type deduction is not necessarily the same as
    the type of the argument in the caller&apos;s scope.  This is not an inference error, but an intentional
    transformation made for reasons of performance or usability.
    For non-template functions there is only one such transformation. That occurs for array arguments.
    When the function&apos;s stackframe is constructed, a pointer is created in stack memory, bound to
    the first element of the array, instead of copying the array.  
  </t-b>
  <t-b>
    All access to the array, within the function,
    accesses the caller&apos;s array via that pointer. It is common to refer to this process as type decay.  That is, 
    the array type decays to a pointer type in the function&apos;s scope.
  </t-b>
  <t-b>
    For template functions, transformations of function argument types are more complicated.  The most important
    of these are:
    <t-b class="indent">
      <ol class="tight">
        <li>
          passing a template parameter by value will strip off constant, volatile, and reference 
          (cvr) qualifiers
        </li>
        <li>
          rvalue references (T&amp;&amp;) can bind to both lvalues and rvalues
        </li>
      </ol>
    </t-b>
    For the details look here:
  </t-b>
  </bb-55>
    <details class="indent">
      <summary class="labelStyle lightItem">Type Transformation Details</summary>
      <bb-55>
  <t-b>
    In this section we will look at type transformations that occur when passing arguments to functions,
    especially template functions. Unfortunately you cannot use the C++ typeid operator to explore these
    effects.  We see below, that passing an argument to a template function by value strips its constant,
    volatile, and reference (cvr) qualifiers.  But typeid is a template function, so it will strip off 
    some of the things we are looking for.
    The Boost libraries have a work-around with their <c-s>boost::typeindex::type_id_with_cvr<T>()</c-s>
    operator<sup>1</sup>. I&apos;ve used that for all of the type analysis reported below.
  </t-b>
  <t-b>
    We see, from Table 1., that in all non-template cases tested, the only case with type decay is the array argument.
    This is true in general, e.g., for non-template functions, the only type decay that happens is with array 
    arguments.
  </t-b>
  <s-halfEm></s-halfEm>
  <h3>Table 1. - Type of arg in bodies of non-template functions</h3>
  <table class="pad10" style="font-size:0.85rem;">
    <tr class="defn">
      <th class="darkItem">arg definition</th>
      <th class="darkItem"><c-s>f(int arg)</c-s></th>
      <th class="darkItem"><c-s>f(const int* arg)</c-s></th>
      <th class="darkItem"><c-s>f(int arg[3])</c-s></th>
    </tr>
    <tr>
      <td class="defn"><c-s>int i{ 3 };</c-s></td>
      <td class="defn"><c-s>int</c-s></td>
      <td class="defn"></td>
      <td class="defn"></td>
    </tr>
    <tr>
      <td class="defn"><c-s>const int&amp; j = &amp;i;</c-s></td>
      <td class="defn"><c-s>int</c-s></td>
      <td class="defn"></td>
      <td class="defn"></td>
    </tr>
    <tr>
      <td class="defn"><c-s>const int* pI = &amp;i;</c-s></td>
      <td class="defn"></td>
      <td class="defn"><c-s>int const *</c-s></td>
      <td class="defn"></td>
    </tr>
    <tr>
      <td class="defn"><c-s>int iarr[4]</c-s></td>
      <td class="defn"></td>
      <td class="defn"></td>
      <td class="defn"><c-s>int *</c-s></td>
    </tr>
  </table>
  <s-halfEm></s-halfEm>
  <t-b>
    Template functions are a different story.  When compiling an instantiated template, the compiler infers
    argument types from syntax of invocations. That inference has several rules:
  </t-b>
  <t-b class="indent">
    <ol class="tight">
      <li>
        Passing an argument by value removes all const, volatile, and reference (cvr) qulifiers.
        Array arguments decay to pointers.
      </li>
      <li>
        Passing an argument by lvalue reference (&amp;) doesn&apos;t remove qualifiers and arrays do not
        decay (because they won&apos;t be copied). An lvalue reference can only bind to lvalues or const rvalues.
      </li>
      <li>
        Passing an argument by pointer doesn&apos;t remove qualifiers, but arrays do decay (because the argument
        is a pointer).
      </li>
      <li>
        Passing an argument by rvalue reference (&amp;&amp;) doesn&apos;t strip qualifiers and arrays do not
        decay. Rvalue references can bind to both lvalues and rvalues.
      </li>
    </ol>
  </t-b>
  </bb-55>
  <h3>Table 2. - Type Transformations for template functions</h3>
  <div class="autoX">
  <table class="pad10" style="table-layout:fixed; width:78em; font-size:0.85rem;">
    <tr class="defn">
      <th class="darkItem" style="width:12em; vertical-align:middle;text-align:center;">arg definition</th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f1(T arg)</c-s></th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f2(T& arg)</c-s></th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f2C(const T& arg)</c-s></th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f3(T* arg)</c-s></th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f3C(const T* arg)</c-s></th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f4(T&& arg)</c-s></th>
    </tr>
    <tr>
      <td class="defn"><c-s>int i{ 3 };</c-s></td> 
      <td class="defn">T = int </td>
      <td class="defn">T&amp; = int &amp;</td>
      <td class="defn">const T&amp; = int&nbsp;const&nbsp;&amp;</td>
      <td class="defn"></td>
      <td class="defn"></td>
      <td class="defn">T&amp;&amp; = int &amp;</td>
    </tr>
    <tr>
      <td class="defn"><c-s>const int&amp; j = &amp;i;</c-s></td>
      <td class="defn">T = int</td>
      <td class="defn">T&amp; = int const &amp;</td>
      <td class="defn">const T&amp; = int&nbsp;const&nbsp;&amp;</td>
      <td class="defn"></td>
      <td class="defn"></td>
      <td class="defn">T&amp;&amp; = int&nbsp;const&nbsp;&amp;</td>
    </tr>
    <tr>
      <td class="defn"><c-s>const int* pI = &amp;i;</c-s></td>
      <td class="defn">T = int const *</td>
      <td class="defn">T&amp; = int&nbsp;const&nbsp;*&nbsp;&amp;</td>
      <td class="defn">const T&amp; = int&nbsp;const&nbsp;*&nbsp;const&nbsp;&amp;</td>
      <td class="defn">T* = int const *</td>
      <td class="defn">const T* = int&nbsp;const&nbsp;*</td>
      <td class="defn">T&amp;&amp; = int&nbsp;const&nbsp;*&nbsp;&amp;</td>
    </tr>
    <tr>
      <td class="defn"><c-s>iarr[4]</c-s></td>
      <td class="defn">T = int *</td>
      <td class="defn">T&amp; = int&nbsp;(&amp;)[4]</td>
      <td class="defn">const T&amp; = int&nbsp;const&nbsp;(&amp;)[4]</td>
      <td class="defn">T* = int *</td>
      <td class="defn">const T* = int&nbsp;const&nbsp;*</td>
      <td class="defn">T&amp;&amp; = int&nbsp;(&amp;)[4]</td>
    </tr>
  </table>
  </div>
  <bb-55 class="indent">
  <t-b>
    Usually you don&apos;t have to think about the rules.  Inference just works as you would expect.
    On rare occasions you may need to consider them to understand unexpected compilation or run-time
    behavior of template code.
  </t-b>
  <hr class="spreadup" />
  <ol class="footnote">
    <li>
      Boost libraries are available from their site, <a href="https://boost.org">boost.org</a>. The use
      of <c-s>boost::typeindex::type_id_with_cvr<T>()</c-s> for this purpose was cited in 
      <a href="https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?crid=28XKCOZTMHOY7&keywords=effective+modern+c%2B%2B+by+scott+meyers&qid=1577367547&s=books&sprefix=effective+modern+c%2B%2B%2Cstripbooks%2C158&sr=1-1">Effective Modern C++</a>
      by Scott Meyers.
    </li>
  </ol>
    </bb-55>
    </details>
  <bb-55 class="indent">
  <num-cont>
    <num-item1>6.23</num-item1><num-item4>Substitution Failure Is Not An Error (SFINAE)</num-item4>
  </num-cont>
  <t-b>
    When compiling overloaded template functions argument type deduction may fail for one or perhaps several 
    overloads. These deductions are based on substitutions in each of the overloads. Substitution failure
    is not a compile error, so the build should succeed unless none of the deductions succeed.
  </t-b>
  </bb-55>
  <details class="indent">
    <summary class="labelStyle lightItem">SFINAE Details</summary>
  <bb-55 class="indent">
  <t-b>
    In the example below, we&apos;ve supplied two function overloads, each displaying the contents of
    a collection.  The first displays contents of an array, and the second, contents of a vector.
  </t-b>
  <t-b>
    In the Using Code main there are three cases:
    <ol class="tight">
      <li>
        First case: no SFINAE - 
        <strong><c-s>show(array)</c-s></strong>
        <tt-b class="indent">
          The array matches both overloads, but <c-s>show(const T (&array)[N])</c-s> is a more
          specific match and is compiled.
        </tt-b>
      </li>
      <li>
        Second case: SFINAE with build success - 
        <strong><c-s>show(vInt)</c-s></strong>
        <tt-b class="indent">
          vInt fails to match <c-s>show(const T (&array)[N])</c-s> but does match
          <c-s>show(const C&Aacute; cont)</c-s> and is compiled. SFINAE prevents the
          substitution failure from causing a compile error.
        </tt-b>
      </li>
      <li>
        Third case: SFINAE with build failure not due to substitution - 
        <strong><c-s>show(3.14159)</c-s></strong>
        <tt-b class="indent">
          Substitution of the double 3.14159 into the first overload fails but is not a compile
          error. Substitution into the second overload succeeds, but the body fails to compile
          since a double does not satify the requirements of a range-based for loop.
        </tt-b>
      </li>
    </ol>
  </t-b>
  <defn-outerBlock>
    <defn-block>
      <defn-head>
        SFINAE Code
      </defn-head>
      <defn-code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include "../Display/Display.h"

template&lt;typename T, size_t N&gt;
void show(const T (&amp;array)[N]) {
  displayDemo("--- show array contents ---");
  std::cout &lt;&lt; "\n  ";
  for (size_t i = 0; i &lt; N; ++i)
    std::cout &lt;&lt; array[i] &lt;&lt; " ";
}

template&lt;typename C&gt;
void show(const C&amp; cont) {
  displayDemo("--- show container contents ---");
  std::cout &lt;&lt; "\n  ";
  for (auto item : cont) {
    std::cout &lt;&lt; item &lt;&lt; " ";
  }
}
      </defn-code>
    </defn-block>
    <defn-block>
      <defn-head>Using Code</defn-head>
      <defn-code>
int main() {

  displayTitle("SFINAE Demo");

  std::cout &lt;&lt; "\n  displaying array:";
  double array[5]{ -0.5, 0.0, 0.5, 1.0, 1.5 };
  show(array);

  std::cout &lt;&lt; "\n  displaying vector";
  std::vector&lt;int&gt; vInt{ -1, 0, 1, 2, 3 };
  show(vInt);

  // show(array);
  // attempted template argument deduction for both show functions
  // - show(const T (&amp;array)[n]) succeeded, built, and used
  // - show(const C&amp; cont) succeeded but less specific so not used

  // show(vInt)
  // attempted template argument deduction for both show functions
  // - show(const T (&amp;array)[n]) failed, vInt is not an array, 
  //   but this is not a compilation error (SFINAE)
  // - show(const C&amp; cont) succeeded, built, and used

  // show(3.14159);
  // argument deduction for show(const T (&amp;array)[N]) fails
  // - double is not an array
  // argument deduction succeeds with show(const C&amp; cont)
  // - compilation of body for double fails, i.e., 
  //   no iterator, begin(), or end() for range-based for

  std::cout &lt;&lt; "\n\n";
}
      </defn-code>
      <defn-head>Output</defn-head>
      <defn-code>
  SFINAE Demo
 =============

  displaying array:
  --- show array contents ---
  -0.5 0 0.5 1 1.5
  displaying vector
  --- show container contents ---
  -1 0 1 2 3
      </defn-code>
    </defn-block>
  </defn-outerBlock>
  <t-b>
    The point of all this is that you can write function code that works for some types 
    but not for others as long as there is a type deduction for some other function overload that succeeds 
    and provides working code for any of the types your program will use for this set invocations.
  </t-b>
  </details>
  <bb-55 class="indent">
  <t-b>
    We will look at SFINAE for template classes in the next chapter7 - Template Metaprogramming.
  </t-b>
  <hr class="spread" />
  <num-cont>
    <num-item1>6.3</num-item1><num-item4>Template Function Examples</num-item4>
  </num-cont>
  <t-b>
    Both examples, below, are from the <a href="CppUtilities.html">CppUtilities Repository</a>. 
    <c-s>Converter&lt;T&gt;::toString(t)</c-s>, in the CodeUtilities folder, converts the value of <c-s>t &epsilon; T</c-s>
    to its string representation.
    And, given the conversion string, ConvStr, <c-s>Converter&lt;T&gt;::toValue(ConvStr)</c-s>
    converts back to a new instance with the original value.

  </t-b>
  <details>
    <summary class="labelStyle darkItem">Converter Example</summary>
    <s-halfEm></s-halfEm>
    <defn-outerBlock>
      <defn-block>
        <defn-head>Converter function</defn-head>
        <defn-code>
/////////////////////////////////////////////////////////////////
// Converter class
// - supports converting unspecified types to and from strings
// - type is convertible if it provides insertion and extraction
//   operators

template &lt;typename T&gt;
class Converter
{
public:
  static std::string toString(const T&amp; t);
  static T toValue(const std::string&amp; src);
};
//----&lt; convert t to a string &gt;----------------------------

template &lt;typename T&gt;
std::string Converter&lt;T&gt;::toString(const T&amp; t) {
  std::ostringstream out;
  out &lt;&lt; t;
  return out.str();
}
//----&lt; convert a string to an instance of T &gt;-------------
/*
*  - the string must have been generated by 
*    Converter&lt;T&gt;::toString(const T&amp; t)
*  - T::operator>> must be the inverse of T::operator&lt;&lt;
*/
template&lt;typename T&gt;
T Converter&lt;T&gt;::toValue(const std::string&amp; src) {
  std::istringstream in(src);
  T t;
  in &gt;&gt; t;
  return t;
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code</defn-head>
        <defn-code>
title("test std::string Converter&lt;T&gt;::toString(T)");

std::string conv1 = Converter&lt;double&gt;::toString(3.1415927);
std::string conv2 = Converter&lt;int&gt;::toString(73);
std::string conv3 = 
  Converter&lt;std::string&gt;::toString("a_test_string plus more");

std::cout &lt;&lt; "\n  Converting from values to strings: ";
std::cout &lt;&lt; conv1 &lt;&lt; ", " &lt;&lt; conv2 
          &lt;&lt; ", " &lt;&lt; conv3;
putline();

title("test T Converter&lt;T&gt;::toValue(std::string)");

std::cout &lt;&lt; "\n  Converting from strings to values: ";
std::cout &lt;&lt; Converter&lt;double>::toValue(conv1) &lt;&lt; ", ";
std::cout &lt;&lt; Converter&lt;int>::toValue(conv2) &lt;&lt; ", ";
std::cout &lt;&lt; Converter&lt;std::string>::toValue(conv3);
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
 test std::string Converter<T>::toString(T)
--------------------------------------------
 Converting from values to strings: 
  3.14159, 73, a_test_string plus more

 test T Converter<T>::toValue(std::string)
-------------------------------------------
 Converting from strings to values: 
   3.14159, 73, a_test_string
        </defn-code>
      </defn-block>
    </defn-outerBlock>  </details>
  <t-b>
    <c-s>Converter</c-s> is simple because it uses <c-s>std::ostringstream</c-s> to convert from
    values to their string representation, and it uses <c-s>std::istringstream</c-s> to convert back.
    Thus, the std::stringstream library classes do all the heavy lifting.
  </t-b>
  <t-b>
    The second example, found in the StringUtilities folder, presents string utility functions 
    <c-s>trim</c-s> and <c-s>split</c-s> with capabilities similar those in the C# string class.
  </t-b>
  <details>
    <summary class="labelStyle darkItem">String Utilities</summary>
    <s-halfEm></s-halfEm>
    <defn-outerBlock>
      <defn-block>
        <defn-head>String Utilities Code</defn-head>
        <defn-code>
/*
*  - remove whitespace from front and back of string argument
*  - does not remove newlines
*/
template &lt;typename T&gt;
inline std::basic_string&lt;T&gt; trim(
const std::basic_string&lt;T&gt;& toTrim
) {
  if (toTrim.size() == 0)
    return toTrim;
  std::basic_string&lt;T&gt; temp;
  std::locale loc;
  typename std::basic_string&lt;T&gt;::const_iterator iter =
  toTrim.begin();
  while (isspace(*iter, loc) && *iter != '\n')
  {
    if (++iter == toTrim.end())
    {
      break;
    }
  }
  for (; iter != toTrim.end(); ++iter)
  {
    temp += *iter;
  }
  typename std::basic_string&lt;T&gt;::reverse_iterator riter;
  size_t pos = temp.size();
  for (riter = temp.rbegin(); riter != temp.rend(); ++riter)
  {
    --pos;
    if (!isspace(*riter, loc) || *riter == '\n')
    {
      break;
    }
  }
  if (0 &lt;= pos && pos &lt; temp.size())
    temp.erase(++pos);
  return temp;
}

/*---
  split sentinel separated strings into vector of trimmed strings
---*/

template &lt;typename T&gt;
inline std::vector&lt;std::basic_string&lt;T&gt;&gt; split(
  const std::basic_string&lt;T&gt;& toSplit, T splitOn = ','
) {
  std::vector&lt;std::basic_string&lt;T&gt;&gt; splits;
  std::basic_string&lt;T&gt; temp;
  typename std::basic_string&lt;T&gt;::const_iterator iter;
  for (iter = toSplit.begin(); iter != toSplit.end(); ++iter)
  {
    if (*iter != splitOn)
    {
      temp += *iter;
    }
    else
    {
      splits.push_back(trim(temp));
      temp.clear();
    }
  }
  if (temp.length() &gt; 0)
    splits.push_back(trim(temp));
  return splits;
}
/*--- show collection of string splits ----------------------*/

template &lt;typename T&gt;
inline void showSplits(
  const std::vector&lt;std::basic_string&lt;T&gt;&gt;& splits,
  std::ostream& out = std::cout
) {
  out &lt;&lt; "\n";
  for (auto item : splits)
  {
    if (item == "\n")
      out &lt;&lt; "\n--" &lt;&lt; "newline";
    else
      out &lt;&lt; "\n--" &lt;&lt; item;
  }
  out &lt;&lt; "\n";
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code</defn-head>
        <defn-code>
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include "StringUtilities.h"
#include "../CodeUtilities/CodeUtilities.h"

#ifdef TEST_STRINGUTILITIES

using namespace Utilities;

int main()
{
  Title("Testing Utilities Package");
  putline();

  title("test split(std::string, ',')");

  std::string test = 
    "a, \n, bc, de, efg, i, j k lm nopq rst";
  std::cout &lt;&lt; "\n  test string = " 
            &lt;&lt; test;

  std::vector&lt;std::string&gt; result = 
    split(test);
  showSplits(result);

  title("test split(std::string, ' ')");

  std::cout &lt;&lt; "\n  test string = " 
            &lt;&lt; test;

  result = split(test, ' ');
  showSplits(result);

  putline(2);
  return 0;
}
#endif
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
  Testing Utilities Package
 ===========================

  test split(std::string, ',')
  ------------------------------
  test string = a,
  , bc, de, efg, i, j k lm nopq rst

  --a
  --newline
  --bc
  --de
  --efg
  --i
  --j k lm nopq rst

  test split(std::string, ' ')
  ------------------------------
  test string = a,
  , bc, de, efg, i, j k lm nopq rst

  --a,
  --
  ,
  --bc,
  --de,
  --efg,
  --i,
  --j
  --k
  --lm
  --nopq
  --rst
        </defn-code>
      </defn-block>
    </defn-outerBlock>  </details>
  <t-b>
    For our last template function example, the table below shows how to create 
    <span class="notice">generic lambdas</span>.
    They are defined using auto parameters, as shown.  This is equivalent to a 
    template function, but doesn&apos;t use template syntax.  That it is generic is
    due to type deduction generated for the auto declarator.
    <s-1em></s-1em>
    <defn-outerBlock>
      <defn-block>
        <defn-head>
          Generic Lambda Code
        </defn-head>
        <defn-code>
  auto genericLambda = [](auto arg) {
    std::cout << "\n  the type of genericLambda's arg is: " 
              << typeid(arg).name();
    std::cout << "\n  arg's value is: " << arg;
  };
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code</defn-head>
        <defn-code>
  displaySubtitle("Demo generic lambda");
  genericLambda(double{ 3.5 });
  genericLambda("this is a string");
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
  Demo generic lambda
 ---------------------
  the type of genericLambda's arg is: double
  arg's value is: 3.5
  the type of genericLambda's arg is: char const *
  arg's value is: this is a string
        </defn-code>
      </defn-block>
    </defn-outerBlock>
  </t-b>
  <t-b>
    We will look at template functions again, in Chapter #7 - Template Metaprogramming, where we explore
    some of the functions used to provide displays for code demonstrations throughout this story.
  </t-b>
  <s-halfEm></s-halfEm>

  <hr class="spread" />
  <num-cont>
    <num-item1>6.4</num-item1><num-item4>Template Classes</num-item4>
  </num-cont>
  <t-b>
    Template classes use syntax as shown in the blocks below.  Everywhere that the class name <c-s>SynDemo</c-s> is used
    as a type it needs the template parameter, e.g., <c-s>SynDemo&lt;T&gt;</c-s>.
  </t-b>
  <t-b>
    Remember that both template declarations <span class="notice">and</span>
    definitions must appear in the class&apos;s header file, as shown below.
    <s-halfEm></s-halfEm>
    <defn-outerblock>
      <defn-block>
        <defn-head>Template Code in SynDemo.h</defn-head>
        <defn-code>
namespace Chap6 {

  template&lt;typename T&gt;
  class SynDemo {
  public:
    void value(T t);
    T value();
  private:
    T t_;
  };

  template&lt;typename T&gt;
  void SynDemo&lt;T&gt;::value(T t) {
    t_ = t;
  }

  template&lt;typename T&gt;
  T SynDemo&lt;T&gt;::value() {
    return t_;
  }
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code in Demo.cpp</defn-head>
        <defn-code>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include "../Display/Display.h"
#include "SynDemo.h"

int main() {

  displayTitle("Demonstrating Template Syntax");

  using namespace Chap6;

  SynDemo&lt;std::string&gt; sd;
  sd.value("hello world");
  std::cout &lt;&lt; "\n  " &lt;&lt; sd.value();
  putline(2);
}
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
  Demonstrating Template Syntax
 ===============================

  hello world

        </defn-code>
      </defn-block>
    </defn-outerblock>
  </t-b>
  <s-halfEm></s-halfEm>
  <t-b>
    The <c-s>Stack&lt;T&gt;</c-s> class example, below, illustrates this syntax
    for a class typical of professionally developed code.  It also illustrates:
    <ol class="tight">
      <li>
        <strong>Template members:</strong><br />
        A copy constructor <c-s>template &lt;class U&gt; stack(const stack&lt;U&gt;&);</c-s> and
        assignment operator 
        <c-s>template &lt;class U&gt; stack&lt;U&gt;&amp; operator=(const stack&lt;U&gt;&);</c-s>
        are declared as methods with a potentially different type <c-s>U</c-s>.  That could be
        the same as <c-s>T</c-s>, providing the usual copy and assignment operations, but could
        also be different, allowing one, for example, to assign a <c-s>stack&lt;int&gt;</c-s> to a 
        <c-s>stack&lt;double&gt;</c-s>. The example code illustrates that use. Template type inference
        is the reason we can design this flexibility.
      </li>
      <li>
        <strong>Inner classes:</strong><br />
        Inner classes aren&apos;t often used for C++ programs, but if a parent class needs
        services of a small and simple class that is specialized for the parent, then using an
        inner class for the child makes sense.  The <c-s>struct stacknode</c-s> is an example
        of that use.
      </li>
      <li>
        <strong>Friend relationships:</strong><br />
        We try to avoid using <c-s>friend</c-s> relationships because they expand encapsulation
        from the granting class to include friends as well.  However, when needed it&apos;s
        easy to use, as shown here.  This <c-s>stack&lt;T&gt;</c-s> class needs to allow
        template members, cited in the first item, to access its private data. That&apos;s because
        <c-s>stack&lt;T&gt;</c-s> is a different class than <c-s>stack&lt;U&gt;</c-s>.
      </li>
    </ol>
  </t-b>
  <t-b>
    This example was adapted from one presented in Effective C++, by Scott Meyers.
  </t-b>
  <t-b>
    <details>
      <summary class="labelStyle darkItem">Stack Class</summary>
      <s-halfEm></s-halfEm>
      <defn-outerBlock>
      <defn-block>
        <defn-head>Stack Code</defn-head>
        <defn-code>
template&lt;class T&gt; class stack {

  template &lt;class U&gt; friend class stack;

  private:
    struct stacknode {
      T data;
      stacknode *next;
      stacknode(const T&amp; newdata, stacknode *nextnode)
	       : data(newdata), next(nextnode) { }
    };
    stacknode *top;
  public:
    stack();
    ~stack();
    void push(const T&amp; object);
    T pop(void);
    void flush();
    int size() const;
    
    // member templates

    template &lt;class U&gt; stack(const stack&lt;U&gt;&amp;);
    template &lt;class U&gt; stack&lt;T&gt;&amp; operator=(const stack&lt;U&gt;&amp;);
};

//
//----&lt; void constructor &gt;---------------------------------

template&lt;class T&gt; stack&lt;T&gt;::stack() : top(0) { }

//----&lt; destructor &gt;---------------------------------------

template &lt;class T&gt; stack&lt;T&gt;::~stack(void) {

  while (top) {
    stacknode *next_to_die = top;
    top = top-&gt;next;
    delete next_to_die;
  }
}
//----&lt; push data onto stack &gt;-----------------------------

template&lt;class T&gt; void stack&lt;T&gt;::push(const T &amp;object) {
  top = new stacknode(object, top);
}
//----&lt; pop data from stack &gt;------------------------------

template &lt;class T&gt; T stack&lt;T&gt;::pop(void) {

  if (!top) {
    throw std::out_of_range(
      "\n  attempt to pop empty stack\n"
    );
  }
  stacknode *save = top;
  top = top-&gt;next;
  T data = save-&gt;data;
  delete save;
  return data;
}
//----&lt; empty stack &gt;--------------------------------------

template &lt;class T&gt; void stack&lt;T&gt;::flush()
{
  stacknode* node = top;
  while(node)
  {
    stacknode *next_to_die = node;
    node = node-&gt;next;
    delete next_to_die;
  }
}
//----&lt; return number of elements on stack &gt;---------------

template &lt;class T&gt; int stack&lt;T&gt;::size() const
{
  stacknode* node = top;
  int count = 0;
  while(node)
  {
    count++;
    node = node-&gt;next;
  }
  return count;
}
//
//--&lt; copy and promotion constructor, a member template &gt;--

template &lt;class T&gt; 
template &lt;class U&gt; 
stack&lt;T&gt;::stack(const stack&lt;U&gt;&amp; s) : top(0)
{
  stack&lt;U&gt;::stacknode* node = 
    const_cast&lt;stack&lt;U&gt;::stacknode*&gt;(s.top);
  while(node)
  {
    this-&gt;push(node-&gt;data);
    node = node-&gt;next;
  }
}
//--&lt; assignment from stack of possibly a compatible type &gt;--

template &lt;class T&gt; 
template &lt;class U&gt; 
stack&lt;T&gt;&amp; stack&lt;T&gt;::operator=(const stack&lt;U&gt;&amp; s)
{
  if((void*)this == (void*)&amp;s)
    return *this;

  flush();
  stack&lt;U&gt;::stacknode* node2 = 
    const_cast&lt;stack&lt;U&gt;::stacknode*&gt;(s.top);
  while(node2)
  {
    this-&gt;push(static_cast&lt;T&gt;(node2-&gt;data));
    node2 = node2-&gt;next;
  }
  return *this;
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code</defn-head>
        <defn-code>
#include &lt;iostream&gt;
#include "stack.h"
using namespace std;

template &lt;class T&gt; void print_field(T t) {

  cout.width(10);
  cout &lt;&lt; t;
}
//----&lt; test stub &gt;--------------------------------------
void main() {

  cout &lt;&lt; "\nTesting Template Based Stack Class\n";

  try
  {
    stack&lt;int&gt;    int_stack;
    stack&lt;double&gt; double_stack;

    int    x=1,    y=2,   z=3;
    double u=-1.5, v=0.5, w=2.5;

    cout &lt;&lt; "\n  pushing stack: "; 
    print_field(x); int_stack.push(x);
    cout &lt;&lt; "\n  pushing stack: "; 
    print_field(y); int_stack.push(y);
    cout &lt;&lt; "\n  pushing stack: "; 
    print_field(z); int_stack.push(z);
    cout &lt;&lt; endl;
    cout &lt;&lt; "\n  stack size = " 
         &lt;&lt; int_stack.size() &lt;&lt; endl;

    stack&lt;double&gt; copyStack = int_stack;
    // copy construction with data conversion

    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int_stack.pop());
    cout &lt;&lt; "\n";

    cout &lt;&lt; "\n  stack size = " 
         &lt;&lt; int_stack.size() &lt;&lt; endl;

    cout &lt;&lt; "\n  popping double copy of int stack:";
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(copyStack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(copyStack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(copyStack.pop());
    cout &lt;&lt; "\n";

    cout &lt;&lt; "\n  pushing stack: ";
    print_field(u); double_stack.push(u);
    cout &lt;&lt; "\n  pushing stack: "; 
    print_field(v); double_stack.push(v);
    cout &lt;&lt; "\n  pushing stack: "; 
    print_field(w); double_stack.push(w);
    cout &lt;&lt; endl;

    stack&lt;int&gt; int2_stack;
    int2_stack = double_stack;  
    // assignment with data conversion

    cout &lt;&lt; "\n  popping stack: "; 
    print_field(double_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(double_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(double_stack.pop());
    cout &lt;&lt; "\n";

    cout &lt;&lt; "\n  popping int copy of double stack:";
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int2_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int2_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int2_stack.pop());
    cout &lt;&lt; "\n";

    int2_stack.pop(); // popping empty stack

    cout &lt;&lt; "\n\n";
  }
  catch(exception&amp; ex)
  {
    cout &lt;&lt; "\n  " &lt;&lt; ex.what() &lt;&lt; endl;
  }
  catch(...)
  {
    cout &lt;&lt; "\n  stack error\n\n";
  }
}
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
Testing Template Based Stack Class

  pushing stack:          1
  pushing stack:          2
  pushing stack:          3

  stack size = 3

  popping stack:          3
  popping stack:          2
  popping stack:          1

  stack size = 0

  popping double copy of int stack:
  popping stack:          1
  popping stack:          2
  popping stack:          3

  pushing stack:       -1.5
  pushing stack:        0.5
  pushing stack:        2.5

  popping stack:        2.5
  popping stack:        0.5
  popping stack:       -1.5

  popping int copy of double stack:
  popping stack:         -1
  popping stack:          0
  popping stack:          2


  attempt to pop empty stack
        </defn-code>
      </defn-block>
      </defn-outerBlock>
    </details>
  </t-b>
  <t-b>
    You won&apos;t use this class for your own designs.  The Standard Template Library (STL) provides
    a stack adapter class<sup>1</sup> and C++ developers know how that works, so you should use it.
    The STL provides a rich set of examples of template classes including one for each of the STL
    containers.  You will find a demonstration of each of them in 
    <a href="STL-Containers.html">STL-Containers.html</a> in the Demonstrations part of the
    <a href="CppRepositories.html">CppRepositories.html</a>.
  </t-b>
  <hr class="spreadup" />
  <ol class="footnote">
    <li>
      There are two STL adapters, <c-s>stack&lt;T&gt;</c-s> and <c-s>queue&lt;T&gt;</c-s>. These were
      built as adapters, wrapping by default the <c-s>deque&lt;T&gt;</c-s>, because they intent to provide
      access only to the top for the <c-s>stack</c-s> and ends for the <c-s>queue</c-s>. That behavior
      voilates the model for STL container classes that provide iteration over entire container
      contents.
    </li>
  </ol>
  <hr class="spread" />
  <num-cont>
    <num-item1>6.5</num-item1><num-item4>Template Parameters</num-item4>
  </num-cont>
  <t-b>
    Template parameters may be:
    <ol class="tight">
      <li>
        <strong>Type Parameters:</strong>
        <i-b>
          <c-s>typename TypeName [= defaultTypeName]</c-s><br />
          TypeName is a formal parameter that represents an unspecified struct or class<br />
          defaultTypeName is the name of a class or struct.<br />
          Example: <c-s>template&lt;typename X=std::string&gt; class Y { ... };</c-s>
        </i-b>
      </li>
      <li>
        <strong>Template type parameters:</strong>
        <i-b>
          <c-s>typename TypeName, template&lt;class TypeName&gt; class TemplateTypeName</c-s><br />
          TemplateTypeName is a formal parameter that represents an unspecified template struct or class<br />
          Example: <c-s>template&lt;typename C, template &lt;class C&gt; class X&gt; class Y { ... };</c-s><br />
          This specifies that <c-s>X</c-s> is a template class that has the parameter <c-s>C</c-s>,
          e.g., the second parameter <c-s>X</c-s> is templated on the first parameter <c-s>C</c-s>.
        </i-b>
      </li>
      <li>
        <strong>Value parameters:</strong>
        <i-b>
          <c-s>Type [= value]</c-s><br />
          Example: <c-s>size_t N = 10</c-s><br />
          <c-s>template&lt;size_t N=10> class Array { ... };</c-s><br />
          This specifies that the templated class uses <c-s>N</c-s> with value <c-s>10</c-s> unless 
          specified otherwise.
        </i-b>
      </li>
    </ol>
  </t-b>
  <t-b>
    In the Logger class example, below, <c-s>Logger</c-s> takes a template parameter <c-s>T</c-s>, 
    the type of message being logged, and parameter type <c-s>C</c-s>, representing a logger category. 
    <c-s>Logger</c-s> uses its <c-s>C</c-s> parameter to define a logging level, e.g., debug or 
    demonstration or results or some combination of the three. For <c-s>Logger</c-s> the <c-s>C</c-s>
    represents an initial value for its logging level.  That may be changed at run-time.
  </t-b>
  <t-b>
    <details>
      <summary class="labelStyle darkItem">Logger Class</summary>
      <s-halfEm></s-halfEm>
      <defn-outerBlock>
      <defn-block>
        <defn-head>Logger Code</defn-head>
        <defn-code>
namespace Utilities {
  
  enum Level { results = 1, demo = 2, debug = 4, all = 7 };

  template &lt;typename T, size_t C = 0&gt;
  struct ILogger {
    virtual ~ILogger() {}
    virtual ILogger&lt;T, C&gt;&amp; add(std::ostream*) = 0;
    virtual ILogger&lt;T, C&gt;&amp; 
    write(T t, size_t level = Level::all) = 0;
    virtual void head(T t = "") = 0;
    virtual void prefix(T prfix = "\n  ") = 0;
    virtual void wait() = 0;
    virtual void waitForWrites() = 0;
    virtual void level(size_t lv) = 0;
    virtual void name(const std::string&amp; nm) = 0;
  };

  template &lt;typename T, size_t C = 0&gt;
  class Logger : public ILogger&lt;T, C&gt; {
  public:
    Logger(const std::string&amp; nm = "");
    ~Logger();
    ILogger&lt;T, C&gt;&amp; add(std::ostream* pOstrm);
    virtual ILogger&lt;T, C&gt;&amp; 
    write(T t, size_t level = 0x7);
    virtual void head(T t = "");
    virtual void prefix(T prfix = "\n  ");
    virtual void level(size_t lv);
    void name(const std::string&amp; nm);
    std::string name();
    void wait();
    void waitForWrites();
  protected:
    std::vector&lt;std::ostream*&gt; dstStrm;
    BlockingQueue&lt;T&gt; blockingQueue_;
    void threadProc();
    std::string name_;
    std::thread writeThread_;
    T head_;
    std::string prefix_ = "\n  ";
    size_t level_ = 
      0x7; // Level::debug + Level::demo + Level::results;
  };
  /*--- object factory --------------------------------------
   *
   *  Creates static logger, so calling makeLogger with
   *  the same value for C will use the same logger.
   */
  template&lt;typename T, size_t C&gt;
  inline ILogger&lt;T, C&gt;&amp; makeLogger() {
    static Logger&lt;T, C&gt; logger;
    return logger;
  }
  /*--- initialize logger with name -----------------------*/

  template&lt;typename T, size_t C&gt;
  Logger&lt;T, C&gt;::Logger(const std::string&amp; nm) : name_(nm) {
    dstStrm.push_back(&amp;std::cout);
    std::thread temp(&amp;Logger&lt;T, C&gt;::threadProc, this);
    writeThread_ = std::move(temp);
  }
  /*--- wait for all writes to be sent --------------------*/

  template&lt;typename T, size_t C&gt;
  Logger&lt;T, C&gt;::~Logger() {
    if (writeThread_.joinable())
      writeThread_.detach();
    for (auto ptrStrm : dstStrm) {
      std::ofstream* ptrOfStrm = 
        dynamic_cast&lt;std::ofstream*&gt;(ptrStrm);
      if (ptrOfStrm) {
        ptrOfStrm-&gt;close();
        delete ptrOfStrm;
      }
    }
  }
  /*--- reset name ----------------------------------------*/

  template&lt;typename T, size_t C&gt;
  void Logger&lt;T, C&gt;::name(const std::string&amp; nm) {
    name_ = nm;
  }
  /*--- retrieve name -------------------------------------*/

  template&lt;typename T, size_t C&gt;
  std::string Logger&lt;T, C&gt;::name() {
    return name_;
  }
  /*--- deQ thread processing -----------------------------*/

  template&lt;typename T, size_t C&gt;
  void Logger&lt;T,C&gt;::threadProc() {
    while (true) {
      T t = blockingQueue_.deQ();
      if (t == "quit")
        break;
      for (auto item : dstStrm) {
        (*item) &lt;&lt; t;
      }
    }
  }
  /*--- enQ stop message, wait for write thread exit ------*/

  template&lt;typename T, size_t C&gt;
  void Logger&lt;T, C&gt;::wait() {
    blockingQueue_.enQ("quit");
    writeThread_.join();
  }
  /*--- wait for Q to empty before writing again ----------*/

  template&lt;typename T, size_t C&gt;
  void Logger&lt;T, C&gt;::waitForWrites() {
    while (blockingQueue_.size() &gt; 0)
      std::this_thread::sleep_for(std::chrono::milliseconds(20));
  }
  /*--- add another stream for concurrent writes ----------*/

  template&lt;typename T, size_t C&gt;
  ILogger&lt;T, C&gt;&amp; 
  Logger&lt;T, C&gt;::add(std::ostream* pOstrm) {
    if(pOstrm != nullptr)
      dstStrm.push_back(pOstrm);
    return *this;
  }
  /*---------------------------------------------------------
  *  write a log message
  *  - probably one of many in a log stream
  */

  template&lt;typename T, size_t C&gt;
  ILogger&lt;T, C&gt;&amp; 
  Logger&lt;T, C&gt;::write(T t, size_t lv) {
    if (lv &amp; level_) {
      blockingQueue_.enQ(prefix_ + t);
    }
    return *this;
  }
  /*---------------------------------------------------------
   *  write a head message
   *  - expected to be the first in a log conversation
   */
  template&lt;typename T, size_t C&gt;
  void Logger&lt;T, C&gt;::head(T t) {
    T temp = (t.size() &gt; 0) ? t : name();
    T prfix = (prefix_ == "") ? "\n" : prefix_;
    head_ = temp + prfix + DateTime().now();
    write(head_);
  }
  /*--- set message prefix --------------------------------*/

  template&lt;typename T, size_t C&gt;
  void Logger&lt;T,C&gt;::prefix(T prfix) {
    prefix_ = prfix;
  }
  /*---------------------------------------------------------
   *  set logging level
   *  - results ==&gt; normal output
   *  - demo    ==&gt; demonstration output
   *  - debug   --&gt; show debugging information
   *  can be any combination, e.g., demo + results
   */
  template&lt;typename T, size_t C&gt;
  void Logger&lt;T, C&gt;::level(size_t lv) {
    level_ = lv;
  }
  /*--- helper to open file stream ------------------------*/

  inline std::ostream* makeStream(
    const std::string&amp; fileName
  ) {
    std::ofstream* pOfstrm = new std::ofstream;
    pOfstrm-&gt;open(fileName);
    if (pOfstrm-&gt;good())
      return pOfstrm;
    else
      return nullptr;
  }
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code</defn-head>
        <defn-code>
#include &lt;string&gt;
#include "Logger.h"

int main() {

  displayTitle("Testing Logger");
  using namespace Utilities;

  Logger&lt;std::string&gt; logger("test");

  // to see logger demo own test stub comment out next statement
  logger.level(Level::results);
  logger.write("-- constructed logger --\n", Level::demo);
  logger.add(makeStream("test.log"));
  logger.write("\n -- added stream --\n", Level::demo);
  logger.add(makeStream("does not exist"));
  //logger.prefix("  ");
  logger.head();
  logger.write("\n -- called head --\n", Level::demo);
  logger.prefix("");
  logger.write("\n -- called write --\n", Level::demo);
  logger.write("\n  Hi ").write("there ");
  logger.write("from Logger.cpp");
  logger.write("\n");
  logger.write(
    "\n -- waiting for writes to complete --\n", Level::demo
  );
  logger.waitForWrites();

  logger.write("\n  setting level = results");
  logger.level(Level::results);
  logger.write("\n  a debug msg", Level::debug);
  logger.write("\n  a demo", Level::demo);
  logger.write("\n  a result", Level::results);
  logger.write(
    "\n -- waiting for writes to complete --\n", Level::demo
  );
  logger.waitForWrites();

  logger.write("\n  setting level = demo");
  logger.level(Level::demo);
  logger.write("\n  a debug msg", Level::debug);
  logger.write("\n  a demo", Level::demo);
  logger.write("\n  a result", Level::results);
  logger.waitForWrites();

  logger.write("\n  setting level = debug");
  logger.level(Level::debug);
  logger.write("\n  a debug msg", Level::debug);
  logger.write("\n  a demo", Level::demo);
  logger.write("\n  a result", Level::results);
  logger.waitForWrites();

  logger.write("\n  setting level = results + demo");
  logger.level(Level::results + Level::demo);
  logger.write("\n  a debug msg", Level::debug);
  logger.write("\n  a demo", Level::demo);
  logger.write("\n  a result", Level::results);
  logger.waitForWrites();
  
  // to see logger demo own test stub comment out next statement
  logger.level(Level::results);
  logger.write("\n -- calling makeLogger factory --\n", Level::demo);
  ILogger&lt;std::string, 0&gt;&amp; logInstance =
    makeLogger&lt;std::string, 0&gt;();
  logInstance.add(makeStream("staticlog.log"));
  logInstance.head("test logger factory");
  logInstance.write("log msg #1").write("log msg #2");
  
  ILogger&lt;std::string, 0&gt;&amp; logInstance2 = 
    makeLogger&lt;std::string, 0&gt;();
  logInstance2.head("test 2nd instance of logger factory");
  logInstance2.write("log2 msg #1").write("log2 msg #2");
  logInstance2.write("log2 msg #3").write("log2 msg #4");

  const auto&amp; logFactory = 
    []()-&gt;ILogger&lt;std::string,0&gt;&amp; { 
      return makeLogger&lt;std::string, 0&gt;(); 
  };
  logFactory().write("\n  using makeLogger");

  logger.wait();
  logInstance.write("\n  done waiting for logger");
  logInstance.wait();
  putline();
  
  displaySubtitle("Testing Assertions");

  Assert(true, "if you see this Assert raised with true pred");
  Assert(false, "a message", __LINE__);
  try {
    Assert(false, "another message", __LINE__, true);
  }
  catch (std::exception &amp; ex) {
    std::cout &lt;&lt; std::string("\n  ") + ex.what();
  }
  putline();
  Requires(1 == 1, "1 == 1", __LINE__);
  Requires(1 == 2, "1 == 2", __LINE__);
  try {
    Requires(1 == 3, "1 == 3", __LINE__, true);
  }
  catch (std::exception &amp; ex) {
    std::cout &lt;&lt; std::string("\n  ") + ex.what();
  }
  putline();
  Ensures(1 == 1, "1 == 1", __LINE__);
  Ensures(1 == 2, "1 == 2", __LINE__);
  try {
    Ensures(1 == 3, "1 == 3", __LINE__, true);
  }
  catch (std::exception &amp; ex) {
    std::cout &lt;&lt; std::string("\n  ") + ex.what();
  }
  putline(2);
}        
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
  test
  Wed Dec  4 08:20:27 2019
  Hi there from Logger.cpp

  setting level = results
  a result
  setting level = demo
  a demo
  setting level = debug
  a debug msg
  setting level = results + demo
  a demo
  a result
        </defn-code>
      </defn-block>
      </defn-outerBlock>
    </details>
  </t-b>
  <t-b>
    The Template Functors code example, below, has a global function <c-s>Traverse</c-s> that is
    defined with a template parameter, <c-s>C</c-s>, and a template template parameter, 
    <c-s>X&lt;C&gt;</c-s>:
    <i-b class="pad5">
      <c-s>
  template &lt;class C, template &lt;class C&gt; class X&gt;<br />
  void tranverse(<br />
    &nbsp;&nbsp;typename C::iterator&amp; Begin, typename C::iterator&amp; End,<br />
    &nbsp;&nbsp;X&lt;C&gt;&amp; x,<br />
    &nbsp;&nbsp;void(X&lt;C&gt;::*fptr)(typename C::iterator&amp;)<br />
  ) {<br />
    &nbsp;&nbsp;...<br />
  }
      </c-s>
    </i-b>
    where <c-s>C</c-s> represents an STL container, and <c-s>X</c-s> is a function
    object that operates on <c-s>C</c-s> in a way specified by the application that defines
    <c-s>X&lt;C&gt;</c-s>.
  </t-b>
  <t-b>
    <details>
      <summary class="labelStyle darkItem">Template Functors</summary>
      <s-halfEm></s-halfEm>
      <defn-outerBlock>
        <defn-block>
          <defn-head>Template Functor Code</defn-head>
          <defn-code>
///////////////////////////////////////////////////////////////
// FunctorsEtc.cpp - Demonstrate Functors, Function Pointers //
//                   with template arguments                 //
//                                                           //
// Jim Fawcett, CSE67 - Object Oriented Design, Spring 2009  //
///////////////////////////////////////////////////////////////

#include &lt;iterator&gt;
#include &lt;string&gt;

// Functor interface, to support substitutability

template &lt;typename C&gt;
struct IFunctor
{
  virtual void operator()(typename C::iterator&amp; iter)=0;
};

// Global funct accepts iterators &amp; base functor reference,
// templatized on a container argument.

template &lt;typename C&gt;
void Traverse(
  typename C::iterator&amp; Begin, typename C::iterator&amp; End,
  IFunctor&lt;C&gt;&amp; funct
)
{
  C::iterator iter;
  for(iter=Begin; iter!=End; ++iter)
    funct(iter);
}

// Global funct accepts iterators &amp; member function pointer
// templatized on a container argument

template &lt;class C, template &lt;class C&gt; class X&gt;
void Traverse(
  typename C::iterator&amp; Begin, 
  typename C::iterator&amp; End, 
  X&lt;C&gt;&amp; x, 
  void(X&lt;C&gt;::*fptr)(typename C::iterator&amp;)
)
{
  C::iterator iter;
  for(iter=Begin; iter!=End; ++iter)
  {
    (x.*fptr)(iter);
  }
}
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>Using Code</defn-head>
          <defn-code>
#include &lt;string&gt;
#include &lt;iostream&gt;

// one possible operation to apply to some container

class aFunctor : public IFunctor&lt;std::string&gt;
{
  void operator()(std::string::iterator&amp; iter)
  {
    std::cout &lt;&lt; *iter &lt;&lt; " ";
  }
};

// template class has member function we will point to

template &lt;typename C&gt;
class X
{
public:
  void doOp(typename C::iterator&amp; iter)
  {
    std::cout &lt;&lt; *iter &lt;&lt; " ";
  }
};

// alias for template function pointer to member

typedef void (X&lt;std::string&gt;::*fptr)(
          std::string::iterator&amp;
        );

void main()
{
  std::string test = 
    "CSE687 - Object Oriented Design";
  
  // testing functor
  aFunctor func;
  std::cout &lt;&lt; "\n  ";
  Traverse(test.begin(), test.end(), func);
  
  // testing function pointer to member

  std::cout &lt;&lt; "\n  ";
  X&lt;std::string&gt; x;
  fptr f = &amp;X&lt;std::string&gt;::doOp;
  Traverse&lt;std::string&gt;(
    test.begin(), test.end(), x, f
  ); 

  // this syntax works too
  
  std::cout &lt;&lt; "\n  ";
  Traverse&lt;std::string&gt;(
    test.begin(), test.end(), 
    x, &amp;X&lt;std::string&gt;::doOp); 

  std::cout &lt;&lt; "\n\n";
}
          </defn-code>
          <defn-head class="defnBorderTop">Output</defn-head>
          <defn-code style="font-size:0.8rem;">
C S E 6 8 7   -   O b j e c t   O r i e n t e d   D e s i g n 
C S E 6 8 7   -   O b j e c t   O r i e n t e d   D e s i g n 
C S E 6 8 7   -   O b j e c t   O r i e n t e d   D e s i g n 
          </defn-code>
        </defn-block>
      </defn-outerBlock>
    </details>
  </t-b>
  <t-b>
    The last example in this section is a Directed Graph class.  You can find the complete code
    in the <a href="CppGraph.html">CppGraph.html</a> repository. A directed graph consists of vertices
    that are connected with directed edges, from parent vertex to child vertex. Graphs are used to
    represent hierarchal relationships, e.g., package dependency or social network friend relationships.
  </t-b>
  <t-b>
    This example is here, because it uses two template parameters, <c-s>V</c-s> and <c-s>E</c-s>, that
    represent information held in each vertex and each edge.  For example, a class dependency graph
    would probably contain a class name in each vertex and a class relationship
    type, e.g., inheritance, composition, aggregation, or using, in each edge.
  </t-b>
  <t-b>
    Before looking at the example, it will help to look at the <a href="CppGraph.html">Graph Documentation</a>
    for the CppGraph repository.  We show diagrams there that will help you understand the code below.
  </t-b>
  <t-b>
  <details>
    <summary class="labelStyle darkItem">Directed Graph Class</summary>
    <s-halfEm></s-halfEm>
    <defn-outerBlock>
    <defn-block>
      <defn-head>Vertex and Graph Code</defn-head>
      <defn-code>
namespace GraphLib 
{
  /////////////////////////////////////////////////////////
  // Vertex class

  template&lt;typename V, typename E&gt; 
  class Vertex
  {
  public:
    typedef std::pair&lt;int, E&gt; Edge;  
    // graph index of target vertex, edge type
    typename typedef std::vector&lt;Edge&gt;::iterator iterator;
    iterator begin();
    iterator end();
    Vertex(V v, size_t id);
    Vertex(V v);
    void add(Edge& edge);
    // compiler generated copy ctor, copy assignOp correct
    // Vertex(const Vertex&lt;V,E&gt;& v);
    // Vertex&lt;V,E&gt;& operator=(const Vertex&lt;V,E&gt;& v);
    Edge& operator[](size_t i);
    Edge operator[](size_t i) const;
    V& value();
    size_t& id(); 
    size_t size();
    bool& mark();
  private:
    std::vector&lt;Edge&gt; _edges;
    V _v;
    size_t _id;
    static size_t count;
    bool _mark;
  };
  //--&lt; reserve memory for, and initialize, static count &gt;--
  template&lt;typename V, typename E&gt;
  size_t Vertex&lt;V,E&gt;::count = 0;

  //--&lt; set and return boolean mark, used for traversal &gt;--
  template&lt;typename V, typename E&gt;
  bool& Vertex&lt;V,E&gt;::mark() { return _mark; }

  //----&lt; return iterator pointing to first edge &gt;---------
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt;::iterator Vertex&lt;V,E&gt;::begin() { 
    return _edges.begin(); 
  }

  //--&lt; return iterator pointing to one past last edge &gt;---
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt;::iterator Vertex&lt;V,E&gt;::end() {
    return _edges.end(); 
  }

  //----&lt; construct instance, specifying unique id &gt;-----
  template&lt;typename V, typename E&gt;
  Vertex&lt;V,E&gt;::Vertex(V v, size_t id) : 
    _v(v), _id(id), _mark(false) {}

  //--&lt; construct instance - creates id sequentially &gt;---
  template&lt;typename V, typename E&gt;
  Vertex&lt;V,E&gt;::Vertex(V v) : 
    _v(v), _id(count++), _mark(false) {}

  //----&lt; add edge to vertex edge collection &gt;-----------
  template&lt;typename V, typename E&gt;
  void Vertex&lt;V,E&gt;::add(Edge& edge) {
    _edges.push_back(edge); 
  }

  //----&lt; index non-const vertex's edges &gt;---------------
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt;::Edge& 
  Vertex&lt;V,E&gt;::operator[](size_t i) { 
    return _edges[i]; 
  }
  
  //----&lt; index const vertex's edges &gt;-------------------
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt;::Edge 
  Vertex&lt;V,E&gt;::operator[](size_t i) const {
    return _edges[i]; 
  }
  
  //---&lt; set and read value of vertex's held type, V &gt;---
  template&lt;typename V, typename E&gt;
  V& Vertex&lt;V,E&gt;::value() { return _v; }
  
  //----&lt; return vertex's id &gt;---------------------------
  template&lt;typename V, typename E&gt;
  size_t& Vertex&lt;V,E&gt;::id() { return _id; }
  
  //----&lt; return number of edges &gt;-----------------------
  template&lt;typename V, typename E&gt;
  size_t Vertex&lt;V,E&gt;::size() { return _edges.size(); }

  ///////////////////////////////////////////////////
  // Graph class

  template&lt;typename V, typename E&gt;
  class Graph
  {
  public:
    typename typedef 
    std::vector&lt; Vertex&lt;V,E&gt; &gt;::iterator iterator;
    iterator begin();
    iterator end();
    // compiler generated copy ctor, copy assignOp correct
    // Graph(const Graph&lt;V,E&gt;& g);
    // Graph&lt;V,E&gt;& operator=(const Graph&lt;V,E&gt;& g);
    Vertex&lt;V,E&gt;& operator[](size_t i);
    Vertex&lt;V,E&gt; operator[](size_t i) const;
    void addVertex(Vertex&lt;V,E&gt; v);
    void addEdge(
      E eval, Vertex&lt;V,E&gt;& parent, 
      Vertex&lt;V,E&gt;& child
    );
    size_t findVertexIndexById(size_t id);
    size_t size();
    template&lt;typename F&gt;
    void dfs(Vertex&lt;V,E&gt;& v, F f);
  private:
    std::vector&lt; Vertex&lt;V,E&gt; &gt; adj;
    std::unordered_map&lt;size_t, size_t&gt; idMap; 
    // id maps to graph index
    template&lt;typename F&gt;
    void dfsCore(Vertex&lt;V,E&gt;& v, F f);
  };
  //----&lt; return iterator pointing to first vertex &gt;-----
  template&lt;typename V, typename E&gt;
  typename Graph&lt;V,E&gt;::iterator Graph&lt;V,E&gt;::begin() { 
    return adj.begin(); 
  }

  //--&lt; return iterator pointing one past last vertex &gt;--
  template&lt;typename V, typename E&gt;
  typename Graph&lt;V,E&gt;::iterator Graph&lt;V,E&gt;::end() { 
    return adj.end(); 
  }
  
  //----&lt; index non-const graph's vertex collection &gt;----
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt;& Graph&lt;V,E&gt;::operator[](size_t i) { 
    return adj[i]; 
  }
 
  //----&lt; index const graph's vertex collection &gt;--------
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt; 
  Graph&lt;V,E&gt;::operator[](size_t i) const { 
    return adj[i]; 
  }
  
  //----&lt; add vertex to graph's vertex collection &gt;------
  template&lt;typename V, typename E&gt;
  void Graph&lt;V,E&gt;::addVertex(Vertex&lt;V,E&gt; v) 
  { 
    adj.push_back(v);
    idMap[v.id()] = adj.size() - 1;
  }
  //----&lt; return number of vertices in graph's coll &gt;----
  template&lt;typename V, typename E&gt;
  size_t Graph&lt;V,E&gt;::size() { return adj.size(); }

  //----&lt; return index of vertex with specified id &gt;-----
  template&lt;typename V, typename E&gt;
  size_t Graph&lt;V,E&gt;::findVertexIndexById(size_t id)
  {
    return idMap[id];
  }
  //----&lt; add edge from parent to child vertices &gt;------
  template&lt;typename V, typename E&gt;
  void Graph&lt;V,E&gt;::addEdge(
    E eVal, Vertex&lt;V,E&gt;& parent, 
    Vertex&lt;V,E&gt;& child
  )
  {
    size_t childIndex = findVertexIndexById(child.id());
    if(childIndex == adj.size())
      throw std::exception("no edge child");
    size_t parentIndex = findVertexIndexById(parent.id());
    if(parentIndex == adj.size())
      throw std::exception("no edge parent");
    Vertex&lt;V,E&gt;::Edge e;
    e.first = childIndex;
    e.second = eVal;
    adj[parentIndex].add(e);
  }
  //---&lt; recursive depth first search with action f &gt;----
  template&lt;typename V, typename E&gt;
  template&lt;typename F&gt;
  void Graph&lt;V,E&gt;::dfsCore(Vertex&lt;V,E&gt;& v, F f)
  {
    f(v);
    v.mark() = true;
    for(auto edge : v)
    {
      if(adj[edge.first].mark() == false)
        dfsCore(adj[edge.first], f);
    }
    for(auto& vert : adj)
    {
      if(vert.mark() == false)
        dfsCore(vert, f);
    }
  }
  //--&lt; depth first srch, clears marks for next srch &gt;---
  template&lt;typename V, typename E&gt;
  template&lt;typename F&gt;
  void Graph&lt;V,E&gt;::dfs(Vertex&lt;V,E&gt;& v, F f)
  {
    dfsCore(v, f);
    for(auto& vert : adj)
      vert.mark() = false;
  }
      </defn-code>
    </defn-block>
    <defn-block>
      <defn-head>Using Code</defn-head>
      <defn-code>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include "Graph.h"
using namespace GraphLib;

typedef Graph&lt;std::string, std::string&gt; graph;
typedef Vertex&lt;std::string, std::string&gt; vertex;
typedef Display&lt;std::string, std::string&gt; display;

void showVert(Vertex&lt;std::string, std::string&gt;& v)
{
  std::cout &lt;&lt; "\n  " &lt;&lt; v.id();
}

template&lt;typename V, typename E&gt;
void TshowVert(Vertex&lt;V,E&gt;& v)
{
  std::cout &lt;&lt; "\n  " &lt;&lt; v.id();
}

#ifdef TEST_GRAPH

int main()
{
  std::cout &lt;&lt; "\n  Testing Graph Library";
  std::cout &lt;&lt; "\n =======================\n";
  try
  {
    std::cout &lt;&lt; "\n  Constructing Graph instance";
    std::cout &lt;&lt; "\n -----------------------------";
    graph g;
    vertex v1("v1");
    vertex v2("v2");
    vertex v3("v3");
    vertex v4("v4");
    vertex v5("v5", 50);
    g.addVertex(v2);
    g.addVertex(v1);
    g.addVertex(v3);
    g.addVertex(v4);
    g.addVertex(v5);
    g.addEdge("e1",v1,v2);
    g.addEdge("e2",v1,v3);
    g.addEdge("e3",v2,v3);
    g.addEdge("e4",v4,v3);
    g.addEdge("e5",v5,v2);

    display::show(g);
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "\n  Making copy of instance";
    std::cout &lt;&lt; "\n -------------------------";
    graph gcopy = g;
    display::show(gcopy);
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "\n  Modifying copy's values";
    std::cout &lt;&lt; "\n -------------------------";
    for(auto& v : gcopy)
      v.value() += "copy";

    display::show(gcopy);
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "\n  Assigning original instance to copy";
    std::cout &lt;&lt; "\n -------------------------------------";
    gcopy = g;
    display::show(gcopy);
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "\n  Vertices with no Parents:";
    std::cout &lt;&lt; "\n ---------------------------";

    std::vector&lt; vertex &gt; verts = 
      display::vertsWithNoParents(g);
    std::cout &lt;&lt; "\n  ";
    for(size_t i=0; i&lt;verts.size(); ++i)
      std::cout &lt;&lt; verts[i].value().c_str() &lt;&lt; " ";
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; 
      "\n  Testing Depth First Search with function pointer";
    std::cout &lt;&lt; 
      "\n --------------------------------------------------";
    for(auto& vert : g)
    {
      std::cout &lt;&lt; "\n  starting at id " &lt;&lt; vert.id();
      g.dfs(vert, TshowVert&lt;std::string, std::string&gt;);
      // this works too: 
      // g.dfs(vert, showVert);
    }
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; 
      "\n  Testing Depth First Search with Functor";
    std::cout &lt;&lt; 
      "\n -----------------------------------------";

    class showFunctor
    {
    public:
      void operator()(Vertex&lt;std::string, std::string&gt;& vert)
      {
        std::cout &lt;&lt; "\n  From functor: vertix id = " 
                  &lt;&lt; vert.id();
        std::cout &lt;&lt; ", number of edges = " 
                  &lt;&lt; vert.size();
      }
    };

    g.dfs(g[0], showFunctor());
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "\n  Testing Serialization to XML";
    std::cout &lt;&lt; "\n ------------------------------";
    std::string str = GraphToXmlString(g);
    std::cout &lt;&lt; str &lt;&lt; "\n";
    std::ofstream out("testGraph.xml");
    out &lt;&lt; str &lt;&lt; "\n";

    std::cout &lt;&lt; 
      "\n  Testing Graph construction from XML";
    std::cout &lt;&lt; 
      "\n -------------------------------------";
    graph gtest;
    GraphFromXmlString(gtest, str);
    display::show(gtest);
    std::cout &lt;&lt; "\n\n";
  }
  catch(std::exception& ex)
  {
    std::cout &lt;&lt; "\n\n  " &lt;&lt; ex.what() 
              &lt;&lt; "\n\n";
  }
  std::cout &lt;&lt; "\n\n";
  return 0;
}

#endif
      </defn-code>
      <defn-head class="defnBorderTop">Output</defn-head>
      <defn-code>
  Testing Graph Library
 =======================

  Constructing Graph instance
 -----------------------------
  vertex id = 1, value = v2
    edge points to vertex with id = 2 and value = v3, edge value = e3
  vertex id = 0, value = v1
    edge points to vertex with id = 1 and value = v2, edge value = e1
    edge points to vertex with id = 2 and value = v3, edge value = e2
  vertex id = 2, value = v3
  vertex id = 3, value = v4
    edge points to vertex with id = 2 and value = v3, edge value = e4
  vertex id = 50, value = v5
    edge points to vertex with id = 1 and value = v2, edge value = e5

  Making copy of instance
 -------------------------
  vertex id = 1, value = v2
    edge points to vertex with id = 2 and value = v3, edge value = e3
  vertex id = 0, value = v1
    edge points to vertex with id = 1 and value = v2, edge value = e1
    edge points to vertex with id = 2 and value = v3, edge value = e2
  vertex id = 2, value = v3
  vertex id = 3, value = v4
    edge points to vertex with id = 2 and value = v3, edge value = e4
  vertex id = 50, value = v5
    edge points to vertex with id = 1 and value = v2, edge value = e5

  Modifying copy's values
 -------------------------
  vertex id = 1, value = v2copy
    edge points to vertex with id = 2 and value = v3copy, edge value = e3
  vertex id = 0, value = v1copy
    edge points to vertex with id = 1 and value = v2copy, edge value = e1
    edge points to vertex with id = 2 and value = v3copy, edge value = e2
  vertex id = 2, value = v3copy
  vertex id = 3, value = v4copy
    edge points to vertex with id = 2 and value = v3copy, edge value = e4
  vertex id = 50, value = v5copy
    edge points to vertex with id = 1 and value = v2copy, edge value = e5

  Assigning original instance to copy
 -------------------------------------
  vertex id = 1, value = v2
    edge points to vertex with id = 2 and value = v3, edge value = e3
  vertex id = 0, value = v1
    edge points to vertex with id = 1 and value = v2, edge value = e1
    edge points to vertex with id = 2 and value = v3, edge value = e2
  vertex id = 2, value = v3
  vertex id = 3, value = v4
    edge points to vertex with id = 2 and value = v3, edge value = e4
  vertex id = 50, value = v5
    edge points to vertex with id = 1 and value = v2, edge value = e5

  Vertices with no Parents:
 ---------------------------
  v1 v4 v5

  Testing Depth First Search with function pointer
 --------------------------------------------------
  starting at id 1
  1
  2
  0
  3
  50
  starting at id 0
  0
  1
  2
  3
  50
  starting at id 2
  2
  1
  0
  3
  50
  starting at id 3
  3
  2
  1
  0
  50
  starting at id 50
  50
  1
  2
  0
  3

  Testing Depth First Search with Functor
 -----------------------------------------
  From functor: vertix id = 1, number of edges = 1
  From functor: vertix id = 2, number of edges = 0
  From functor: vertix id = 0, number of edges = 2
  From functor: vertix id = 3, number of edges = 1
  From functor: vertix id = 50, number of edges = 1

  Testing Serialization to XML
 ------------------------------
&lt;graph&gt;
  &lt;vertex id="1" value="v2"&gt;
    &lt;edge targetId="2" value="e3"&gt;
    &lt;/edge&gt;
  &lt;/vertex&gt;
  &lt;vertex id="0" value="v1"&gt;
    &lt;edge targetId="1" value="e1"&gt;
    &lt;/edge&gt;
    &lt;edge targetId="2" value="e2"&gt;
    &lt;/edge&gt;
  &lt;/vertex&gt;
  &lt;vertex id="2" value="v3"&gt;
  &lt;/vertex&gt;
  &lt;vertex id="3" value="v4"&gt;
    &lt;edge targetId="2" value="e4"&gt;
    &lt;/edge&gt;
  &lt;/vertex&gt;
  &lt;vertex id="50" value="v5"&gt;
    &lt;edge targetId="1" value="e5"&gt;
    &lt;/edge&gt;
  &lt;/vertex&gt;
&lt;/graph&gt;

  Testing Graph construction from XML
 -------------------------------------
  vertex id = 1, value = v2
    edge points to vertex with id = 2 and value = v3, edge value = e3
  vertex id = 0, value = v1
    edge points to vertex with id = 1 and value = v2, edge value = e1
    edge points to vertex with id = 2 and value = v3, edge value = e2
  vertex id = 2, value = v3
  vertex id = 3, value = v4
    edge points to vertex with id = 2 and value = v3, edge value = e4
  vertex id = 50, value = v5
    edge points to vertex with id = 1 and value = v2, edge value = e5
      </defn-code>
    </defn-block>
    </defn-outerBlock>
  </details>
  </t-b>
  <t-b>
    In section 6.6 we discuss template class specialization, a mechanism for providing not only a
    generic pattern for implementing a template class, but also alternate implementations for special
    cases for which the generic pattern may not work well.
  </t-b>
  <hr class="spread" />
  <num-cont>
    <num-item1>6.6</num-item1><num-item4>Template Class Specialization</num-item4>
  </num-cont>
  <div>
    <details>
      <summary class="labelStyle darkItem">Property Class Specialization</summary>
      <s-halfEm></s-halfEm>
      <defn-outerBlock>
        <defn-block>
          <defn-head>Property Example</defn-head>
          <defn-code>
enum class PropertyType { Numeric, SeqContr, AssocContr, Nil };

template&lt;typename T, PropertyType PT = PropertyType::Nil &gt;
class Property {
public:
  Property() : t_{ T() } {}

  Property(const T&amp; t) : t_{ t } {}

  void operator()(const T&amp; t) {
    t_ = t;
  }
  T operator()() {
    return t_;
  }
protected:
  T t_;
};

template&lt;typename T&gt;
class Property&lt;T, PropertyType::Numeric&gt; : public Property&lt;T&gt; {
public:
  Property() {}

  Property(const T&amp; t) : Property&lt;T&gt;{ t } {}

  void operator+=(T t) {
    Property&lt;T&gt;::t_ += t;
  }
  T operator+(T t) {
    return Property&lt;T&gt;::t_ + t;
  }
  void operator-=(const T&amp; t) {
    Property&lt;T&gt;::t_ -= t;
  }
  T operator-(const T&amp; t) {
    return Property&lt;T&gt;::t_ - t;
  }
  void operator*=(const T&amp; t) {
    Property&lt;T&gt;::t_ *= t;
  }
  T operator*(const T&amp; t) {
    return Property&lt;T&gt;::t_ * t;
  }
  void operator/=(const T&amp; t) {
    Property&lt;T&gt;::t_ /= t;
  }
  T operator/(const T&amp; t) {
    return Property&lt;T&gt;::t_ / t;
  }
};

template&lt;typename T&gt;
class Property&lt;T, PropertyType::SeqContr&gt; : public Property&lt;T&gt; {
public:
  using iterator = typename T::iterator;

  Property() {}

  Property(const T&amp; t) : Property&lt;T&gt;{ t } {}

  size_t size() {
    return Property &lt; T&gt;::t_.size();
  }
  typename T::value_type back() {
    return Property &lt; T&gt;::t_.back();
  }
  void push_back(const typename T::value_type&amp; v) {
    Property&lt;T&gt;::t_.push_back(v);
  }
  void pop_back() {
    Property&lt;T&gt;::t_.pop_back();
  }
  typename T::value_type front() {
    return Property &lt; T&gt;::t_.back();
  }
  void push_front(const typename T::value_type&amp; v) {
    Property&lt;T&gt;::t_.push_front(v);
  }
  void pop_front() {
    Property&lt;T&gt;::t_.pop_front();
  }
  iterator insert(iterator iter, const typename T::value_type&amp; v) {
    return Property&lt;T&gt;::t_.insert(iter, v);
  }
  typename iterator erase(iterator iter) {
    return Property&lt;T&gt;::t_.erase(iter);
  }
  iterator begin() {
    return Property&lt;T&gt;::t_.begin();
  }
  iterator end() {
    return Property&lt;T&gt;::t_.end();
  }
};
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>Using Code</defn-head>
          <defn-code>
#include &lt;iostream&gt;
#include &lt;vector&gt;

template&lt;typename T&gt;
using baseProp = Property&lt;T&gt;;

template&lt;typename T&gt;
using numProp = Property&lt;T, PropertyType::Numeric&gt;;

template&lt;typename T&gt;
using seqProp = Property&lt;T, PropertyType::SeqContr&gt;;

template&lt;typename T&gt;
void show(seqProp&lt;T&gt;&amp; prop) {
  std::cout &lt;&lt; "\n  ";
  for (auto item : prop) {
    std::cout &lt;&lt; item &lt;&lt; " ";
  }
}

class Widget {
public:
  void say() {
    std::cout &lt;&lt; "\n  Widget instance here";
  }
};

int main() {

  displayTitle("Demonstrating template class specialization");

  displayDemo("--- basic property of Widget ---");
  baseProp&lt;Widget&gt; wProp;
  wProp().say();
  std::cout &lt;&lt; std::endl;

  /*-- defining class using properties --*/

  class X {
  public:
    numProp&lt;int&gt; iProp;
    numProp&lt;double&gt; dProp;
    seqProp&lt;std::vector&lt;int&gt;&gt; viProp;
  };

  displayDemo("-- Property&lt;int, PropertyType::Numeric&gt; --");
  X x;
  x.iProp(1);
  std::cout &lt;&lt; "\n  x.iProp(1) = " &lt;&lt; x.iProp();
  x.iProp += 3;
  std::cout &lt;&lt; "\n  x.iProp += 3 =&gt; x.iProp = " &lt;&lt; x.iProp();
  x.iProp = -2;
  std::cout &lt;&lt; "\n  x.iProp = -2 =&gt; x.iProp = " &lt;&lt; x.iProp();
  putline();

  displayDemo("-- Property&lt;double, PropertyType::Numeric&gt; --");
  x.dProp(3.14159);
  x.dProp += 1.0;
  x.dProp(3.14159);
  std::cout &lt;&lt; "\n  x.dProp(3.14159) = " &lt;&lt; x.dProp();
  std::cout &lt;&lt; std::endl;

  displayDemo("-- Property&lt;std::vector&lt;int&gt;, PropertyType::SeqContr&gt; --");
  x.viProp.push_back(1);
  x.viProp.push_back(2);
  x.viProp.push_back(3);

  std::cout &lt;&lt; "\n  contents of x.vProp are:";
  show(x.viProp);

  x.viProp.pop_back();
  std::cout &lt;&lt; "\n  after pop_back, contents of x.vProp are:";
  show(x.viProp);
  x.viProp.insert(x.viProp.begin() + 1, -4);
  std::cout &lt;&lt; "\n  after inserting -4 in the second position:";
  show(x.viProp);
  x.viProp.erase(x.viProp.begin() + x.viProp.size() - 1);
  std::cout &lt;&lt; "\n  after erasing last element:";
  show(x.viProp);

  std::cout &lt;&lt; "\n\n";
}
          </defn-code>
          <defn-head>Output</defn-head>
          <defn-code>
  Demonstrating template class specialization
 =============================================

  --- basic property of Widget ---
  Widget instance here

  -- Property&lt;int, PropertyType::Numeric&gt; --
  x.iProp(1) = 1
  x.iProp += 3 => x.iProp = 4
  x.iProp = -2 => x.iProp = -2

  -- Property&lt;double, PropertyType::Numeric&gt; --
  x.dProp(3.14159) = 3.14159

  -- Property&lt;std::vector&lt;int&gt;, PropertyType::SeqContr&gt; --
  contents of x.vProp are:
  1 2 3
  after pop_back, contents of x.vProp are:
  1 2
  after inserting -4 in the second position:
  1 -4 2
  after erasing last element:
  1 -4

          </defn-code>
        </defn-block>
      </defn-outerBlock>
    </details>
  </div>
  </bb-55>
  <spacer-25></spacer-25>
  <indent-blocks>
    <h3>Template Class Specialization:</h3>
    <h3>Variadic Templates</h3>
    <h3>CppProperties</h3>

    <indent-blocks>
    </indent-blocks>
    <spacer-25></spacer-25>
    <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

    <info-bar></info-bar>
</body>
</html>