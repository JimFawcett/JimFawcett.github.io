<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Templates.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>C++ Story-Templates</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesBlueTheme.css" />
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="CppStory_TemplateMetaprog.html">N</a>
  <a id="Prev" href="CppStory_ClassRelationships.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter #6 - C++ Templates</h1>
      <h3 id="subtitle">template functions and classes</h3>
    </hgroup>
  </header>

  <toc-b id="toc">
    <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>
    <a href="#top">Top</a>, <a href="#Templ">Templ</a>, <a href="#TmplFun">Tmpl Fun</a>, 
    <a href="#Overload">Overload</a>, <a href="#TypeCat">Type Cat</a>, 
    <a href="#TypeTran">Type Tran</a>, <a href="#SFINAE">SFINAE</a>, 
    <a href="#FunExpl">Fun Expl</a>, <a href="#TmplClass">Tmpl Class</a>, 
    <a href="#Params">Params</a>, <a href="#ClassSpec">Tmpl Class Spec</a>,
    <a href="#epilog">Epilogue</a>, 
    <a href="#refs">Refs</a>, 
    <a href="Javascript:;" onclick="closeTOC()" style="color:darkred;">Close</a>
    <up-b id="chaps" onmouseout="storyMenu.chaps()">
      <a href="CppStory_Prologue.html">Prologue</a><br />
      <a href="CppStory_Survey.html">Survey</a><br />
      <a href="CppStory_Data.html">Data</a><br />
      <a href="CppStory_Operations.html">Operations</a><br />
      <a href="CppStory_Classes.html">Classes</a><br />
      <a href="CppStory_ClassRelationships.html">ClassRel</a><br />
      <a href="CppStory_Templates.html">Templates</a><br />
      <a href="CppStory_TemplateMetaProg.html">TMP</a><br />
      <a href="CppStory_Libraries.html">Libraries</a><br />
      <a href="CppStory_Interesting.html">Interesting</a>
    </up-b>
  </toc-b>

  <a id="Templ"></a>
  <hr class="spread" />
  <bb-55 class="indent">
  <num-cont>
    <num-item1>6.0</num-item1><num-item4>Templates Prologue</num-item4>
  </num-cont>
  <t-b>
    Templates support building parameterized types and functions that accept an unspecified type which gets 
    resolved only when an application instantiates the code with a concrete type. Parameterized code will 
    accept, without compilation error, arbitrary calls on instances of the template type. When an application 
    instantiates the parameterized code with a concrete type, compilation of the instantiated code succeeds 
    if the type supports specified operations that are used by the application, else it fails.
  </t-b>
  <t-b>
    So there are two C++ template compilation phases:
    <indent-block>
    <ol class="tight">
      <li>
        Compilation of the template library code does a syntax check to identify known errors, but 
        <span class="notice">No object code is generated</span> in this first phase since the type of the 
        template parameter is not specified.
      </li>
      <li>
        Compilation of instantiated application code now has the template argument specification and 
        generates an object file if instantiated syntax is correct, otherwise it fails.
      </li>
    </ol>
    </indent-block>
    Compilation of templates does not include any function or statement that isn&apos;t used.
    This lazy translation is very useful. We compile the template library successfully and defer 
    translation of functions to the second phase.  If the instantiated type has an appropriate method
    compilation succeeds.  If the instantiated type does not have a method used by the template but
    that method is never called, the translation succeeds.  It fails only for called methods that are not
    matched in the instantiated type(s).
  </t-b>
  <t-b>
    An implication of lazy compilation is that all of the template definition code must go in a 
    header file, because the application that uses the template definition has to see all of it's code 
    to compile successfully, and it gets that only by including a header file.
  </t-b>
  <t-b>
    <details class="indent">
      <summary class="labelStyle lightItem">Quick Starter Example - Lazy Template Compilation</summary>
      <s-halfEm></s-halfEm>
    <div class="defnBorderTop defnBorderBottom" style="padding:0em 3em 2em 2em;">
    <t-b>
      <div style="padding-top:0rem; padding-bottom:1rem;">
        &quot;You only pay for what you need&quot;<br />
        - Liberty Mutual advertisement
      </div>
      This example builds two classes: <c-s>Parameter</c-s>, used to provide a
      template parameter, and <c-s>LazyDemo</c-s> which uses that type. 
      The <c-s>LazyDemo&lt;P&gt;</c-s> class
      has two methods: <c-s>LazyDemo&lt;P&gt;::say()</c-s> which calls <c-s>Parameter::say()</c-s> and
      <c-s>LazyDemo&lt;P&gt;::shout()</c-s> which calls <c-s>Parameter::shout()</c-s>.
    </t-b>
    <t-b>
      If we comment out <c-s>Parameter::shout()</c-s>, the code will compile provided that
      it does not call <c-s>LazyDemo::shout()</c-s>, even though <c-s>LazyDemo::shout()</c-s>
      depends on <c-s>Parameter::shout()</c-s>! That&apos;s because a template method that is
      never called won&apos;t be compiled.
    </t-b>
    <t->
      You can demonstrate that for yourself by looking at the project&apos;s assembly code.
      That&apos;s fairly large due to its include files, but you can just search on &quot;shout&quot;
      and discover that it isn&apos;t in the assembly.
    </t->
    <t-b>
      <defn-outerBlock class="indents" style="width:100%;">
      <defn-block>
        <defn-head>Code: Demo of Lazy Template Compil'n</defn-head>
        <defn-code>
class Parameter {
public:
  void say() {
    std::cout << "\n  Parameter here";
  }
  /*-----------------------------------
    when commented out, illustrates lazy
    compilation
   */
  //void shout() {
  //  std::string msg = 
  //    "\n  [very loudly] ";
  //  msg += "Parameter here";
  //  std::cout << msg;
  //}
};

template&lt;typename P&gt;
class LazyDemo {
public:
  void say() {
    std::cout 
      << "\n  LazyDemo here with ";
    p_.say();
  }
  void shout() {
    std::string msg = 
      "\n  [very loudly] ";
    msg += "LazyDemo here with ";
    std::cout << msg;
    <span class="notice">p_.shout();</span>
  }
private:
  P p_;
};
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code</defn-head>
        <defn-code>
int main() {

  displayDemo("-- Lazy Templ Compl --");

  LazyDemo&lt;Parameter&gt; ld;
  ld.say();

  /*-----------------------------------
     Uncommenting next line will cause
     compilation error, because 
     Parameter does not define shout.

     It&apos;s not compiled if it isn&apos;t
     used.
  */
  //ld.shout();

  std::cout << "\n\n";
}
          </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
-- Lazy Templ Compil --
  LazyDemo here with
  Parameter here
        </defn-code>
      </defn-block>
      </defn-outerBlock>
    </t-b>
    <t-b>
      Lazy template compilation is very important.  It allows us to build template classes that,
      for some parameters, may want to call a method on that parameter, but for other parameters
      it still works as long as we don&apos;t call a missing method.
    </t-b>
    <t-b>
      I&apos;ve used this effect in several of the demo codes for this story and other codes
      in the C++ Repository, most notably the
      Property&lt;T&gt; class example, presented later in this chapter.
    </t-b>
    <t-b>
      <defn-block class="indents" style="width:30em;">
        <defn-head>Conclusion:</defn-head>
        <defn-body>
          Lazy template compilation makes template classes very forgiving of their parameter
          types.  If a type doesn&apos;t have a method that&apos;s used for other parameter types,
          that causes no problems as long as we don&apos;t call the missing method.
        </defn-body>
      </defn-block>
    </t-b>
    </div>
    <s-1em></s-1em>
    </details>
  </t-b>
  <t-b>
  C# and Java generics do eagar type checking so many generic operations 
  that would succeed for useful types are not allowed because the compiler can't ensure that they will 
  succeed.  You have to use a constraint that requires the generic class to implement an interface with
  the required method.
  </t-b>

  <a id="TmplFun"></a>
  <hr class="spread" />
  <num-cont>
    <num-item1>6.1</num-item1><num-item4>Template Functions</num-item4>
  </num-cont>
  <t-b>
    <t-b>
      Template function syntax may take one of several forms:
    </t-b>    <defn-outerBlock>
      <defn-block>
        <defn-code>
template&lt;typename T&gt;
void f(T t) { ... }
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-code>
template&lt;class R, class A1, class A2, class A3&gt;
R g(A1 a1, A2& a2, A3&& a3) { ... }
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-code>
template&lt;typename T&gt;
T h() {
  // t &epsilon; T defined in function scope 
  // then returned
}
        </defn-code>
      </defn-block>
    </defn-outerBlock>
    <t-b>
      For the first two forms using code provides arguments and the compiler will infer the types and compile
      a function using those types. In the second form function <c-s>g</c-s> takes arguments: <c-s>a1</c-s> by value,
      <c-s>a2</c-s> by lvalue reference (&amp;), and <c-s>a3</c-s> by rvalue reference (&amp;&amp;).
      In that second form we&apos;ve used &quot;<c-s>class</c-s>&quot; instead of &quot;<c-s>typename</c-s>&quot;.
      Both forms are supported, but <c-s>typename</c-s> is preferred syntax.
    </t-b>
    <t-b>
      Passing by value makes a copy of the argument in the function&apos;s stackframe.  Passing with an lvalue
      reference creates a reference in the function&apos;s stackframe, bound to the argument in the caller&apos;s
      scope.  lvalue references will not bind to non-const temporaries. rvalue references behave like lvalue
      references except that they can bind to a temporary, e.g., an rvalue, and are used most frequently with
      move operations.
    </t-b>
    <t-b>
      For the
      third case, type inference is not possible from the arguments, as there are none, and the compiler does not attempt to
      analyze the body code to figure that out, so we have to help by providing the type we want, as shown
      in the last line of code, below.
    </t-b>
    <defn-outerBlock class="indent">
      <defn-block>
        <defn-code>
int i{ 3 };
f(i);</defn-code>
        <defn-code>
double d{ 3.1415927 };
const std::string s = "a demo string";
int j = g&lt;int&gt;(d, s, 'z');</defn-code>
        <defn-code>
std::string s = h&lt;std::string&gt;();
        </defn-code>
      </defn-block>
    </defn-outerBlock>
  <t-b>
    For the first case the compiler knows the type of <c-s>i</c-s> 
    and will compile <c-s>f</c-s> as if the
    function was defined as:
    <t-b>
      <c-b>  void f(int i) { ... }</c-b>
    </t-b>    and does the same thing with the remaining two cases.
  </t-b>

  <a id="Overload"></a>
  <hr class="spread" />
  <num-cont>
    <num-item1>6.2</num-item1><num-item4>Overloading Template Functions</num-item4>
  </num-cont>
  <t-b>
    Template functions provide generic recipes for their operation.  That is often all we need
    for a program we are implementing.  However, frequently we need to handle a range of types,
    some of which may not compile or operate correctly with the generic pattern.  In those cases we
    look for a function overload that will work correctly.
  </t-b>
  <t-b>
    In the code below, we&apos;ve expanded the <c-s>T max(T t1,T t2)</c-s> example from Chapter #1
    by allowing the two arguments to have different types. That results in some interesting
    processing activities.
  </t-b>
  <t-b>
    Looking at the output of the using code, we see that:
    <i-b>
      <ol class="tight">
        <li>
          In the first use case, the arguments are 4 and 2, each inferred to be int and the generic
          version is compiled for that case.
        </li>
        <li>
          In the second case, the arguments are 3.5, a double, and 2L, a long int. The C++ language
          supports comparing a value of double with an integral value, so the generic template is compiled.
        </li>
        <li>
          For the third case the arguments are 3.5 and 4L. When compared, the 4L is promoted to a double
          with value 4 and that is returned.  Note that the return type is double, not long int.  Since
          there is only one type for the return value, that is inferred to be the more inclusive type.
        </li>
        <li>
          The fourth case matches the overload, and the C++ language guarantees that if an overload
          matches it will be the form compiled.
        </li>
        <li>
          The fifth and last case has arguments of std::string and const char*.  That cannot match the
          overload, but the generic version works correctly.  The string is compared to the const char*
          value by promoting the const char* to a std::string using a string constructor, and the two
          strings are compared.
          The larger value, passed as the const char*, is returned as a std::string.
        </li>
      </ol>
    </i-b>  </t-b>
  <t-b>
    Using two unique parameter types allows <c-s>max</c-s> to compile successfully in cases that would
    fail if we required both arguments to be the same type.  Only the first and fourth examples, below, will 
    compile for the original <c-s>T max(T t1, T t2)</c-s> function.
  </t-b>
  <t-b>
    Returning the result as an auto gets around
    the problem of how to state the return type if more than one type could be returned, e.g., 
    <c-s>T1</c-s> or <c-s>T2</c-s>.
  </t-b>
  <div class="autoX viewWidth">
  <table class="tdefn">
    <tr>
      <th class="tdefn" style="border-right:2px solid darkred; font-size:1rem;">Template Code</th>
      <th class="tdefn" style="font-size:1rem;">Output</th>
    </tr>
    <tr>
      <td class="tdefn" style="border-bottom:2px solid darkred; border-right:2px solid darkred;">
        <tdefn-block>
          <tdefn-code>
template&lt;typename T1, typename T2&gt;
auto max(T1 t1, T2 t2) {
  displayDemo("--- using generic template ---");
  return t1 &gt; t2 ? t1 : t2;
}

using pChar = const char*;
auto max(pChar s1, pChar s2) {
  displayDemo("--- using overload for const char* ---");
  return ((strcmp(s1, s2) &gt; 0) ? s1 : s2);
}
          </tdefn-code>
        </tdefn-block>
      </td>
      <td class="tdefn" style="border-bottom:2px solid darkred;">
        <tdefn-block>
          <tdefn-code>
Demonstrate Template Functions
================================
--- using generic template ---
max(4,2) returns 4
the return type of the last statement is: int
--- using generic template ---
max(3.5, 2L) returns 3.5
the return type of the last statement is: double
--- using generic template ---
max(3.5, 4L) returns 4
the return type of the last statement is: double
--- using overload for const char* ---
max("aardvark", "zebra") returns zebra
the return type of the last statement is: char const *
--- using generic template ---
max(std::string("a string"), "b string") returns "b string"
the return type of the last statement is:
class std::basic_string&lt;
  char,struct std::char_traits&lt;char&gt;, 
  class std::allocator&lt;char&gt; 
&gt;

          </tdefn-code>
        </tdefn-block>
      </td>
    </tr>
    <!--<tr>
      <th class="tdefn" colspan="2">Using Code</th>
    </tr>-->
    <tr style="border:2px solid #fefefa;">
      <td class="tdefn" colspan="2" style="border:none;">
        <details>
          <summary class="labelStyle, darkItem">Using Code</summary>
          <s-halfEm></s-halfEm>
        <tdefn-block class="defnBorder">
          <tdefn-code>
auto test1 = max(4, 2);
std::cout &lt;&lt; "\n  max(4,2) returns " &lt;&lt; test1;

auto test2 = max(3.5, 2L);
std::cout &lt;&lt; "\n  max(3.5, 2L) returns " &lt;&lt; test2;
std::cout &lt;&lt; "\n  the return type of the last statement is: ";
std::cout &lt;&lt; typeid(test2).name();
  
auto test3 = max(3.5, 4L);
std::cout &lt;&lt; "\n  max(3.5, 4L) returns " &lt;&lt; test3;
std::cout &lt;&lt; "\n  the return type of the last statement is: ";
std::cout &lt;&lt; typeid(test3).name();

auto test4 = max("aardvark", "zebra");
std::cout &lt;&lt; "\n  max(\"aardvark\", \"zebra\") returns " &lt;&lt; test4;
std::cout &lt;&lt; "\n  the return type of the last statement is: ";
std::cout &lt;&lt; typeid(test4).name();

auto test5 = max(std::string("a string"), "b string");
std::cout &lt;&lt; "\n  max(std::string(\"a string\"), \"b string\") returns " 
          &lt;&lt; "\"" &lt;&lt; test5 &lt;&lt; "\"";
decltype(test5) what;
std::cout &lt;&lt; "\n  the return type of the last statement is:";
std::cout &lt;&lt; "\n  " &lt;&lt; typeid(what).name();
          </tdefn-code>
        </tdefn-block>
        </details>
      </td>
    </tr>
  </table>
  </div>
  <t-b>
    To understand how template functions work, we need to look at type categories and type inference, the process
    compilation uses to establish the types that arguments take after being passed to template functions.
  </t-b>

  <a id="TypeCat"></a>
  <s-halfEm></s-halfEm>
   <num-cont>
    <num-item1>6.21</num-item1><num-item4>Type Categories</num-item4>
  </num-cont>
  <t-b>
    Before C++11, there were only two type categories, lvalue and rvalue:
    <ol class="tight">
      <li>
        lvalue refers to any named variable, e.g., anything for which we can evaluate an address.
        It was called lvalue because it could by used on the left side of an assignment expression:
        <c-b class="indent pad5">char ch = 'z';</c-b>
        Here, ch is an lvalue.
      </li>
      <li>
        rvalue refers to any entity for which you cannot evaluate an address, as it has no name
        and is usually a temporary.  rvalues can only appear on the right side of an assignment
        expression, e.g., the 'z' of the previous item.
      </li>
    </ol>
  </t-b>
  <t-b>
    Things are now, with C++17, somewhat more complicated.  rvalues split into xvalues and prvalues:
    <ol class="tight">
      <li>
        An xvalue is an entity that can be the source of a move operation.  These are almost always
        values of temporary objects created in the scope of some function, and are syntactically returned
        by value.  An xvalue is not copied, but instead moved by transferring its resources to the
        entity that is the target of the return operation.   
      </li>
      <li>
        A prvalue is an expression that defines the initialization of the destination.  Under return
        value optimization the prvalue initializes the creation of a target instance.  When rvo does
        not apply, the prvalue initializes an xvalue as part of a move operation, provided the
        returned object has a move constructor and move assignment operator.
      </li>
    </ol>
  </t-b>
  <t-b>
    For most of your implementations, you won&apos;t have to think about these categories unless you are
    writing code that runs partially at compile-time, e.g., template metaprogramming.
  </t-b>

  <a id="TypeTran"></a>
  <s-halfEm></s-halfEm>
   <num-cont>
    <num-item1>6.22</num-item1><num-item4>Type Transformations</num-item4>
  </num-cont>
  <t-b>
    When passing arguments to functions, the result of template type deduction is not necessarily the same as
    the type of the argument in the caller&apos;s scope.  This is not an inference error, but an intentional
    transformation made for reasons of performance or usability.
    For non-template functions there is only one such transformation. That occurs for array arguments.
    When the function&apos;s stackframe is constructed, a pointer is created in stack memory, bound to
    the first element of the array, instead of copying the array.  
  </t-b>
  <t-b>
    All access to the array, within the function,
    accesses the caller&apos;s array via that pointer. It is common to refer to this process as type decay.  That is, 
    the array type decays to a pointer type in the function&apos;s scope.
  </t-b>
  <t-b>
    For template functions, transformations of function argument types are more complicated.  The most important
    of these are:
    <t-b class="indent">
      <ol class="tight">
        <li>
          passing a template parameter by value will strip off constant, volatile, and reference 
          (cvr) qualifiers
        </li>
        <li>
          lvalue references (T&amp;) can bind only to lvalues and const rvalues. The resulting type
          is always an lvalue reference. C++ classifies literal strings as lvalues. All other literals,
          e.g., 42 and 3.14159, are classified as rvalues.
        </li>
        <li>
          rvalue references (T&amp;&amp; in a context with no type deduction) can bind only to rvalues.
          <indent-block>
            <ul class="tight indent">
              <li>
                <c-s>Widget&& w = createWidget();</c-s>
              </li>
              <li>
                <c-s>void f(Widget&& w);</c-s>
              </li>
            </ul>
          </indent-block>
        </li>
        <li>
          universal a.k.a. forwarding references (T&amp;&amp; in a context with type deduction) can bind to anything.
          <indent-block>
            <ul class="tight indent">
              <li>
                <c-s>
                  template&lt;typename T&gt;<br />
                  void f(T&amp;&amp; t);
                </c-s>
              </li>
              <li>
                <c-s>auto&amp;&amp; x1 = x2;</c-s>
              </li>
            </ul>
          </indent-block>        </li>
      </ol>
    </t-b>
    For the details look here:
  </t-b>
    <details class="indent">
      <summary class="labelStyle lightItem">Type Transformation Details</summary>
      <s-1em class="defnBorderBottom"></s-1em>
  <t-b>
    In this section we will look at type transformations that occur when passing arguments to functions,
    especially template functions. Unfortunately you cannot use the C++ typeid operator to explore these
    effects.  We see below, that passing an argument to a template function by value strips its constant,
    volatile, and reference (cvr) qualifiers.  But typeid is a template function, so it will strip off 
    some of the things we are looking for.
    The Boost libraries have a work-around with their <c-s>boost::typeindex::type_id_with_cvr<T>()</c-s>
    operator<sup>1</sup>. I&apos;ve used that for all of the type analysis reported below.
  </t-b>
  <t-b>
    We see, from Table 1., that in all non-template cases tested, the only case with type decay is the array argument.
    This is true in general, e.g., for non-template functions, the only type decay that happens is with array 
    arguments.
  </t-b>
  <s-halfEm></s-halfEm>
  <h3>Table 1. - Type of arg in bodies of non-template functions</h3>
  <table class="pad10" style="font-size:0.85rem;">
    <tr class="defn">
      <th class="darkItem">arg definition</th>
      <th class="darkItem"><c-s>f(int arg)</c-s></th>
      <th class="darkItem"><c-s>f(const int* arg)</c-s></th>
      <th class="darkItem"><c-s>f(int arg[3])</c-s></th>
    </tr>
    <tr>
      <td class="defn"><c-s>int i{ 3 };</c-s></td>
      <td class="defn"><c-s>int</c-s></td>
      <td class="defn notice">NA</td>
      <td class="defn notice">NA</td>
    </tr>
    <tr>
      <td class="defn"><c-s>const int&amp; j = &amp;i;</c-s></td>
      <td class="defn"><c-s>int</c-s></td>
      <td class="defn notice">NA</td>
      <td class="defn notice">NA</td>
    </tr>
    <tr>
      <td class="defn"><c-s>const int* pI = &amp;i;</c-s></td>
      <td class="defn notice">NA</td>
      <td class="defn"><c-s>int const *</c-s></td>
      <td class="defn notice">NA</td>
    </tr>
    <tr>
      <td class="defn"><c-s>int iarr[4]</c-s></td>
      <td class="defn notice">NA</td>
      <td class="defn notice">NA</td>
      <td class="defn"><c-s>int *</c-s></td>
    </tr>
    <tr>
      <td class="defn"><c-s>42</c-s></td>
      <td class="defn">int</td>
      <td class="defn notice">NA</td>
      <td class="defn notice">NA</td>
    </tr>
  </table>
  <s-halfEm></s-halfEm>
  <t-b>
    Template functions are a different story.  When compiling an instantiated template, the compiler infers
    argument types from syntax of invocations. That inference has several rules:
  </t-b>
  <t-b class="indent">
    <ol class="tight">
      <li>
        Passing an argument by value removes all const, volatile, and reference (cvr) qulifiers.
        Array arguments decay to pointers.
      </li>
      <li>
        Passing an argument by lvalue reference (T&amp;) doesn&apos;t remove qualifiers and arrays do not
        decay (because they won&apos;t be copied). An lvalue reference can only bind to lvalues or const rvalues.
        Note that C++ classifies literal strings as lvalues.  All other literals, e.g., ints and doubles, are rvalues.
      </li>
      <li>
        Passing an argument by pointer doesn&apos;t remove qualifiers, but arrays do decay (because the argument
        is a pointer).
      </li>
      <li>
        Passing an argument by universal reference (T&amp;&amp; where T is being deduced) doesn&apos;t strip qualifiers and arrays do not
        decay. Universal references can bind to both lvalues and rvalues.
      </li>
    </ol>
  </t-b>
  <h3>Table 2. - Type Transformations for template functions</h3>
  <div tabindex="1" class="autoX" style="width:calc(100vw - 10rem);">
  <table class="" style="table-layout:fixed; width:78em; font-size:0.85rem;">
    <tr class="defn">
      <th class="darkItem" style="width:12em; vertical-align:middle;text-align:center;">arg definition</th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f1(T arg)</c-s></th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f2(T& arg)</c-s></th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f2C(const T& arg)</c-s></th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f3(T* arg)</c-s></th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f3C(const T* arg)</c-s></th>
      <th class="darkItem" style="width:11em;"><c-s>template&lt;class T&gt;<br />f4(T&& arg)</c-s></th>
    </tr>
    <tr>
      <td class="defn"><c-s>int i{ 3 };<br />lvalue</c-s></td> 
      <td class="defn">T = int </td>
      <td class="defn">T&amp; = int &amp;</td>
      <td class="defn">const T&amp; = int&nbsp;const&nbsp;&amp;</td>
      <td class="defn notice">NA</td>
      <td class="defn notice">NA</td>
      <td class="defn">T&amp;&amp; = int &amp;</td>
    </tr>
    <tr>
      <td class="defn"><c-s>const int&amp; j = &amp;i;<br />lvalue</c-s></td>
      <td class="defn">T = int</td>
      <td class="defn">T&amp; = int const &amp;</td>
      <td class="defn">const T&amp; = int&nbsp;const&nbsp;&amp;</td>
      <td class="defn notice">NA</td>
      <td class="defn notice">NA</td>
      <td class="defn">T&amp;&amp; = int&nbsp;const&nbsp;&amp;</td>
    </tr>
    <tr>
      <td class="defn"><c-s>const int* pI = &amp;i;<br />lvalue</c-s></td>
      <td class="defn">T = int const *</td>
      <td class="defn">T&amp; = int&nbsp;const&nbsp;*&nbsp;&amp;</td>
      <td class="defn">const T&amp; = int&nbsp;const&nbsp;*&nbsp;const&nbsp;&amp;</td>
      <td class="defn">T* = int const *</td>
      <td class="defn">const T* = int&nbsp;const&nbsp;*</td>
      <td class="defn">T&amp;&amp; = int&nbsp;const&nbsp;*&nbsp;&amp;</td>
    </tr>
    <tr>
      <td class="defn"><c-s>iarr[4]</c-s><br />lvalue</td>
      <td class="defn">T = int *</td>
      <td class="defn">T&amp; = int&nbsp;(&amp;)[4]</td>
      <td class="defn">const T&amp; = int&nbsp;const&nbsp;(&amp;)[4]</td>
      <td class="defn">T* = int *</td>
      <td class="defn">const T* = int&nbsp;const&nbsp;*</td>
      <td class="defn">T&amp;&amp; = int&nbsp;(&amp;)[4]</td>
    </tr>
    <tr>
      <td class="defn"><c-s>"a string literal"</c-s><br />lvalue</td>
      <td class="defn">T = char const *</td>
      <td class="defn">T&amp; = char const (&amp;)[17]</td>
      <td class="defn">const T&amp; = char const (&amp;)[17]</td>
      <td class="defn">T* = const char *</td>
      <td class="defn">const T* = char&nbsp;const&nbsp;*</td>
      <td class="defn">T&amp;&amp; = char&nbsp;const&nbsp;&amp;&nbsp;*</td>
    </tr>
    <tr>
      <td class="defn"><c-s>42</c-s><br />rvalue</td>
      <td class="defn">T = int</td>
      <td class="defn">doesn&apos;t compile</td>
      <td class="defn">const T&amp; = int const &amp;</td>
      <td class="defn notice">NA</td>
      <td class="defn notice">NA</td>
      <td class="defn">T&amp;&amp; = int&nbsp;&amp&amp;</td>
    </tr>
  </table>
  </div>
  <hr class="spreadup" />
  <ol class="footnote">
    <li>
      Boost libraries are available from their site, <a href="https://boost.org">boost.org</a>. The use
      of <c-s>boost::typeindex::type_id_with_cvr<T>()</c-s> for this purpose was cited in 
      <a href="https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?crid=28XKCOZTMHOY7&keywords=effective+modern+c%2B%2B+by+scott+meyers&qid=1577367547&s=books&sprefix=effective+modern+c%2B%2B%2Cstripbooks%2C158&sr=1-1">Effective Modern C++</a>
      by Scott Meyers.
    </li>
  </ol>
    <s-1em class="defnBorderBottom"></s-1em>
    </details>
  <t-b>
    Usually you don&apos;t have to think about the rules.  Inference just works as you would expect.
    On rare occasions you may need to consider them to understand unexpected compilation or run-time
    behavior of template code.
  </t-b>

  <a id="SFINAE"></a>
  <num-cont>
    <num-item1>6.23</num-item1><num-item4>Substitution Failure Is Not An Error (SFINAE)</num-item4>
  </num-cont>
  <t-b>
    When compiling overloaded template functions argument type deduction may fail for one or perhaps several 
    overloads. These deductions are based on substitutions in each of the overloads. Substitution failure
    is not a compile error, so the build should succeed unless none of the deductions succeed.
  </t-b>
  <details class="indent">
    <summary class="labelStyle lightItem">SFINAE Details</summary>
  <t-b>
    In the example below, we&apos;ve supplied two function overloads, each displaying the contents of
    a collection.  The first displays contents of an array, and the second, contents of a vector.
  </t-b>
  <t-b>
    In the Using Code main there are three cases:
    <ol class="tight">
      <li>
        First case: no SFINAE - 
        <strong><c-s>show(array)</c-s></strong>
        <tt-b class="indent">
          The array matches both overloads, but <c-s>show(const T (&array)[N])</c-s> is a more
          specific match and is compiled.
        </tt-b>
      </li>
      <li>
        Second case: SFINAE with build success - 
        <strong><c-s>show(vInt)</c-s></strong>
        <tt-b class="indent">
          vInt fails to match <c-s>show(const T (&array)[N])</c-s> but does match
          <c-s>show(const C&Aacute; cont)</c-s> and is compiled. SFINAE prevents the
          substitution failure from causing a compile error.
        </tt-b>
      </li>
      <li>
        Third case: SFINAE with build failure not due to substitution - 
        <strong><c-s>show(3.14159)</c-s></strong>
        <tt-b class="indent">
          Substitution of the double 3.14159 into the first overload fails but is not a compile
          error. Substitution into the second overload succeeds, but the body fails to compile
          since a double does not satify the requirements of a range-based for loop.
        </tt-b>
      </li>
    </ol>
  </t-b>
  <defn-outerBlock>
    <defn-block>
      <defn-head>
        SFINAE Code
      </defn-head>
      <defn-code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include "../Display/Display.h"

template&lt;typename T, size_t N&gt;
void show(const T (&amp;array)[N]) {
  displayDemo("--- show array contents ---");
  std::cout &lt;&lt; "\n  ";
  for (size_t i = 0; i &lt; N; ++i)
    std::cout &lt;&lt; array[i] &lt;&lt; " ";
}

template&lt;typename C&gt;
void show(const C&amp; cont) {
  displayDemo("--- show container contents ---");
  std::cout &lt;&lt; "\n  ";
  for (auto item : cont) {
    std::cout &lt;&lt; item &lt;&lt; " ";
  }
}
      </defn-code>
    </defn-block>
    <defn-block>
      <defn-head>Using Code</defn-head>
      <defn-code>
int main() {

  displayTitle("SFINAE Demo");

  std::cout &lt;&lt; "\n  displaying array:";
  double array[5]{ -0.5, 0.0, 0.5, 1.0, 1.5 };
  show(array);

  std::cout &lt;&lt; "\n  displaying vector";
  std::vector&lt;int&gt; vInt{ -1, 0, 1, 2, 3 };
  show(vInt);

  // show(array);
  // attempted template argument deduction for both show functions
  // - show(const T (&amp;array)[n]) succeeded, built, and used
  // - show(const C&amp; cont) succeeded but less specific so not used

  // show(vInt)
  // attempted template argument deduction for both show functions
  // - show(const T (&amp;array)[n]) failed, vInt is not an array, 
  //   but this is not a compilation error (SFINAE)
  // - show(const C&amp; cont) succeeded, built, and used

  // show(3.14159);
  // argument deduction for show(const T (&amp;array)[N]) fails
  // - double is not an array
  // argument deduction succeeds with show(const C&amp; cont)
  // - compilation of body for double fails, i.e., 
  //   no iterator, begin(), or end() for range-based for

  std::cout &lt;&lt; "\n\n";
}
      </defn-code>
      <defn-head>Output</defn-head>
      <defn-code>
  SFINAE Demo
 =============

  displaying array:
  --- show array contents ---
  -0.5 0 0.5 1 1.5
  displaying vector
  --- show container contents ---
  -1 0 1 2 3
      </defn-code>
    </defn-block>
  </defn-outerBlock>
  <t-b>
    The point of all this is that you can write function code that works for some types 
    but not for others as long as there is a type deduction for some other function overload that succeeds 
    and provides working code for any of the types your program will use for this set invocations.
  </t-b>
  </details>
  <t-b>
    We will look at SFINAE for template classes in the next chapter7 - Template Metaprogramming.
  </t-b>

  <a id="FunExpl"></a>
  <hr class="spread" />
  <num-cont>
    <num-item1>6.3</num-item1><num-item4>Template Function Examples</num-item4>
  </num-cont>
  <t-b>
    There are a number of standard template functions that prove useful, especially for template metaprogramming:
  </t-b>
  <bb-full>
    <h3>Table 1. - Standard template functions</h3>
    <table class="tdefns" style="width:calc(100vw - 12rem);">
      <tr>
        <th class="defn darkItem">Function name</th>
        <th class="defn darkItem">Return Type</th>
        <th class="defn darkItem">Semantics</th>
      </tr>
      <tr>
        <td class="defn">std::move(T&amp;&nbsp;t)</td>
        <td class="defn">static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;(t)</td>
        <td class="defn">
          Casts t to an r value type, e.g., can be moved from. Nothing is actually moved.
        </td>
      </tr>
      <tr>
        <td class="defn">std::forward(T&amp;&amp;&nbsp;t)</td>
        <td class="defn">type of t in the caller&apos;s context</td>
        <td class="defn">
          Used in a function to un-decay T&apos;s type<sup>1</sup>.
          Revert back to caller&apos;s value category (rvalue or lvalue).
          This is a cast operation. Nothing is actually forwarded.
        </td>
      </tr>
      <tr>
        <td class="defn">std::apply&lt;F&&&nbsp;f,&nbsp;Tuple&&&nbsp;t&gt;</td>
        <td class="defn">value&nbsp;returned&nbsp;by&nbsp;f</td>
        <td class="defn">
          Use tuple items as arguments of function f. The t argument may be a std::tuple, std::array, or
          std::pair.
        </td>
      </tr>
      <tr>
        <td class="defn">std::invoke(F&&&nbsp;f,&nbsp;Args&&...&nbsp;args)</td>
        <td class="defn">std::Invoke_Result_t&lt;F,&nbsp;Args...&gt;</td>
        <td class="defn">
          Invoke the callable object f with parameters Args.
        </td>
      </tr>
    </table>
    <hr class="spreadup" />
    <div class="footnote indent">
      <ol class="tight indent">
        <li>
          Remember that passed arguments are always lvalues because they have their parameter name and a location
          in the function&apos;s stackframe.
        </li>
      </ol>
    </div>
    <t-b>
      This next table holds type traits that are often associated with the standard functions cited in the
      previous table.
    </t-b>
    <h3>Table 2. - Selected type_traits</h3>
    <table class="tdefns" style="width:calc(100vw - 12rem);">
      <tr>
        <th class="defn darkItem">type_trait</th>
        <th class="defn darkItem">Semantics</th>
      </tr>
      <tr>
        <td class="defn">template&lt;class T&gt; struct decay</td>
        <td class="defn">
          decay has a public member type which converts T to the decayed type that results from making a call
          <c-s>f(T t)</c-s> inside the scope of <c-s>f</c-s>.  That is, decay&lt;T&gt;::type is the decayed type.
        </td>
      </tr>
      <tr>
        <td class="defn">template&lt;class&nbsp;T&gt;&nbsp;struct&nbsp;remove_reference</td>
        <td class="defn">
          remove_reference::type evaluates as T with a reference removed if T is a reference type, otherwise
          evaluates as T.
        </td>
      </tr>
    </table>
  </bb-full>
  <s-halfEm></s-halfEm>
  <t-b>
    Next we will look at some example template function designs.  The first two come from the 
    <a href="CppUtilities.html">CppUtilities</a> repository.
  </t-b>
  <t-b>
    <c-s>Converter&lt;T&gt;::toString(t)</c-s>, in the CodeUtilities folder, converts the value of <c-s>t &epsilon; T</c-s>
    to its string representation.
    And, given the conversion string, ConvStr, <c-s>Converter&lt;T&gt;::toValue(ConvStr)</c-s>
    converts back to a new instance with the original value.

  </t-b>
  <details>
    <summary class="labelStyle darkItem">Converter Example</summary>
    <s-halfEm></s-halfEm>
    <defn-outerBlock>
      <defn-block>
        <defn-head>Converter function</defn-head>
        <defn-code>
///////////////////////////////////////////////////////
// Converter class
// - supports converting unspecified types to and 
//   from strings
// - type is convertible if it provides insertion 
//   and extraction operators

template &lt;typename T&gt;
class Converter
{
public:
  static std::string toString(const T&amp; t);
  static T toValue(const std::string&amp; src);
};
//----&lt; convert t to a string &gt;------------------

template &lt;typename T&gt;
std::string Converter&lt;T&gt;::toString(const T&amp; t) {
  std::ostringstream out;
  out &lt;&lt; t;
  return out.str();
}
//----&lt; convert a string to an instance of T &gt;---
/*
*  - the string must have been generated by 
*    Converter&lt;T&gt;::toString(const T&amp; t)
*  - T::operator>> must be the inverse of T::operator&lt;&lt;
*/
template&lt;typename T&gt;
T Converter&lt;T&gt;::toValue(const std::string&amp; src) {
  std::istringstream in(src);
  T t;
  in &gt;&gt; t;
  return t;
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code</defn-head>
        <defn-code>
title("test std::string Converter&lt;T&gt;::toString(T)");

std::string conv1 = Converter&lt;double&gt;::toString(3.1415927);
std::string conv2 = Converter&lt;int&gt;::toString(73);
std::string conv3 = 
  Converter&lt;std::string&gt;::toString("a_test_string plus more");

std::cout &lt;&lt; "\n  Converting from values to strings: ";
std::cout &lt;&lt; conv1 &lt;&lt; ", " &lt;&lt; conv2 
          &lt;&lt; ", " &lt;&lt; conv3;
putline();

title("test T Converter&lt;T&gt;::toValue(std::string)");

std::cout &lt;&lt; "\n  Converting from strings to values: ";
std::cout &lt;&lt; Converter&lt;double>::toValue(conv1) &lt;&lt; ", ";
std::cout &lt;&lt; Converter&lt;int>::toValue(conv2) &lt;&lt; ", ";
std::cout &lt;&lt; Converter&lt;std::string>::toValue(conv3);
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
 test std::string Converter<T>::toString(T)
--------------------------------------------
 Converting from values to strings: 
  3.14159, 73, a_test_string plus more

 test T Converter<T>::toValue(std::string)
-------------------------------------------
 Converting from strings to values: 
   3.14159, 73, a_test_string
        </defn-code>
      </defn-block>
    </defn-outerBlock>  </details>
  <t-b>
    <c-s>Converter</c-s> is simple because it uses <c-s>std::ostringstream</c-s> to convert from
    values to their string representation, and it uses <c-s>std::istringstream</c-s> to convert back.
    Thus, the std::stringstream library classes do all the heavy lifting.
  </t-b>
  <t-b>
    The second example, found in the StringUtilities folder, presents string utility functions 
    <c-s>trim</c-s> and <c-s>split</c-s> with capabilities similar those in the C# string class.
  </t-b>
  <details>
    <summary class="labelStyle darkItem">String Utilities</summary>
    <s-halfEm></s-halfEm>
    <defn-outerBlock>
      <defn-block>
        <defn-head>String Utilities Code</defn-head>
        <defn-code>
/*
*  - remove whitespace from front and back of string argument
*  - does not remove newlines
*/
template &lt;typename T&gt;
inline std::basic_string&lt;T&gt; trim(
const std::basic_string&lt;T&gt;& toTrim
) {
  if (toTrim.size() == 0)
    return toTrim;
  std::basic_string&lt;T&gt; temp;
  std::locale loc;
  typename std::basic_string&lt;T&gt;::const_iterator iter =
  toTrim.begin();
  while (isspace(*iter, loc) && *iter != '\n')
  {
    if (++iter == toTrim.end())
    {
      break;
    }
  }
  for (; iter != toTrim.end(); ++iter)
  {
    temp += *iter;
  }
  typename std::basic_string&lt;T&gt;::reverse_iterator riter;
  size_t pos = temp.size();
  for (riter = temp.rbegin(); riter != temp.rend(); ++riter)
  {
    --pos;
    if (!isspace(*riter, loc) || *riter == '\n')
    {
      break;
    }
  }
  if (0 &lt;= pos && pos &lt; temp.size())
    temp.erase(++pos);
  return temp;
}

/*---
  split sentinel separated strings into vector of trimmed strings
---*/

template &lt;typename T&gt;
inline std::vector&lt;std::basic_string&lt;T&gt;&gt; split(
  const std::basic_string&lt;T&gt;& toSplit, T splitOn = ','
) {
  std::vector&lt;std::basic_string&lt;T&gt;&gt; splits;
  std::basic_string&lt;T&gt; temp;
  typename std::basic_string&lt;T&gt;::const_iterator iter;
  for (iter = toSplit.begin(); iter != toSplit.end(); ++iter)
  {
    if (*iter != splitOn)
    {
      temp += *iter;
    }
    else
    {
      splits.push_back(trim(temp));
      temp.clear();
    }
  }
  if (temp.length() &gt; 0)
    splits.push_back(trim(temp));
  return splits;
}
/*--- show collection of string splits ----------------------*/

template &lt;typename T&gt;
inline void showSplits(
  const std::vector&lt;std::basic_string&lt;T&gt;&gt;& splits,
  std::ostream& out = std::cout
) {
  out &lt;&lt; "\n";
  for (auto item : splits)
  {
    if (item == "\n")
      out &lt;&lt; "\n--" &lt;&lt; "newline";
    else
      out &lt;&lt; "\n--" &lt;&lt; item;
  }
  out &lt;&lt; "\n";
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code</defn-head>
        <defn-code>
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include "StringUtilities.h"
#include "../CodeUtilities/CodeUtilities.h"

#ifdef TEST_STRINGUTILITIES

using namespace Utilities;

int main()
{
  Title("Testing Utilities Package");
  putline();

  title("test split(std::string, ',')");

  std::string test = 
    "a, \n, bc, de, efg, i, j k lm nopq rst";
  std::cout &lt;&lt; "\n  test string = " 
            &lt;&lt; test;

  std::vector&lt;std::string&gt; result = 
    split(test);
  showSplits(result);

  title("test split(std::string, ' ')");

  std::cout &lt;&lt; "\n  test string = " 
            &lt;&lt; test;

  result = split(test, ' ');
  showSplits(result);

  putline(2);
  return 0;
}
#endif
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
  Testing Utilities Package
 ===========================

  test split(std::string, ',')
  ------------------------------
  test string = a,
  , bc, de, efg, i, j k lm nopq rst

  --a
  --newline
  --bc
  --de
  --efg
  --i
  --j k lm nopq rst

  test split(std::string, ' ')
  ------------------------------
  test string = a,
  , bc, de, efg, i, j k lm nopq rst

  --a,
  --
  ,
  --bc,
  --de,
  --efg,
  --i,
  --j
  --k
  --lm
  --nopq
  --rst
        </defn-code>
      </defn-block>
    </defn-outerBlock>  </details>
  <t-b>
    For our last template function example, the code below shows how to create 
    <span class="notice">generic lambdas</span>.
    They are defined using auto parameters, as shown.  This is equivalent to a 
    template function, but doesn&apos;t use template syntax.  That it is generic is
    due to type deduction generated for the auto declarators.
    <s-1em></s-1em>
    <details>
      <summary class="labelStyle darkItem">Generic Lambda Code</summary>
      <s-halfEm></s-halfEm>
    <defn-outerBlock>
      <defn-block>
        <defn-head>
          Generic Lambda Code
        </defn-head>
        <defn-code>
  auto genericLambda = [](auto arg) {
    std::cout << "\n  the type of genericLambda's arg is: " 
              << typeid(arg).name();
    std::cout << "\n  arg's value is: " << arg;
  };
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code</defn-head>
        <defn-code>
  displaySubtitle("Demo generic lambda");
  genericLambda(double{ 3.5 });
  genericLambda("this is a string");
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
  Demo generic lambda
 ---------------------
  the type of genericLambda's arg is: double
  arg's value is: 3.5
  the type of genericLambda's arg is: char const *
  arg's value is: this is a string
        </defn-code>
      </defn-block>
    </defn-outerBlock>
    </details>
  </t-b>
  <t-b>
    We will look at template functions again, in Chapter #7 - Template Metaprogramming, where we explore
    some of the functions used to provide displays for code demonstrations throughout this story.
  </t-b>
  <s-halfEm></s-halfEm>

  <a id="TmplClass"></a>
  <hr class="spread" />
  <num-cont>
    <num-item1>6.4</num-item1><num-item4>Template Classes</num-item4>
  </num-cont>
  <t-b>
    Template classes use syntax as shown in the blocks below.  Everywhere that the class name <c-s>SynDemo</c-s> is used
    as a type it needs the template parameter, e.g., <c-s>SynDemo&lt;T&gt;</c-s>.
  </t-b>
  <t-b>
    Remember that both template declarations <span class="notice">and</span>
    definitions must appear in the class&apos;s header file, as shown below.
    <s-halfEm></s-halfEm>
    <defn-outerblock>
      <defn-block>
        <defn-head>Template Code in SynDemo.h</defn-head>
        <defn-code>
namespace Chap6 {

  template&lt;typename T&gt;
  class SynDemo {
  public:
    void value(T t);
    T value();
  private:
    T t_;
  };

  template&lt;typename T&gt;
  void SynDemo&lt;T&gt;::value(T t) {
    t_ = t;
  }

  template&lt;typename T&gt;
  T SynDemo&lt;T&gt;::value() {
    return t_;
  }
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code in Demo.cpp</defn-head>
        <defn-code>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include "../Display/Display.h"
#include "SynDemo.h"

int main() {

  displayTitle("Demonstrating Template Syntax");

  using namespace Chap6;

  SynDemo&lt;std::string&gt; sd;
  sd.value("hello world");
  std::cout &lt;&lt; "\n  " &lt;&lt; sd.value();
  putline(2);
}
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
  Demonstrating Template Syntax
 ===============================

  hello world

        </defn-code>
      </defn-block>
    </defn-outerblock>
  </t-b>
  <s-halfEm></s-halfEm>
  <t-b>
    The <c-s>Stack&lt;T&gt;</c-s> class example, below, illustrates this syntax
    for a class typical of professionally developed code.  It also illustrates:
    <ol class="tight">
      <li>
        <strong>Template members:</strong><br />
        A copy constructor <c-s>template &lt;class U&gt; stack(const stack&lt;U&gt;&);</c-s> and
        assignment operator 
        <c-s>template &lt;class U&gt; stack&lt;U&gt;&amp; operator=(const stack&lt;U&gt;&);</c-s>
        are declared as methods with a potentially different type <c-s>U</c-s>.  That could be
        the same as <c-s>T</c-s>, providing the usual copy and assignment operations, but could
        also be different, allowing one, for example, to assign a <c-s>stack&lt;int&gt;</c-s> to a 
        <c-s>stack&lt;double&gt;</c-s>. The example code illustrates that use. Template type inference
        is the reason we can design this flexibility.
      </li>
      <li>
        <strong>Inner classes:</strong><br />
        Inner classes aren&apos;t often used for C++ programs, but if a parent class needs
        services of a small and simple class that is specialized for the parent, then using an
        inner class for the child makes sense.  The <c-s>struct stacknode</c-s> is an example
        of that use.
      </li>
      <li>
        <strong>Friend relationships:</strong><br />
        We try to avoid using <c-s>friend</c-s> relationships because they expand encapsulation
        from the granting class to include friends as well.  However, when needed it&apos;s
        easy to use, as shown here.  This <c-s>stack&lt;T&gt;</c-s> class needs to allow
        template members, cited in the first item, to access its private data. That&apos;s because
        <c-s>stack&lt;T&gt;</c-s> is a different class than <c-s>stack&lt;U&gt;</c-s>.
      </li>
    </ol>
  </t-b>
  <t-b>
    This example was adapted from one presented in Effective C++, by Scott Meyers.
  </t-b>
  <t-b>
    <details>
      <summary class="labelStyle darkItem">Stack Class</summary>
      <s-halfEm></s-halfEm>
      <defn-outerBlock>
      <defn-block>
        <defn-head>Stack Code</defn-head>
        <defn-code>
template&lt;class T&gt; class stack {

  template &lt;class U&gt; friend class stack;

  private:
    struct stacknode {
      T data;
      stacknode *next;
      stacknode(
        const T&amp; newdata, stacknode *nextnode
      )
	    : data(newdata), next(nextnode) { }
    };
    stacknode *top;
  public:
    stack();
    ~stack();
    void push(const T&amp; object);
    T pop(void);
    void flush();
    int size() const;
    
    // member templates

    template &lt;class U&gt; stack(
      const stack&lt;U&gt;&amp;
    );
    template &lt;class U&gt; 
    stack&lt;T&gt;&amp; operator=(
      const stack&lt;U&gt;&amp;
    );
};

//
//----&lt; void constructor &gt;-------------

template&lt;class T&gt; 
stack&lt;T&gt;::stack() : top(0) { }

//----&lt; destructor &gt;-------------------

template &lt;class T&gt; 
stack&lt;T&gt;::~stack(void) {

  while (top) {
    stacknode *next_to_die = top;
    top = top-&gt;next;
    delete next_to_die;
  }
}
//----&lt; push data onto stack &gt;---------

template&lt;class T&gt; 
void stack&lt;T&gt;::push(const T &amp;object) {
  top = new stacknode(object, top);
}
//----&lt; pop data from stack &gt;----------

template &lt;class T&gt; 
T stack&lt;T&gt;::pop(void) {

  if (!top) {
    throw std::out_of_range(
      "\n  attempt to pop empty stack\n"
    );
  }
  stacknode *save = top;
  top = top-&gt;next;
  T data = save-&gt;data;
  delete save;
  return data;
}
//----&lt; empty stack &gt;------------------

template &lt;class T&gt; 
void stack&lt;T&gt;::flush() {

  stacknode* node = top;
  while(node)
  {
    stacknode *next_to_die = node;
    node = node-&gt;next;
    delete next_to_die;
  }
}
//---&lt; number of elements on stack &gt;---

template &lt;class T&gt; 
int stack&lt;T&gt;::size() const {

  stacknode* node = top;
  int count = 0;
  while(node)
  {
    count++;
    node = node-&gt;next;
  }
  return count;
}
//
//--&lt; copy and promo ctor, a member template &gt;--

template &lt;class T&gt; 
template &lt;class U&gt; 
stack&lt;T&gt;::stack(
  const stack&lt;U&gt;&amp; s
) : top(0)
{
  stack&lt;U&gt;::stacknode* node = 
    const_cast&lt;stack&lt;U&gt;::stacknode*&gt;(s.top);
  while(node)
  {
    this-&gt;push(node-&gt;data);
    node = node-&gt;next;
  }
}
//--&lt; assignment from stack of compatible type &gt;--

template &lt;class T&gt; 
template &lt;class U&gt; 
stack&lt;T&gt;&amp; 
stack&lt;T&gt;::operator=(const stack&lt;U&gt;&amp; s)
{
  if((void*)this == (void*)&amp;s)
    return *this;

  flush();
  stack&lt;U&gt;::stacknode* node2 = 
    const_cast&lt;stack&lt;U&gt;::stacknode*&gt;(s.top);
  while(node2)
  {
    this-&gt;push(static_cast&lt;T&gt;(node2-&gt;data));
    node2 = node2-&gt;next;
  }
  return *this;
}
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code</defn-head>
        <defn-code>
#include &lt;iostream&gt;
#include "stack.h"
using namespace std;

template &lt;class T&gt; void print_field(T t) {

  cout.width(10);
  cout &lt;&lt; t;
}
//----&lt; test stub &gt;--------------------
void main() {

  cout &lt;&lt; 
    "\nTesting Template Based Stack Class\n";

  try
  {
    stack&lt;int&gt;    int_stack;
    stack&lt;double&gt; double_stack;

    int    x=1,    y=2,   z=3;
    double u=-1.5, v=0.5, w=2.5;

    cout &lt;&lt; "\n  pushing stack: "; 
    print_field(x); int_stack.push(x);
    cout &lt;&lt; "\n  pushing stack: "; 
    print_field(y); int_stack.push(y);
    cout &lt;&lt; "\n  pushing stack: "; 
    print_field(z); int_stack.push(z);
    cout &lt;&lt; endl;
    cout &lt;&lt; "\n  stack size = " 
         &lt;&lt; int_stack.size() 
         &lt;&lt; endl;

    stack&lt;double&gt; copyStack = int_stack;
    // copy construction with data conversion

    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int_stack.pop());
    cout &lt;&lt; "\n";

    cout &lt;&lt; "\n  stack size = " 
         &lt;&lt; int_stack.size() 
         &lt;&lt; endl;

    cout &lt;&lt; 
      "\n  popping double copy of int stack:";
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(copyStack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(copyStack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(copyStack.pop());
    cout &lt;&lt; "\n";

    cout &lt;&lt; "\n  pushing stack: ";
    print_field(u); double_stack.push(u);
    cout &lt;&lt; "\n  pushing stack: "; 
    print_field(v); double_stack.push(v);
    cout &lt;&lt; "\n  pushing stack: "; 
    print_field(w); double_stack.push(w);
    cout &lt;&lt; endl;

    stack&lt;int&gt; int2_stack;
    int2_stack = double_stack;  
    // assignment with data conversion

    cout &lt;&lt; "\n  popping stack: "; 
    print_field(double_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(double_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(double_stack.pop());
    cout &lt;&lt; "\n";

    cout &lt;&lt; 
      "\n  popping int copy of double stack:";
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int2_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int2_stack.pop());
    cout &lt;&lt; "\n  popping stack: "; 
    print_field(int2_stack.pop());
    cout &lt;&lt; "\n";

    int2_stack.pop(); // popping empty stack

    cout &lt;&lt; "\n\n";
  }
  catch(exception&amp; ex)
  {
    cout &lt;&lt; "\n  " &lt;&lt; ex.what() 
         &lt;&lt; endl;
  }
  catch(...)
  {
    cout &lt;&lt; "\n  stack error\n\n";
  }
}
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
Testing Template Based Stack Class

  pushing stack:          1
  pushing stack:          2
  pushing stack:          3

  stack size = 3

  popping stack:          3
  popping stack:          2
  popping stack:          1

  stack size = 0

  popping double copy of int stack:
  popping stack:          1
  popping stack:          2
  popping stack:          3

  pushing stack:       -1.5
  pushing stack:        0.5
  pushing stack:        2.5

  popping stack:        2.5
  popping stack:        0.5
  popping stack:       -1.5

  popping int copy of double stack:
  popping stack:         -1
  popping stack:          0
  popping stack:          2


  attempt to pop empty stack
        </defn-code>
      </defn-block>
      </defn-outerBlock>
    </details>
  </t-b>
  <t-b>
    You won&apos;t use this class for your own designs.  The Standard Template Library (STL) provides
    a stack adapter class<sup>1</sup> and C++ developers know how that works, so you should use it.
    The STL provides a rich set of examples of template classes including one for each of the STL
    containers.  You will find a demonstration of each of them in 
    <a href="STL-Containers.html">STL-Containers.html</a> in the Demonstrations part of the
    <a href="CppRepositories.html">CppRepositories.html</a>.
  </t-b>
  <t-b>
    The next example, <c-s>DirExplorerT</c-s>, shows how to build a component - a directory navigator - to be reusable,
    e.g., can be used in many different applications without changing any of its code.  The way that is done
    is to parameterize the navigator on an application specific class, <c-s>DirExplorerT&lt;App&gt;</c-s>.
  </t-b>
  <t-b>
    The application class is expected to provide methods <c-s>doFile(const std::string&amp; fileName)</c-s>
    and <c-s>doDir(const std::string&amp; dirName)</c-s> that handle all application specific
    requirements for using file and directory information.
  </t-b>
  <t-b>
    <details>
      <summary class="labelStyle darkItem">DirExplorerT</summary>
      <s-halfEm></s-halfEm>
      <div class="indent pad10">
        <a href="Resources/DirExplorerT.h.html">DirExplorerT.h</a>, 
        <a href="Resources/Application.h.html">Application.h</a>, 
        <a href="Resources/DirExplorerT.cpp.html">DirExplorerT.cpp</a>, 
        <a href="Resources/DirExplorerT.out.html">DirExplorerT.out</a>
      </div>
      <defn-outerBlock>
        <defn-block>
          <defn-head>Code: DirExplorerT</defn-head>
          <defn-code>
#include &lt;vector&gt;
#include "../FileSystem/FileSystem.h"

namespace FileSystem
{
  template&lt;typename App&gt;
  class DirExplorerT
  {
  public:
    using patterns = std::vector&lt;std::string&gt;;

    static std::string version() { return "ver 1.2"; }

    DirExplorerT(const std::string&amp; path);

    void addPattern(const std::string&amp; patt);
    void hideEmptyDirectories(bool hide);
    void maxItems(size_t numFiles);
    void showAllInCurrDir(bool showAllCurrDirFiles);
    bool showAllInCurrDir();
    void recurse(bool doRecurse = true);
    
    void search();
    void find(const std::string&amp; path);
    bool done();

    void showStats();
    size_t fileCount();
    size_t dirCount();

  private:
    App app_;
    std::string path_;
    patterns patterns_;
    bool hideEmptyDir_ = false;
    bool showAll_ = false;     
      // show files in current dir 
      // even if maxItems_ exceeded
    size_t maxItems_ = 0;
    size_t dirCount_ = 0;
    size_t fileCount_ = 0;
    bool recurse_ = false;
  };

  //---&lt; ctor using default pattern &gt;--

  template&lt;typename App&gt;
  DirExplorerT&lt;App&gt;::DirExplorerT(
     const std::string&amp; path
  ) : path_(path)
  {
    patterns_.push_back("*.*");
  }
  //---&lt; add patts selecting files &gt;---

  template&lt;typename App&gt;
  void DirExplorerT&lt;App&gt;::addPattern(
    const std::string&amp; patt
  )
  {
    if (
      patterns_.size() == 1 
      &amp;&amp; patterns_[0] == "*.*"
    )
      patterns_.pop_back();
    patterns_.push_back(patt);
  }
  //---&lt; option to hide empty dirs &gt;---

  template&lt;typename App&gt;
  void DirExplorerT&lt;App&gt;
    ::hideEmptyDirectories(bool hide)
  {
    hideEmptyDir_ = hide;
  }
  //---&lt; max num files to display &gt;----

  template&lt;typename App&gt;
  void DirExplorerT&lt;App&gt;::maxItems(
    size_t numFiles
  )
  {
    maxItems_ = numFiles;
    app_.maxItems(maxItems_);
  }
  //---&lt; show all files in dir &gt;-------

  template&lt;typename App&gt;
  void DirExplorerT&lt;App&gt;
    ::showAllInCurrDir(
    bool showAllCurrDirFiles
  )
  {
    showAll_ = showAllCurrDirFiles;
  }
  //---&lt; show all files in dir? &gt;------

  template&lt;typename App&gt;
  bool DirExplorerT&lt;App&gt;
    ::showAllInCurrDir()
  {
    return showAll_;
  }
  //---&lt; recusively walk dir tree &gt;--

  template&lt;typename App&gt;
  void DirExplorerT&lt;App&gt;
    ::recurse(bool doRecurse)
  {
    recurse_ = doRecurse;
  }
  //---&lt; start at path_ &gt;------------

  template&lt;typename App&gt;
  void DirExplorerT&lt;App&gt;::search()
  {
    if (showAllInCurrDir())
      app_.showAllInCurrDir(true);

    find(path_);
  }
  //---&lt; search directories &gt;----------
  /*
    Recursively find all dirs and files on
    specified path, executing doDir when 
    entering a directory and doFile when 
    finding a file
  */
  template&lt;typename App&gt;
  void DirExplorerT&lt;App&gt;::find(
    const std::string&amp; path
  )
  {
    if (done())  // stop searching
      return;

    bool hasFiles = false;
    std::string fpath = 
      FileSystem::Path::getFullFileSpec(path);
    if (!hideEmptyDir_)
      app_.doDir(fpath);

    for (auto patt : patterns_)
    {
      std::vector&lt;std::string&gt; files = 
        FileSystem::Directory
          ::getFiles(fpath, patt);
      if (!hasFiles &amp;&amp; hideEmptyDir_)
      {
        if (files.size() &gt; 0)
        {
          app_.doDir(fpath);
          hasFiles = true;
        }
      }
      for (auto f : files)
      {
        app_.doFile(f);
      }
    }

    if (done())  // stop recursion
      return;

    std::vector&lt;std::string&gt; dirs = 
      FileSystem::Directory::
        getDirectories(fpath);
  
    for (auto d : dirs)
    {
      if (d == "." || d == "..")
        continue;
      std::string dpath = fpath + "\\" + d;
      if (recurse_)
      {
        find(dpath);
      }
      else
      {
        app_.doDir(dpath);
      }
    }
  }
  //---&lt; num files processed &gt;---------

  template&lt;typename App&gt;
  size_t DirExplorerT&lt;App&gt;::fileCount()
  {
    return App.fileCount();
  }
  //---&lt; num dirs processed &gt;----------

  template&lt;typename App&gt;
  size_t DirExplorerT&lt;App&gt;::dirCount()
  {
    return App.dirCount();
  }
  //---&lt; counts for files &amp; dirs &gt;-----

  template&lt;typename App&gt;
  void DirExplorerT&lt;App&gt;::showStats()
  {
    app_.showStats();
  }

  template&lt;typename App&gt;
  bool DirExplorerT&lt;App&gt;::done()
  {
    return app_.done();
  }
}
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>Code: Application.h</defn-head>
          <defn-code>
#include &lt;iostream&gt;
#include &lt;string&gt;

class Application
{
public:
  Application();
  
  // App defines handling files and dirs, 
  // when to quit, and how to display final
  // results.
  // None of this requires alteration of 
  // DirExplorerT's code.

  void doFile(
    const std::string&amp; filename
  );
  void doDir(
    const std::string&amp; dirname
  );
  size_t fileCount();
  size_t dirCount();
  bool done();
  void showStats();

  // configure application options

  void showAllInCurrDir(
    bool showAllFilesInCurrDir
  );
  bool showAllInCurrDir();
  void maxItems(size_t maxItems);
  
private:
  size_t fileCount_ = 0;
  size_t dirCount_ = 0;
  size_t maxItems_ = 0;
  bool showAll_ = false;
};

inline Application::Application()
{
  std::cout 
    &lt;&lt; "\n  Using App methods "
    &lt;&lt; doFile and doDir\n";
}
inline void Application::doFile(
  const std::string&amp; filename
)
{
  ++fileCount_;
  if(showAll_ || !done())
  {
    std::cout &lt;&lt; "\n  file--&gt;    "
              &lt;&lt; filename;
  }
}
inline void Application::doDir(
  const std::string&amp; dirname
)
{
  ++dirCount_;
  std::cout &lt;&lt; "\n  dir---&gt;  " 
            &lt;&lt; dirname;
}
inline size_t Application::fileCount()
{
  return fileCount_;
}
inline size_t Application::dirCount()
{
  return dirCount_;
}
inline void Application::showAllInCurrDir(
  bool showAllFilesInCurrDir
)
{
  showAll_ = showAllFilesInCurrDir;
}
inline bool Application::showAllInCurrDir()
{
  return showAll_;
}
inline void Application::maxItems(
  size_t maxItems
)
{
  maxItems_ = maxItems;
}
//---&lt; counts for files and dirs &gt;-----

inline void Application::showStats()
{
  std::cout &lt;&lt; "\n\n  processed " 
            &lt;&lt; fileCount_ 
            &lt;&lt; " files in " 
            &lt;&lt; dirCount_ 
            &lt;&lt; " directories";
  if(done())
  {
    std::cout &lt;&lt; 
      "\n  stopped - max num files exceeded";
  }
}
inline bool Application::done()
{
  return (0 &lt; maxItems_ 
            &amp;&amp; maxItems_ 
            &lt; fileCount_);
}
          </defn-code>
        </defn-block>
      </defn-outerBlock>
      <defn-outerBlock>
        <defn-block>
          <defn-head>Using Code</defn-head>
          <defn-code>
#include "DirExplorerT.h"
#include "Application.h"
#include "../StringUtilities/StringUtilities.h"
#include "../CodeUtilities/CodeUtilities.h"
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace Utilities;
using namespace FileSystem;

std::string customUsage()
{
  /* code elided */
  return usage;
}

int main(int argc, char *argv[])
{
  Title("Demonstrate DirExplorer-Template");

  ProcessCmdLine pcl(argc, argv);
  pcl.usage(customUsage());

  preface("Command Line: ");
  pcl.showParse();
  putline();

  if (pcl.parseError())
  {
    pcl.usage();
    std::cout &lt;&lt; "\n\n";
    return 1;
  }

  DirExplorerT&lt;Application&gt; 
     de(pcl.path());

  for (auto patt : pcl.patterns())
  {
    de.addPattern(patt);
  }

  if (pcl.hasOption('s'))
  {
    de.recurse();
  }

  if (pcl.hasOption('h'))
  {
    de.hideEmptyDirectories(true);
  }

  if (pcl.hasOption('a'))
  {
    de.showAllInCurrDir(true);
  }

  if (pcl.maxItems() &gt; 0)
  {
    de.maxItems(pcl.maxItems());
  }

  de.search();
  de.showStats();

  std::cout &lt;&lt; "\n\n";
  return 0;
}
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>Output</defn-head>
          <defn-code>
Demonstrate DirExplorer-Template
==================================
Command Line:

Path:     .
options:
patterns:
Regex:    .*


Using Application methods doFile and doDir

dir--->  C:\github\JimFawcett\CppUtilities...
file-->    Application.cpp
file-->    Application.h
file-->    Application1.cpp.html
file-->    Application1.h.html
file-->    DirExplorer-Template-classes.gliffy
file-->    DirExplorer-Template-classes.jpg
file-->    DirExplorer-Template.jpg
file-->    DirExplorer-Template.vcxproj
file-->    DirExplorer-Template.vcxproj.filters
file-->    DirExplorer-Template.vcxproj.user
file-->    DirExplorerT.cpp
file-->    DirExplorerT.h
file-->    DirExplorerT1.cpp.html
file-->    DirExplorerT1.h.html
dir--->  C:\github\JimFawcett\CppUtilities...

processed 14 files in 2 directories
          </defn-code>
        </defn-block>
      </defn-outerBlock>
    </details>
  </t-b>
  <t-b>
    There is a significant amount of code in <c-s>DirExplorerT</c-s> to digest, but the effort will show you
    a very powerful method of building flexible reusable components.
  </t-b>
  <hr class="spreadup" />
  <ol class="footnote">
    <li>
      There are two STL adapters, <c-s>stack&lt;T&gt;</c-s> and <c-s>queue&lt;T&gt;</c-s>. These were
      built as adapters, wrapping by default the <c-s>deque&lt;T&gt;</c-s>, because they intent to provide
      access only to the top for the <c-s>stack</c-s> and ends for the <c-s>queue</c-s>. That behavior
      voilates the model for STL container classes that provide iteration over entire container
      contents.
    </li>
  </ol>

  <a id="Params"></a>
  <hr class="spread" />
  <num-cont>
    <num-item1>6.5</num-item1><num-item4>Template Parameters</num-item4>
  </num-cont>
  <t-b>
    Template parameters may be:
    <ol class="tight">
      <li>
        <strong>Type Parameters:</strong>
        <i-b>
          <c-s>typename TypeName [= defaultTypeName]</c-s><br />
          TypeName is a formal parameter that represents an unspecified struct or class<br />
          defaultTypeName is the name of a class or struct.<br />
          Example: <c-s>template&lt;typename X=std::string&gt; class Y { ... };</c-s>
        </i-b>
      </li>
      <li>
        <strong>Template type parameters:</strong>
        <i-b>
          <c-s>typename TypeName, template&lt;class TypeName&gt; class TemplateTypeName</c-s><br />
          TemplateTypeName is a formal parameter that represents an unspecified template struct or class<br />
          Example: <c-s>template&lt;typename C, template &lt;class C&gt; class X&gt; class Y { ... };</c-s><br />
          This specifies that <c-s>X</c-s> is a template class that has the parameter <c-s>C</c-s>,
          e.g., the second parameter <c-s>X</c-s> is templated on the first parameter <c-s>C</c-s>.
        </i-b>
      </li>
      <li>
        <strong>Value parameters:</strong>
        <i-b>
          <c-s>Type [= value]</c-s><br />
          Example: <c-s>size_t N = 10</c-s><br />
          <c-s>template&lt;size_t N=10> class Array { ... };</c-s><br />
          This specifies that the templated class uses <c-s>N</c-s> with value <c-s>10</c-s> unless 
          specified otherwise.
        </i-b>
      </li>
    </ol>
  </t-b>
  <t-b>
    <span class="notice">Type parameters</span> may hold processing that customizes behavior of 
    a template class for specific applications.
    they may also be used to define specific data structures
    for an application. Often an application defines type parameters for 
    its unique processing to be used with and existing template class framework.
  </t-b>
  <t-b>
    <span class="notice">Template type parameters</span> are themselves templates. You will see in
    the Template Functors example, below, use of a functor, <c-s>X&lt;C&gt;</c-s> that is parameterized on
    <c-s>C</c-s>, the type of an STL container. It is used in a traversal function to operate on all 
    the members of the STL container.
  </t-b>
  <t-b>
    <span class="notice">Value parameters</span> are values rather than classes. 
    The <c-s>std::Array&lt;T,N&gt; class</c-s>
    uses a value parameter, <c-s>N</c-s> to define the number of elements it holds.
  </t-b>
  <t-b>
    The Template Functors code example, below, has a global function <c-s>Traverse</c-s> that is
    defined with a template parameter, <c-s>C</c-s>, and a 
    <span class="notice">template template parameter, <c-s>X&lt;C&gt;</c-s></span>:
    <i-b class="pad5">
      <c-s>
  template &lt;class C, template &lt;class C&gt; class X&gt;<br />
  void tranverse(<br />
    &nbsp;&nbsp;typename C::iterator&amp; Begin, typename C::iterator&amp; End,<br />
    &nbsp;&nbsp;X&lt;C&gt;&amp; x,<br />
    &nbsp;&nbsp;void(X&lt;C&gt;::*fptr)(typename C::iterator&amp;)<br />
  ) {<br />
    &nbsp;&nbsp;...<br />
  }
      </c-s>
    </i-b>
    where <c-s>C</c-s> represents an STL container, and <c-s>X</c-s> is a function
    object that operates on <c-s>C</c-s> in a way specified by the application that defines
    <c-s>X&lt;C&gt;</c-s>.
  </t-b>
  <t-b>
    <details>
      <summary class="labelStyle darkItem">Template Functors</summary>
      <s-halfEm></s-halfEm>
      <defn-outerBlock>
        <defn-block>
          <defn-head>Template Functor Code</defn-head>
          <defn-code>
///////////////////////////////////////////////////////////////
// FunctorsEtc.cpp - Demonstrate Functors, Function Pointers //
//                   with template arguments                 //
//                                                           //
// Jim Fawcett, CSE67 - Object Oriented Design, Spring 2009  //
///////////////////////////////////////////////////////////////

#include &lt;iterator&gt;
#include &lt;string&gt;

// Functor interface, to support substitutability

template &lt;typename C&gt;
struct IFunctor
{
  virtual void operator()(typename C::iterator&amp; iter)=0;
};

// Global funct accepts iterators &amp; base functor reference,
// templatized on a container argument.

template &lt;typename C&gt;
void Traverse(
  typename C::iterator&amp; Begin, typename C::iterator&amp; End,
  IFunctor&lt;C&gt;&amp; funct
)
{
  C::iterator iter;
  for(iter=Begin; iter!=End; ++iter)
    funct(iter);
}

// Global funct accepts iterators &amp; member function pointer
// templatized on a container argument

template &lt;class C, template &lt;class C&gt; class X&gt;
void Traverse(
  typename C::iterator&amp; Begin, 
  typename C::iterator&amp; End, 
  X&lt;C&gt;&amp; x, 
  void(X&lt;C&gt;::*fptr)(typename C::iterator&amp;)
)
{
  C::iterator iter;
  for(iter=Begin; iter!=End; ++iter)
  {
    (x.*fptr)(iter);
  }
}
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>Using Code</defn-head>
          <defn-code>
#include &lt;string&gt;
#include &lt;iostream&gt;

// one possible operation to apply to some container

class aFunctor : public IFunctor&lt;std::string&gt;
{
  void operator()(std::string::iterator&amp; iter)
  {
    std::cout &lt;&lt; *iter &lt;&lt; " ";
  }
};

// template class has member function we will point to

template &lt;typename C&gt;
class X
{
public:
  void doOp(typename C::iterator&amp; iter)
  {
    std::cout &lt;&lt; *iter &lt;&lt; " ";
  }
};

// alias for template function pointer to member

typedef void (X&lt;std::string&gt;::*fptr)(
          std::string::iterator&amp;
        );

void main()
{
  std::string test = 
    "CSE687 - Object Oriented Design";
  
  // testing functor
  aFunctor func;
  std::cout &lt;&lt; "\n  ";
  Traverse(test.begin(), test.end(), func);
  
  // testing function pointer to member

  std::cout &lt;&lt; "\n  ";
  X&lt;std::string&gt; x;
  fptr f = &amp;X&lt;std::string&gt;::doOp;
  Traverse&lt;std::string&gt;(
    test.begin(), test.end(), x, f
  ); 

  // this syntax works too
  
  std::cout &lt;&lt; "\n  ";
  Traverse&lt;std::string&gt;(
    test.begin(), test.end(), 
    x, &amp;X&lt;std::string&gt;::doOp); 

  std::cout &lt;&lt; "\n\n";
}
          </defn-code>
          <defn-head class="defnBorderTop">Output</defn-head>
          <defn-code style="font-size:0.8rem;">
C S E 6 8 7   -   O b j e c t   O r i e n t e d   D e s i g n 
C S E 6 8 7   -   O b j e c t   O r i e n t e d   D e s i g n 
C S E 6 8 7   -   O b j e c t   O r i e n t e d   D e s i g n 
          </defn-code>
        </defn-block>
      </defn-outerBlock>
    </details>
  </t-b>
  <t-b>
    In section 6.6 we discuss template class specialization, a mechanism for providing not only a
    generic pattern for implementing a template class, but also alternate implementations for special
    cases for which the generic pattern may not work well.
  </t-b>

  <a id="ClassSpec"></a>
  <hr class="spread" />
  <num-cont>
    <num-item1>6.6</num-item1><num-item4>Template Class Specialization</num-item4>
  </num-cont>
  <t-b>
    Templates provide the means to define classes that are configured with other subordinate
    classes. In the code block, below, we&apos;re configuring class <c-s>X</c-s> to use helper
    classes <c-s>P</c-s> and <c-s>Q</c-s>.  Each application can decide which helpers to use
    and/or implement another set of helpers specific to that application.
  </t-b>
  <t-b>
    Template <span class="notice">specialization</span> gives us another degree of design freedom.  
    Specialization occurs when
    we define a template class with one or more template arguments, but also provide one or more
    additional classes with the same name, but with at least one of the arguments specialized.
  </t-b>
  <t-b>
    In the code below, we&apos;ve specialized <c-s>X&lt;P,Q&gt;</c-s> for the cases:
    <c-s>X&lt;P,Q1&gt;</c-s>, <c-s>X&lt;P1,Q&gt;</c-s>, and <c-s>X&lt;P1,Q1&gt;</c-s>. Each
    specialization provides its own class implementation and each will be different in some
    way needed for those specific cases. Note that these are different classes.  The compiler
    is required, when compiling a template class, to look for specializations, and if one matches
    the declaration it&apos;s compiling, it must compile the specialized class.
  </t-b>
  <t-b>
    The code block below illustrates template specialization syntax. The following logger example
    demonstrates how specialization is used for practical applications.
  </t-b>
  <t-b>
    <defn-outerBlock class="indent">
    <defn-block>
      <defn-head>Template Class</defn-head>
      <defn-code>
/*----------------------------------------
   Classes P0, P1,Q0, and Q1 defined 
   before this code.
*/
/*-----------------------------------------
   Class used for generic operations
*/
template&lt;typename P = P0, typename Q = Q0&gt;
class X {
public:
  X() {
    std::cout &lt;&lt; "\n  Generic X Template";
  }
  void doProc() {
    p_.doProc();
    q_.doProc();
  }
private:
  P p_;
  Q q_;
};
/*-----------------------------------------
   Class specialized to use Q1
*/
template&lt;typename P&gt;
class X&lt;P, Q1&gt; {
public:
  X() {
    std::cout &lt;&lt; 
      "\n  X partially specialized for Q1";
  }
  void doProc() {
    p_.doProc();
    q_.doProc();
  }
private:
  P p_;
  Q1 q_;
};
/*-----------------------------------------
   Class specialized to use P1
*/
template&lt;typename Q&gt;
class X&lt;P1, Q&gt; {
public:
  X() {
    std::cout &lt;&lt; 
      "\n  X partially specialized for P1";
  }
  void doProc() {
    p_.doProc();
    q_.doProc();
  }
private:
  P1 p_;
  Q q_;
};
/*-----------------------------------------
  Class fully specialized to use P1 and Q1
*/
template&lt;&gt;
class X&lt;P1, Q1&gt; {
public:
  X() {
    std::cout &lt;&lt; 
      "\n  X fully specialized for P1 &amp; Q1";
  }
  void doProc() {
    p_.doProc();
    q_.doProc();
  }
private:
  P1 p_;
  Q1 q_;
};
      </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code:</defn-head>
        <defn-code>
int main() {

  displayDemo("-- generic processing --");
  X&lt;P0, Q0&gt; x1;
  x1.doProc();

  displayDemo(
    "\n  -- using default template args --"
  );
  X&lt;&gt; x2;
  x2.doProc();

  displayDemo(
    "\n  -- Using full specializ'n --"
  );
  X&lt;P1, Q1&gt; x3;
  x3.doProc();

  displayDemo(
    "\n  -- Using specializ'n for P1 --"
  );
  X&lt;P1, Q0&gt; x4;
  x4.doProc();

  displayDemo(
    "\n  -- Using specializ'n for Q1 --"
  );
  X&lt;P0, Q1&gt; x5;
  x5.doProc();

  putline(2);
}
        </defn-code>
      <defn-head class="defnBorderTop">Output</defn-head>
      <defn-code>
  -- generic processing --
  Generic X Template
  doing P0 processing
  doing Q0 processing

  -- using default template args --
  Generic X Template
  doing P0 processing
  doing Q0 processing

  -- Using full specializ'n --
  X fully specialized for P1 & Q1
  doing P1 processing
  doing Q1 processing

  -- Using specializ'n for P1 --
  X partially specialized for P1
  doing P1 processing
  doing Q0 processing

  -- Using specializ'n for Q1 --
  X partially specialized for Q1
  doing P0 processing
  doing Q1 processing
      </defn-code>
    </defn-block>
    </defn-outerBlock>
  </t-b>
  <s-halfEm></s-halfEm>
  <t-b>
    Template specialization provides a generic class, expected to handle common program needs.
    Each specialization adds another class that replaces the generic one for a specific case, e.g.
    a specific parameter type when instantiated.  There may be as many specializations as you need.
  </t-b>
  <t-b>
    The logger example, below, is simpler than that presented above.  It is here to illustrate
    template specialization.  It uses specialization to provide:
    <indent-block>
    <ol class="tight indent">
      <li>
        A generic logger class, Logger&lt;S, F, T&gt;, describing Logger structure.
        It&apos;s not intended for use, but provides the layout for template
        arguments. S is a text-based message, F is a message formatter, and T is a timer.
      </li>
      <li>
        An unadorned logger, Logger&lt;S, FNull, TNull&gt;, that provides basic logging, i.e.,
        writes text to a specified stream. The first argument, S, will usually be a std::string,
        but could also be a structured message. The FNull argument provides a do nothing formatter,
        and the TNull argument provides a do nothing timer.
      </li>
      <li>
        A partial specialization on F, to provide application specific formatting. Note that this
        parameter is a template, e.g., F&lt;S&gt;, allowing F to handle different types of text messages.
      </li>
      <li>
        A partial specialization on T, to provide elapsed time annotations on each message.
      </li>
    </ol>
    </indent-block>
  </t-b>
  <t-b>
    This example deviates from the usual pattern in that the generic class is just used to provide a
    framework for subsequent specializations, so every template the application instantiates is
    a specialization. This design style is used less often than providing a working generic class,
    but sometimes it&apos;s easier to build this way.
  </t-b>
  <div>
    <details>
      <summary class="labelStyle darkItem">Simplified Logger illustrates specialization</summary>
      <s-halfEm></s-halfEm>
      <defn-outerBlock>
        <defn-block>
          <defn-head>Code: Specialized Logger</defn-head>
          <defn-code>
  struct TNull {};

  template&lt;typename S&gt;
  struct FNull {};

  template&lt;
    typename S, 
    template&lt;typename S&gt; typename F = FNull, 
    typename T = TNull
  &gt;
  class Logger { 
    /*-- used for specializ'n structure --*/ 
  };
  /*---------------------------------------
     unadorned Logger
  ---------------------------------------*/

  template&lt;typename S&gt;
  class Logger&lt;S, FNull, TNull&gt; {
  public:
    Logger(std::ostream* pStr) 
      : pStream_(pStr) {}
    ~Logger() {}
    void write(S s) {
      (*pStream_) &lt;&lt; prefix_ &lt;&lt; s;
    }
  private:
    std::string prefix_ = "\n  ";
    std::ostream* pStream_;
  };

  /*---------------------------------------
    template class partial specialization 
    on Formatter class
    - this is partial class specialization
      since S and F are still unspecified
  ---------------------------------------*/

  template&lt;typename S&gt;
  struct Formatter {
    const char* prefix_ = "\n  &lt;-- ";
    const char* suffix_ = " --&gt;";
    std::string transform(const S&amp; s) {
      return prefix_ + s + suffix_;
    }
  };

  template&lt;
    typename S, 
    template&lt;typename S&gt; typename F
  &gt;
  class Logger&lt;S, F, TNull&gt; {
  public:
    Logger(std::ostream* pStr) 
      : pStream_(pStr) {}
    ~Logger() {}
    void write(S s) {
      (*pStream_) &lt;&lt; f.transform(s);
    }
  private:
    std::string prefix_ = "\n  ";
    std::ostream* pStream_;
    F&lt;S&gt; f;
  };
  
  /*---------------------------------------
    template class partial specialization 
    on Timer class
    - See Timer.h for details
  ---------------------------------------*/

  template&lt;typename S, typename T&gt;
  class Logger&lt;S, FNull, T&gt; {
  public:
    Logger(std::ostream* pStr) 
      : pStream_(pStr) {}
    ~Logger() {
      timer_.stop();
    }
    void start() {
      timer_.start();
    }
    void stop() {
      timer_.stop();
    }
    void write(S s) {
      (*pStream_) 
        &lt;&lt; prefix_ &lt;&lt; std::setw(6) 
        &lt;&lt; timer_.elapsedMicroseconds() 
        &lt;&lt; " microsec : " &lt;&lt; s;
    }
  private:
    std::string prefix_ = "\n  ";
    T timer_;
    std::ostream* pStream_;
  };
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>Using Code</defn-head>
          <defn-code>
int main() {
  
  displayTitle("Demonstrate Logger Specializ'n");

  displayDemo("--- Unadorned Logger ---\n");
  /* using defaults F=FNull, T=TNull */
  Logger&lt;std::string&gt; log(&amp;std::cout);
  log.write("first log item");
  log.write("second log item");

  displayDemo(
    "\n  -- Specializ'n for format logs --\n"
  );
  /* using default T = TNull */
  Logger&lt;std::string, Formatter&gt; 
    flog(&amp;std::cout);
  flog.write("first formatted log item");
  flog.write("second formatted log item");

  displayDemo(
    "\n  -- Specializ'n for timed logs --\n"
  );
  /* cite FNull because defaults only at end */
  Logger&lt;std::string, FNull, Timer&gt; 
    tlog(&amp;std::cout);
  tlog.start();
  tlog.write("first timed log item");
  tlog.write("second timed log item");
  tlog.write("third timed log item");

  std::cout &lt;&lt; "\n\n";
}
          </defn-code>
          <defn-head class="defnBorderTop">Output</defn-head>
          <defn-code>
Demonstrate Logger Specializ'n
===============================

--- Unadorned Logger ---

first log item
second log item

--- Specializ'n for format logs ---

<-- first formatted log item -->
<-- second formatted log item -->

--- Specializ'n for timed logs ---

    41 microsec : first timed log item
    482 microsec : second timed log item
    790 microsec : third timed log item
          </defn-code>
        </defn-block>
      </defn-outerBlock>
      <t-b>
        A more fully featured implementation would probably also provide a full specialization for both
        formatting and timing.
      </t-b>
    </details>
  </div>

  <!--<div>
    <details>
      <summary class="labelStyle darkItem">Property Class Specialization</summary>
      <s-halfEm></s-halfEm>
      <defn-outerBlock>
        <defn-block>
          <defn-head>Property Example</defn-head>
          <defn-code>
enum class PropertyType { Numeric, SeqContr, AssocContr, Nil };

template&lt;typename T, PropertyType PT = PropertyType::Nil &gt;
class Property {
public:
  Property() : t_{ T() } {}

  Property(const T&amp; t) : t_{ t } {}

  void operator()(const T&amp; t) {
    t_ = t;
  }
  T operator()() {
    return t_;
  }
protected:
  T t_;
};

template&lt;typename T&gt;
class Property&lt;T, PropertyType::Numeric&gt; : public Property&lt;T&gt; {
public:
  Property() {}

  Property(const T&amp; t) : Property&lt;T&gt;{ t } {}

  void operator+=(T t) {
    Property&lt;T&gt;::t_ += t;
  }
  T operator+(T t) {
    return Property&lt;T&gt;::t_ + t;
  }
  void operator-=(const T&amp; t) {
    Property&lt;T&gt;::t_ -= t;
  }
  T operator-(const T&amp; t) {
    return Property&lt;T&gt;::t_ - t;
  }
  void operator*=(const T&amp; t) {
    Property&lt;T&gt;::t_ *= t;
  }
  T operator*(const T&amp; t) {
    return Property&lt;T&gt;::t_ * t;
  }
  void operator/=(const T&amp; t) {
    Property&lt;T&gt;::t_ /= t;
  }
  T operator/(const T&amp; t) {
    return Property&lt;T&gt;::t_ / t;
  }
};

template&lt;typename T&gt;
class Property&lt;T, PropertyType::SeqContr&gt; : public Property&lt;T&gt; {
public:
  using iterator = typename T::iterator;

  Property() {}

  Property(const T&amp; t) : Property&lt;T&gt;{ t } {}

  size_t size() {
    return Property &lt; T&gt;::t_.size();
  }
  typename T::value_type back() {
    return Property &lt; T&gt;::t_.back();
  }
  void push_back(const typename T::value_type&amp; v) {
    Property&lt;T&gt;::t_.push_back(v);
  }
  void pop_back() {
    Property&lt;T&gt;::t_.pop_back();
  }
  typename T::value_type front() {
    return Property &lt; T&gt;::t_.back();
  }
  void push_front(const typename T::value_type&amp; v) {
    Property&lt;T&gt;::t_.push_front(v);
  }
  void pop_front() {
    Property&lt;T&gt;::t_.pop_front();
  }
  iterator insert(iterator iter, const typename T::value_type&amp; v) {
    return Property&lt;T&gt;::t_.insert(iter, v);
  }
  typename iterator erase(iterator iter) {
    return Property&lt;T&gt;::t_.erase(iter);
  }
  iterator begin() {
    return Property&lt;T&gt;::t_.begin();
  }
  iterator end() {
    return Property&lt;T&gt;::t_.end();
  }
};
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>Using Code</defn-head>
          <defn-code>
#include &lt;iostream&gt;
#include &lt;vector&gt;

template&lt;typename T&gt;
using baseProp = Property&lt;T&gt;;

template&lt;typename T&gt;
using numProp = Property&lt;T, PropertyType::Numeric&gt;;

template&lt;typename T&gt;
using seqProp = Property&lt;T, PropertyType::SeqContr&gt;;

template&lt;typename T&gt;
void show(seqProp&lt;T&gt;&amp; prop) {
  std::cout &lt;&lt; "\n  ";
  for (auto item : prop) {
    std::cout &lt;&lt; item &lt;&lt; " ";
  }
}

class Widget {
public:
  void say() {
    std::cout &lt;&lt; "\n  Widget instance here";
  }
};

int main() {

  displayTitle("Demonstrating template class specialization");

  displayDemo("--- basic property of Widget ---");
  baseProp&lt;Widget&gt; wProp;
  wProp().say();
  std::cout &lt;&lt; std::endl;

  /*-- defining class using properties --*/

  class X {
  public:
    numProp&lt;int&gt; iProp;
    numProp&lt;double&gt; dProp;
    seqProp&lt;std::vector&lt;int&gt;&gt; viProp;
  };

  displayDemo("-- Property&lt;int, PropertyType::Numeric&gt; --");
  X x;
  x.iProp(1);
  std::cout &lt;&lt; "\n  x.iProp(1) = " &lt;&lt; x.iProp();
  x.iProp += 3;
  std::cout &lt;&lt; "\n  x.iProp += 3 =&gt; x.iProp = " &lt;&lt; x.iProp();
  x.iProp = -2;
  std::cout &lt;&lt; "\n  x.iProp = -2 =&gt; x.iProp = " &lt;&lt; x.iProp();
  putline();

  displayDemo("-- Property&lt;double, PropertyType::Numeric&gt; --");
  x.dProp(3.14159);
  x.dProp += 1.0;
  x.dProp(3.14159);
  std::cout &lt;&lt; "\n  x.dProp(3.14159) = " &lt;&lt; x.dProp();
  std::cout &lt;&lt; std::endl;

  displayDemo("-- Property&lt;std::vector&lt;int&gt;, PropertyType::SeqContr&gt; --");
  x.viProp.push_back(1);
  x.viProp.push_back(2);
  x.viProp.push_back(3);

  std::cout &lt;&lt; "\n  contents of x.vProp are:";
  show(x.viProp);

  x.viProp.pop_back();
  std::cout &lt;&lt; "\n  after pop_back, contents of x.vProp are:";
  show(x.viProp);
  x.viProp.insert(x.viProp.begin() + 1, -4);
  std::cout &lt;&lt; "\n  after inserting -4 in the second position:";
  show(x.viProp);
  x.viProp.erase(x.viProp.begin() + x.viProp.size() - 1);
  std::cout &lt;&lt; "\n  after erasing last element:";
  show(x.viProp);

  std::cout &lt;&lt; "\n\n";
}
          </defn-code>
          <defn-head>Output</defn-head>
          <defn-code>
  Demonstrating template class specialization
 =============================================

  --- basic property of Widget ---
  Widget instance here

  -- Property&lt;int, PropertyType::Numeric&gt; --
  x.iProp(1) = 1
  x.iProp += 3 => x.iProp = 4
  x.iProp = -2 => x.iProp = -2

  -- Property&lt;double, PropertyType::Numeric&gt; --
  x.dProp(3.14159) = 3.14159

  -- Property&lt;std::vector&lt;int&gt;, PropertyType::SeqContr&gt; --
  contents of x.vProp are:
  1 2 3
  after pop_back, contents of x.vProp are:
  1 2
  after inserting -4 in the second position:
  1 -4 2
  after erasing last element:
  1 -4

          </defn-code>
        </defn-block>
      </defn-outerBlock>
    </details>
  </div>-->
    <t-b>
      This concludes our discussion of templates, overloading, and specialization.  In the next
      chapter we discuss Template Metaprogramming.
    </t-b>
    <a id="epilog"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>6.7</num-item1><num-item4>Epilog - Two More Examples and References</num-item4>
    </num-cont>
    <t-b>
      The examples below are too large for the main part of this chapter. They are here to illustrate 
      very typical uses of templates:
      <indent-block>
        <ol class="indent tight">
          <li>
            <c-s>Graph&lt;V,E&gt;</c-s> illustrates the use of template parameters to hold information.  The
            <c-s>V</c-s> type holds information specific to each instance of a graph vertex, perhaps a name,
            and the <c-s>E</c-s> type holds information specific to each instance of a graph edge, perhaps
            the type of relationship between the dependency parent and child vertices.
          </li>
          <li>
            <c-s>Logger&lt;T,C&gt;</c-s> uses a value parameter, <c-s>C</c-s>, to define categories of
            loggers, by creating a different logger class for each value of <c-s>C</c-s>.  So, for example,
            we might define <c-s>Logger&lt;std::string,1&gt;</c-s> and <c-s>Logger&lt;std::string,2&gt;</c-s>
            to log information from two threads, <c-s>t1</c-s> and <c-s>t2</c-s>.
          </li>
        </ol>
      </indent-block>
    </t-b>
  <t-b>
    The first example is a Directed Graph class.  You can find complete code
    in the <a href="CppGraph.html">CppGraph.html</a> repository. A directed graph consists of vertices
    that are connected with directed edges, from parent vertex to child vertex. Graphs are used to
    represent hierarchal relationships, e.g., package dependency or social network friend relationships.
  </t-b>
  <t-b>
    The example is here, because it uses two template
    <span class="notice">type parameters, <c-s>V</c-s> and <c-s>E</c-s></span>, that
    represent information held in each vertex and each edge.  For example, a class dependency graph
    would probably contain a class name in each vertex and in each edge a class relationship
    type, e.g., inheritance, composition, aggregation, or using.
  </t-b>
  <t-b>
    Before looking at the example, it will help to look at the <a href="CppGraph.html">Graph Documentation</a>
    for the CppGraph repository.  We show diagrams there that will help you understand the code below.
  </t-b>
  <t-b>
  <details>
    <summary class="labelStyle darkItem">Directed Graph Class</summary>
    <s-halfEm></s-halfEm>
    <div class="indent pad10">
      <a href="Resources/Graph.h.html">Graph.h</a>, 
      <a href="Resources/Graph.cpp.html">Graph.cpp</a>, 
      <a href="Resources/Graph.out.html">Graph.out</a>
    </div>
    <defn-outerBlock>
    <defn-block>
      <defn-head>Vertex and Graph Code</defn-head>
      <defn-code>
namespace GraphLib 
{
  /////////////////////////////////////////////////////////
  // Vertex class

  template&lt;typename V, typename E&gt; 
  class Vertex
  {
  public:
    typedef std::pair&lt;int, E&gt; Edge;  
    // graph index of target vertex, edge type
    typename typedef std::vector&lt;Edge&gt;::iterator iterator;
    iterator begin();
    iterator end();
    Vertex(V v, size_t id);
    Vertex(V v);
    void add(Edge& edge);
    // compiler generated copy ctor, copy assignOp correct
    // Vertex(const Vertex&lt;V,E&gt;& v);
    // Vertex&lt;V,E&gt;& operator=(const Vertex&lt;V,E&gt;& v);
    Edge& operator[](size_t i);
    Edge operator[](size_t i) const;
    V& value();
    size_t& id(); 
    size_t size();
    bool& mark();
  private:
    std::vector&lt;Edge&gt; _edges;
    V _v;
    size_t _id;
    static size_t count;
    bool _mark;
  };
  //--&lt; reserve memory for, and initialize, static count &gt;--
  template&lt;typename V, typename E&gt;
  size_t Vertex&lt;V,E&gt;::count = 0;

  //--&lt; set and return boolean mark, used for traversal &gt;--
  template&lt;typename V, typename E&gt;
  bool& Vertex&lt;V,E&gt;::mark() { return _mark; }

  //----&lt; return iterator pointing to first edge &gt;---------
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt;::iterator Vertex&lt;V,E&gt;::begin() { 
    return _edges.begin(); 
  }

  //--&lt; return iterator pointing to one past last edge &gt;---
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt;::iterator Vertex&lt;V,E&gt;::end() {
    return _edges.end(); 
  }

  //----&lt; construct instance, specifying unique id &gt;-----
  template&lt;typename V, typename E&gt;
  Vertex&lt;V,E&gt;::Vertex(V v, size_t id) : 
    _v(v), _id(id), _mark(false) {}

  //--&lt; construct instance - creates id sequentially &gt;---
  template&lt;typename V, typename E&gt;
  Vertex&lt;V,E&gt;::Vertex(V v) : 
    _v(v), _id(count++), _mark(false) {}

  //----&lt; add edge to vertex edge collection &gt;-----------
  template&lt;typename V, typename E&gt;
  void Vertex&lt;V,E&gt;::add(Edge& edge) {
    _edges.push_back(edge); 
  }

  //----&lt; index non-const vertex's edges &gt;---------------
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt;::Edge& 
  Vertex&lt;V,E&gt;::operator[](size_t i) { 
    return _edges[i]; 
  }
  
  //----&lt; index const vertex's edges &gt;-------------------
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt;::Edge 
  Vertex&lt;V,E&gt;::operator[](size_t i) const {
    return _edges[i]; 
  }
  
  //---&lt; set and read value of vertex's held type, V &gt;---
  template&lt;typename V, typename E&gt;
  V& Vertex&lt;V,E&gt;::value() { return _v; }
  
  //----&lt; return vertex's id &gt;---------------------------
  template&lt;typename V, typename E&gt;
  size_t& Vertex&lt;V,E&gt;::id() { return _id; }
  
  //----&lt; return number of edges &gt;-----------------------
  template&lt;typename V, typename E&gt;
  size_t Vertex&lt;V,E&gt;::size() { return _edges.size(); }

  ///////////////////////////////////////////////////
  // Graph class

  template&lt;typename V, typename E&gt;
  class Graph
  {
  public:
    typename typedef 
    std::vector&lt; Vertex&lt;V,E&gt; &gt;::iterator iterator;
    iterator begin();
    iterator end();
    // compiler generated copy ctor, copy assignOp correct
    // Graph(const Graph&lt;V,E&gt;& g);
    // Graph&lt;V,E&gt;& operator=(const Graph&lt;V,E&gt;& g);
    Vertex&lt;V,E&gt;& operator[](size_t i);
    Vertex&lt;V,E&gt; operator[](size_t i) const;
    void addVertex(Vertex&lt;V,E&gt; v);
    void addEdge(
      E eval, Vertex&lt;V,E&gt;& parent, 
      Vertex&lt;V,E&gt;& child
    );
    size_t findVertexIndexById(size_t id);
    size_t size();
    template&lt;typename F&gt;
    void dfs(Vertex&lt;V,E&gt;& v, F f);
  private:
    std::vector&lt; Vertex&lt;V,E&gt; &gt; adj;
    std::unordered_map&lt;size_t, size_t&gt; idMap; 
    // id maps to graph index
    template&lt;typename F&gt;
    void dfsCore(Vertex&lt;V,E&gt;& v, F f);
  };
  //----&lt; return iterator pointing to first vertex &gt;-----
  template&lt;typename V, typename E&gt;
  typename Graph&lt;V,E&gt;::iterator Graph&lt;V,E&gt;::begin() { 
    return adj.begin(); 
  }

  //--&lt; return iterator pointing one past last vertex &gt;--
  template&lt;typename V, typename E&gt;
  typename Graph&lt;V,E&gt;::iterator Graph&lt;V,E&gt;::end() { 
    return adj.end(); 
  }
  
  //----&lt; index non-const graph's vertex collection &gt;----
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt;& 
  Graph&lt;V,E&gt;::operator[](size_t i) { 
    return adj[i]; 
  }
 
  //----&lt; index const graph's vertex collection &gt;--------
  template&lt;typename V, typename E&gt;
  typename Vertex&lt;V,E&gt; 
  Graph&lt;V,E&gt;::operator[](size_t i) const { 
    return adj[i]; 
  }
  
  //----&lt; add vertex to graph's vertex collection &gt;------
  template&lt;typename V, typename E&gt;
  void Graph&lt;V,E&gt;::addVertex(Vertex&lt;V,E&gt; v) 
  { 
    adj.push_back(v);
    idMap[v.id()] = adj.size() - 1;
  }
  //----&lt; return number of vertices in graph's coll &gt;----
  template&lt;typename V, typename E&gt;
  size_t Graph&lt;V,E&gt;::size() { return adj.size(); }

  //----&lt; return index of vertex with specified id &gt;-----
  template&lt;typename V, typename E&gt;
  size_t Graph&lt;V,E&gt;::findVertexIndexById(size_t id)
  {
    return idMap[id];
  }
  //----&lt; add edge from parent to child vertices &gt;------
  template&lt;typename V, typename E&gt;
  void Graph&lt;V,E&gt;::addEdge(
    E eVal, Vertex&lt;V,E&gt;& parent, 
    Vertex&lt;V,E&gt;& child
  )
  {
    size_t childIndex = findVertexIndexById(child.id());
    if(childIndex == adj.size())
      throw std::exception("no edge child");
    size_t parentIndex = findVertexIndexById(parent.id());
    if(parentIndex == adj.size())
      throw std::exception("no edge parent");
    Vertex&lt;V,E&gt;::Edge e;
    e.first = childIndex;
    e.second = eVal;
    adj[parentIndex].add(e);
  }
  //---&lt; recursive depth first search with action f &gt;----
  template&lt;typename V, typename E&gt;
  template&lt;typename F&gt;
  void Graph&lt;V,E&gt;::dfsCore(Vertex&lt;V,E&gt;& v, F f)
  {
    f(v);
    v.mark() = true;
    for(auto edge : v)
    {
      if(adj[edge.first].mark() == false)
        dfsCore(adj[edge.first], f);
    }
    for(auto& vert : adj)
    {
      if(vert.mark() == false)
        dfsCore(vert, f);
    }
  }
  //--&lt; depth first srch, clears marks for next srch &gt;---
  template&lt;typename V, typename E&gt;
  template&lt;typename F&gt;
  void Graph&lt;V,E&gt;::dfs(Vertex&lt;V,E&gt;& v, F f)
  {
    dfsCore(v, f);
    for(auto& vert : adj)
      vert.mark() = false;
  }
      </defn-code>
    </defn-block>
    <defn-block>
      <defn-head>Using Code</defn-head>
      <defn-code>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include "Graph.h"
using namespace GraphLib;

typedef Graph&lt;std::string, std::string&gt; graph;
typedef Vertex&lt;std::string, std::string&gt; vertex;
typedef Display&lt;std::string, std::string&gt; display;

void showVert(Vertex&lt;std::string, std::string&gt;& v)
{
  std::cout &lt;&lt; "\n  " &lt;&lt; v.id();
}

template&lt;typename V, typename E&gt;
void TshowVert(Vertex&lt;V,E&gt;& v)
{
  std::cout &lt;&lt; "\n  " &lt;&lt; v.id();
}

#ifdef TEST_GRAPH

int main()
{
  std::cout &lt;&lt; "\n  Testing Graph Library";
  std::cout &lt;&lt; "\n =======================\n";
  try
  {
    std::cout &lt;&lt; "\n  Constructing Graph instance";
    std::cout &lt;&lt; "\n -----------------------------";
    graph g;
    vertex v1("v1");
    vertex v2("v2");
    vertex v3("v3");
    vertex v4("v4");
    vertex v5("v5", 50);
    g.addVertex(v2);
    g.addVertex(v1);
    g.addVertex(v3);
    g.addVertex(v4);
    g.addVertex(v5);
    g.addEdge("e1",v1,v2);
    g.addEdge("e2",v1,v3);
    g.addEdge("e3",v2,v3);
    g.addEdge("e4",v4,v3);
    g.addEdge("e5",v5,v2);

    display::show(g);
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "\n  Making copy of instance";
    std::cout &lt;&lt; "\n -------------------------";
    graph gcopy = g;
    display::show(gcopy);
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "\n  Modifying copy's values";
    std::cout &lt;&lt; "\n -------------------------";
    for(auto& v : gcopy)
      v.value() += "copy";

    display::show(gcopy);
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "\n  Assigning instance to copy";
    std::cout &lt;&lt; "\n ----------------------------";
    gcopy = g;
    display::show(gcopy);
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "\n  Vertices with no Parents:";
    std::cout &lt;&lt; "\n ---------------------------";

    std::vector&lt; vertex &gt; verts = 
      display::vertsWithNoParents(g);
    std::cout &lt;&lt; "\n  ";
    for(size_t i=0; i&lt;verts.size(); ++i)
      std::cout &lt;&lt; verts[i].value().c_str() 
      &lt;&lt; " ";
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; 
      "\n  Testing Depth First Search function pointer";
    std::cout &lt;&lt; 
      "\n ---------------------------------------------";
    for(auto& vert : g)
    {
      std::cout &lt;&lt; "\n  starting at id " 
                &lt;&lt; vert.id();
      g.dfs(vert, TshowVert&lt;std::string, std::string&gt;);
      // this works too: 
      // g.dfs(vert, showVert);
    }
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; 
      "\n  Testing Depth First Search with Functor";
    std::cout &lt;&lt; 
      "\n -----------------------------------------";

    class showFunctor
    {
    public:
      void operator()(
        Vertex&lt;std::string, std::string&gt;& vert
      )
      {
        std::cout &lt;&lt; "\n  From functor: vertix id = " 
                  &lt;&lt; vert.id();
        std::cout &lt;&lt; ", number of edges = " 
                  &lt;&lt; vert.size();
      }
    };

    g.dfs(g[0], showFunctor());
    std::cout &lt;&lt; "\n";

    std::cout &lt;&lt; "\n  Testing Serialization to XML";
    std::cout &lt;&lt; "\n ------------------------------";
    std::string str = GraphToXmlString(g);
    std::cout &lt;&lt; str &lt;&lt; "\n";
    std::ofstream out("testGraph.xml");
    out &lt;&lt; str &lt;&lt; "\n";

    std::cout &lt;&lt; 
      "\n  Testing Graph construction from XML";
    std::cout &lt;&lt; 
      "\n -------------------------------------";
    graph gtest;
    GraphFromXmlString(gtest, str);
    display::show(gtest);
    std::cout &lt;&lt; "\n\n";
  }
  catch(std::exception& ex)
  {
    std::cout &lt;&lt; "\n\n  " &lt;&lt; ex.what() 
              &lt;&lt; "\n\n";
  }
  std::cout &lt;&lt; "\n\n";
  return 0;
}

#endif
      </defn-code>
      <defn-head class="defnBorderTop">Output</defn-head>
      <defn-code tabindex="1" class="autoX" style="max-width:40vw;">
  Testing Graph Library
 =======================

  Constructing Graph instance
 -----------------------------
  vertex id = 1, value = v2
    edge points to vertex with id = 2 and value = v3, edge value = e3
  vertex id = 0, value = v1
    edge points to vertex with id = 1 and value = v2, edge value = e1
    edge points to vertex with id = 2 and value = v3, edge value = e2
  vertex id = 2, value = v3
  vertex id = 3, value = v4
    edge points to vertex with id = 2 and value = v3, edge value = e4
  vertex id = 50, value = v5
    edge points to vertex with id = 1 and value = v2, edge value = e5

  Making copy of instance
 -------------------------
  vertex id = 1, value = v2
    edge points to vertex with id = 2 and value = v3, edge value = e3
  vertex id = 0, value = v1
    edge points to vertex with id = 1 and value = v2, edge value = e1
    edge points to vertex with id = 2 and value = v3, edge value = e2
  vertex id = 2, value = v3
  vertex id = 3, value = v4
    edge points to vertex with id = 2 and value = v3, edge value = e4
  vertex id = 50, value = v5
    edge points to vertex with id = 1 and value = v2, edge value = e5

  Modifying copy's values
 -------------------------
  vertex id = 1, value = v2copy
    edge points to vertex with id = 2 and value = v3copy, edge value = e3
  vertex id = 0, value = v1copy
    edge points to vertex with id = 1 and value = v2copy, edge value = e1
    edge points to vertex with id = 2 and value = v3copy, edge value = e2
  vertex id = 2, value = v3copy
  vertex id = 3, value = v4copy
    edge points to vertex with id = 2 and value = v3copy, edge value = e4
  vertex id = 50, value = v5copy
    edge points to vertex with id = 1 and value = v2copy, edge value = e5

  Assigning original instance to copy
 -------------------------------------
  vertex id = 1, value = v2
    edge points to vertex with id = 2 and value = v3, edge value = e3
  vertex id = 0, value = v1
    edge points to vertex with id = 1 and value = v2, edge value = e1
    edge points to vertex with id = 2 and value = v3, edge value = e2
  vertex id = 2, value = v3
  vertex id = 3, value = v4
    edge points to vertex with id = 2 and value = v3, edge value = e4
  vertex id = 50, value = v5
    edge points to vertex with id = 1 and value = v2, edge value = e5

  Vertices with no Parents:
 ---------------------------
  v1 v4 v5

  Testing Depth First Search with function pointer
 --------------------------------------------------
  starting at id 1
  1
  2
  0
  3
  50
  starting at id 0
  0
  1
  2
  3
  50
  starting at id 2
  2
  1
  0
  3
  50
  starting at id 3
  3
  2
  1
  0
  50
  starting at id 50
  50
  1
  2
  0
  3

  Testing Depth First Search with Functor
 -----------------------------------------
  From functor: vertix id = 1, number of edges = 1
  From functor: vertix id = 2, number of edges = 0
  From functor: vertix id = 0, number of edges = 2
  From functor: vertix id = 3, number of edges = 1
  From functor: vertix id = 50, number of edges = 1

  Testing Serialization to XML
 ------------------------------
&lt;graph&gt;
  &lt;vertex id="1" value="v2"&gt;
    &lt;edge targetId="2" value="e3"&gt;
    &lt;/edge&gt;
  &lt;/vertex&gt;
  &lt;vertex id="0" value="v1"&gt;
    &lt;edge targetId="1" value="e1"&gt;
    &lt;/edge&gt;
    &lt;edge targetId="2" value="e2"&gt;
    &lt;/edge&gt;
  &lt;/vertex&gt;
  &lt;vertex id="2" value="v3"&gt;
  &lt;/vertex&gt;
  &lt;vertex id="3" value="v4"&gt;
    &lt;edge targetId="2" value="e4"&gt;
    &lt;/edge&gt;
  &lt;/vertex&gt;
  &lt;vertex id="50" value="v5"&gt;
    &lt;edge targetId="1" value="e5"&gt;
    &lt;/edge&gt;
  &lt;/vertex&gt;
&lt;/graph&gt;

  Testing Graph construction from XML
 -------------------------------------
  vertex id = 1, value = v2
    edge points to vertex with id = 2 and value = v3, edge value = e3
  vertex id = 0, value = v1
    edge points to vertex with id = 1 and value = v2, edge value = e1
    edge points to vertex with id = 2 and value = v3, edge value = e2
  vertex id = 2, value = v3
  vertex id = 3, value = v4
    edge points to vertex with id = 2 and value = v3, edge value = e4
  vertex id = 50, value = v5
    edge points to vertex with id = 1 and value = v2, edge value = e5
      </defn-code>
    </defn-block>
    </defn-outerBlock>
  </details>
  </t-b>
  <t-b>
  <t-b>
    In the Logger class example, below, <c-s>Logger</c-s> has a larger design than the earlier
    simplified Logger example.  It takes a 
    <span class="notice">template type parameter <c-s>T</c-s></span>, 
    the type of message being logged, and <span class="notice">value parameter <c-s>size_t C</c-s></span>, 
    representing a logger category. 
    <c-s>Logger</c-s> uses its <c-s>C</c-s> parameter to define a logging level, e.g., debug or 
    demonstration or results or some combination of the three.
  </t-b>
  <t-b>
    <details>
      <summary class="labelStyle darkItem">Logger Class</summary>
      <s-halfEm></s-halfEm>
      <defn-outerBlock>
      <defn-block>
        <defn-head>Logger Code</defn-head>
        <defn-code>
namespace Utilities {
  
  enum Level { results = 1, demo = 2, debug = 4, all = 7 };

  template &lt;typename T, size_t C = 0&gt;
  struct ILogger {
    virtual ~ILogger() {}
    virtual ILogger&lt;T, C&gt;&amp; add(std::ostream*) = 0;
    virtual ILogger&lt;T, C&gt;&amp; 
    write(T t, size_t level = Level::all) = 0;
    virtual void head(T t = "") = 0;
    virtual void prefix(T prfix = "\n  ") = 0;
    virtual void wait() = 0;
    virtual void waitForWrites() = 0;
    virtual void level(size_t lv) = 0;
    virtual void name(const std::string&amp; nm) = 0;
  };

  template &lt;typename T, size_t C = 0&gt;
  class Logger : public ILogger&lt;T, C&gt; {
  public:
    Logger(const std::string&amp; nm = "");
    ~Logger();
    ILogger&lt;T, C&gt;&amp; add(std::ostream* pOstrm);
    virtual ILogger&lt;T, C&gt;&amp; 
    write(T t, size_t level = 0x7);
    virtual void head(T t = "");
    virtual void prefix(T prfix = "\n  ");
    virtual void level(size_t lv);
    void name(const std::string&amp; nm);
    std::string name();
    void wait();
    void waitForWrites();
  protected:
    std::vector&lt;std::ostream*&gt; dstStrm;
    BlockingQueue&lt;T&gt; blockingQueue_;
    void threadProc();
    std::string name_;
    std::thread writeThread_;
    T head_;
    std::string prefix_ = "\n  ";
    size_t level_ = 
      0x7; // Level::debug + Level::demo + Level::results;
  };
  /*--- object factory ----------------------------------
   *
   *  Creates static logger, so calling makeLogger with
   *  the same value for C will use the same logger.
   */
  template&lt;typename T, size_t C&gt;
  inline ILogger&lt;T, C&gt;&amp; makeLogger() {
    static Logger&lt;T, C&gt; logger;
    return logger;
  }
  /*--- initialize logger with name -------------------*/

  template&lt;typename T, size_t C&gt;
  Logger&lt;T, C&gt;::Logger(const std::string&amp; nm) 
    : name_(nm) {
    dstStrm.push_back(&amp;std::cout);
    std::thread temp(&amp;Logger&lt;T, C&gt;::threadProc, this);
    writeThread_ = std::move(temp);
  }
  /*--- wait for all writes to be sent ----------------*/

  template&lt;typename T, size_t C&gt;
  Logger&lt;T, C&gt;::~Logger() {
    if (writeThread_.joinable())
      writeThread_.detach();
    for (auto ptrStrm : dstStrm) {
      std::ofstream* ptrOfStrm = 
        dynamic_cast&lt;std::ofstream*&gt;(ptrStrm);
      if (ptrOfStrm) {
        ptrOfStrm-&gt;close();
        delete ptrOfStrm;
      }
    }
  }
  /*--- reset name ------------------------------------*/

  template&lt;typename T, size_t C&gt;
  void Logger&lt;T, C&gt;::name(const std::string&amp; nm) {
    name_ = nm;
  }
  /*--- retrieve name ---------------------------------*/

  template&lt;typename T, size_t C&gt;
  std::string Logger&lt;T, C&gt;::name() {
    return name_;
  }
  /*--- deQ thread processing -------------------------*/

  template&lt;typename T, size_t C&gt;
  void Logger&lt;T,C&gt;::threadProc() {
    while (true) {
      T t = blockingQueue_.deQ();
      if (t == "quit")
        break;
      for (auto item : dstStrm) {
        (*item) &lt;&lt; t;
      }
    }
  }
  /*-- enQ stop message, wait for write thread exit --*/

  template&lt;typename T, size_t C&gt;
  void Logger&lt;T, C&gt;::wait() {
    blockingQueue_.enQ("quit");
    writeThread_.join();
  }
  /*-- wait for Q to empty before writing again ------*/

  template&lt;typename T, size_t C&gt;
  void Logger&lt;T, C&gt;::waitForWrites() {
    while (blockingQueue_.size() &gt; 0)
      std::this_thread::sleep_for(
        std::chrono::milliseconds(20)
      );
  }
  /*--- add another stream for concurrent writes -----*/

  template&lt;typename T, size_t C&gt;
  ILogger&lt;T, C&gt;&amp; 
  Logger&lt;T, C&gt;::add(std::ostream* pOstrm) {
    if(pOstrm != nullptr)
      dstStrm.push_back(pOstrm);
    return *this;
  }
  /*----------------------------------------------------
  *  write a log message
  *  - probably one of many in a log stream
  */

  template&lt;typename T, size_t C&gt;
  ILogger&lt;T, C&gt;&amp; 
  Logger&lt;T, C&gt;::write(T t, size_t lv) {
    if (lv &amp; level_) {
      blockingQueue_.enQ(prefix_ + t);
    }
    return *this;
  }
  /*----------------------------------------------------
   *  write a head message
   *  - expected to be the first in log conversation
   */
  template&lt;typename T, size_t C&gt;
  void Logger&lt;T, C&gt;::head(T t) {
    T temp = (t.size() &gt; 0) ? t : name();
    T prfix = (prefix_ == "") ? "\n" : prefix_;
    head_ = temp + prfix + DateTime().now();
    write(head_);
  }
  /*--- set message prefix ---------------------------*/

  template&lt;typename T, size_t C&gt;
  void Logger&lt;T,C&gt;::prefix(T prfix) {
    prefix_ = prfix;
  }
  /*----------------------------------------------------
   *  set logging level
   *  - results ==&gt; normal output
   *  - demo    ==&gt; demonstration output
   *  - debug   --&gt; show debugging information
   *  can be any combination, e.g., demo + results
   */
  template&lt;typename T, size_t C&gt;
  void Logger&lt;T, C&gt;::level(size_t lv) {
    level_ = lv;
  }
  /*--- helper to open file stream --------------------*/

  inline std::ostream* makeStream(
    const std::string&amp; fileName
  ) {
    std::ofstream* pOfstrm = new std::ofstream;
    pOfstrm-&gt;open(fileName);
    if (pOfstrm-&gt;good())
      return pOfstrm;
    else
      return nullptr;
  }
        </defn-code>
      </defn-block>
      <defn-block>
        <defn-head>Using Code</defn-head>
        <defn-code>
#include &lt;string&gt;
#include "Logger.h"

int main() {

  displayTitle("Testing Logger");
  using namespace Utilities;

  Logger&lt;std::string&gt; logger("test");

  // to see logger demo own test comment next statement
  logger.level(Level::results);
  logger.write("-- constructed logger --\n", Level::demo);
  logger.add(makeStream("test.log"));
  logger.write("\n -- added stream --\n", Level::demo);
  logger.add(makeStream("does not exist"));
  //logger.prefix("  ");
  logger.head();
  logger.write("\n -- called head --\n", Level::demo);
  logger.prefix("");
  logger.write("\n -- called write --\n", Level::demo);
  logger.write("\n  Hi ").write("there ");
  logger.write("from Logger.cpp");
  logger.write("\n");
  logger.write(
    "\n -- waiting for writes to complete --\n", 
    Level::demo
  );
  logger.waitForWrites();

  logger.write("\n  setting level = results");
  logger.level(Level::results);
  logger.write("\n  a debug msg", Level::debug);
  logger.write("\n  a demo", Level::demo);
  logger.write("\n  a result", Level::results);
  logger.write(
    "\n -- waiting for writes to complete --\n", 
    Level::demo
  );
  logger.waitForWrites();

  logger.write("\n  setting level = demo");
  logger.level(Level::demo);
  logger.write("\n  a debug msg", Level::debug);
  logger.write("\n  a demo", Level::demo);
  logger.write("\n  a result", Level::results);
  logger.waitForWrites();

  logger.write("\n  setting level = debug");
  logger.level(Level::debug);
  logger.write("\n  a debug msg", Level::debug);
  logger.write("\n  a demo", Level::demo);
  logger.write("\n  a result", Level::results);
  logger.waitForWrites();

  logger.write("\n  setting level = results + demo");
  logger.level(Level::results + Level::demo);
  logger.write("\n  a debug msg", Level::debug);
  logger.write("\n  a demo", Level::demo);
  logger.write("\n  a result", Level::results);
  logger.waitForWrites();
  
  // to see logger demo own test comment next statement
  logger.level(Level::results);
  logger.write(
    "\n -- calling makeLogger factory --\n", 
    Level::demo
  );
  ILogger&lt;std::string, 0&gt;&amp; logInstance =
    makeLogger&lt;std::string, 0&gt;();
  logInstance.add(makeStream("staticlog.log"));
  logInstance.head("test logger factory");
  logInstance.write("log msg #1").write("log msg #2");
  
  ILogger&lt;std::string, 0&gt;&amp; logInstance2 = 
    makeLogger&lt;std::string, 0&gt;();
  logInstance2.head("test 2nd instance of factory");
  logInstance2.write("log2 msg #1").write("log2 msg #2");
  logInstance2.write("log2 msg #3").write("log2 msg #4");

  const auto&amp; logFactory = 
    []()-&gt;ILogger&lt;std::string,0&gt;&amp; { 
      return makeLogger&lt;std::string, 0&gt;(); 
  };
  logFactory().write("\n  using makeLogger");

  logger.wait();
  logInstance.write("\n  done waiting for logger");
  logInstance.wait();
  putline();
  
  displaySubtitle("Testing Assertions");

  Assert(true, "if you see this Assert raised");
  Assert(false, "a message", __LINE__);
  try {
    Assert(
      false, "another message", __LINE__, true
    );
  }
  catch (std::exception &amp; ex) {
    std::cout &lt;&lt; std::string("\n  ") 
      + ex.what();
  }
  putline();
  Requires(1 == 1, "1 == 1", __LINE__);
  Requires(1 == 2, "1 == 2", __LINE__);
  try {
    Requires(
      1 == 3, "1 == 3", __LINE__, true
    );
  }
  catch (std::exception &amp; ex) {
    std::cout &lt;&lt; std::string("\n  ") 
      + ex.what();
  }
  putline();
  Ensures(1 == 1, "1 == 1", __LINE__);
  Ensures(1 == 2, "1 == 2", __LINE__);
  try {
    Ensures(
      1 == 3, "1 == 3", __LINE__, true
    );
  }
  catch (std::exception &amp; ex) {
    std::cout &lt;&lt; std::string("\n  ") 
      + ex.what();
  }
  putline(2);
}        
        </defn-code>
        <defn-head class="defnBorderTop">Output</defn-head>
        <defn-code>
test
Wed Dec  4 08:20:27 2019
Hi there from Logger.cpp

setting level = results
a result
setting level = demo
a demo
setting level = debug
a debug msg
setting level = results + demo
a demo
a result
        </defn-code>
      </defn-block>
      </defn-outerBlock>
    </details>
    </t-b>
    <t-b>
      Both designs have merit. I will eventually merge the best features of each and put that in the
      <a href="Logger.html">Logger Repository</a>.
    </t-b>
    <t-b>
      C++ templates are a very powerful feature of the language.  We use them to build components that can
      be reused by instantiating with application specific types.  Because templates are constructed at compile
      time, template type deduction makes it suprisingly effective to build these reusable types.
    </t-b>
    <t-b>
      We will explore this further in the next chapter where we look at template metaprogramming.
    </t-b>
    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>6.8</num-item1><num-item4>References:</num-item4>
    </num-cont>
    <t-b>
      <indent-block>
        <div>
          Template Normal Programming - Arthur O'Dwyer'<br />
          <a href="https://www.youtube.com/watch?v=vwrXHznaYLA">video - part 1</a>, 
          <a href="https://github.com/CppCon/CppCon2016/blob/master/Tutorials/Template%20Normal%20Programming%2C%20Part%201/Template%20Normal%20Programming%2C%20Part%201%20-%20Arthur%20O'Dwyer%20-%20CppCon%202016.pdf">
            slides - part 1
          </a>, 
          <a href="https://www.youtube.com/watch?v=VIz6xBvwYd8&t=1721s">video - part 2</a>, 
          <a href="https://github.com/CppCon/CppCon2016/blob/master/Tutorials/Template%20Normal%20Programming%2C%20Part%202/Template%20Normal%20Programming%2C%20Part%202%20-%20Arthur%20O'Dwyer%20-%20CppCon%202016.pdf">
            slides - part 2
          </a>, 
          <a href="https://quuxplusone.github.io/blog/">blog</a>
        </div>
        <s-halfEm></s-halfEm>
        <a href="https://github.com/CppCon/CppCon2018/blob/master/Presentations/class_template_argument_deduction_for_everyone/class_template_argument_deduction_for_everyone__stephan_t_lavavej__cppcon_2018.pdf">
          class template argument deduction
        </a> - Stephan T. Lavavej<br />
        <a href="https://isocpp.org/wiki/faq/templates">isocpp.org - templates</a><br />
        <a href="https://www.youtube.com/watch?v=UDs90b0yjjQ">
          Class template argument deduction in C++17
        </a> - Timur Doumler<br />
      </indent-block>
    </t-b>
  </t-b>
  </bb-55>
  <spacer-25></spacer-25>
    <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->
  <info-bar></info-bar>
</body>
</html>