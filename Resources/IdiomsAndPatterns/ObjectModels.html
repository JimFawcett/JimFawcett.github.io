<!DOCTYPE html>
<html id="top">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>Object Models</title>
    <link rel="stylesheet" href="css/IaP_Styles.css" />
    <script src="js/IaP_Scripts.js"></script>
    <style>
      #github .topborder { border-top: 1px solid #363636;}
      #github th.num { width:3em; text-align:right; padding-right:1.0em; }
      #github td.num { width:3em; text-align:right; padding-right:1.0em; }
      #github table {
        border-collapse:collapse;
      }
      #github th { text-align:left; font-size:1.25em;}
      #github th.elem { 
        border-collapse:collapse;
        padding: 0.5em 0em; white-space:normal; 
      }
      #github td.elem { 
        padding: 1.0em 0.5em; white-space:normal; 
      }
      #github t-b { 
        display: block;
        margin-top: 0.75rem;
        margin-bottom: 0.75rem;
        max-width:55rem;
      }
      #github tt-b {
        padding-top: 0.5em;
        padding-bottom: 0.5em;
      }
    </style>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Idioms and Patterns</span>
      <div style="position:relative; left:calc(100vw - 15rem);">
        <span class="top-center">Object Models</span>
        <!-- <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a> -->
      </div>
  </div>
  <next-prev>
    <a id="prev" href="javascript:;">prev</a> 
    <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
    <a id="next" href="javascript:;">next</a>
  </next-prev>

      <toc-b id="toc">
        <div style="display:flex; flex-direction:row">
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.sects()" style="color: #fefefa; ">Sects</a>&nbsp;
          <a href="../../RustBiteByByte.html" style="color:#fefefa;">Repo</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">Esc</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp;
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
          <up-b id="chaps">
            <a href="ObjectModels.html">Object Models</a><br />
            <a href="Javascript.;#"></a><br />
          </up-b>
            <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#bottom">Bottom</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>N</td><td>Next Bite</td>
          </tr>
          <tr>
            <td>P</td><td>Prev Bite</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>
      </div>
   
    <bb-55>
      <h1>Object Models</h1>
      <h3 style="margin-left:3em; margin-top:0em; font-weight:normal;">Comparisons of C#, C++, and Rust</h3>
      <hr />
      <t-b>
        The table, below, describes what an object model is, and illustrates differences in object models defined
        by the programming languages: C#, C++, and Rust.
        <s-halfEm></s-halfEm>
        Programs for the languagaes we consider here divide memory into three parts:
        <ol class="tight">
          <li>
            Static memory holds its contents for the entire lifetime of a program.  Static memory holds 
            compiled code and values declared as &quot;static&quot; which are initialized only once.
          </li>
          <li>
            Stack memory is allocated when a thread of execution enters a program scope and is deallocated when 
            the thread leaves that scope.  Each scope is defined by a code block enclosed by braces: &apos;{&apos;
            and &apos;}&apos;.
          </li>
          <li>
            Heap memory is allocated (from a process heap) when a program requests storage for some type and 
            lives until the program releases that storage or the program terminates.
          </li>
        </ol>
      </t-b>
      <t-b>
        Object models depend upon this memory model.
      </t-b>
    </bb-55>
    <s-halfEm></s-halfEm>
      <table style="width:100%;">
        <tr>
          <td class="darkItem" colspan="5">Definition: Object Model</td>
        </tr>
        <tr>
          <td class="elem topborder" colspan="4">
            <s-HalfEm></s-HalfEm>
            Instances:<br />
            <s-halfEm></s-halfEm>
            <div class="indent">
              An <strongs>instance</strongs> is a typed memory location initialized with some value.
            </div>
            <s-halfEm></s-halfEm>
            Objects:<br />
            <s-halfEm></s-halfEm>
            <div class="indent">
              An Object is a pattern for creating instances.  If the type is defined by the language we usually
              use the term primitive, e.g., int or double.  Otherwise we use the term object, e.g., struct, vector.
            </div>
            <s-1Em></s-1Em>
            An <strong>Object Model</strong> describes:
            <ol class="tights">
              <li>
                <div>Types:</div>
                <s-halfEm></s-halfEm>
                <div class="indent">
                  A type is defined by a memory configuration with specified set of allowed operations.<br />
                  Examples: integers, floating point numbers, vectors, ...
                </div>
              </li>
              <li>
                <strongs>Execution environment:</strongs>
                <s-halfEm></s-halfEm>
                <div class="indent">
                  Defines where objects are hosted, how their values are accessed, how operations on objects are processed,
                  how errors are handled, and what information about objects are available to programs.
                </div>
              </li>
              <li>
                <strongs>Scope:</strongs>
                <s-halfEm></s-halfEm>
                <div class="indent">
                  Program scopes are defined by code blocks enclosed in braces, e.g., &apos;{&apos; and &apos;}&apos;. 
                  They come in two flavors: compile-time only and run-time scopes.
                  <s-halfEm></s-halfEm>
                  <div class="indents">
                    Compile time scopes define names and access priviledges for namespaces, structs,  
                    classes, and enums.  They affect what program statements are allowed to compile, but 
                    have no run-time affects.
                    <s-halfEm></s-halfEm>
                    Run-time scopes are defined by functions, methods, lambdas, and control statements.  They have both
                    compile-time and run-time affects.  Whenever a thread of program execution enters a scope, 
                    a new allocation of stack memory, called a stack-frame, is acquired to store local variables 
                    and calling parameters for methods, functions and lambdas.  When the thread of execution 
                    leaves that scope the memory is returned to its process for reuse.
                  </div>
                </div>
              </li>
              <li>
                <strongs>Object layout:</strongs>
                <s-halfEm></s-halfEm>
                <div class="indent">
                  Primitive types, defined by the language, occupy a contiguous block of memory and may be copied
                  and assigned.  A copy or assignment results in two named memory 
                  locations each with the same value immediately following the operation, subject to cache flushing.
                  <s-halfEm></s-halfEm>
                  Objects are types defined by the language libraries and by developers.  They often occupy two or more 
                  disjoint regions of memory, linked internally by addresses, usually with a control block in static 
                  memory, and data stored in a process heap.  Assignment and copy operations on these objects have
                  semantics defined by each of the languages we consider here, and those are quite different.
                </div>
              </li>
              <li>
                <strongs>Object relationships:</strongs>
                <s-halfEm></s-halfEm>
              </li>
              <li>
                <strongs>Instance management:</strongs>
                <s-halfEm></s-halfEm>
              </li>
              <li>
                <strongs>Operations:</strongs>
                <s-halfEm></s-halfEm>
              </li>
            </ol>
          </td>
        </tr>
        <tr>
          <th class="darkItem">Topic</th>
          <th class="darkItem">C#</th>
          <th class="darkItem">C++</th>
          <th class="darkItem">Rust</th>
        </tr>
        <tr>
          <td class="elem topborder">
            Types
          </td>
          <td class="elem topborder">
            <strong>Value types:</strong><br />
            bool, int, char, double, enum, struct, ..
            <strong>Reference types:</strong><br />
            string, class, interface, array, delegate, ..<br />
            <strong>Collections are reference types:</strong><br />
            ArrayList, Hashtable, Stack, Queue, Dictionary, SortedList, ..
          </td>
          <td class="elem topborder">
            <strong>Primitive types:</strong><br />
            bool, int, unsigned int, char, wchar_t, float, double, ..<br />
            <strong>Aggregate types:</strong><br />
            array, struct, class, enum<br />
            <strong>Collections:</strong><br />
            vector, deque, set, map, unordered_set, unordered_map, ..
          </td>
          <td class="elem topborder">
            <strong>Primitive types:</strong><br />
            bool u8, i8, .. u64, i64, f32, f64<br />
            <strong>Aggregate types:</strong><br />
            array, struct, enum<br />
            <strong>Collections:</strong><br />
            Vec, VecDec, HashSet, HashMap, ..
          </td>
        </tr>
        <tr>
          <td class="elem topborder">
            <strongs>Execution environment:</strongs>
          </td>
          <td class="elem topborder">
            Common Language Runtime (CLR), a stack-based virtual machine.  Runs byte-code. 
            <s-halfEm></s-halfEm>
            Manages all reference types
            on the heap, including every library and user defined type.
            <s-halfEm></s-halfEm>
            Type resources are eventually garbage collected.
          </td>
          <td class="elem topborder">
            Compiles to native code.  Provides initialization and termination code that handles its process.
            <s-halfEm></s-halfEm>
            All instances, of any type, may reside in stack, heap, or static memory. 
            <s-halfEm></s-halfEm>
            Type resources returned implicitly by 
            type's destructor (primitive values are discarded with stack frame).
          </td>
          <td class="elem topborder">
            Compiles to native code.  Provides initialization and termination code that handles its process. 
            <s-halfEm></s-halfEm>
            All instances, of any type, may reside in stack or heap memory.  
            <s-halfEm></s-halfEm>
            Type resources returned implicitly by drop function
            (primitive values are discarded with stack frame).
          </td>
        </tr>
        <tr>
          <td class="elem topborder">
            Object Relationships:
          </td>
          <td class="elem topborder">
            <strong>inheritance:</strong><br />Reference types only. 
            Base class embedded within memory footprint of derived.<br />
            <strong>composition:</strong><br />Only value types, embedded in composer.<br />
            <strong>aggregateon:</strong><br />Reference type created at run-time and stored seperately.<br />
            <strong>using:</strong><br />Non-owning, given access to used object as reference argument of 
            users member function.
          </td>
          <td class="elem topborder">
            <strong>inheritance:</strong><br />Structs and classes only. 
            Base class embedded within memory footprint of derived.<br />
            <strong>composition:</strong><br />All types, embedded in composer.<br />
            <strong>aggregateon:</strong><br />All types, created at run-time and stored seperately.<br />
            <strong>using:</strong><br />Non-owning, given access to used object as reference argument of 
            users member function.
          </td>
          <td class="elem topborder">
            <strong>inheritance:</strong><br />Structs may inherit only Traits (similar to an interface). 
            Traits are usually function declarations without implementation.<br />
            <strong>composition:</strong><br />All types, embedded in composer.<br />
            <strong>aggregateon:</strong><br />All types, created at run-time and stored seperately.<br />
            <strong>using:</strong><br />Non-owning, given access to used object as reference argument of 
            users member function.
          </td>
        </tr>
        <tr>
          <td class="elem topborder">
            Object Layout
          </td>
          <td class="elem topborder">
            <img src="pictures/CSharpLayout.jpg" />
          </td>
          <td class="elem topborder">
            <img src="pictures/CppLayout.jpg" />
          </td>
          <td class="elem topborder">
            <img src="pictures/RustLayout.jpg" />
          </td>
        </tr>
        <tr>
          <td class="elem topborder">
            Instance management
          </td>
          <td class="elem topborder">
            C# CLR creates reference type instances on managed heap.  Instances are eventually removed by garbage collection.
            Creates exceptions and supports event notification.  Provides detailed type information from reflection.
            <s-halfEm></s-halfEm>
            Reference types do not provide value type behavior.  Copy and assignment do not result in independent instances.
            These operations result in multiple references to the same heap-based object.
            <s-halfEm></s-halfEm>
            C# reference types cannot be value types, but value behavior can be approximated in the following way. 
            The C# string class has no interface for mutation.  To change the character sequence associated with some named 
            string reference one creates a new string instance with capacity to hold the desired change, and uses the original 
            string&apos;s character sequence to build the new character sequence.  Note that this is a new instance, and the 
            old is readied for garbage collection.
          </td>
          <td class="elem topborder">
            C++ supports creation of instances in stack, heap, or static memory.  Instance resources are returned when an instance
            goes out of scope, by calling its destructor.  That always happens when a thread of execution leaves the scope where
            and instance was defined.
            <s-halfEm></s-halfEm>
            C++ supports operator overloading for instance management, e.g., copy and move constructors, copy and move assignment operators,
            and destructors.
            <s-halfEm></s-halfEm>
            Appropriate definition of these operators enable value behavior, e.g., creation and assignment of instances that are 
            independent replicas of the source instances.
            <s-halfEm></s-halfEm>
            If bases and members of a class have correct copy, assignment, and destruction semantics, a class does not need
            to provide these operators - compiler generated versions work correctly.
            <s-halfEm></s-halfEm>
            These conditions are satisfied if class members are limited to primitive types, strings, and collection types provided by
            the standard template library (STL).
          </td>
          <td class="elem topborder">
            Rust supports creation of instances in stack or heap memory. Instances are removed by a drop operation
            that is implicitly called when a thread of execution leaves the scope in which the instance was defined.
            <s-halfEm></s-halfEm>
            Rust does not support operator overloading, so implict value operation is supported only for primitive types.
            For other types copy and assignment results in a move operation which transfers ownership of source 
            instance&apos;s resources to the destination instance and invalidates the source. This is usually a very efficient 
            operation.
            <s-halfEm></s-halfEm>
            Rust does support clone operations which a program calls explicitly, resulting in an independent replica of the source
            instance.
          </td>
        </tr>
        <tr>
          <td class="elem topborder">
            Operations:
          </td>
          <td class="elem topborder">
            All C# operations are processed by the CLR stack-based virtual machine.  For example, an add operation
            starts by loading the first addend from memory and pushing onto CLR stack.  It then loads the second addend and 
            pushes it on the stack.  Then an add operation runs that pops the two arguments and adds them and pushes
            the result onto the stack.  The operation completes by popping the result and storing in memory.
            <s-halfEm></s-halfEm>
            At a more abstract level, in C#, all operations are methods of a class. A method may be resolved at
            compile time and invoked directly, or, if virtual, may be dispatched dynamically via a virtual 
            function pointer table.  If the called method is know at compile-time, C#&apos;s compiler will optimize away 
            dynamic dispatching, binding directly to the known method.
            <s-halfEm></s-halfEm>
            C# supports definition of lambdas within a member function&apos;s code block.  Lambdas are compiled into a
            class with a method that captures the lambda code block, and, if the code block uses data defined prior to the 
            lambda definition in the same parent scope, then that data becomes member(s) of the compiler generated class.
          </td>
          <td class="elem topborder">
            All C++ operations are processed directly in native code.  For example, an add operation loads both arguments 
            into a register, adds them, and stores the result into the specified location.
            <s-halfEm></s-halfEm>
            C++ operations may be free functions, static functions bound to a class, or member functions with access to 
            the class&apos;s member data.  
            <s-halfEm></s-halfEm>
            Non-static member functions may be declared virtual, resulting in the generation 
            of a virtual function pointer table.  That enables, for derived classes, dynamic dispatch where the function 
            is called via a pointer typed as a pointer to a base.  If the base pointer is bound to a derived class instance, 
            the call resolves to the function defined by the class of that instance.
            <s-halfEm></s-halfEm>
            C++ also supports the definition of lambdas. A lambda is compiled into a class which overloads the operator(),
            a method that captures the lambda code block, and, if the code block uses data defined prior to the 
            lambda definition in the same parent scope, then that data becomes member(s) of the compiler generated class.
          </td>
          <td class="elem topborder">
            All Rust operations are processed in native code.
            <s-halfEm></s-halfEm>
            Rust assignment operations and pass by value function calls result, for primitive types, in copy operations. 
            <s-halfEm></s-halfEm>
            For non-primitive types these operations result in moves, e.g., transfers of ownership from the source to the 
            destination.  That is efficient, but invalidates the source.  To avoid invalidation one may assign or 
            pass a clone of the source instance.
          </td>
        </tr>
      </table>
      <s-1em></s-1em>
      <a id="bottom"></a>
  </body>
</html>
