<!DOCTYPE html>
<html id="top">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>Object Models</title>
    <link rel="stylesheet" href="css/IaP_Styles.css" />
    <script src="js/IaP_Scripts.js"></script>
    <script src="js/ScriptsWebComponents.js"></script>
    <link rel="stylesheet" href="css/StylesWebComponents.css" />
    <style>
      #github .topborder { border-top: 1px solid #363636;}
      #github th.num { width:3em; text-align:right; padding-right:1.0em; }
      #github td.num { width:3em; text-align:right; padding-right:1.0em; }
      #github table {
        border-collapse:collapse;
      }
      #github th { text-align:left; font-size:1.25em;}
      #github th.elem { 
        border-collapse:collapse;
        padding: 0.5em 0em; white-space:normal; 
      }
      #github td.elem { 
        padding: 1.0em 0.5em; white-space:normal; 
      }
      #github t-b { 
        display: block;
        margin-top: 0.75rem;
        margin-bottom: 0.75rem;
        max-width:55rem;
      }
      #github tt-b {
        padding-top: 0.5em;
        padding-bottom: 0.5em;
      }
    </style>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Idioms and Patterns Story</span>
      <div style="position:relative; left:calc(100vw - 15rem);">
        <span class="top-center">Object Models</span>
        <!-- <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a> -->
      </div>
  </div>
  <next-prev>
    <a id="prev" href="Tooling.html">prev</a> 
    <a id="repo" href="../../IdiomsAndPatterns.html">Repo</a> 
    <a id="next" href="Tooling.html">next</a>
  </next-prev>

      <toc-b id="toc">
        <div style="display:flex; flex-direction:row">
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.sects()" style="color: #fefefa; ">Sects</a>&nbsp;
          <a href="../../IdiomsAndPatterns.html" style="color:#fefefa;">Repo</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">Esc</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp;
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
          <up-b id="chaps">
            <a href="ObjectModels.html">Object Models</a><br />
            <a href="Tooling.html">Tooling</a><br />
            <a href="javascript:;"></a><br />
          </up-b>
            <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#bottom">Bottom</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>N</td><td>Next Bite</td>
          </tr>
          <tr>
            <td>P</td><td>Prev Bite</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>
      </div>
   
    <bb-55>
      <h1>Object Models</h1>
      <h3 style="margin-left:3em; margin-top:0em; font-weight:normal;">Comparisons of C#, C++, and Rust</h3>
      <hr />
      <t-b>
        <div style="font-size:small;">
          "I get the impression that those who have experience of languages like C, C++, even assembler, get the
          idea of Rust more easily.  They have already spent years chasing bugs caused by memory usage errors,
          null pointers, data races in threaded code etc. They appreciate how Rust is helping with all those issues."
        </div>
        <a href="https://users.rust-lang.org/t/failed-to-contribute-due-to-difficulty-in-understanding-rust/49148/7">ZiCog</a>
      </t-b>
      <h3>1. Prologue</h3>
      <t-b>
        In this story we look at common idioms and patterns used to build programs and software systems.  Each will
        be implemented in the three programming languages: C#, C++, and Rust.  That may help developers familiar with one
        of the languages to start learning the others.  It also provides a useful cache of techniques to help
        remember key implementation strategies.
      </t-b>
      <t-b>
        In order to write code effectively, you need to have an initial design and a good mental model of what your program 
        will do when it executes programming language statements.  That understanding helps you predict, with some 
        precision, context appropriate sequences of statements to implement your ideas.  Without that understanding 
        you don&apos;t know what to write.
      </t-b>
      <t-b>
        You will frequently find that each language implements an idiom in different ways, sometimes radically different.
        Each of them is built around a different object model that governs how code you write executes in practice.
      </t-b>
      <t-b>
        <ul>
          <li>
            C#, like Java, uses a reference model, runs in a virtual machine, and employs garbage collection to 
            return process resources when no longer needed.  This model has significant performance implications.
          </li>
          <li>
            C++ uses a value model, compiles to native code that runs directly on its computer platform, and its objects
            are usually designed to behave as primitive types do, supporting copy and assignment of instances.
          </li>
          <li>
            Rust uses an ownership model, compiles to native code, and behaves in ways that are distinct from either 
            C# or C++, especially for binding, assignment, and mutation through references.  Rust ownership rules are 
            strict, enforcing memory safety and freedom from data races.  Most important, it does that by construction.
          </li>
        </ul>
      </t-b>
      <t-b>
        There are other differences discussed below and in the idiom and pattern implementations in following pages.
      </t-b>
      <h3>2. Models:</h3>
      <t-b>
        The two most important models describe how a program uses memory, and how it creates and manipulates objects residing
        in memory.  Most
        modern imperative languages have approximately the same memory model.  There are, however, significant differences in how
        these languages use objects.
      </t-b>
      <t-b>
        The intent of this page is to help you understand differences in object models for C#, C++, and Rust.  We first
        review a memory model, common to all three of these languages.
      </t-b>
      <s-halfEm></s-halfEm>
    </bb-55>
      <table style="width:100%;">
        <tr>
          <td class="darkItem" colspan="5">Definition: Memory Model</td>
        </tr>
        <tr>
          <td class="elem topborder" colspan="4">
            Programs for the languages we consider here divide memory into three parts:
            <ol class="tight">
              <li>
                Static memory holds its contents for the entire lifetime of a program.  Static memory holds 
                compiled code and values declared as &quot;static&quot; which are initialized only once.
              </li>
              <li>
                Stack memory is allocated when a thread of execution enters a program scope and is deallocated when 
                the thread leaves that scope.  Each scope is defined by a code block enclosed by braces: &apos;{&apos;
                and &apos;}&apos;.
              </li>
              <li>
                Heap memory is allocated (from a process heap) when a program requests storage for some type and 
                lives until the program releases that storage or the program terminates.
              </li>
            </ol>
            <s-halfEm></s-halfEm>
          </td>
        </tr>
        <tr>
          <td class="darkItem" colspan="5">Definition: Object Model</td>
        </tr>
        <tr>
          <td class="elem topborder" colspan="4">
            <t-b>
              <strong>Instances:</strong><br />
              <s-halfEm></s-halfEm>
              <div class="indent">
                An <strongs>instance</strongs> is a typed memory location initialized with some value.
              </div>
            </t-b>
            <t-b>
              <strong>Objects:</strong><br />
              <s-halfEm></s-halfEm>
              <div class="indent">
                An <strongs>object</strongs> is an instance of a non-primitive type.
              </div>
            </t-b>
            <t-b>
              <strong>Types:</strong><br />
              <s-halfEm></s-halfEm>
              <div class="indent">
                A type is a pattern for creating instances.  If the type is defined by the 
                language we usually use the term primitive, e.g., int or double.  Otherwise we just use the term type, 
                e.g., struct, vector. Non-primitive types are defined by standard libraries and developers.  
                All three of these languages support development of new types, e.g., person, order, graph, ...
                <s-halfEm></s-halfEm>
                To indicate that <c-s>a</c-s> is an instance of type <c-s>A</c-s> we use the notation:
                <div class="pad5 indent">
                  <c-s>a &epsilon; A</c-s>
                </div>
              </div>
            </t-b>
            An <strong>Object Model</strong> describes:
            <ol class="tights">
              <li>
                <hr class="sep" />
                <div>Types:</div>
                <s-halfEm></s-halfEm>
                <div class="indent">
                  A type is defined by a memory configuration with specified set of allowed operations.
                  Examples: integers, floating point numbers, vectors, ...  An instance results from instantiating
                  a type, i.e., declaring a name associated with the type and allocating and initializing the 
                  memory location it represents.
                </div>
              </li>
              <li>
                <hr class="sep" />
                <strongs>Execution environment:</strongs>
                <s-halfEm></s-halfEm>
                <div class="indent">
                  Defines where objects are hosted, how their values are accessed, how operations on objects are processed,
                  how errors are handled, and what information about objects are available to programs.
                </div>
              </li>
              <li>
                <hr class="sep" />
                <strongs>Scope:</strongs>
                <s-halfEm></s-halfEm>
                <div class="indent">
                  Program scopes are defined by code blocks enclosed in braces, e.g., &apos;{&apos; and &apos;}&apos;. 
                  They come in two flavors: compile-time only and run-time scopes.
                  <s-halfEm></s-halfEm>
                  <div class="indents">
                    Compile time scopes define names and access priviledges for namespaces, structs,  
                    classes, and enums.  They affect what program statements are allowed to compile, but 
                    have no run-time affects.
                    <s-halfEm></s-halfEm>
                    Run-time scopes are defined by functions, methods, lambdas, and control statements.  They have both
                    compile-time and run-time affects.  Whenever a thread of program execution enters a scope, 
                    a new allocation of stack memory, called a stack-frame, is acquired to store local variables 
                    and calling parameters for methods, functions and lambdas.  When the thread of execution 
                    leaves that scope the memory is returned to its process for reuse.
                  </div>
                </div>
              </li>
              <li>
                <hr class="sep" />
                <strongs>Object layout:</strongs>
                <s-halfEm></s-halfEm>
                <div class="indent">
                  Primitive types, defined by the language, occupy a contiguous block of memory and may be copied
                  and assigned.  A copy or assignment results in two named memory 
                  locations each with the same value immediately following the operation, subject to cache flushing.
                  <s-halfEm></s-halfEm>
                  Objects are instances of types defined by the language libraries and by developers.  They often occupy two or more 
                  disjoint regions of memory, linked internally by addresses, usually with a control block in static 
                  memory, and data stored in a process heap.
                  <s-halfEm></s-halfEm>
                  Assignment and copy operations on these objects have
                  semantics defined differently by each of the languages we consider here.
                </div>
              </li>
              <li>
                <hr class="sep" />
                <strongs>Object relationships:</strongs>
                <div style="width:calc(100vw - 9em);">
                  <photosizer-block src="../../Pictures/ObjectRelationships.JPG" width="500" class="photoSizerBlock right clear">
                    <span style="font-family:'Comic Sans MS';">Figure 1. Object Relationships</span>
                  </photosizer-block>
                </div>                
                <s-halfEm></s-halfEm>
                There are four relationships between objects for all three languages.  C++ offers an infrequently used
                fifth relationship:
                <ul>
                  <li>
                    <strong>Inheritence:</strong><br />
                    Base types declare methods and associated functions.  They may, but often don&apos;t, supply 
                    implementations.  Base methods may be declared virtual. That causes compilation to layout a
                    virtual function pointer table used for dispatching methods dynamically, i.e., decide at run-time
                    which derived class override to invoke.
                    <s-halfEm></s-halfEm>
                    Derived classes inherit from a base and are obligated to supply implementations for every 
                    undefined method declared in the base.
                    A base class becomes part of the memory footprint of every class that derives from that base.
                  </li>
                  <li>
                    <strong>Composition:</strong><br />
                    Include in the composing class instance an <strong>instance</strong> of a composed class.  This
                    supports factoring complex operations into sets of simpler parts.
                    <s-halfEm></s-halfEm>
                    The composed instance becomes part of the memory footprint of the composing class; and is
                    constructed as part of the composer construction.
                  </li>
                  <li>
                    <strong>Aggregation:</strong><br />
                    Include in the aggregating class a <strong>reference</strong> to an aggregated class. The 
                    aggregated class instance is created, at run-time, by one of the aggregating class methods.
                    <s-halfEm></s-halfEm>
                    An aggregated class instance does not become part of the footprint of the aggregating class,
                    and is not inherently created as part of the aggregating class construction.
                  </li>
                  <li>
                    <strong>Using:</strong><br />
                    A reference to a used class is passed as an argument in a using class method.  The used 
                    class is not created by the user and is not part of the using class footprint.
                  </li>
                  <li>
                    <strong>Friendship:</strong><br />
                    The C++ language allows a class to grant friendship to a non-class function, or to another class.
                    Friendship allows the friend access to private data of the granting class. This is primarily used 
                    to support overloading insertion and extraction operators that are used for, but are not part of 
                    the granting class.
                  </li>
                </ul>
              </li>
              <li>
                <hr class="sep" />
                <strongs>Instance management:</strongs>
                <s-halfEm></s-halfEm>
                Managing instances consists of:
                <ul>
                  <li>
                    <strong>Binding</strong><br />
                    Binding associates a name with a newly created typed memory location.  
                    <t-b class="pad5 indent" style="margin-top:0px; margin-bottom:0px;">
                      <c-s>let dst:D = D::new()</c-s>   // Rust<br />
                      <c-s>D dst</c-s>                  // C++<br />
                      <c-s>D dst = new D()</c-s>        // C#
                    </t-b>
                    C# and C++ allow only one binding of 
                    a specific name within the same scope.  Rust allows rebinding the same name multiple times.
                  </li>
                  <li>
                    <strong>Assignment</strong><br />
                    The destination of an assignment aquires the same state as the source.
                    <t-b class="pad5 indent" style="margin-top:0px; margin-bottom:0px;">
                      <c-s>dst = src</c-s>
                    </t-b>
                    The semantics of assignment are quite different for each of the three languages (see below).
                  </li>
                  <li>
                    <strong>access</strong><br />
                    The ability of one instance to read contents of another instance.  Rules for access are
                    determined by ownership policies, class declarations, and location.  The rules differ significantly 
                    for the three languages (see below).
                  </li>
                  <li>
                    <strong>mutation</strong><br />
                    The ability to modify contents of an accessible instance.  Mutation rules are determined by 
                    ownership policy, binding syntax, and class declaration.
                  </li>
                  <li>
                    <strong>destruction</strong><br />
                    Return resources attached to an instance to the program&apos;s process.  Rules for destruction are
                    determined by the execution environment.  C# uses garbage collection; C++ and Rust use scope-based 
                    deallocation.
                  </li>
                </ul>
              </li>
              <li>
                <hr class="sep" />
                <strongs>Operations:</strongs>
                <s-halfEm></s-halfEm>
                Operations are operators, functions, methods, and lambdas.  The biggest differences for the three 
                languages are which operations can be overloaded. 
                <ul>
                  <li>
                    <strong>operators</strong><br />
                    Operators are functions that have an alternate symbolic representation, e.g., <c-s>+</c-s>, 
                    <c-s>-</c-s>, <c-s>=</c-s>, ...
                  </li>
                  <li>
                    <strong>functions</strong><br />
                    Functions are named code blocks that accept zero or more parameters and may return a value of some
                    type.
                  </li>
                  <li>
                    <strong>methods</strong><br />
                    Methods are functions that are bound to a class and have access to the class&apos;s member data.
                  </li>
                  <li>
                    <strong>associated methods</strong><br />
                    Associated methods are bound to a class, but do not have access to its member data.
                  </li>
                  <li>
                    <strong>lambdas</strong><br />
                    Lambdas are anonymous types that can be defined locally within functions and methods.  They 
                    compile to class instances with a function that contains the lambda code block and member 
                    data that is captured from the scope in which the lambda was defined.
                  </li>
                </ul>
              </li>
            </ol>
          </td>
        </tr>
        <tr>
          <td colspan="4">
            <h3>3. Object Model Details:</h3>
          </td>
        </tr>
        <tr>
          <th class="darkItem normal-font">Topic</th>
          <th class="darkItem normal-font">C#</th>
          <th class="darkItem normal-font">C++</th>
          <th class="darkItem normal-font">Rust</th>
        </tr>
        <tr>
          <td class="elem topborder">
            Types
          </td>
          <td class="elem topborder">
            <strong>Value types:</strong><br />
            bool, int, char, double, enum, struct, ..<br />
            <strong>Reference types:</strong><br />
            string, class, interface, array, delegate, ..<br />
            <strong>Collections are reference types:</strong><br />
            ArrayList, Hashtable, Stack, Queue, Dictionary, SortedList, ..
          </td>
          <td class="elem topborder">
            <strong>Primitive types:</strong><br />
            bool, int, unsigned int, char, wchar_t, float, double, ..<br />
            <strong>Aggregate types:</strong><br />
            array, struct, class, enum<br />
            <strong>Collections:</strong><br />
            vector, deque, set, map, unordered_set, unordered_map, ..
          </td>
          <td class="elem topborder">
            <strong>Primitive types:</strong><br />
            bool u8, i8, .. u64, i64, f32, f64<br />
            <strong>Aggregate types:</strong><br />
            array, struct, enum<br />
            <strong>Collections:</strong><br />
            Vec, VecDec, HashSet, HashMap, ..
          </td>
        </tr>
        <tr>
          <td class="elem topborder">
            <strongs>Execution environment:</strongs>
          </td>
          <td class="elem topborder">
            Common Language Runtime (CLR), a stack-based virtual machine.  Runs byte-code. 
            <s-halfEm></s-halfEm>
            Manages all reference types
            on the heap, including every library and user defined type.
            <s-halfEm></s-halfEm>
            Type resources are eventually garbage collected.
          </td>
          <td class="elem topborder">
            Compiles to native code.  Provides initialization and termination code that handles its process.
            <s-halfEm></s-halfEm>
            All instances, of any type, may reside in stack, heap, or static memory. 
            <s-halfEm></s-halfEm>
            Type resources returned implicitly by 
            type's destructor (primitive values are discarded with stack frame).
          </td>
          <td class="elem topborder">
            Compiles to native code.  Provides initialization and termination code that handles its process. 
            <s-halfEm></s-halfEm>
            All instances, of any type, may reside in stack or heap memory.  
            <s-halfEm></s-halfEm>
            Type resources returned implicitly by drop function
            (primitive values are discarded with stack frame).
          </td>
        </tr>
        <tr>
          <td class="elem topborder">
            Object Relationships:
          </td>
          <td class="elem topborder">
            <strong>inheritance:</strong><br />Reference types only. 
            Base class embedded within memory footprint of derived.<br />
            <strong>composition:</strong><br />Only value types, embedded in composer.<br />
            <strong>aggregateon:</strong><br />Reference type created at run-time and stored seperately.<br />
            <strong>using:</strong><br />Non-owning, given access to used object as reference argument of 
            users member function.
          </td>
          <td class="elem topborder">
            <strong>inheritance:</strong><br />Structs and classes only. 
            Base class embedded within memory footprint of derived.<br />
            <strong>composition:</strong><br />All types, embedded in composer.<br />
            <strong>aggregateon:</strong><br />All types, created at run-time and stored seperately.<br />
            <strong>using:</strong><br />Non-owning, given access to used object as reference argument of 
            users member function.
          </td>
          <td class="elem topborder">
            <strong>inheritance:</strong><br />Structs may inherit only Traits (similar to an interface). 
            Traits are usually function declarations without implementation.<br />
            <strong>composition:</strong><br />All types, embedded in composer.<br />
            <strong>aggregateon:</strong><br />All types, created at run-time and stored seperately.<br />
            <strong>using:</strong><br />Non-owning, given access to used object as reference argument of 
            users member function.
          </td>
        </tr>
        <tr>
          <td class="elem topborder">
            Object Layout
          </td>
          <td class="elem topborder">
            <img src="pictures/CSharpLayout.jpg" />
          </td>
          <td class="elem topborder">
            <img src="pictures/CppLayout.jpg" />
          </td>
          <td class="elem topborder">
            <img src="pictures/RustLayout.jpg" />
          </td>
        </tr>
        <tr>
          <th class="darkItem normal-font">Topic</th>
          <th class="darkItem normal-font">C#</th>
          <th class="darkItem normal-font">C++</th>
          <th class="darkItem normal-font">Rust</th>
        </tr>
        <tr>
          <td class="elem topborder">
            Instance management
          </td>
          <td class="elem topborder">
            C# CLR creates reference type instances on its managed heap.  Instances are eventually removed by garbage collection.
            CLR creates exceptions and supports event notification.  Provides detailed type information from reflection.
            <s-halfEm></s-halfEm>
            Reference types do not provide value type behavior.  Copy and assignment do not result in independent instances.
            These operations result in multiple references to the same heap-based object.
            <s-halfEm></s-halfEm>
            C# reference types cannot be value types, but value behavior can be approximated in the following way. 
            The C# string class has no interface for mutation.  To change the character sequence associated with some named 
            string reference, a new string instance is created with capacity to hold the desired change, and uses the original 
            string&apos;s character sequence to build the new character sequence.  Note that this is a new instance, and the 
            old is readied for garbage collection.
          </td>
          <td class="elem topborder">
            C++ supports creation of instances in stack, heap, or static memory.  Instance resources are returned when an instance
            goes out of scope, by calling its destructor.  That always happens when a thread of execution leaves the scope where
            an instance was defined.
            <s-halfEm></s-halfEm>
            C++ supports function and operator overloading for instance management, e.g., copy and move constructors, copy and move assignment operators,
            and destructors.
            <s-halfEm></s-halfEm>
            Appropriate definition of these operators enable value behavior, e.g., creation and assignment of instances that are 
            independent replicas of the source instances.
            <s-halfEm></s-halfEm>
            If bases and members of a class have correct copy, assignment, and destruction semantics, a class does not need
            to provide these operators - compiler generated versions work correctly.
            <s-halfEm></s-halfEm>
            These conditions are satisfied if class members are limited to primitive types, strings, and collection types provided by
            the standard template library (STL).
          </td>
          <td class="elem topborder">
            Rust supports creation of instances in stack or heap memory. Instances are removed by a drop operation
            that is implicitly called when a thread of execution leaves the scope in which the instance was defined.
            <s-halfEm></s-halfEm>
            Rust does not support operator overloading, so implict value operation is supported only for primitive types.
            For other types copy and assignment results in a move operation which transfers ownership of source 
            instance&apos;s resources to the destination instance and invalidates the source. This is usually a very efficient 
            operation.
            <s-halfEm></s-halfEm>
            Rust does support clone operations which a program calls explicitly, resulting in an independent replica of the source
            instance.
          </td>
        </tr>
        <tr>
          <th class="darkItem normal-font">Topic</th>
          <th class="darkItem normal-font">C#</th>
          <th class="darkItem normal-font">C++</th>
          <th class="darkItem normal-font">Rust</th>
        </tr>
        <tr>
          <td class="elem topborder">
            Operations:
          </td>
          <td class="elem topborder">
            All <strong>C#</strong> operations are processed by the CLR stack-based virtual machine.  For example, an add operation
            starts by loading the first addend from memory and pushing onto CLR stack.  It then loads the second addend and 
            pushes it on the stack.  Then an add operation runs that pops the two arguments and adds them and pushes
            the result onto the stack.  The operation completes by popping the result and storing in memory.
            <s-halfEm></s-halfEm>
            At a more abstract level, in C#, all operations are methods of a class. A method may be resolved at
            compile time and invoked directly, or, if virtual, may be dispatched dynamically via a virtual 
            function pointer table.  If the called method is known at compile-time, C#&apos;s compiler will optimize away 
            dynamic dispatching, binding directly to the known method.
            <s-halfEm></s-halfEm>
            The value of every variable of non-primitive type is a reference to an instance on the CLR heap.  
            For example, every declaration of non-primitive class 
            member data is a declaration of a reference to an instance of that data, stored on the managed heap, 
            not the instance itself.
            <s-halfEm></s-halfEm>
            The assignment operator operator cannot be overloaded in C#.  Assignments are applied to references to class 
            instances, with the result that the source and destination references refer to the same instance.
            <s-halfEm></s-halfEm>
            C# supports definition of lambdas within a member function&apos;s code block.  Lambdas are compiled into a
            class with a method that captures the lambda code block, and, if the code block uses data defined prior to the 
            lambda definition in the same parent scope, then that data becomes member(s) of the compiler generated class.
          </td>
          <td class="elem topborder">
            All <Strong>C++</Strong> operations are processed directly in native code.  For example, an add operation loads both arguments 
            into a register, adds them, and stores the result into the specified location.
            <s-halfEm></s-halfEm>
            C++ operations may be free functions, static functions bound to a class, or member functions with access to 
            the class&apos;s member data.  
            <s-halfEm></s-halfEm>
            Non-static member functions may be declared virtual, resulting in the generation 
            of a virtual function pointer table.  That enables, for derived classes, dynamic dispatch where the function 
            is called via a pointer typed as a pointer to a base.  If the base pointer is bound to a derived class instance, 
            the call resolves to the function defined by the class of that instance.
            <s-halfEm></s-halfEm>
            The name of every non-pointer or non-reference variable is the name of an instance of some type.  C++ supports 
            overloading the assignment operator to assign the state of a source instance to the state of a 
            destination instance.  But these instances are independent.  Immediately following assignment they have the 
            same state, but may then evolve independently.
            <s-halfEm></s-halfEm>
            C++ also supports the definition of lambdas. A lambda is compiled into a class which overloads the operator(),
            a method that captures the lambda code block, and, if the code block uses data defined prior to the 
            lambda definition in the same parent scope, then that data becomes member(s) of the compiler generated class.
          </td>
          <td class="elem topborder">
            All <strong>Rust</strong> operations are processed in native code.
            <s-halfEm></s-halfEm>
            Rust assignment operations and pass by value function calls result, for primitive types, in copy operations. 
            <s-halfEm></s-halfEm>
            For non-primitive types these operations result in moves, e.g., transfers of ownership from the source to the 
            destination.  That is efficient, but invalidates the source.  To avoid invalidation one may assign or 
            pass a clone of the source instance.
            <s-halfEm></s-halfEm>
            Rust does not support overloading of any operation, e.g., no overloading of operators, of functions, or of methods.
            <s-halfEm></s-halfEm>
            Rust qualifies its operations with <strong>Ownership Rules</strong>. Every object instance has a unique owner.
            The owner creates its associated instance with a binding statement.  When the owner goes out of scope 
            the instance&apos;s
            resources are returned to the process with an implicit drop operation, much like a C++ destructor.
            <s-halfEm></s-halfEm>
            An instance has to be qualified with the <c-s>mut</c-s> keyword to be <strong>mutable</strong>.  
            <s-halfEm></s-halfEm>
            Reference views of an instance
            can be created and, if mutable, a reference is allowed to mutate the instance it views.  When references are 
            active, the owner of the instance is not allowed to mutate its data, until all references become inactive by 
            going out of scope.  
            <s-halfEm></s-halfEm>
            That&apos;s what happens when you pass an argument to a function by reference.  When the call returns, 
            the reference is no longer active.
            <s-halfEm></s-halfEm>
            Rust also supports the definition of lambdas, in a manner very similar to that used by C++.
          </td>
        </tr>
        <tr>
          <td class="elem topborder"></td>
          <td class="elem topborder"></td>
          <td class="elem topborder"></td>
          <td class="elem topborder"></td>
        </tr>
      </table>
      <h3 style="margin-top:0px;">4. References</h3>
        <table style="width:calc(100vw - 12rem); margin-left:2em;">
      <tr>
        <th class="darkItem">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.oreilly.com/programming/free/files/why-rust.pdf">Why Rust? - Jim Blandy</a>
        </td>
        <td class="lightItem">
          Monograph on why Rust is important
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://users.rust-lang.org/">Rust users forum</a>
        </td>
        <td class="lightItem">
          Answers to a broad range of questions from beginner to advanced.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/">A half-hour to learn Rust</a>
        </td>
        <td class="lightItem">
          Code fragments with commentary that cover most of the Rust ideas.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust by Example</a>
        </td>
        <td class="lightItem">
          Rust docs - walkthrough of syntax
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://rust-lang-nursery.github.io/rust-cookbook/intro.html">Rust Cookbook</a>
        </td>
        <td class="lightItem">
          Rust docs - a collection of example projects using the Rust libraries and external crates
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html">A Gentle Introduction To Rust</a>
        </td>
        <td class="lightItem">
          Read early in your Rust travels.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/book/">The Rust Book</a>
        </td>
        <td class="lightItem">
          Rust docs - walkthrough of syntax
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://cheats.rs/">Rust cheat sheet</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
        <td class="lightItem">
          Container diagrams
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/reference/">The Rust Reference Book</a>
        </td>
        <td class="lightItem">
          Rust&apos;s approximation of a language standard. Clear and well written, with a glossary at the end.
          Its <a href="https://github.com/rust-lang/reference">github site</a> shows that changes are still being
          actively incorporated.
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">RIP Tutorial on Rust</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, the stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">Learning Rust ebook</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/rust/awesome-learning/book">Rust - Awesome Book</a></td>
        <td class="lightItem">
          lots of interesting discussions from RIP, the Stackoverflow Archive
        </td>
      </tr>
        <tr>
          <td class="lightItem">
            <a href="https://docs.rs/dtolnay/0.0.8/dtolnay/macro._02__reference_types.html">
              Shared&nbsp;reference&nbsp;&amp;T&nbsp;and&nbsp;exclusive&nbsp;reference&nbsp;&amp;mut&nbsp;T
            </a>
          </td>
          <td class="lightItem">
            More accurate description than immutable reference and mutable reference
          </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.twelve21.io/getting-started-with-rust-on-windows-and-visual-studio-code/">
            Getting Started with Rust on Windows and Visual Studio Code
          </a>
        </td>
        <td class="lightItem">
          Install Rust, Verify, Configure Visual Studio Code, Create Hello World, Create Build Task, 
          Configuring Unit Tests, Configure Debugging, 
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.rust-lang.org/">rust-lang.org home page</a>
        </td>
        <td class="lightItem">
          Links to download and documentation
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.youtube.com/watch?v=zF34dRivLOw">(video) Rust - Crash Course | Rustlang</a>
        </td>
        <td class="lightItem">
          Code demo using basic types.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.tutorialspoint.com/rust/index.htm">Tutorial - tutorialspoint.com</a>
        </td>
        <td class="lightItem">
          Tutorials for most of the Rust parts with code examples.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://deterministic.space/">Blog - Pascal's Scribbles</a>
        </td>
        <td class="lightItem">
          Pascal Hertleif - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://blog.mgattozzi.dev/">Blog - Barely Functional</a>
        </td>
        <td class="lightItem">
          Michael Gattozzi - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.snoyman.com/blog/2020/05/no-mutable-parameters-in-rust">Blog - S.Noyberg</a>
        </td>
        <td class="lightItem">
          Examples of aysnc/await, tokio, lifetime, ...
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="http://kmcallister.github.io/talks/rust/2015-contributing-to-rust/slides.html">Compilation details</a>
        </td>
        <td class="lightItem">
          kmcallister.github.io
        </td>
      </tr>
      <tr>
        <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
        <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
      </tr>
      <!--<tr>
        <td class="lightItem">
          <a href="https://www.javatpoint.com/rust-tutorial">Tutorial - javatpoint.com</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>-->
    </table>

      <h3>5. Epilogue</h3>
      <t-b>
        The next page discusses the tools you need to build and run projects written in C#, C++, and Rust.
        The pages after that provide sequences of code examples for idioms and principles in each of the three languages 
        cited here, e.g. C#, C++, and Rust.  Object model differences will often be pointed out in comments within the 
        code blocks.
      </t-b>
      <s-1em></s-1em>
      <a id="bottom"></a>
  </body>
</html>
