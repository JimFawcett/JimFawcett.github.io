<!DOCTYPE html>
<!--
  BasicBites_Intro.html
--->
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="keywords" content="Rust, Introduction" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Basic Bites Execution</title>
  <link rel="stylesheet" href="css/BiteStyles.css" />
  <link rel="stylesheet" href="css/BiteTables.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/BasicBiteScripts.js"></script>
  <script src="js/BiteTables.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <style>
    #github table {
      width: 90%; border:1px solid black;
    }
    #github th {
      border:1px solid black;
    }
    #github code {
    display: block;
    padding: 10px 25px;
    font-size: 1.0rem;
    font-family: Consolas;
    font-weight: bold;
    }
    #github inline-code {
    display: inline-block ;
    font-size: 1.0rem;
    font-family: Consolas;
    font-weight: bold;
    }
  </style>
</head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Platform and Code Basics</span>
      <span class="top-center">Prog Execution</span>
    </div>
    <next-prev>
      <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
      <a id="repo" href="BasicBites_Intro.html">Repo</a> 
      <a id="Prev" href="BasicBites_Programming.html">prev</a> 
      <a id="Next" href="BasicBites_ProgTypes.html">next</a>
    </next-prev>

    <toc-b id="toc">
      <div id="bottom-menu" style="display:flex; flex-direction:row">
      </div>
        <up-b id="chaps">
        </up-b>
          <rt-b id="sects">
        <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
        <a href="#contents">Contents</a>, <a href="#refs">References</a>
      </rt-b>
    </toc-b>
    <div id="hlp" style="display:none;">
    </div>
   
    <h2>BasicBites - Program Execution</h2>
    <t-b>
      Execution of all user code happens in the context of a process.  Native code is embedded, by the compiler, in
      an execution image which is then loaded, at execution time, into a newly created process.
    </t-b>
    <t-b>
      Managed source code compiles to byte code.  At execution time a new process is created and loads a virtual machine. 
      Byte code is &quot;just-in-time&quot; compiled by the virtual machine on a function or assembly basis and run in the 
      context of the new process.  Compiled byte code is cached and not compiled again.
    </t-b>
    <div class="right">
      <photosizer-block src="pictures/process.png" width="500" class="photoSizerBlock" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;"
        >
            Figure 1. Windows Process Model
        </span>
      </photosizer-block>
    </div>
    <div class="right clear">
      <photosizer-block src="pictures/NativeCopy.png" width="400" class="photoSizerBlock" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;"
        >
            Figure 2. Native Assignment
        </span>
      </photosizer-block>
    </div>
    <div class="right clear">
      <photosizer-block src="pictures/Assignment.png" width="500" class="photoSizerBlock" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;"
        >
            Figure 3. Managed Assignments
        </span>
      </photosizer-block>
    </div>
    <!--<div style="height:0.25rem"></div>-->
    <t-b>
      In Windows a process is a container of one or more threads and resources they share.  All process resources are
      accessed and manipulated using handles.  Figure 1. shows a process with handles for two threads, a dynamic link
      library, loaded at execution time, and handles to GUI windows and heap memory.
    </t-b>
    <t-b>
      Windows has an object model that provides programs with handles to object instances created with calls to the
      Windows API.  For example, a heap object is created with:
      <code>
        HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
      </code>
      Most of a program&apos;s API calls are handled by the programming lanaguage&apos;s standard libraries so the
      program doesn&apos;t need to know about these calls.
    </t-b>
    <t-b>
      The Windows scheduler starts, runs, and interrupts threads, not processes.  A Windows process is just a container
      for its threads and resources.
    </t-b>
    <t-b>
      The process model for linux and Unix are similar to Windows except that a linux thread is simply a child process
      that shares its parent&apos;s address space.  That is hidden by the pthread library and linux no longer increments its
      reported process count when a new thread is created.  So, the linux scheduler starts, runs, and interrupts processes. 
    </t-b>
    <t-b>
      Process memory is divided into:
      <ul>
        <li>
          Static memory holding code and global data
        </li>
        <li>
          Stack memory is allocated when the program&apos;s thread of execution enters a new scope, delineated by &quot;{...}&quot;,
          and deallocated when execution leaves the scope.  For native code this scratch-pad memory holds function parameters
          and all local objects declared within the scope.  For managed code stack memory holds
          values for value types and references to heap-based objects for managed types.  This is true for both function parameters
          and instances declared within the current scope.
        </li>
        <li>
          Heap memory allocated with calls to <inline-code>new</inline-code>.  Native code deallocates heap-based instances with
          calls to <inline-code>delete</inline-code>.  Managed code uses the services of a garbage collector to defer deallocation
          for latter analysis to ensure that no references to the instance remain.
        </li>
      </ul>
    </t-b>
    <t-b>
      All code, both native and managed run in some scope.  The semantics of construction and assignment are
      quite different for native and managed types.  Native types are by default copy constructed and copy assigned.  
      If a native instance holds a
      reference to an object on the heap, its copy constructor and copy assignment operator are obligated to make copies of 
      both parts, the stack part and its heap resource, as shown in Figure 2.
    </t-b>
    <t-b>
      This creats a new independent instance that holds the same state as the original, but may be seperately
      mutated without affecting the original.
    </t-b>
    <t-b>
      Managed code semantics for construction and assignment are shown in Figure 2.  Value types are copied just like 
      native types, but
      for reference types only the handles are copied, so both wind up pointing to the same instance.  Future mutations
      of either one affect the other as well, because the two handles always point to the same underlying instance.
    </t-b>
    <t-b>
      The point of this is to see that different languages may use platform resources in quite different ways, each
      with their own advantages and disadvantages.  We will explore this in more detail in 
      <a href="BasicBites_ProgTypes.html">Types</a> and <a href="BasicBites_ObjModel.html">Object Models</a>.  
    </t-b>
    <t-b>
      For this discussion we&apos;ve taken C++ semantics as the prototypical
      native type and C# as the prototypical managed type.  We will see in Types that the Rust programming language
      semantics are an interesting variant that combines some of the strongest features of each.
    </t-b>
    <t-b class="clear">
      <h3>Summary</h3>
      <table>
        <tr>
          <th>Native Code</th><th></th>
        </tr>
        <tr>
          <td>Source code</td><td>Compiles to native code executed by its process</td>
        </tr>
        <tr>
          <td>Objects</td><td>stored in function&apos;s stack frame unless explicity placed in heap</td>
        </tr>
        <tr>
          <td>Object&nbsp;management</td><td>provided by program code, e.g., deallocation, exception handling</td>
        </tr>
        <tr>
          <td>Types</td>
          <td>
            Language enables user-defined objects to behave like primitive types, e.g., value behavior,
            through use of constructors and assignment operators.
          </td>
        </tr>
        <tr>
          <td>Moves</td>
          <td>
            C++ provides move constructors but does not enforce single ownership, allowing use of source
            after move, possibly resulting in undefined behavior.
          </td>
        </tr>
        <tr>
          <td>Pros and Cons</td>
          <td>
            excellent performance, requires care to avoid paths to undefined behavior
            <div style="height:0.5rem;"></div>
          </td>
        </tr>
        <tr>
          <th>Rust</th><th></th>
        </tr>
        <tr>
          <td>Source code</td><td>Compiles to native code executed by its process</td>
        </tr>
        <tr>
          <td>Objects</td><td>stored in function&apos;s stack frame unless explicity placed in heap with Box</td>
        </tr>
        <tr>
          <td>Object&nbsp;management</td><td>provided by language and library, e.g., deallocation, error handling</td>
        </tr>
        <tr>
          <td>Types</td>
          <td>
            Rust has two categories of types: Copy types and Move types.  Copy types have value behavior.
            Move types transfer ownership when assigned or passed by value.
          </td>
        </tr>
        <tr>
          <td>Moves</td>
          <td>
            Rust treats all types that are not copy (satisfy the Copy trait) as moves.  It enforces single ownership
            so source becomes invalid after move.
          </td>
        </tr>
        <tr>
          <td>Pros and Cons</td>
          <td>
            excellent performance and safety.  Initially hard to build due to safety
            constraints, but once built is very likely to have correct implementation.
            <div style="height:0.5rem;"></div>
          </td>
        </tr>
        <tr>
          <th>Managed Code</th><th></th>
        </tr>
        <tr>
          <td>Source code</td><td>Compiles to byte-code, jitted and executed by its process&apos;s virtual machine</td>
        </tr>
        <tr>
          <td>Object storage</td><td>object handles stored in function&apos;s stack, pointing to instances stored in heap</td>
        </tr>
        <tr>
          <td>Object&nbsp;management</td><td>provided by virtual machine using garbage collector and VM events</td>
        </tr>
        <tr>
          <td>Types</td><td>Types are either value or reference types, with quite different behavior</td>
        </tr>
        <tr>
          <td>Moves</td>
          <td>
            All C# and Java user-defined types are Move types but neither language enforces single ownership.
            That doesn&apos;t cause undefined behavior because these move types are handles to an instance 
            on the heap, but it may cause difficulty in managing program operations.
          </td>
        </tr>
        <tr>
          <td>Pros and Cons</td>
          <td>
            promotes safety at the expense of performance and initial latency
            <div style="height:0.5rem;"></div>
          </td>
        </tr>
      </table>
    </t-b>
    <t-b>
      C++ is the classic native language.  Java and C# (very similar languages) are archtypes of managed languages.
      Rust generates native code, but has some of the look-and-feel of managed code, in part due to its Copy and
      Move Type dichotomy.
    </t-b>
    <t-b>
      All four languages enable building the same kinds of program functionality.  But the implementation techniques
      are occasionally different.  My personal opinion is that Rust source code more accurately represents its
      underlying mechanics than the other three.  For example, both Rust and C++ have syntax for Move operations,
      but Rust enforces no use after move at compile time, while C++ will allow subsequent use with likely
      undefined behavior.
    </t-b>
  </body>
</html>
