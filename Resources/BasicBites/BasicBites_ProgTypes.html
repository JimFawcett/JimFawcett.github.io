<!DOCTYPE html>
<!--
  BasicBites_Intro.html
--->
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>Basic Bites Types</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <link rel="stylesheet" href="css/StylesWebComponents.css" />
    <script src="js/ScriptsWebComponents.js"></script>
    <script src="js/BasicBiteScripts.js"></script>
    <script src="js/BiteTables.js"></script>
    <script src="js/ScriptsKeyboard.js"></script>
    <style>
      #github .codesnip {
        font-family: Consolas, monospace;
        font-size: 1.0rem;
        vertical-align: middle;
      }
      #github .textsnip {
        font-size: 1.0rem;
        vertical-align: middle;
      }
      #github .lightgray {
        background-color: lightgray;
      }
      #github table {
        border-spacing:1rem 0.5rem;
      }
    </style>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Platform and Code Basics</span>
      <span class="top-center">Program Types</span>
    </div>
    <next-prev>
      <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
      <a id="repo" href="BasicBites_Intro.html">Repo</a> 
      <a id="Prev" href="BasicBites_ProgExec.html">prev</a> 
      <a id="Next" href="BasicBites_ProgFunctions.html">next</a>
    </next-prev>

    <toc-b id="toc">
      <div id="bottom-menu" style="display:flex; flex-direction:row">
      </div>
        <up-b id="chaps">
        </up-b>
          <rt-b id="sects">
        <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
        <a href="#contents">Contents</a>, <a href="#refs">References</a>
      </rt-b>
    </toc-b>
    <div id="hlp" style="display:none;">
    </div>
   
    <h2>BasicBites - Program Static Data Types</h2>
    <t-b>
      "In programming languages, a type system is a logical system comprising a set of rules that 
      assigns a property called a type to the various constructs of a computer program, such as variables, 
      expressions, functions or modules." - <a href="https://en.wikipedia.org/wiki/Type_system">Wikipedia</a>
    </t-b>
    <t-b>
      In this page we discuss static data types to illustrate some key differences between native and
      managed code.  A static data type declaration defines, at compile-time, a set of rules for creating,
      mutating, and disposing of a typed data instance.  Each instance has a fixed type throughout its lifetime
      [We will not be concerned here with type coersions like cast operations].
    </t-b>
    <t-b>
      In the following sections we define type categories: <strong>Copy</strong>, <strong>Move</strong>, 
      and <strong>Reference</strong> that have distinct
      operations for setting the value of one instance based on the value held by another instance.  Common
      languages like C++, Rust, C#, and Java, implement these operations in different ways and may use other
      names for them.
    </t-b>
    <t-b>
      So, there are two parts to this discussion:
      <ul>
        <li>
          Part 1. Define abstract type behaviors as Copy, Move, and Reference.
        </li>
        <li>
          Part 2. Show how C++, Rust, and C# implement these abstract behaviors in their own type systems.
          <div style="height:0.75rem;"></div>
          A description for Java would use almost the same text as used for C#, as C# started out as a fork
          of Java after a dispute between Microsoft and Oracle over changes to the JVM.
        </li>
      </ul>
    </t-b>
    <h3>Copy Types:</h3>
    <div class="indent">
      <t-b>
        Copy types are modeled after primitive language types like integers and floats.  When instances are
        copy constructed or copy assigned, their values are copied to new locations with new names and can be
        independently mutated.  For types occupying one contiguous block of memory this is implemented with
        a memcopy.
        <div class="indent pad10">
          <table>
            <tr>
              <td class="textsnip">Copy&nbsp;construction:</td>
              <td class="codesnip">T&nbsp;t1&nbsp;=&nbsp;2;</td>
              <td class="codesnip lightgray">T&nbsp;t2&nbsp;=&nbsp;t1;</td>
              <td class="textsnip">t1 and t2 occupy disjoint blocks of memory with the same value</td>
            </tr>
            <tr>
              <td class="textsnip">Copy assignment:</td>
              <td class="codesnip">T t3 = 0;</td>
              <td class="codesnip lightgray">t2 = t3;</td>
              <td class="textsnip">t2 and t3 occupy disjoint blocks of memory with the same value</td>
            </tr>
          </table>
        </div>
      </t-b>
    </div>
    <div style="floatx:right">
      <photosizer-block src="pictures/NativeCopy.png" width="300" class="photoSizerBlock" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;"
        >
            Figure 1. Copy Types
        </span>
      </photosizer-block>
    </div>
    <h3>Move Types:</h3>
    <div class="indent">
      <t-b>
        Move types efficiently transfer ownership of instance resources from the original named instance to another.  
        The original becomes
        invalid and the new instance takes ownership of the resources of the original without moving them in memory.  
        We have moved the resources from one instance to another efficiently. This is
        often implemented by giving the new owner the address of the resource.
        <div class="indent pad10">
          <table>
            <tr>
              <td class="textsnip">Move construction:</td>
              <td class="codesnip">T t1 = new T(1, "xyz")</td>
              <td class="codesnip lightgray">T t2 = t1;</td>
              <td class="textsnip">t1&apos;s resources given to t2, t1 now invalid</td>
            </tr>
            <tr>
              <td class="textsnip">Move assignment:</td>
              <td class="codesnip">T&nbsp;t3&nbsp;=&nbsp;new&nbsp;T(2,&nbsp;"abc");</td>
              <td class="codesnip lightgray">t2&nbsp;=&nbsp;t3;</td>
              <td class="textsnip">t3&apos;s resources given to t2, t3 now invalid</td>
            </tr>
          </table>
        </div>
      </t-b>
      <t-b>
        Move types often provide a clone() method that gives the destination a copy of the source&apos;s
        resources so the source remains valid.  
      </t-b>
      <t-b>
        Move operations usually only copy a pointer and so are
        fast.  Clone operations require copying all of the resources into a new instance and may be
        slow if the resources are large.
      </t-b>
    </div>
    <div style="float:left">
      <photosizer-block src="pictures/MoveType.png" width="300" class="photoSizerBlock" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;"
        >
            Figure 2a. Move Types
        </span>
      </photosizer-block>
    </div>
    <div style="float:left">
      <photosizer-block src="pictures/CloneType.png" width="300" class="photoSizerBlock" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;"
        >
            Figure 2b. Clone Operation
        </span>
      </photosizer-block>
    </div>
    <div style="height:0rem; clear:both"></div>
    <h3>Reference Types:</h3>
    <div class="indent">
      <t-b>
        Reference types are handle-body pairs.  The handle resides in a local scope and body in the program&apos;s
        heap.
        Program code manipulates the handle to effect changes to
        the body&apos;s value.
        <div class="indent pad10">
          <table>
            <tr>
              <td class="textsnip">Handle-body&nbsp;construction:</td>
              <td class="codesnip">T&nbsp;h1&nbsp;=&nbsp;new&nbsp;T(1,&nbsp;"xyz")</td>
              <td class="codesnip lightgray">T&nbsp;h2&nbsp;=&nbsp;h1;</td>
              <td class="textsnip">h1&apos;s resources - the body - are now attached to both h1 and h2</td>
            </tr>
            <tr>
              <td class="textsnip">Handle-body&nbsp;assignment:</td>
              <td class="codesnip">T&nbsp;h3&nbsp;=&nbsp;new&nbsp;T(2,&nbsp;"abc");</td>
              <td class="codesnip lightgray">h2&nbsp;=&nbsp;h3;</td>
              <td class="textsnip">Both h2 and h3 point to the same body</td>
            </tr>
          </table>
        </div>
        <div>
          <div style="    float: left; padding-right: 1rem;">
            <photosizer-block src="pictures/ManagedCopy.png" width="300" class="photoSizerBlock" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;"
              >
                  Figure 3. Reference Types
              </span>
            </photosizer-block>
          </div>
        </div>
      </t-b>
      <t-b>
        Reference types require either reference counting or garbage collection to avoid double deletion or
        memory leaks.  
      </t-b>
      <t-b>
        Reference counting is fast and deterministic, but reference cycles will cause
        memory leads unless some form of mark and remove is used.  
      </t-b>
      <t-b>
        Garbage collection is non-deterministic
        and must devote processing resources to track pointers.
      </t-b>
    </div>
    <div style="height:1rem; clear:both;"></div>
    <h3>C++ Types</h3>
    <div class="indent">
      <t-b>
        <div style="float:right">
          <photosizer-block src="pictures/NativeTypes.png" width="350" class="photoSizerBlock" style="margin-top:0;">
            <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS, Tahoma';
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;"
            >
                Figure 4. Native Types
            </span>
          </photosizer-block>
        </div>
      </t-b>
      <t-b>
        C++ programs compile to native code and run directly in the processes created for them. 
      </t-b>
      <t-b>
        Composed members
        of a native type&apos;s instance reside within the memory footprint of the instance.  Aggregated members reside
        in the heap and only a pointer to the heap instance resides in the native instance.
      </t-b>
      <h4>Copy Types</h4>
      <t-b>
        In the C++ programming language all primitives and any user defined type that has valid copy constructor
        and valid copy assignment are value types.
      </t-b>
      <t-b>
        The copy operations and destructor are compiler generated if all the user type data members have correct 
        copy semantics.  Otherwise, the developer is obligated to provide definitions for them.
      </t-b>
      <h4>Move Types</h4>
      <t-b>
        C++ user types that define move constructor and move assignment and do not define copy constructor and copy assignment,
        and disallow compiler generation of them,
        are Move types.  If copy construcor and copy assignment are also defined the type will act like copy or move type
        depending on the context or use with a move modifier.
      </t-b>
      <t-b>
        Unlike Rust, the C++ compiler does not disallow use of the invalid source after it is moved, resulting
        in undefined behavior.
      </t-b>
      <h4>Reference Types</h4>
      <t-b>
        C++ provides the primitives raw pointer, <span class="lightgray codesnip">T* ptr = *t;</span> and reference
        <span class="lightgray codesnip">T& ref = &amp;t;</span>
      </t-b>
      <t-b>
        User types can take on reference behavior by using std::unique_ptr&lt;T&gt; or std::shared_ptr&lt;T&gt;
        <div class="indent pad10 codesnip">
          auto r = std::shared_ptr&lt;T&gt;(new T(args));
        </div>
        These pointer types are reference counted, so the lifetime of the instance ends when the last shared pointer
        goes out of scope.
      </t-b>
      <t-b>
        One could create a type with reference behavior by carefully crafting copy operations and destructor, but
        requires care to avoid memory leaks or double delete exceptions.  Not recommended.
      </t-b>
      <h4>Type Aliases</h4>
      <t-b>
        An alias is simply another name for a given type.  C++ provides two means of defining aliases:
        <ul class="tight" style="margin-left:0rem;">
          <li>
            <span class="lightgray codesnip">
              using ID = unsigned int;
            </span>
          </li>
          <li>
            <span class="lightgray codesnip">
              typedef unsigned int ID;
            </span>
          </li>
        </ul>
      </t-b>
      <h4>Strong Types</h4>
      <t-b>
        TBD
      </t-b>
    </div>
    <h3>Rust Types</h3>
    <div class="indent">
      <t-b>
        Rust programs compile to native code and run directly in the processes created for them.  
      </t-b>
      <t-b>
        User defined types in Rust are structs, enums, or unions.  The struct plays essentially the same role 
        in Rust as classes do in C++, C#, and Java.
      </t-b>
      <t-b>
        The Rust
        compiler disallows use of instances that have been moved.  
        It also disallows mutation of an instance
        through a mutable reference whenever another reference is active unless the other reference is not used
        after the mutation. 
      </t-b>
      <h4>Copy Types</h4>
      <t-b>
        In the Rust programming language all types that implement the Copy trait are copy types. That includes
        all primitives and any user defined structs that have all copy members and are bounded by the Copy trait.
      </t-b>
      <h4>Move Types</h4>
      <t-b>
        Rust user defined structs that do not implement the Copy trait are Move types.
      </t-b>
      <h4>Reference Types</h4>
      <t-b>
        Rust provides the primitives unsafe raw pointer, <span class="lightgray codesnip">let ptr:T* = *t;</span> and reference
        <span class="lightgray codesnip">let ref:&T = &t;</span>
      </t-b>
      <t-b>
        The standard smart reference-counted pointers Rc&lt;T&gt; and Arc&lt;T&gt; 
        and smart heap pointer <span class="lightgray codesnip">Box&lt;T&gt;</span> are the only stdlib reference 
        types in Rust.
      </t-b>
      <t-b>
        When any of them are initialized from an instance in the stack, the instance is copied to the heap.
        <div class="indent pad10" style="width:max-content;">
          <span class="lightgray codesnip">let t = T:new(); let boxed = Box::new(t);</span>
        </div>
        boxed is a smart pointer to a copy of t in the heap.
      </t-b>
      <details>
        <summary class="darkItem">User defined reference types</summary>
        <t-b>
          A user defined reference type could be constructed with a struct using unsafe implementation blocks or
          lifetime annotations; but users of that type will find it hard to craft compilable syntax.
        </t-b>
      </details>
      <h4>Type Aliases</h4>
      <t-b>
        An alias is simply another name for a given type.  Rust provides two means of defining aliases:
        <ul class="tight" style="margin-left:0rem;">
          <li>
            <span class="lightgray codesnip">
              type ID = u32;
            </span>
          </li>
          <li>
            <span class="lightgray codesnip">
              use u32 as ID;
            </span>
          </li>
        </ul>
      </t-b>
      <h4>Strong Types</h4>
      <t-b>
        TBD
      </t-b>
    </div>
    <div style="height:1rem;"></div>
    <h3>C# Types:</h3>
    <div class="indent">
      <t-b>
        <div class="right clear">
          <photosizer-block src="pictures/ManagedObjects.png" width="400" class="photoSizerBlock" style="margin-top:0;">
            <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS, Tahoma';
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;"
            >
                Figure 5. Managed Types
            </span>
          </photosizer-block>
        </div>
      </t-b>
      <t-b>
        C# programs compile to IL (byte code) and run in a virtual machine (CLR) hosted by the processes 
        created for them.  At load time the CLR compiles IL to native code by function or assembly.  The
        compiled code is cached and not compiled again.
      </t-b>
      <t-b>
        C# types have two categories:
        <ul class="tight" style="margin-left:-0.0rem;">
          <li>
            Value Types:
            <div class="indent pad5">
              primitive scalar types, struct and enum<br />
              All reside in the stack
            </div>
          </li>
          <li>
            Reference Types:
            <div class="indent pad5">
              class, interface, array, and delegate<br />
              All reside on the managed heap
            </div>
          </li>
        </ul>
        All value types reside in the stack; all reference types reside in the managed heap.
      </t-b>
      <t-b>
        Java types are nearly isomorphic to C# types, e.g., they have the same behaviors.
      </t-b>
      <h4>Copy Types</h4>
      <t-b>
        All of the value types are Copy types with the exception of structs that have aggregated members, i.e.
        contain references to instances on the managed heap.
      </t-b>
      <t-b>
        Structs have the layout shown in Figure 4.  Struct members are composed if, and only if, they are
        value types. All other members are aggregated.  If no member is aggreggated then the struct is Copy.
      </t-b>
      <h4>Move Types</h4>
      <t-b>
        C# has no Move types.
      </t-b>
      <h4>Reference Types</h4>
      <t-b>
        All C# reference types have the same behavior as the Reference Type, described above.
        All classes are reference types and their instances reside in the managed heap.
      </t-b>
      <h4>Type Aliases</h4>
      <t-b>
        An alias is simply another name for a given type.  C# provides:
        <ul class="tight" style="margin-left:0rem;">
          <li>
            <span class="lightgray codesnip">
              using Records = List&lt;Tuple&lt;int, string, int&gt;&gt;
            </span>
          </li>
        </ul>
      </t-b>
      <h4>Strong Types</h4>
      <t-b>
        TBD
      </t-b>
    </div>
    <!--<div class="indent">
      <t-b>
        <div style="height:1rem; clear:both"></div>
        <photosizer-block src="pictures/ClassesAndObjects.png" width="500" class="photoSizerBlock" style="margin-top:0;">
          <span style="
            display: inline-block;
            font-weight: bold;
            font-family: 'Comic Sans MS, Tahoma';
            background-color: #ddd;
            width: 100%;
            padding: 5px 0px;"
          >
              Figure 3. Native Classes and Objects
          </span>
        </photosizer-block>
        <photosizer-block src="pictures/CS_ClassesAndObjects.png" width="500" class="photoSizerBlock" style="margin-top:0;">
          <span style="
            display: inline-block;
            font-weight: bold;
            font-family: 'Comic Sans MS, Tahoma';
            background-color: #ddd;
            width: 100%;
            padding: 5px 0px;"
          >
              Figure 4. Managed Classes and Objects
          </span>
        </photosizer-block>
      </t-b>
    </div>
    <div class="indent">
    <h4>C# and Java Value Types</h4>
    <t-b>
      Only primitive types are value types.  The only user-defined value type is the struct with all value type data members.
    </t-b>
    </div>
    <t-b>
      <ul>
        <li>
          Value Types
          <ul>
            <li>Copy</li>
            <li>Move</li>
            <li>Clone</li>
          </ul>
        </li>
        <li>Reference Types</li>
        <li>Type aliases</li>
        <li>Strong types</li>
      </ul>
    </t-b>-->
  </body>
</html>
