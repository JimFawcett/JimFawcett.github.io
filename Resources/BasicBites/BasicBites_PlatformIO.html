<!DOCTYPE html>
<!--
  BasicBites_Intro.html
--->
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>Basic Bites PlatformIO</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <link rel="stylesheet" href="css/StylesWebComponents.css" />
    <script src="js/ScriptsWebComponents.js"></script>
    <script src="js/BasicBiteScripts.js"></script>
    <script src="js/BiteTables.js"></script>
    <script src="js/ScriptsKeyboard.js"></script>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Platform and Code Basics</span>
      <span class="top-center">Platform IO</span>
    </div>
    <next-prev>
      <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
      <a id="repo" href="BasicBites_Intro.html">Repo</a> 
      <a id="Prev" href="BasicBites_PlatformSched.html">prev</a> 
      <a id="Next" href="BasicBites_PlatformSysRescr.html">next</a>
    </next-prev>

    <toc-b id="toc">
      <div id="bottom-menu" style="display:flex; flex-direction:row">
      </div>
        <up-b id="chaps">
        </up-b>
          <rt-b id="sects">
        <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
        <a href="#contents">Contents</a>, <a href="#refs">References</a>
      </rt-b>
    </toc-b>
    <div id="hlp" style="display:none;">
    </div>
   
    <h2>BasicBites - Platform I/O</h2>
    <t-b>
      I/O operations send or receive data using terminals, files, in-memory strings, sockets, Graphical User 
      Interfaces (GUIs), and devices like keyboards, mice, trackpads, and speakers.
      This involves one of two rather distinct types of processing: synchronous or asynchronous.  
      <ul>
        <li>
          Synchronous I/O uses functions that don&quot;t return until the operation completes.  
          Programming language libraries provide read and write functions for that purpose.      
        </li>
        <li>
          Asynchronous I/O uses functions that supply a call back function and return immediately.
          The callback is invoked when the operation completes.  
          Programming language libraries provide async read and async write functions for that purpose.      
        </li>
      </ul>
    </t-b>
    <t-b>
      Synchronous operations interact with the platform API to translate to and from 
      an external environment.
      Asynchronous operations use either I/O completion ports or Windows messages to send and receive data, using
      the platform API.  API calls are routed to device drivers appropriate for a specified device.
    </t-b>
    <photosizer-block src="pictures/IOCP.png" width="500" class="photoSizerBlock right" style="margin-top:0;">
      <span style="
        display: inline-block;
        font-weight: bold;
        font-family: 'Comic Sans MS, Tahoma';
        background-color: #ddd;
        width: 100%;
        padding: 5px 0px;"
      >
          Figure 1. Windows I/O completion ports
      </span>
    </photosizer-block>
    <h3>I/O Completion Ports</h3>
    <photosizer-block src="pictures/windows.png" width="500" class="photoSizerBlock right clear" style="margin-top:0;">
      <span style="
        display: inline-block;
        font-weight: bold;
        font-family: 'Comic Sans MS, Tahoma';
        background-color: #ddd;
        width: 100%;
        padding: 5px 0px;"
      >
          Figure 2. Windows Event Processing
      </span>
    </photosizer-block>
    <h3>Windows Messaging</h3>
    <h3 class="clear">Streams</h3>
    <t-b>
      Streams provide buffered I/O operations that collect data from possibly several requests and send that 
      data collection to a device driver.  Each basic read or write request needs to enter the platform kernel
      to access an appropriate device driver.  That takes a 
      significant amount of time compared to user mode processing.  Buffering reduces the number of calls into the
      platform kernel and so improves program throughput.
    </t-b>
    <h3 class="clear">Consequences</h3>
    <h3 class="clear">References:</h3>
    <ol class="indent tight">
      <li>
        <a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2201309&seqNum=3">Understanding the Windows IO System</a>
      </li>
      <li>
        <a href="https://dschenkelman.github.io/2013/10/29/asynchronous-io-in-c-io-completion-ports/">Asynchronous I/O: I/O Completion Ports</a>
      </li>
      <li>
        <a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2201309&seqNum=3">Understanding Windows I/O System</a>
      </li>
    </ol>
  </body>
</html>
