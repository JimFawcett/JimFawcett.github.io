<!DOCTYPE html>
<html>
<!--
  BasicBites_Intro.html
-->
<head>
  <title>Design Intro</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeDefault.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesDesignTrack.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <style>
    #github table {
      width: 90%;
      border: 1px solid black;
    }

      #github table tr {
        border: 1px solid var(--dark);
      }

        #github table tr th {
          color: var(--dark);
          background-color: var(--menu);
        }

        #github table tr td {
          color: var(--dark);
          background-color: var(--light);
        }

      #github table a:link {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:visited {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:hover {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:active {
        color: var(--dark);
        background-color: transparent;
      }
  </style>
<!--   <script>
    window.onmessage = function () {
      bottomMenu.sections();
    }
  </script>
 --></head>
<body id="github" onload="initialize()">

  <a id="Next" href="Design.html">Next</a>
  <a id="Prev" href="DesignBites_StructurePlugIn.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="modified">3/05/2022</div>
      <div id="page">Introduction</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <header id="pagetitle">
          <h1>Design Bite - Introduction</h1>
          <h3 id="subtitle" class="indent">Concept, Architecture, TextFinder Spec, TextFinder Impl</h3>
        </header>
        <t-b class="indent">
          &quot;We will either find a way, or make one.&quot;<br />
          - Hannibal
        </t-b>
        <a id="prologue"></a>
        <hr style="margin:1em 0em 1.5em 0em;" />
        <a id="prologue"></a>
        <h3>1.0 Prologue</h3>
        <div class="indents">
          <t-b>
            Design Bites are a short sequence of pages, each focused on a specific aspect
            of software design.  They are brief, pragmatic, and relevent to things you and I do professionally.
          </t-b>
          <t-b>
            This page is an introduction to the sequence. We use the <a href="../../RustTextFinder.html">TextFinder</a> project,
            introduced in
            <a href="file:///C:/github/JimFawcett/JimFawcett.github.io/Resources/BuildOn/Step0.html">BuildOn</a>
            presentations, to make discussion concrete and specific.
          </t-b>
          <t-b>
            Software development has several phases: 
            <ul class="tight">
              <li>
                designing concept, architecture, specification, and documenting the design
              </li>
              <li>
                implementing and testing code, and documenting the results
              </li>
              <li>
                deploying code and documentation
              </li>
            </ul>
            You can view examples of documentation and code from this site here: <a href="../../RustTextFinder.html">Rust TextFinder</a> and 
            <a href="CommCompare.html">CommCompare</a>.
          </t-b>
          <t-b>
            For small brief projects, like TextFinder, This likely to be a linear sequence.  For larger projects
            development may be staged into producing a core release, and then a series of releases with progressively
            more functionality, until the specification has been satisfied.
          </t-b>
          <t-b>
            It is important to note that design need not be a huge process.  Its size, effort, and products should
            be scaled to match the project. For projects like TextFinder, it might be a day or two of work with a
            few pages of documentation, perhaps split between web page disclosure and comments in individual
            code packages.
            <a id="concept"></a>
          </t-b>
          <div style="height:0.15rem;"></div>
        </div>
        <a id="concept"></a>
        <h3>2.0 Concept Development</h3>
        <div style="width:calc(100vw - 6rem);">
          <div class="right">
            <photosizer-block src="pictures/Design.jpg" width="450" class="photoSizerBlock" style="margin-top:0;">
              <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS, Tahoma';
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
                Figure 1. Software Design
              </span>
            </photosizer-block>
          </div>
        </div>
        <div>
          <t-b>
            There we think about who the users will be, what their goals and expected
            activities are, and we also think about issues that may become apparent as the design proceeds.
          </t-b>
          <t-b>
            Issues may be things like performance, ease of use, scope of activities, complexity, and ability
            of the development team to complete the project at reasonable cost with a practical schedule.
          </t-b>
          <t-b>

          </t-b>
        </div>
        <div class="indents">
          <a id="concept"></a>
          <h4>2.1 - TextFinder Concept</h4>
          <div class="indents">
            <t-b>
              Design concept deals with what?, why?, and so what?
            </t-b>
            <t-b>
              <strong>What</strong> do we want to do?&nbsp;&nbsp;&nbsp;Find files that contain specified text.
            </t-b>
            <t-b>
              <strong>Why</strong> do we want to do that?&nbsp;&nbsp;&nbsp;To locate files that contain things we want to look at and modify.
              <div style="height:0.75rem;"></div>
              Here are some practical <strong>uses</strong>:
              <ul class="tight outdent">
                <li>
                  Find links in html files, write them to a test page, then click on each link to check for 404s.
                </li>
                <li>
                  Find all html pages that mention a specific Rust feature, e.g., Arc&lt;T&gt;, to build a
                  glossary of links.
                </li>
                <li>
                  where did I write about xyz?
                </li>
              </ul>
              Note that generation of output differs markedly for each of these!
            </t-b>
            <t-b>
              <strong>So what</strong> are the <strongs>issues</strongs>?
              <ul class="tight">
                <li>
                  May need to look at thousands of files.  So performance is an issue.
                </li>
                <li>
                  Some uses seem to require using regular expressions to specify text to find.
                </li>
                <li>
                  How do we build flexibility to handle a variety of uses, e.g., things cited
                  above.
                </li>
                <li>
                  Are there any existing parts we can reuse?
                </li>
              </ul>
            </t-b>
            <t-b>
              When the concept is complete, we begin developing an architecture.
              <a id="architecture"></a>
            </t-b>
          </div>
          <div style="height:0.15rem;"></div>
          <a id="arch"></a>
          <h3>3.0 Architecture</h3>
          <div class="indents">
            <t-b>
              Architecture is an abstraction that leaves out all of the details of language and platform,
              letting ideas take precedence. Its purpose is to think about how the project will function,
              what its parts will be, their responsibilities,
              how they will communicate, and how data flows through the system.
            </t-b>
            <h4>3.1 TextFinder Architecture</h4>
            <div style="width:calc(100vw - 9rem);">
              <div class="right">
                <photosizer-block src="pictures/TextFinderPackages.jpg" width="250" class="photoSizerBlock" style="margin-top:0;">
                  <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS, Tahoma';
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
                    Figure 2. TextFinder Packages
                  </span>
                </photosizer-block>
              </div>
            </div>
            <t-b>
              One useful way to start is to summarize tasks the system will need to execute in order
              to to find files with specified text:
              <ul class="tight" style="margin:0.5em 2em;">
                <li>
                  Accept information from the command line that specifies directories to search, kinds of
                  files to analyze, text to find, and any options that seem appropriate.
                </li>
                <li>
                  Navigate through the directory tree rooted at an input path, find names of all files that match
                  specified patterns, e.g., extensions like &quot;.html&quot;, &quot;.rs&quot;, &quot;.h&quot;, &quot;.cpp&quot;, ...,
                  and the paths where they are found, and send on for text search.
                </li>
                <li>
                  Open each such file and search for specified text.  Send results on for display.
                </li>
                <li>
                  Extract useful information from the data stream, perform any required post-processing,
                  and display the results.
                </li>
              </ul>
              Here&apos;s an example description: <a href="../BuildOn/Step0.html">TextFinder architecture</a>,
              with more detail in subsequent BuildOn steps.
            </t-b>
            <t-b>
              Each task is a candidate to become a package. Note that we&apos;ve described a data flow process.
              That&apos;s not the only way to configure TextFinder, but will be effective.  That&apos;s because
              Information can be supplied to the user as part of the processing, which may visit hundreds or
              even thousands of files and directories.  We will see later, that data-flow lends itself to
              concurrent processing for text search in files.
            </t-b>
            <t-b>
              Now the parts - source code packages - are emerging from that thought process, e.g.:
              <ul class="tight" style="margin:0.5em 2em;">
                <li>
                  <strong>TextFinder</strong> executive creates instances of the implementation&apos;s types
                  and starts the processing flow.
                  It creates CmdlnParser and accepts its parsed output, creates an instance of DirNav
                  and configures it with the TextSearch type.  It creates an instance of the Display type,
                  and configures TextSearch with text and a reference to the Display type.
                </li>
                <li>
                  <strong>CmdlnParser</strong> accepts the input command line, parses it into an associative list of
                  attributes - path, patterns, text, ... - and returns that information to TextFinder.
                </li>
                <li>
                  <strong>DirNav</strong> accepts a starting path and the set of file patterns to find, and recursively
                  visits all directories in the directory tree rooted at the specified path.  Each time it
                  enters a directory and finds file names that match one of its patterns it passes that
                  information on for text search, using an eventing interface.
                </li>
                <li>
                  <strong>TextSearch</strong> opens each file it&apos;s given and searches for the specified text.
                  It then passes that information on for display.
                </li>
                <li>
                  <strong>Display</strong> is interesting.  What it needs to do is very application specific,
                  as indicated in the Textfinder Concept.  Since TextFinder executive configures TextSearch with
                  a reference to its display, the application can provide several display types, one of
                  which is instantiated based on user input.
                </li>
              </ul>
              We now have a clear picture of what needs to be implemented and what structure to use.  Next, we
              need to describe what we are going to deliver.
            </t-b>
            <div style="height:0.15rem;"></div>
          </div>
          <a id="spec"></a>
          <h3>4.0 TextFinder Specification:</h3>
          <div class="indents">
            <t-b>
              A specification should be as brief as practical while still being complete and unambiguous.  We are
              electing to make display quite simple, but the architecture leaves open the possibility of easily
              replacing that with alternate display processing in a later version.
            </t-b>
            <t-b>
              <ol class="tight" style="margin-left:2em;">
                <li>
                  Identify all files in a directory subtree that match one or more patterns and contain a specified text.
                </li>
                <li>
                  Specify root path, one or more file patterns (.h, .cpp, .cs, .rs, ...), and search text on command line.
                </li>
                <li>
                  Specify options <c-s>/s [true|false]</c-s>, <c-s>/v [true|false]</c-s>, <c-s>/H [true|false]</c-s>
                  <c-s>/h [true|false]</c-s> for recursive directory walk, verbose output header, Hidden dirs with no match,
                  and help message, respectively.
                </li>
                <li>
                  Display file name and path, without duplication of path name, e.g., organized by directory, for files
                  containing the search text.
                </li>
                <li>
                  Interesting extensions, not required for this implementation:
                  <ul class="tight" style="margin-left:0.85rem;">
                    <li>
                      Replace text by regular expressions for both search text and file patterns.
                    </li>
                    <li>
                      Replace sequential file searches with parallel searches to improve performance and useability.
                    </li>
                  </ul>
                </li>
              </ol>
              At this point, we can begin developing code, focusing on generating specified processing with user-defined
              types and their methods.  We know how data will flow, which makes it relatively simple to build test mocks
              for functionality not yet in place.
              <a id="impl"></a>
            </t-b>
            <div style="height:0.1rem;"></div>
          </div>
          <a id="impl"></a>
          <h3>5.0 Implementation</h3>
          <div class="indents">
            <t-b>
              Implementation is all about details.  Every single line of code for every package matters. Once an
              architecture is defined, each package can be built in near isolation from the others until we tie
              everything together near the end. So that makes it much easier to handle this level of detail.
            </t-b>
            <div style="width:calc(100vw - 9rem);">
              <div class="right clear">
                <photosizer-block src="pictures/TextFinderClassDiagram2.jpg" width="350" class="photoSizerBlock" style="margin-top:0;">
                  <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                    Figure 3. TextFinder Types
                  </span>
                </photosizer-block>
              </div>
            </div>
            <t-b>
              The implementation process often starts with a single package, populating that with types and functions.
              Since we will be using Rust, we won&apos;t use the term class as it builds user-defined types with
              structs.
            </t-b>
            <t-b>
              Each package will have a primary type, as shown in Figure 3.  The types DirEvent and SearchEvent are
              traits, used to support communication, as described below.
              <t-b>
                <ul class="tight">
                  <li>
                    <strong><c-s>Executive</c-s></strong> type is defined in the TextFinder package.  It creates an instance
                    of <c-s>DirNav&lt;Finder&gt;</c-s> and configures its internal <c-s>Finder</c-s> instance with a reference
                    to an instance of <c-s>GenOut</c-s>.  This generates a data flow pipe-line which dominates TextFinder processing.
                  </li>
                  <li>
                    <strong><c-s>DirNav&lt;Finder&gt;</c-s></strong> and the <strong><c-s>DirEvent</c-s></strong> interface
                    is defined in the DirNav package.  In its constructor <c-s>DirNav</c-s> creates an instance of
                    <c-s>Finder</c-s> using a factory function specified in the DirEvent trait and implemented
                    by Finder.
                    <div style="height:0.5rem"></div>
                    It exposes a
                    public method <c-s>get_app(&mut self) -> &mut App</c-s>.  The App type is a generic parameter
                    which Executive supplied by constructing <c-s>DirNav&lt;Finder&gt;</c-s>.  <c-s>get_app()</c-s> is called
                    by <c-s>Executive</c-s> to configure the <c-s>Finder</c-s> app with an instance of <c-s>GenOut</c-s>
                    and search text.
                    <div style="height:0.5rem"></div>
                    <c-s>DirNav</c-s> provides a function <c-s>visit(&amp;mut self, dir: Path) -> io::Result&lt;()&gt;</c-s>
                    that <c-s>Executive</c-s> calls to start TextFinder processing flow.
                  </li>
                  <li>
                    <strong><c-s>Finder</c-s></strong> and <strong><c-s>SearchEvent</c-s></strong> are defined in the
                    TextSearch package. <c-s>Finder</c-s> creates a file path using file name and current directory,
                    passed by <c-s>DirNav&lt;Finder&gt;</c-s>.  It attempts to open the file and, if successful it
                    searches the file for text supplied by <c-s>Executive</c-s>.  In either case it reports the
                    result to <c-s>GenOut</c-s> using the <c-s>SearchEvent</c-s> interface.
                  </li>
                  <li>
                    <c-s>GenOut</c-s> is defined in the Display package.  It receives search events from <c-s>Finder</c-s>
                    and builds information for TextFinder users.  For simple applications - see uses in the Concept
                    section - it simply formats results information and writes to the console.  For more complex
                    applications it may build an internal data structure and do some post processing for each search
                    event, perhaps sending out the entire results data at the end of the program.
                    <div style="height:0.5rem"></div>
                    If so, it will likely indicate search activities, perhaps by displaying directories as they become
                    available, so users know that the application is running as expected.
                  </li>
                </ul>
              </t-b>

            </t-b>
          </div>
          <a id="dataflow"></a>
          <h4>6. - Data Flow Patterns</h4>
          <div class="indents">
            <t-b>
              In the next Bite: <a href="DesignBites_Structure.html">Structure</a> we look at the the ideas that lead
              up to the structure shown in Figure 3.
              <a id="epilogue"></a>
            </t-b>
          </div>
        </div>
        <a id="epilogue"></a>
        <h3>3. Epilogue</h3>
        <div class="indents">
          <t-b>
            Before diving into options for <a href="DesignBites_Structure.html">design stucture</a>
            you may find a relatively pragmatic discussion of <a href="../../Design.html">design philosophy</a>
            helps to understand some of the motivations for these Bites.
          </t-b>
          <t-b>
            We will consider five design alternatives for TextFinder:
            <ol class="tight" style="margin-left:2em;">
              <li><a href="DesignBites_StructureBasic.html">Monolithic Structure</a></li>
              <li><a href="DesignBites_StructureFactored.html">Factored Structure</a></li>
              <li><a href="DesignBites_StructureDataFlow.html">DataFlow Structure</a></li>
              <li><a href="DesignBites_StructureTypeErase.html">TypeErase Structure</a></li>
              <li><a href="DesignBites_StructurePlugIn.html">PlugIn Structure</a></li>
            </ol>
            These are progressively more flexible, eventually resulting in reusable components, but also increasingly
            complex.  Where you settle in these alternatives is determined by design context.  Is this a
            one-of-a-kind project that you want to finish quickly or is it
            heading for production code that will be maintained by more than one developer?
          </t-b>
        </div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <sec-elem style="width:0.0em">&nbsp;</sec-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#epilogue">epilogue</a></menu-elem>
        <menu-elem class="secElem"><a href="#impl">impl</a></menu-elem>
        <menu-elem class="secElem"><a href="#spec">spec</a></menu-elem>
        <menu-elem class="secElem"><a href="#arch">arch</a></menu-elem>
        <menu-elem class="secElem"><a href="#concept">concept</a></menu-elem>
        <menu-elem class="secElem"><a href="#prologue">prologue</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
        <div style='margin:0em -1em; padding:0.25em 2em 0.45em 2em; text-align:center' class='darkItem'>Sections</div>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <!--<menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.decrZoomScreen()">Zout</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.normZoomScreen()">Zdef</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.incrZoomScreen()">Zin</menu-elem>-->
    </frame-footer>
  </page-frame>
</body>
</html>