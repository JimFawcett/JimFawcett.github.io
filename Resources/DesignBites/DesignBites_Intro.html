<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>DesignBites Intro</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <link rel="stylesheet" href="css/StylesWebComponents.css" />
    <script src="js/BiteScripts.js"></script>
    <script src="js/ScriptsKeyboard.js"></script>
    <script src="js/ScriptsWebComponents.js"></script>
    <!--<style>
      #github .outdent {
        margin-left: 25.5rem;
        border:2px solid green;
      }
    </style>-->
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Design Bite by Byte</span>
      <span class="top-center">Introduction</span>
      <!-- <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a> -->
    </div>
    <next-prev>
      <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
      <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
      <a id="Prev" href="DesignBites_Intro.html">prev</a> 
      <a id="Next" href="DesignBites_DIP.html">next</a>
    </next-prev>

      <toc-b id="toc">
        <div id="bottom-menu" style="display:flex; flex-direction:row">
          <!--<a href="Javascript:;" onclick="storyMenu.sects()" style="color: #fefefa; ">Sects</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;-->
            <!-- <a href="../../RustBiteByByte.html" style="color:#fefefa;">Repo</a>&nbsp; -->
          <!-- <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp; -->
          <!-- <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">esc</a>&nbsp; -->
          <!-- <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp; -->
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
          <up-b id="chaps">
            <!--<a href="RustBites_Facts.html">Facts</a><br />
            <a href="RustBites_Intro.html">Introduction</a><br />
            <a href="RustBites_Safety.html">Safety</a><br />
            <a href="RustBites_UDB.html">UndefBehavior</a><br />
            <a href="RustBites_Data.html">Data</a><br />
            <a href="RustBites_DataStr.html">DataStructs</a><br />
            <a href="RustBites_SmrtPtrs.html">SmartPtrs</a><br />
            <a href="RustBites_LifeCycle.html">LifeCycle</a><br />
            <a href="RustBites_Ownrs.html">Ownership</a><br />
            <a href="RustBites_Traits.html">Generics&Traits</a><br />
            <a href="RustBites_Functs.html">Functions</a><br />
            <a href="RustBites_Structs.html">Structs</a><br />
            <a href="RustBites_LifeTime.html">LifeTime</a><br />
            <a href="RustBites_Abstract.html">Abstractions</a><br />
            <a href="RustBites_ErrHnd.html">ErrHandling</a><br />
            <a href="RustBites_Collects.html">Collections</a><br />
            <a href="RustBites_Iterator.html">Iterators</a><br />
            <a href="RustBites_Threads.html">Threads</a><br />
            <a href="RustBites_Synchron.html">Synchronize</a><br />
            <a href="RustBites_Channels.html">Channels</a><br />
            <a href="RustBites_AsyncAwt.html">AsyncAwait</a><br />
            <a href="RustBites_Macros.html">Macros</a><br />
            <a href="RustBites_TipsAndTricks.html">Hacks and Helpers</a><br />-->
            <!-- <a href="RustBites_Generics.html">Generics</a><br /> -->
            <!-- <a href="RustBites_Intmut.html">InterMutat</a><br /> -->
            <!--<a href="Javascript.;#"></a><br />-->
          </up-b>
            <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
          <a href="#contents">Contents</a>, <a href="#refs">References</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <!--<table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>N</td><td>Next Bite</td>
          </tr>
          <tr>
            <td>P</td><td>Prev Bite</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>-->
       </div>
   
      <h2>Design Bite - Introduction</h2>
      <hr />
      <h3>1.0 Prologue</h3>
      <div class="indent">
        <t-b>
          Design Bites are a short sequence of pages, each focused on a specific aspect
          of software design.  They are brief, pragmatic, and relevent to things you and I do professionally.
        </t-b>
        <t-b>
          This page is an introduction to the sequence. We use the <strong>TextFinder</strong> project, 
          introduced in BuildOn presentations, to make discussion concrete and specific.
        </t-b>
        <t-b>
          Design has two main phases: defining an architecture and implementing it.  It has a precursor,
          concept development. When an architecture is relatively complete, a design specification is
          developed. Then, design begins.
        </t-b>
        <t-b>
          For small brief projects, like TextFinder, This likely to be a linear sequence.  For larger projects
          development may be staged into producing a core release, and then a series of releases with progressively
          more functionality, until the specification has been satisfied.
        </t-b>
        <t-b>
          It is important to note that design need not be a huge process.  Its size, effort, and products should 
          be scaled to match the project. For projects like TextFinder, it might be a day or two of work with a
          few pages of documentation.
        </t-b>
      </div>
      <h3>2.0 Concept Development</h3>
      <div style="width:calc(100vw - 6rem);">
        <div class="right">
          <photosizer-block src="pictures/Design.jpg" width="600" class="photoSizerBlock" style="margin-top:0;">
            <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS, Tahoma';
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
              Figure 1. Software Design
            </span>
          </photosizer-block>
        </div>
      </div>
      <div>
        <t-b>
          There we think about who the users will be, what their goals and expected
          activities are, and we also think about issues that may become apparent as the design proceeds.
        </t-b>
        <t-b>
          Issues may be things like performance, ease of use, scope of activities, complexity, and ability
          of the development team to complete the project at reasonable cost with a practical schedule.
        </t-b>
        <t-b>

        </t-b>
      </div>
    <div class="indent">
      <div class="indents">
        <h4>2.1 - TextFinder Concept</h4>
        <div class="indents">
          <t-b>
            Design concept deals with what?, why?, and so what?
          </t-b>
          <t-b>
            <strong>What</strong> do we want to do?&nbsp;&nbsp;&nbsp;Find files that contain specified text.
          </t-b>
          <t-b>
            <strong>Why</strong> do we want to do that?&nbsp;&nbsp;&nbsp;To locate files that contain things we want to look at and modify.
            <div style="height:0.75rem;"></div>
            Here are some practical <strong>uses</strong>:
            <ul class="tight outdent">
              <li>
                Find links in html files, write them to a test page, then click on each link to check for 404s.
              </li>
              <li>
                Find all html pages that mention a specific Rust feature, e.g., Arc&lt;T&gt;, to build a
                glossary of links.
              </li>
              <li>
                where did I write about xyz?
              </li>
            </ul>
            Note that generation of output differs markedly for each of these!
          </t-b>
          <t-b>
            <strong>So what</strong> are the <strongs>issues</strongs>? 
            <ul class="tight">
              <li>
                May need to look at thousands of files.  So performance is an issue.
              </li>
              <li>
                Some uses seem to require using regular expressions to specify text to find.
              </li>
              <li>
                How do we build flexibility to handle a variety of uses, e.g., things cited
                above.
              </li>
              <li>
                Are there any existing parts we can reuse?
              </li>
            </ul>
          </t-b>
        <t-b>
          When the concept is complete, we begin developing an architecture.
        </t-b>
      </div>
      <h3>3.0 Architecture</h3>
      <div class="indent">
        <t-b>
          Architecture is an abstraction that leaves out all of the details of language and platform, 
          letting ideas take precedence. Its purpose is to think about how the project will function,
          what its parts will be, their responsibilities,
          how they will communicate, and how data flows through the system.
        </t-b>
        <h4>3.1 TextFinder Architecture</h4>
        <div style="width:calc(100vw - 9rem);">
          <div class="right">
            <photosizer-block src="pictures/TextFinderPackages.jpg" width="500" class="photoSizerBlock" style="margin-top:0;">
              <span style="
                display: inline-block;
                font-weight: bold;
                font-family: 'Comic Sans MS, Tahoma';
                background-color: #ddd;
                width: 100%;
                padding: 5px 0px;
              ">
                Figure 2. TextFinder Packages
              </span>
            </photosizer-block>
          </div>
        </div>
        <t-b>
          One useful way to start is to summarize tasks the system will need to execute in order
          to to find files with specified text:
          <ul class="tight">
            <li>
              Accept information from the command line that specifies directories to search, kinds of 
              files to analyze, text to find, and any options that seem appropriate.
            </li>
            <li>
              Navigate through the directory tree rooted at an input path, find names of all files that match
              specified patterns, e.g., extensions like &quot;.html&quot;, &quot;.rs&quot;, &quot;.h&quot;, &quot;.cpp&quot;, ...,
              and the paths where they are found, and send on for text search.
            </li>
            <li>
              Open each such file and search for specified text.  Send results on for display.
            </li>
            <li>
              Extract useful information from the data stream, perform any required post-processing,
              and display the results.
            </li>
          </ul>
          Each task is a candidate to become a package. Note that we&apos;ve described a data flow process.
          That&apos;s not the only way to configure TextFinder, but will be effective.  That&apos;s because
          Information can be supplied to the user as part of the processing, which may visit hundreds or
          even thousands of files and directories.  We will see later, that data-flow lends itself to
          concurrent processing for text search in files. 
        </t-b>
        <t-b>
          Now the parts - source code packages - are emerging from that thought process, e.g.:
          <ul class="tight">
            <li>
              <strong>TextFinder</strong> executive creates instances of the implementation&apos;s types 
              and starts the processing flow.
              It creates CmdlnParser and accepts its parsed output, creates an instance of DirNav
              and configures it with the TextSearch type.  It creates an instance of the Display type,
              and configures TextSearch with text and a reference to the Display type.
            </li>
            <li>
              <strong>CmdlnParser</strong> accepts the input command line, parses it into an associative list of
              attributes - path, patterns, text, ... - and returns that information to TextFinder.
            </li>
            <li>
              <strong>DirNav</strong> accepts a starting path and the set of file patterns to find, and recursively
              visits all directories in the directory tree rooted at the specified path.  Each time it
              enters a directory and finds file names that match one of its patterns it passes that
              information on for text search, using an eventing interface.
            </li>
            <li>
              <strong>TextSearch</strong> opens each file it&apos;s given and searches for the specified text. 
              It then passes that information on for display.
            </li>
            <li>
              <strong>Display</strong> is interesting.  What it needs to do is very application specific, 
              as indicated in the Textfinder Concept.  Since TextFinder executive configures TextSearch with
              a reference to its display, the application can provide several display types, one of
              which is instantiated based on user input.
            </li>
          </ul>
          Now, we have a clear picture of what needs to be implemented and what structure to use.  Next, we
          need to describe what we are going to deliver.
        </t-b>
      </div>
      <h3>4.0 TextFinder Specification:</h3>
      <dir class="indent">
        <t-b>
          A specification should be as brief as practical while still being complete and unambiguous.  We are
          electing to make display quite simple, but the architecture leaves open the possibility of easily
          replacing that with alternate display processing in a later version.
        </t-b>
        <t-b>
          <ol class="tight">
            <li>
              Identify all files in a directory subtree that match one or more patterns and contain a specified text.
            </li>
            <li>
              Specify root path, one or more file patterns (.h, .cpp, .cs, .rs, ...), and search text on command line.
            </li>
            <li>
              Specify options <c-s>/s [true|false]</c-s>, <c-s>/v [true|false]</c-s>, <c-s>/H [true|false]</c-s>
              <c-s>/h [true|false]</c-s> for recursive directory walk, verbose output header, Hidden dirs with no match,
              and help message, respectively.
            </li>
            <li>
              Display file name and path, without duplication of path name, e.g., organized by directory, for files
              containing the search text.
            </li>
            <li>
              Interesting extensions, not required for this implementation:
              <ul class="tight" style="margin-left:0.85rem;">
                <li>
                  Replace text by regular expressions for both search text and file patterns.
                </li>
                <li>
                  Replace sequential file searches with parallel searches to improve performance and useability.
                </li>
              </ul>
            </li>
          </ol>
          At this point, we can begin developing code, focusing on generating specified processing with user-defined
          types and their methods.  We know how data will flow, which makes it relatively simple to build test mocks
          for functionality not yet in place.
        </t-b>
      </dir>
      <h3>5.0 Implementation</h3>
      <div class="indent">
        <t-b>
          Implementation is all about details.  Every single line of code for every package matters. Once an
          architecture is defined, each package can be built in near isolation from the others until we tie
          everything together near the end. So that makes it much easier to handle this level of detail.
        </t-b>
         <div style="width:calc(100vw - 9rem);">
            <div class="right clear">
              <photosizer-block src="pictures/TextFinderClassDiagram2.jpg" width="600" class="photoSizerBlock" style="margin-top:0;">
                <span style="
                  display: inline-block;
                  font-weight: bold;
                  font-family: 'Comic Sans MS, Tahoma';
                  background-color: #ddd;
                  width: 100%;
                  padding: 5px 0px;
                ">
                  Figure 3. TextFinder Types
                </span>
              </photosizer-block>
            </div>
          </div>
          <t-b>
            The implementation process often starts with a single package, populating that with types and functions.
            Since we will be using Rust, we won&apos;t use the term class as it builds user-defined types with
            structs.
          </t-b>
          <t-b>
            Each package will have a primary type, as shown in Figure 3.  The types DirEvent and SearchEvent are
            traits, used to support communication, as described below.
            <t-b>
              <ul class="tight">
                <li>
                  <strong><c-s>Executive</c-s></strong> type is defined in the TextFinder package.  It creates an instance
                  of <c-s>DirNav&lt;Finder&gt;</c-s> and configures its internal <c-s>Finder</c-s> instance with a reference 
                  to an instance of <c-s>GenOut</c-s>.  This generates a data flow pipe-line which dominates TextFinder processing.
                </li>
                <li>
                  <strong><c-s>DirNav&lt;Finder&gt;</c-s></strong> in its constructor creates an instance of 
                  <c-s>Finder</c-s> using a
                  factory function specified in the DirEvent trait and implemented by Finder.  It exposes a 
                  public method <c-s>get_app(&mut self) -> &mut App</c-s>.  The App type is a generic parameter
                  which Executive supplied by constructing <c-s>DirNav&lt;Finder&gt;</c-s>.  That is called
                  by <c-s>Executive</c-s> to configure the <c-s>Finder</c-s> app with an instance of GenOut.
                </li>
                <li>
                  <strong><c-s>TextSearch</c-s></strong>
                </li>
              </ul>
            </t-b>
            
          </t-b>
        </div>
        <h4>1.2 - Specification</h4>
        <h4>1.3 - Tasks</h4>
        <h4>1.4 - Structure</h4>
        <h4>1.5 - Reuse</h4>
        <h4>1.5 - Flexibility</h4>
        <t-b>
          Abstractions are simpified representations of complex entities, things that are composed of many detailed parts and processing.
        </t-b>
        <t-b>
          Large software systems may be composed of hundreds of thousands, even millions, of lines of source code.  Much more than any
          developer can understand completely.  In order to use and maintain these systems a developer needs to have some way of
          understanding their properties and expected operations.
        </t-b>
        <t-b>
          Most often we factor systems into components that are small enough to be well understood and visualize the complete system
          as couplings of these smaller components.  Often the components themselves may be decomposed into fundamental parts.
        </t-b>
        <t-b>
          An abstraction consists of a set of components with specified responsibilities and usually one or more diagrams That
          illustrate ownership and usage relationships between components.
        </t-b>
      </div> 
    </div>
    <h3>2. RustComm Abstraction</h3>
<!--         <div class="indent">-->
      <t-b>
        We will use code from the <a href="../../RustComm.html">RustComm</a> repository as an Example for this discussion.
        RustComm is a message-passing communication system based on Tcp Sockets provided by the Rust std::net library.
      </t-b>
      <t-b>
        Figure 1. is a Universal Modeling Language (UML) class diagram that displays the most important types and traits used
        in the RustComm implementation.  The main players are <c-s>Connector&lt;M,P,L&gt;</c-s> and
        <c-s>Listener&lt;P,L&gt;</c-s>.
      </t-b>
      <t-b>
        <c-s>Listener&lt;P,L&gt;</c-s> listens for incoming connection requests, extablishes a connection, and processes
        received messages, returning a reply for each. P is a generic parameter representing one of a set of processing types that
        determine what the listener does with incoming messages, and how it replies. L is a generic parameter representing one of a
        set of loggers used to capture processing events.
      </t-b>
      <t-b>
        <c-s>Connector&lt;M,P,L&gt;</c-s> attempts to establish connections with a listener at a specified endpoint, ipaddress:port.
        If a connection is established it then sends messages and receives replies.  The generic arguments M, P, and L represent sets
        of message, processing, and logging types.  Each of them are constrained by traits, some of which are shown in Fig. 1.
      </t-b>
      <t-b>
        The traits <c-s>Msg</c-s>, <c-s>Sndr&lt;&gt;</c-s>, <c-s>Rcvr&lt;&gt;</c-s>, <c-s>Process&lt;M&gt;</c-s> and <c-s>Logger</c-s>
        each define method signatures that types with those
        traits are obligated to implement.  Traits say nothing about the implementation of those methods, so each trait establishes a
        bound on the types that the library uses.
        <div>
          <ul>
            <li>
              <c-s>Msg</c-s> defines methods that messages provide for managing their contents.  The <c-s>Msg</c-s> trait was designed to support more than
              one style of message.  RustComm uses fixed header size messages, but <c-s>Msg</c-s> supports other types as well.
            </li>
            <li>
              <c-s>Sndr&lt;M&gt;</c-s> and <c-s>Rcvr&lt;M&gt;</c-s> define method signatures for sending and receiving messages.  They are parameterized on
              a Message type <c-s>M</c-s>, so they can be tailored to the type of messages a library defines.
            </li>
            <li>
              <c-s>Process&lt;M&gt;</c-s> declares methods for processing messages.  Both <c-s>Connector&lt;M,P,L&gt;</c-s> and
              <c-s>Listener&lt;P,L&gt;</c-s> have process members which are different, but satisfy the same trait bounds.
            </li>
            <li>
              <c-s>Logger</c-s> defines method signatures for writing to log streams in the console or files.
            </li>
            <li>
              The generic parameters: <c-s>M</c-s>, <c-s>P</c-s>, and <c-s>L</c-s> are also bound by some of Rust&apos;s std traits,
              e.g., <c-s>Debug</c-s>, <c-s>Clone</c-s>, <c-s>Send</c-s>, <c-s>Sync</c-s>, and in some cases <c-s>Copy</c-s>, and <c-s>'static</c-s>.
            </li>
          </ul>
        </div>
      </t-b>
      <t-b>
        <c-s>Connector&lt;M,P,L&gt;</c-s> and <c-s>Listener&lt;P,L&gt;</c-s> use the <c-s>TcpStream</c-s> and <c-s>TcpListener</c-s> types to
        provide socet-based Tcp messaging infrastructure.
      </t-b>
      <t-b>
        Each of the four layers shown in Fig 1. have a specific role to play in RustComm&apos;s implementation:
        <div>
          <ul>
            <li>
              The top, traits, layer provides component interfaces that are implementation agnostic.  That means that
              <c-s>Connector&lt;M,P,L&gt;</c-s> and <c-s>Listener&lt;P,L&gt;</c-s> can easily adopt different messaging and message-passing
              designs without a lot of breakage, because most of their code uses the trait interfaces.
            </li>
            <li>
              The second, generic parameter layer, supports compile-time substitution of specialized components that tailor RustComm behaviors
              to meet the needs of a specific design.
            </li>
            <li>
              The third, custom type layer, holds the connector and listener user-defined types.  They provide the framework that supports and
              uses the first two layers.  It is this layer that using code works with to build communicating processes.
            </li>
            <li>
              The bottom, std libary component, layer provides all of the low level system processing, greatly simplifying implementation
              of listener and connector.
            </li>
          </ul>
        </div>
      </t-b>
      <t-b>
        You can access all of the code for RustComm in this <a href="https://github.com/JimFawcett/RustComm">Repository</a>.
      </t-b>
    </div>      
    <h3>3. Epilogue</h3>
    <div class="indent">
      <t-b>
        The combination of traits and generic types provides a powerful environment for building flexible systems that can adapt to
        changing requirements and be used to explore new design ideas.  Adding selections from the well crafted Rust std libraries can lead
        to designs that are easy to use, understand and maintain, and modify for new uses.  Highly recommended.
      </t-b>
    </div>  </body>
</html>
