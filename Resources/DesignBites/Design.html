<!DOCTYPE html>
<html>
<!--
  BasicBites_Intro.html
-->
<head>
  <title>Basics Design</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeDefault.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesDesignTrack.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <style>
    #github table {
      width: 90%;
      border: 1px solid black;
    }

      #github table tr {
        border: 1px solid var(--dark);
      }

        #github table tr th {
          color: var(--dark);
          background-color: var(--menu);
        }

        #github table tr td {
          color: var(--dark);
          background-color: var(--light);
        }

      #github table a:link {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:visited {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:hover {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:active {
        color: var(--dark);
        background-color: transparent;
      }
  </style>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="DesignBites_Structure.html">Next</a>
  <a id="Prev" href="DesignBites_Intro.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="modified">3/05/2022</div>
      <div id="page">Design</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <header id="pagetitle">
          <h1>Design Bite - Design and Documentation</h1>
          <h3 id="subtitle" class="indent">Concept, Design, Evolution, Document</h3>
        </header>

        <t-b class="mbz" style="padding:5px 25px;">
          "There are two ways of constructing a software design; one way is to make it so simple that there
          are obviously no deficiences, and the other way is to make it so complicated that there are no
          obvious deficiencies. The first method is far more difficult."
          <br />
          - C.A.R.Hoare
        </t-b>
        <hr style="margin:1em 0em 1.5em 0em;" />

        <a id="prologue"></a>
        <h3>Prologue:</h3>
        <indent-blocks>
          <t-b style="margin-top:0px;">
            Definitions for design from <a href="https://www.merriam-webster.com/dictionary/design">Merriam-Webster</a>:
            <ul class="tight pad5">
              <li>.. scheme in which means to an end are laid down</li>
              <li>.. outline showing the main features of something to be executed</li>
              <li>a plan or protocol for carrying out or accomplishing something ..</li>
            </ul>
          </t-b>
          <t-b>
            I often work on designs early in the morning, coffee cup in hand - scribbling notes and diagrams on
            sheets of paper, many, at first, get crumpled and thrown away, but soon there&apos;s a small stack of papers,
            perhaps five or six, convincing that the project is sensible, do-able, and has a clear starting point.
          </t-b>
          <t-b>
            Implementing code is a consuming mental task.  We think about the context, semantics, and syntax of each
            line of code we write.  That doesn&apos;t leave too many mental cycles for building a well structured
            program that is quick, robust, elegant, and easy to use.
          </t-b>
          <t-b>
            That&apos;s why project design begins before coding, perhaps at the start of coding sprints, and finally as
            a post-mortem process to get documentation user-ready.
          </t-b>
        </indent-blocks>
        <a id="concept"></a>
        <h3>Program Design Concept:</h3>
        <indent-blocks>
          <t-b style="margin-top:0px;">
            <a href="../../BlogOCD.html">Concept</a> is the starting point for design.  Concept development may precede creation
            of a specification governing program build.  It focuses on users and uses, program structure,
            and issues.
          </t-b>
          <indent-block>
            <t-b>
              <strong>Users and uses</strong> considers who the users are and what they need from the program.  Exploring this thoughtfully
              could make the difference between a satisfactory outcome and creation of &quot;shelfware&quot; that no one
              wants to use. These considerations help to specify program operations.
            </t-b>
            <t-b>
              <strong>Structure</strong> deals with what top level parts are needed to build the program, or system
              of programs.  This doesn&apos;t get into a lot
              of detail, but should identify top-level parts, processing phases, and data flow.
            </t-b>
            <t-b>
              <strong>Issues</strong> lay out all the things we can think of that may affect program function or ease of
              construction, use, and maintenance.
            </t-b>
          </indent-block>
        </indent-blocks>
        <a id="design"></a>
        <h3>Design:</h3>
        <indent-blocks>
          <t-b style="margin-top:0px;">
            The purpose of design is to think about structure and process strategies before diving into coding.
            We want our designs to:
            <ul class="tight pad5">
              <li>
                Explain, in brief, unambiguous, and relatively complete fashion, the project goals, structure,
                processing concepts, and delivered information.
              </li>
              <li>
                Extract away all of the details of platform and language so that our ideas take precedence.
              </li>
              <li>
                Be small and simple enough that team members will acturally read the document.
              </li>
            </ul>
          </t-b>
          <t-b>
            Try to implement the
            <a href="https://en.wikipedia.org/wiki/Goldilocks_principle">&quot;Goldilocks principle&quot;</a> - not to much,
            not to little, just enough to guide your implementation.
          </t-b>
          <t-b>
            It is important that the description of a design be pragmatic and concrete. No vague statements like &quot;optimum&quot;
            or &quot;user-friendly&quot; Those words provide almost no guidance for an implementation.  Prefer statements like
            &quot;program options are supplied with named command line arguments of the form &apos;/P .&apos; to specify that
            a search path is to start at the current working directory&quot;.
          </t-b>
        </indent-blocks>
        <a id="dsgnevol"></a>
        <h3>Design Evolution:</h3>
        <indent-blocks>
          <t-b style="margin-top:0px;">
            None of us has perfect foresight.  It is not uncommon that a good design evolves a bit as it is implemented.
            We think of better ways to process some data or decide that the structure needs refactoring to add a part or
            two that will handle some processing that turned out to be more complex than expected.
          </t-b>
          <t-b>
            Evolutionary development is a powerful way to be effective, both for individuals and teams.  The agile movement
            has shown how well that can work - if applied with some wisdom.
          </t-b>
          <t-b>
            That means that design will happen repeatedly, once for each evolutionary step.  When used in this enviroment,
            each design phase is relatively small, focused, and results in brief documents. Each phase will probably build
            on the document from the preceding phase.  This reuse has the same benefits as code reuse.
          </t-b>
          <t-b>
            The evolutionary process is a good way to manage this extension of design.
          </t-b>
        </indent-blocks>
        <a id="document"></a>
        <h3>Design of a Software Design Document:</h3>
        <indent-blocks>
          <t-b style="margin-top:0px;">
            A design document <strong>represents</strong> a program design, providing:
            <ol>
              <li>
                A brief specification, if one doesn&apos;t already exist. Ideally:
                <ul class="tight">
                  <li>
                    One or two line statement of what the program does
                  </li>
                  <li>
                    Pre-conditions: the program&apos;s environment and inputs
                  </li>
                  <li>
                    Post-condtions: a list of things it must provide
                  </li>
                  <li>
                    Non-functional requirements: platform, programming language, ...
                  </li>
                </ul>
              </li>
              <li>
                Use: how will users interact with the program: what inputs do they supply, how do they interpret program
                results - the program is, after all, going to supply information, not raw data - right?
              </li>
              <li>
                A list of tasks the program must execute, more or less in the order they occur during operation.
                Each task becomes a candidate part in the program&apos;s structure.  Some will become parts, some may not.
              </li>
              <li>
                A structure consisting of a network of named parts, where each part has a stated responsibility. Parts might
                be functions, or classes, or packages.
              </li>
              <li>
                One or more diagrams showing structural relationships, e.g., a call stack diagram, or class diagram,
                or package diagram, or some combination.
              </li>
              <li>
                A description of the major processing parts.  If you help your friend work on her motorcycle you might
                describe in words and a diagram how to clean and adjust the bike&apos;s carburetor.  You do the same
                thing here, perhaps briefly describing a directory tree traversal or messaging process.  Pseudo-code may
                work well for this.
              </li>
              <li>
                A description of error handling.  What errors may occur? How will they be handled?
              </li>
              <li>
                Testing description: test name, description, procedure.
              </li>
              <li>
                Thoughts about future expansions, not implemented, but which may be in future versions.  That could lead us
                in a design direction that we would not otherwise follow.
              </li>
              <li>
                Very brief outline of a prototype developed to verify feasibility of one or more operations.
              </li>
            </ol>
          </t-b>
          <t-b>
            What do you mean <strong>small and simple</strong>!  There&apos;s a lot of steps here.  Look&apos;s like
            Goldilocks slept in today.
          </t-b>
          <t-b>
            Robin Mathew said "Design is where science and art break even". Here is where the art comes in.  Speaking
            and writing in clear, simple, brief statements. If in doubt, throw it out!
          </t-b>
          <t-b>
            If a project is small - perhaps a week&apos;s work, then a small design is appropriate; just enough to
            think about processing and use.  Some of the steps, above, would be unnecessary.  Big projects with
            several developers working for a month or more will likely address each of the steps described here.
          </t-b>
          <t-b style="padding:0em 1em; margin:1em 0em;">
            &quot;Put it before them briefly so they will read it, clearly so they will appreciate it, picturesquely
            so they will remember it and, above all, accurately so they will be guided by its light.&quot;<br />
            - Joseph Pulitzer, Editor
          </t-b>
        </indent-blocks>
        <a id="why"></a>
        <h3>Why Write one:</h3>
        <indent-blocks>
          <t-b style="margin-top:0px;">
            Should you write a design document for every project you build. No! If the project is relatively small, in
            a domain in your comfort zone, and similar to things you&apos;ve built before, writing a design document is
            probably a waste of time.
          </t-b>
          <t-b>
            Write a document when:
            <ul>
              <li>
                The project is relatively large or has some complex processing.  Write a document to help you think
                through processing and communication.  When the implementation is complete, the document will live
                on as a maintenance manual.
              </li>
              <li>
                The project has more than one developer.  You need to name parts, specify interfaces, data flow, and
                test processes so that work can be partitioned for the team, everyone knows their obligations, and
                the means of communication are clear.
              </li>
              <li>
                User interactions with the program are complex or unspecified.  You need to define the user interactions,
                think about how to make them as simple and intuitive as practical, and partition program parts to allow
                changes to input and output processing without major surgery to the other parts. The document will live
                on, after program completion, as a user&apos;s manual. Here&apos;s a user manual for this
                <a href="../../SiteDemo.html">site</a>, a quite complex design.
              </li>
            </ul>
          </t-b>
          <t-b>
            Remember: a design document is not some large ediface.  It should be small, clear, and readable. Documents
            for your own use might be two or three sheets of paper.  For sharing with others, the document may need more
            than that, but keep it short and simple - the KISS principle.
          </t-b>
        </indent-blocks>
        <a id="build"></a>
        <h3>Building a Design:</h3>
        <indent-blocks>
          <t-b style="margin-top:0px;">
            You might scribble ideas on a few pieces of paper, then build your design by writing a design document, thinking
            and creating as you go.
          </t-b>
          <t-b>
            One of the best ways to think clearly about some complex topic is to try to write about it.  Expository
            writing is very similar to developing code.  You start with an idea, then describe it, bound by the
            syntax, context and conventions of your topic.  Essentially writing is coding ideas rather than functions
            and classes.  Same issues of connections, process, and structure.
          </t-b>
          <t-b>
            Sometimes I have written design documentation after the implementation is complete - providing information for
            others.  I&apos;ve often regretted not working through the design process first. I&apos;ve found
            things I wish I had done differently. Sometimes I am quite dissatisfied with the code structure or its
            processing mechanisms or its user interface. While that post-mortem is useful, it is also dissapointing to find
            that you could have built so much better.
          </t-b>
          <t-b>
            Implementation may start as part of this process.  As packages are identified you can create a package
            file and state its requirements in its opening comments.
          </t-b>
          <t-b>
            For projects with multiple contributors you might think about building your concept, specification, and
            design documents as web pages, perhaps using markdown. That makes collaboration effective at this
            early phase of development. That was done for TextFinder in the <a href="../BuildOn/Step0.html">BuildOn</a>
            project.
          </t-b>
        </indent-blocks>
        <a id="present"></a>
        <h3>Presenting Designs:</h3>
        <indent-blocks>
          <t-b style="margin-top:0px;">
            Let&apos;s assume you present using slides.  Allow 2 minutes per slide (that is optimistic).  So a ten minute
            presentation means you will have 5 slides including your opening and closing slides.
          </t-b>
          <t-b>
            Clearly you have to cherry-pick the design document, selecting small pieces of of each design topic as
            representative of your design.  You may have to eliminate some of the design topics altogether.  Keep those
            with the most impact for your audience.
          </t-b>
          <t-b>
            Be very careful to stick to the script.  Don&apos;t ramble, use one strong statement per topic with perhaps
            a very few words of elaboration.
          </t-b>
          <t-b>
            Finally, talk to the audience - don&apos;t read your slides.  The slides are there for your audience and to keep you
            on track.  Remember, you know more about your presentation topic than the audience.
          </t-b>
        </indent-blocks>
        <h3>Epilogue:</h3>
        <indent-blocks>
          <t-b style="margin-top:0px;">
            We want to make our programs elegant and simple, make their intents clear, and make them quick and reliable.
            That is most likely to happen if we think first about design.
          </t-b>
        </indent-blocks>
        <spacer-15></spacer-15>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <sec-elem style="width:0.0em">&nbsp;</sec-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#present">present</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">build</a></menu-elem>
        <menu-elem class="secElem"><a href="#why">why?</a></menu-elem>
        <menu-elem class="secElem"><a href="#document">document</a></menu-elem>
        <menu-elem class="secElem"><a href="#dsgnevol">dsgnevol</a></menu-elem>
        <menu-elem class="secElem"><a href="#design">design</a></menu-elem>
        <menu-elem class="secElem"><a href="#concept">concept</a></menu-elem>
        <menu-elem class="secElem"><a href="#prologue">prologue</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <!--<menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.decrZoomScreen()">Zout</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.normZoomScreen()">Zdef</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.incrZoomScreen()">Zin</menu-elem>-->
    </frame-footer>
  </page-frame>
</body>
</html>