<!DOCTYPE html>
<!--
  TestGrid2.html
  -------------
  This page is a prototype for pages that provide:
  - Header block at the top
  - page menu in the left panel
  - content in the right panel
  - content section links in a footer block
  Its design uses:
  - CSS grid to lay out the page in three rows, header, main, footer
  - The grid is fixed to the viewport using margins and height attributes
  - flex grid in the main row to hold the page menu and content panels
  - flex grid in the footer holding a toggle button and section links
  - JavaScript to respond to the toggle button by:
    a. Setting the menu panel display to none or block which toggles
       its visibility and space
    b. Setting the right area in the footer to a menu of section links
       or a copyright notice.
  This is a test prototype for story pages.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BuildOn Step#1 - TS</title>
  <link rel="stylesheet" href="css/Styles_Basic.css" />
  <link rel="stylesheet" href="css/Styles_Structure.css" />
  <link rel="stylesheet" href="css/Styles_RustTheme.css" />
  <link rel="stylesheet" href="css/Styles_StoryPagesGrid.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/Scripts_StoryPageMenu.js"></script>
</head>
<body id="github" onload="init()">
  <grid-container>
    <grid-header class="dark" onclick="togglemenus()">
       <h2 class="dark">BuildOn -  Step #1: TextSearch Pkg</h2>
     </grid-header>
     <grid-main>
       <a href="#top"></a>
       <main-wrapper>
         <main-left id="nav" class="light">
           <ul>
            <li><a href="../../index.html">Home</a></li>
            <li><a href="../../BuildOn.html">Repo</a></li>
            <li><a href="Intro.html">Introduction</a>&nbsp;&nbsp;</li>
            <li><a href="Step0.html">Step&nbsp;#0&nbsp;-&nbsp;TF</a>&nbsp;&nbsp;</li>
            <li><a href="Step1.html">Step&nbsp;#1&nbsp;-&nbsp;TS</a>&nbsp;&nbsp;</li>
            <li><a href="Step2.html">Step&nbsp;#2&nbsp;-&nbsp;DN</a>&nbsp;&nbsp;</li>
            <li class="undefined"><a href="JavaScript:;">Step&nbsp;#3&nbsp;-&nbsp;CP</a>&nbsp;&nbsp;</li>
            <li class="undefined"><a href="JavaScript:;">Step&nbsp;#4&nbsp;-&nbsp;Exc</a>&nbsp;&nbsp;</li>
            <li class="undefined"><a href="JavaScript:;">Step&nbsp;#5&nbsp;-&nbsp;REx</a>&nbsp;&nbsp;</li>
            <li class="undefined"><a href="JavaScript:;">Step&nbsp;#6&nbsp;-&nbsp;Par</a>&nbsp;&nbsp;</li>
            <li><a href="../../IndexPage.html">Glossary</a>&nbsp;&nbsp;</li>
            <li><a href="../../RustStory_References.html">References</a>&nbsp;&nbsp;</li>
            <li><a href="../../RustStory_Prologue.html">Rust Story</a>&nbsp;&nbsp;</li>
           </ul>
         </main-left>
         <main-right id="content" class="light">
         <!--<a id="buildon" name="buildon"></a>
        <h3>BuildOn</h3>
        <t-b>
          BuildOn is a process for learning Rust programming by writing code.  You need to have
          some skill in a modern programming language, but need have no past experience with Rust. The
          process takes you through a series of steps building interesting, not too complex,
          projects.
        </t-b>
        <t-b>
          Each step will start with a remote presentation that:
          <ol>
            <li>
              Looks at my implementation of the previous step&apos;s code, usually a single package.
            </li>
            <li>
              Answers questions you may have about the implementation.  You can post questions, while working
              on your code, on a Discord server set up for that purpose.
            </li>
            <li>
              Presents the next step&apos;s specification.
            </li>
            <li>
              Discusses things you need to learn about Rust for that next step.
            </li>
            <li>
              Provides links to Rust reference materials here or, for question specific details, on the Discord Server.
            </li>
          </ol>
        </t-b>
        <t-b>
          Each succeeding step adds another package to the project.  Steps are organized so that you only
          need to learn a relatively small part of Rust to complete the current step.  Later steps get
          into progressively more language details.
        </t-b>
        <t-b>
          I plan to post a video of each remote session on YouTube with links to that in the Discord server
          and in these web pages.
        </t-b>
        <div style="height:0.25em;">&nbsp;</div>
        <hr class="spread" />
        <a id="rust"></a>
        <h3>Why Rust?</h3>
        <t-b>
          Rust is an interesting language, combining memory safety of C# and Java with
          performance of C++.  Unlike these languages, Rust also provides data race safety.
        </t-b>
        <t-b>
          Using modern idioms, one can build, with C++, memory safe programs without data
          races.  But when building large systems, with many thousands of lines of code, it is 
          easy to forget, in a few of those lines, to use an idiom or
          unintentionally share data between threads without proper locking.  
        </t-b>
        <t-b>
          Rust, however,
          ensures memory and data safety by construction.  Code with unsafe memory access and
          data races will fail to compile.  It accomplishes that with an intersting ownership model
          that we will explore in later steps in this BuildOn process.
        </t-b>
        <t-b>
          Table 1., below, provides a few references suitable for Rust beginners.  They all assume competence
          in some modern programming language, but not with Rust.  You will find references specific to the
          first BuildOn step in Table 2., further down this page.
        </t-b>
        <div style="height:0.15em;">&nbsp;</div>
        <h4>Table 1. - Beginning Rust References</h4>
        <div>
          <table style="width:100%;" class="lightItem">
            <tr>
              <th class="darkItem" style="width: 10em;">Topic</th>
              <th class="darkItem" style-"width: auto;">Description</th>
              <th class="darkItem" style="width: 15em;">Link</th>
            </tr>
            <tr>
              <td>Survey</td>
              <td>
                This blog post walks through most of Rust, explaining, with code fragments and short simple language,
                the core ideas.
              </td>
              <td>
                <a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half-hour to learn Rust</a><br />
              </td>
            </tr>
            <tr>
              <td>Survey</td>
              <td>
                This is an extensive github Readme.md file with table of contents and most of the ideas 
                expressed in simple language with lots of details.
              </td>
              <td>
                <a href="https://github.com/Dhghomon/easy_rust">easy-rust</a><br />
              </td>
            </tr>
            <tr>
              <td>Syntax</td>
              <td>
                This is is a github Gist that presents much of the Rust syntax without much drill-down.
                This is a good starting place, but you will find, as you learn Rust, that a lot is missing
                here.  But starting out, that is probably a good thing.  Almost all the missing details you can
                find in the previous easy-rust link.
              </td>
              <td>
                <a href="https://gist.github.com/brson/9dec4195a88066fa42e6">syntax guide</a><br />
              </td>
            </tr>
            <tr>
              <td>Language Cheat Sheet</td>
              <td>
                This is a very condensed illustration of almost all of the Rust ideas - little tiny statements,
                code fragments, and a lot of diagrams if you scroll down far enough.
              </td>
              <td>
                <a href="https://cheats.rs">Rust Lanaguage Cheat Sheet</a><br />
              </td>
            </tr>
            <tr>
              <td>Rust Story</td>
              <td>
                A narrative walk through of the Rust Language, provide by this site.
              </td>
              <td>
                <a href="../../RustStory_Prologue.html">Rust Story</a><br />
              </td>
            </tr>
            <tr>
              <td>Rust Bite by Byte</td>
              <td>
                A sequence of small bites from the Rust language with examples.
              </td>
              <td>
                <a href="../../RustBiteByByte.html#bites">Rust Bites</a><br />
              </td>
            </tr>
          </table>
        </div>
        <t-b>
          The first three references are the first things to look at.  The next three you might
          skim over, just to see what is there, and come back later for details as you need them.
        </t-b>-->
        <!--
          placeholder for list of companies using Rust  
        -->
        <!--<div style="height:1.0em;">&nbsp;</div>
        <hr class="spread" />-->
        <!--<a id="textfinder"></a>
        <h3>BuildOn Project - TextFinder</h3>
        <div style="float:right;">
          <photosizer-block 
            src="pictures/TextFinderPackages.jpg" 
            width="300" class="photoSizerBlock left"
            style="background-color: #fefefa;"  
          >
            <span style="font-family:'Comic Sans MS';">Figure 1. TextFinder Packages</span>
          </photosizer-block>
        </div>
       <t-b>
          The first BuildOn project, TextFinder, is described here.  After that we will layout the
          first step for this BuildOn.
        </t-b>
        <t-b>
          Figure 1. shows a package diagram for our first project with five packages.  If you look through
          the repositories in this site you will find a 
          <a href="../../RustTextFinder.html">RustTextFinder repository</a> that is similar, 
          but not identical, to this first project.
        </t-b>
        <t-b>
          The idea is that you can use as much of that project as you like, but will write additional code 
          to meet our specifications.  This project has slightly different structure and different
          specification for each part.
        </t-b>
        <t-b>
          TextFinder is a program that accepts from its command line a path, a set of file patterns,
          a text specifier, and zero or more options.  It returns the path and name of each file that
          contains text matching the specifier.
        </t-b>
        <t-b>
          The TextFinder program is small enough to be relatively easy to understand, but rich enough
          to use a lot of the most important features of Rust.  The first four steps will build:
          TextSearch, DirNav, CmdlnParser, and Executive and Display packages.
          That is enough to build a fully function and useful tool.
        </t-b>
        <t-b>
          To that, we will add extensions for processing regular expressions for representing text to 
          match and file patterns.  Finally we build code that supports
          parallel execution of text searches.
        </t-b>
        <indent-block>
        <h4>TextFinder Specification:</h4>
        <t-b>
          <ol class="tight">
            <li>
              Identify all files in a directory subtree that match a pattern and contain a specified text.
            </li>
            <li>
              Specify root path, one or more file patterns (.h, .cpp, .cs, .rs, ...), and search text on command line.
            </li>
            <li>
              Specify options <c-s>/s [true|false]</c-s>, <c-s>/v [true|false]</c-s>, <c-s>/H [true|false]</c-s>
              <c-s>/h [true|false]</c-s> for recursive directory walk, verbose output header, Hidden dirs with no match,
              and help message, respectively.
            </li>
            <li>
              Display file name and path, withou duplication of path name, e.g., organized by directory, for files
              containing the search text.
            </li>
            <li>
              Interesting externsions:
              <ul class="tight" style="margin-left:0.85rem;">
                <li>
                  Replace text by regular expressions for both search text and file patterns.
                </li>
                <li>
                  Replace sequential file searches with parallel searches to improve performance and useability.
                </li>
              </ul>
            </li>
          </ol>
        </t-b>
        </indent-block>
        <t-b>
          TextFinder structure is shown in the package diagram, Fig. 1.  The Executive uses
          CmdlnParser to extract parameters and options from the commandline.  Executive then
          creates instances of DirNav and TextSearch, passing a reference to TextSearch to DirNav,
          allowing DirNav to call TextSearch each time it finds a file of the specified patterns.
        </t-b>-->
        <!--<div style="height:0.15em;">&nbsp;</div>
        <hr class="spread" />-->
         <h3>BuildOn Project - TextSearch Package</h3>
        <div style="float:right;">
          <photosizer-block 
            src="pictures/TextFinderPackages.jpg" 
            width="300" class="photoSizerBlock left"
            style="background-color: #fefefa;"  
          >
            <span style="font-family:'Comic Sans MS';">Figure 1. TextFinder Packages</span>
          </photosizer-block>
        </div>
       <t-b>
         TextSearch is a package in the first BuildOn project, TextFinder.  Figure 1 is a package diagram for
         Textfinder, discussed in Step #0.
        </t-b>
        <indent-block>
        <h4>TextFinder Specification:</h4>
        <t-b>
          <ol class="tight">
            <li>
              Identify all files in a directory subtree that match a pattern and contain a specified text.
            </li>
            <li>
              Specify root path, one or more file patterns (.h, .cpp, .cs, .rs, ...), and search text on command line.
            </li>
            <li>
              Specify options <c-s>/s [true|false]</c-s>, <c-s>/v [true|false]</c-s>, <c-s>/H [true|false]</c-s>
              <c-s>/h [true|false]</c-s> for recursive directory walk, verbose output header, Hidden dirs with no match,
              and help message, respectively.
            </li>
            <li>
              Display file name and path, withou duplication of path name, e.g., organized by directory, for files
              containing the search text.
            </li>
            <li>
              Interesting externsions:
              <ul class="tight" style="margin-left:0.85rem;">
                <li>
                  Replace text by regular expressions for both search text and file patterns.
                </li>
                <li>
                  Replace sequential file searches with parallel searches to improve performance and useability.
                </li>
              </ul>
            </li>
          </ol>
        </t-b>
        </indent-block>
       <a id="step1"></a>
        <div style="height:0.5rem;"></div>
        <h3>Step #1 - Build TextSearch Package</h3>
        <t-b>
          TextSearch seeks specified text and if found sends the path and file name to
          Display.  The Display package turns the sequence of successful search completion events
          into useful user information.
        </t-b>
        <t-b>
          In this step we will create the TextSearch package.  It:
          <ol>
            <li>
              Accepts a file name and search text in a find method.
            </li>
            <li>
              Attempts to open the file.
            </li>
            <li>
              If successful, searches the file for the specified text.
            </li>
            <li>
              Sends a tuple of file name and boolean to the display package where
              the boolean value is true if specified text was found in the file, otherwise false.
            </li>
          </ol>
        </t-b>
        <h4>Notes:</h4>
        <t-b>
          <ol>
            <li>
              Returning the boolean along with file name supports displaying files with the search text 
              or files without the text.
              We might wish to use the later option to find files that do not provide comment
              prologues, for example.
            </li>
            <li>
              TextSearch package will create an instance of Display and send its events directly instead
              of passing its results back to Executive to forward.
            </li>
            <li>
              In a later step, after looking at generics, we will show how this structure can allow the
              TextFinder program to be quite flexible in how its display processing is effected.
            </li>
          </ol>
        </t-b>
        <t-b>
          TextSearch package defines a struct <c-s>Finder</c-s> that provides the method:
          <indent-block class="code">fn find(&mut self, flnm: &str, stxt: &str)</indent-block>
          It also defines a struct <c-s>Display</c-s> that provides a method:
          <indent-block class="code">fn accept(&mut self, r:(String, bool))</indent-block>
        </t-b>
        <div style="height:0.15em;">&nbsp;</div>
        <hr class="spread" />
        <a id="tooling"></a>
        <h3>Tooling</h3>
        <t-b>
          The Rust ecosystem has some very well designed tools that allow you to create, build, and execute
          code on Windows 10, Linux, and macOS.
        </t-b>
        <t-b>
          Rust comes with a tool called cargo that creates new packages for either executables or libraries.  
          It creates a metadata file called Cargo.toml that describes the package (Rust community calles them crates)
          and provides a section for describing dependencies.
        </t-b>
        <details>
          <summary>Cargo Commands</summary>
          <indent-block style="border:1px solid #5c2107; padding: 0em 1.0em; width:max-content;">
            <t-b>
              Create a package with the command:
              <indent-block class="code">cargo new pkgFolder [--lib | --bin] [--n pkgname]</indent-block>
              This creates a folder pkgFolder, builds metadata for package pkgname.  It also creates
              a /src directory that holds either lib.rs or main.rs.
            </t-b>
            <hr />
            <t-b>
              After building a package with the command:
              <indent-block class="code">cargo run [arg1, ...]</indent-block>
              cargo invokes the executable it built with rustc, passing command line arguments, if any, to the
              executable.
            </t-b>
            <hr />
            <t-b>
              Get cargo help with the commands:
              <c-s>cargo --help</c-s>
              or
              <c-s>cargo cmd --help</c-s>.
              You can also find more details here: 
              <a href="https://doc.rust-lang.org/cargo/">Cargo Book</a>.
            </t-b>
          </indent-block>
        </details>
        <t-b>
          Rust does not come with an Integrated Development Environment (IDE), but you will find the
          Visual Studio Code editor, aka VSCode, to be effective; and it works on all three platforms, 
          Win, Lin, and Mac.
        </t-b>
        <t-b>
          For more details check out this: <a href="../IdiomsAndPatterns/Tooling.html">Tooling</a> page.
        </t-b>
        <div style="height:0.15em;">&nbsp;</div>
        <hr class="spread" />
        <a id="refs"></a>
        <h3>Step #1 References</h3>
        <t-b>
          The table below provides references relevant for Step #1 : TextSearch.  The first links refer to specific
          regions of the Rust Story, from this site.  Other links go to Rust documentation. 
        </t-b>
        <t-b>
          You can look at the Rust Story
          by going to the Home page (Home link in the menu), clicking on the Stories menu item (at the top) and selecting
          the Rust Story link.
        </t-b>
        <div style="height:0.5rem;">&nbsp;</div>
        <h4>Table 2. - Step #1 References</h4>
        <div>
          <table style="width:100%;" class="lightItem">
            <tr>
              <th class="darkItem" style="width: 10em;">Topic</th>
              <th class="darkItem" style-"width: auto;">Description</th>
              <th class="darkItem" style="width: 15em;">Link</th>
            </tr>
            <tr>
              <td>Tooling</td>
              <td>
                The Rust environment comes with some great tools: cargo, clippy, doc.  You will want to
                add Visual Studio Code.
              </td>
              <td>
                <a href="../IdiomsAndPatterns/Tooling.html">Tooling</a><br />
                <a href="https://doc.rust-lang.org/cargo/">Cargo Book</a><br />
                <a href="https://code.visualstudio.com/">Visual Studio Code</a><br />
              </td>
            </tr>
            <tr>
              <td>Data Operations</td>
              <td>
                Rust data operations copy, move, and clone.  These operations combined with Rust&apos;s
                ownership rules (discussed next time) are the defining characteristics of the language.  
                They are responsible for Rust&apos;s data safety and performance.
              </td>
              <td>
                <a href="../RustBites/RustBites_Data.html">Data types, copy, and move</a><br />
                <a href="../../RustStory_Data.html">Rust Story Data</a><br />
                <a href="https://doc.rust-lang.org/beta/core/marker/trait.Copy.html">Trait Copy</a><br />
                <a href="https://doc.rust-lang.org/std/keyword.move.html">keyword move</a><br />
                <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Trait Clone</a><br />
              </td>
            </tr>
            <tr>
              <td>Strings</td>
              <td>
                Rust strings come in two flavors: <c-s>String</c-s> and <c-s>str</c-s>, representing
                string objects and literal strings.  Each contains utf-8 characters.
              </td>
              <td>
                <a href="../../RustStory_Data.html#strings">Rust Story Strings</a><br />
                <a href="https://doc.rust-lang.org/std/string/struct.String.html">std::String</a><br />
                <a href="https://doc.rust-lang.org/std/primitive.str.html">Primitive Type str</a>
              </td>
            </tr>
            <tr>
              <td>struct</td>
              <td>
                Rust structs serve the same role as classes do in C++ and C#.  Struct methods are
                defined inside impl StructName {} blocks.
              </td>
              <td>
                <a href="../../RustStory_Data.html#structs">Rust Story structs</a><br />
                <a href="https://doc.rust-lang.org/std/keyword.struct.html">std::Stuct</a><br />
                <a href="https://doc.rust-lang.org/std/keyword.impl.html">keyword impl</a>
              </td>
            </tr>
            <tr>
              <td>File System</td>
              <td>
                Rust has a well engineered facility for accessing files and directories.<br />
                Some key types in std::fs are: DirEntry, File, OpenOptions, ReadDir, ...
              </td>
              <td>
                <a href="../../RustStory_Libraries.html#fs">Rust story File System</a><br />
                <a href="https://doc.rust-lang.org/std/fs/index.html">std::fs</a><br />
                &nbsp;
              </td>
            </tr>
          </table>
        </div>
        <div style="height:1.0em;">&nbsp;</div>
        <hr class="spread" />
        <a id="code"></a>
        <h3>Starter Code</h3>
        <t-b>
          This section contains a simple code example showing how to:
          <ol>
            <li>
              Define a struct with methods - similar in use to a C++ or C# class.
            </li>
            <li>
              Build a library that contains the struct and test its methods.
            </li>
            <li>
              Link the static library to a test console application and run that.
            </li>
          </ol>
        </t-b>
        <div style="height:0.75em">&nbsp;</div>
        <details>
          <summary class="dark" style="width:max-content;">Starter Code Example</summary>
        <two-column style="width:max-content;">
          <left-content class="code" style="font-size:0.9em;">/////////////////////////////////////////////////////////////
/// BuildOn::step_1::lib.rs
///
/// Jim Fawcett, https://JimFawcett.github.io, 23 Nov 2020 
/////////////////////////////////////////////////////////////
/// This demo illustrates how you define structs and use them
/// like you do classes in C++ and C#.
/// 
/// This package builds a static library.  There is a console
/// application, called test1 in the examples directory, sister
/// to the src directory where this file resides.
/// 
/// test1 uses this library by declaring:
///   uses step_1::*;
/// e.g., use any of the facilities provided by this library.
/// The name, step_1, is defined in Cargo.toml.
/// 
/// You build test1 and link to this library with cargo command:
///   cargo run --example test1
/// Note that option is example (singular) even though directory
/// name is examples.
///////////////////////////////////////////////////////
/// Rust Notes:
/// 1. Two string types are defined in the std library
///    a. String is a type that manages a collection of
///       utf-8 characters in the native heap.
///    b. str is a type that represents literal strings
///       stored in stack or static memory, e.g., fixed
///       size arrays of utf-8 characters.
///    c. str instances are almost always managed through
///       references, e.g., &str
///    d. It is easy to convert between String and str 
///       types - see code below.
/// https://github.com/Dhghomon/easy_rust#strings
/// 2. Rust uses Structs where C++ and C# use classes.
///    e. Methods are defined using impl blocks, as shown
///       below.
///    f. Associated methods, like new are not declared 
///       with a reference to self.  They act like C++
///       static methods.
///    g. All other methods are declared with a reference
///       to self, which may be mutable.  On invocation,
///       &self or &mut self is passed to the method code
///       implicitly, e.g., not supplied by the using
///       code. 

/// Debug, Clone, and Default are traits, much like Java 
/// or C# interfaces.
/// Some traits, like these can be implemented by the 
/// compiler.  The
/// #[derive(Debug, Clone, Default)] annotation is asking
/// the compiler to do that.
/// 
#[derive(Debug, Clone, Default)]
pub struct Demo {
    value: f64,
    name: String
}

impl Demo {
    /// static constructor method
    /// -----------------------------------------
    pub fn new() -> Self {
        Demo {
            value: 0.0,
            name: String::from("un_named"),
        }
    }
    /// method that sets Demo::value to v
    /// -----------------------------------------
    pub fn set_value(&mut self, v:f64) {
        self.value = v
    }
    /// method that retrieves Demo::value
    /// -----------------------------------------
    pub fn get_value(&self) -> f64 {
        self.value
    }
    /// method that sets Demo::name
    /// -----------------------------------------
    /// Note that nm is passed by reference &str
    /// If we passed by value, e.g., nm:String
    /// that would move nm into the function and
    /// it would become invalid in the caller's scope
    /// -----------------------------------------
    pub fn set_name(&mut self, nm:&str) {
        self.name = String::from(nm);
    }
    /// method returns name as a reference
    /// -----------------------------------------
    pub fn get_name(&self) -> &str {
        &self.name
    }
}//////////////////////////////////////////////////////
/// Testing:
/// ---------------------------------------------------
/// Rust libraries can be configured with unit tests,
/// as you see below.  You run them with the command:
///   cargo test
/// By default, cargo runs each test on separate thread,
/// so you can not count on the ordering of tests.
/// If you want to run all tests on single thread, which
/// will preserve test order, use the command: 
///   cargo test -- --test-threads=1
#[cfg(test)]
/// Notes:
/// 1. test_construct() uses typ_name method from std::any
/// 2. All tests use the fact that private data in struct
///    is accessible (only) within the defining library
mod tests {
    use super::*;
    #[test]
    fn test_construct() {
        let demo = Demo::new();
        let tn = std::any::type_name::<Demo>();
        assert_eq!(tn, "step_1::Demo");
        assert_eq!(demo.value, 0.0);
        assert_eq!(demo.name, "un_named".to_string());
    }
   #[test]
   fn test_setters() {
        let mut demo = Demo::new();
        demo.set_name("test2");
        demo.set_value(3.14159);
        assert_eq!(demo.name, "test2".to_string());
        assert_eq!(demo.value, 3.14159);
   }
   #[test]
   fn test_getters() {
       let mut demo = Demo::new();
       demo.name = String::from("test3");
       demo.value = 0.33333;
       assert_eq!(demo.get_name(), "test3".to_string());
       assert_eq!(demo.get_value(), 0.33333);
   }
}
          </left-content>
          <right-content class="code" style="font-size:0.9em;">
Microsoft Windows [Version 10.0.19042.685]
(c) 2020 Microsoft Corporation. All rights reserved.

C:\github\JimFawcett\BuildOn\step_1>
cargo test
   Compiling step_1 v0.1.0 
     (C:\github\JimFawcett\BuildOn\step_1)
   Finished test [unoptimized + debuginfo] target(s)
     in 1.24s  
   Running target\debug\deps\step_1-acfe1e9cd7ec2332.exe      

running 3 tests
test tests::test_construct ... ok
test tests::test_getters ... ok
test tests::test_setters ... ok

test result: 
   ok. 3 passed; 0 failed; 0 ignored; 0 measured; 
       0 filtered out


C:\github\JimFawcett\BuildOn\step_1>
cargo run --example test1
    Finished dev [unoptimized + debuginfo] target(s)
      in 0.02s   
    Running `target\debug\examples\test1.exe`

  -- Demonstration of Demo type --

  demo.name  = "un_named"
  demo.value = 0.0

  demo.name  = "JoeDemo"
  demo.value = 0.5

  That's all Folks
          </right-content>
        </two-column>
        </details>
        <t-b>
          You will need to know how to implement code like this for Step #1, where we build the TextSearch package
          and test it.
        </t-b>
        <t-b>
          You may wish to open this code in Visual Studio Code.  To do that, clone the 
          <a href="https://github.com/JimFawcett/BuildOn">BuildOn Repository</a>.  Then navigate to the cloned directory
          in a command window, cd into step_1, and emit the command <c-s>code .</c-s>, e.g.:
          <indent-block class="code">code .</indent-block>
          That will bring up VSCode with the library and test1 code loaded.
        </t-b>
        <t-b>
          You can do the same thing with the <a href="https://github.com/JimFawcett/RustTextFinder">RustTextFinder</a> 
          code. Clone the repository, then navigate into it in a command Widnow, and emit the command:
          <indent-block class="code">code .</indent-block>
          You then select the directory of the package you want to examine and build.
        </t-b>
        <div style="height:10em;">&nbsp;</div>
        <a id="bottom"></a>
         </main-right>
       </main-wrapper>
     </grid-main>
     <grid-footer class="light">
       <footer-wrapper>
         <footer-left class="dark" onclick="togglemenus()">
           &nbsp;toggle&nbsp;menu&nbsp;
         </footer-left>
         <footer-right id="sects" style="display:flex; padding:0em 1em;">
           <ul>
             <!--<li><a href="#buildon">BuildOn</a></li>
             <li><a href="#rust">Why Rust?</a></li>-->
             <!--<li><a href="#textfinder">TextFinder Prj</a></li>-->
             <li><a href="#step1">TextSearch Pkg</a></li>
             <li><a href="#tooling">Tooling</a></li>
             <li><a href="#refs">References</a></li>
             <li><a href="#code">Starter Code</a></li>
           </ul>
         </footer-right>
       </footer-wrapper>
     </grid-footer>
   </grid-container>
</body>
</html>