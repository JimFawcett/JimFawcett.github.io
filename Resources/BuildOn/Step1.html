<!DOCTYPE html>
<!--
  TestGrid2.html
  -------------
  This page is a prototype for pages that provide:
  - Header block at the top
  - page menu in the left panel
  - content in the right panel
  - content section links in a footer block
  Its design uses:
  - CSS grid to lay out the page in three rows, header, main, footer
  - The grid is fixed to the viewport using margins and height attributes
  - flex grid in the main row to hold the page menu and content panels
  - flex grid in the footer holding a toggle button and section links
  - JavaScript to respond to the toggle button by:
    a. Setting the menu panel display to none or block which toggles
       its visibility and space
    b. Setting the right area in the footer to a menu of section links
       or a copyright notice.
  This is a test prototype for story pages.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BuildOn Step#1 - TS</title>
  <link rel="stylesheet" href="css/Styles_Basic.css" />
  <link rel="stylesheet" href="css/Styles_Structure.css" />
  <link rel="stylesheet" href="css/Styles_RustTheme.css" />
  <link rel="stylesheet" href="css/Styles_StoryPagesGrid.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/Scripts_StoryPageMenu.js"></script>
  <style>
    #github .refsep {
      font-weight: normal;
      text-align: left;
    }
  </style>
</head>
<body id="github" onload="init()">

  <a id="Next" href="Step2.html">N</a>
  <a id="Prev" href="Step0.html">P</a>

  <grid-container>
    <grid-header class="dark" onclick="togglemenus()">
       <h2 class="dark">BuildOn - Step #1:&nbsp;&nbsp;&nbsp;TextSearch Pkg</h2>
     </grid-header>
     <grid-main>
       <a href="#top"></a>
       <main-wrapper>
         <main-left id="nav" class="light">
           <ul>
              <li><a href="../../index.html">Home</a></li>
              <li><a href="../../BuildOn.html">Repo</a></li>
              <li><a href="Intro.html">BuildOn Intro</a>&nbsp;&nbsp;</li>
              <li><a href="Step0.html">Step&nbsp;#0&nbsp;-&nbsp;TF</a>&nbsp;&nbsp;</li>
              <li><a href="Step1.html">Step&nbsp;#1&nbsp;-&nbsp;TS</a>&nbsp;&nbsp;</li>
              <li><a href="Step2.html">Step&nbsp;#2&nbsp;-&nbsp;DN</a>&nbsp;&nbsp;</li>
              <li><a href="Step3.html">Step&nbsp;#3&nbsp;-&nbsp;CP</a>&nbsp;&nbsp;</li>
              <li><a href="Step4.html">Step&nbsp;#4&nbsp;-&nbsp;Exc</a>&nbsp;&nbsp;</li>
              <li><a href="Step5.html">Step&nbsp;#5&nbsp;-&nbsp;RE</a>&nbsp;&nbsp;</li>
              <li><a href="Step6.html">Step&nbsp;#6&nbsp;-&nbsp;Par</a>&nbsp;&nbsp;</li>
              <li><a href="StepsRefs.html">StepsRefs</a>&nbsp;&nbsp;</li>
              <li><a href="../Animations/Anim_Features.html">Anim_Features</a>&nbsp;&nbsp;</li>
              <li><a href="../RustBites/RustBites_GettingStarted.html">Starting Rust</a>&nbsp;&nbsp;</li>
              <li><a href="../RustBites/RustBites_Intro.html">Rust Bites</a>&nbsp;&nbsp;</li>
              <li><a href="../../RustStory_Prologue.html">Rust Story</a>&nbsp;&nbsp;</li>
              <li><a href="../../IndexPage.html">Glossary</a>&nbsp;&nbsp;</li>
              <!--<li><a href="../../RustStory_References.html">References</a>&nbsp;&nbsp;</li>-->
           </ul>
         </main-left>
         <main-right id="content" class="light">
        <div style="height:0.5rem;"></div>
        <a id="textsearch"></a>
        <h3>BuildOn Project - TextSearch Package</h3>
        <div style="float:right;" class="light">
          <photosizer-block 
            src="pictures/TextFinderPackages.jpg" 
            width="300" class="photoSizerBlock left"
            style="background-color: #fefefa;"  
          >
            <span style="font-family:'Comic Sans MS';">Figure 1. TextFinder Packages</span>
          </photosizer-block>
        </div>
        <div style="float:right; clear:both;" class="light clear">
          <photosizer-block 
            src="pictures/ClassesStep1.jpg" 
            width="300" class="photoSizerBlock left"
            style="background-color: #fefefa;"  
          >
            <span style="font-family:'Comic Sans MS';">Figure 2. Step #1 Types</span>
          </photosizer-block>
        </div>
       <t-b>
         TextSearch is a package in the first BuildOn project, TextFinder.  Figure 1 is a package diagram for
         Textfinder, discussed in Step #0.
        </t-b>
        <indent-block>
          <details>
            <summary class="darkItem" style="width:max-content;">TextFinder Specification</summary>
        <h4>TextFinder Specification:</h4>
        <t-b>
          <ol class="tight">
            <li>
              Identify all files in a directory subtree that match a pattern and contain a specified text.
            </li>
            <li>
              Specify root path, one or more file patterns (.h, .cpp, .cs, .rs, ...), and search text on command line.
            </li>
            <li>
              Specify options <c-s>/s [true|false]</c-s>, <c-s>/v [true|false]</c-s>, <c-s>/H [true|false]</c-s>
              <c-s>/h [true|false]</c-s> for recursive directory walk, verbose output header, Hidden dirs with no match,
              and help message, respectively.
            </li>
            <li>
              Display file name and path, without duplication of path name, e.g., organized by directory, for files
              containing the search text.
            </li>
            <li>
              Interesting extensions:
              <ul class="tight" style="margin-left:0.85rem;">
                <li>
                  Replace text by regular expressions for both search text and file patterns.
                </li>
                <li>
                  Replace sequential file searches with parallel searches to improve performance and useability.
                </li>
              </ul>
            </li>
          </ol>
        </t-b>
          </details>
        </indent-block>
        <t-b>
          TextSearch is provided file information by DirNav, searches for text in each file, and sends results
          to Display.  You will find sample starter code <a href="#code">below</a>.
        </t-b>
        <div style="height:0.5rem;"></div>
        <!--<hr class="spread" />-->
        <a id="step1"></a>
        <h3>Step #1 - Build TextSearch Package</h3>
        <t-b>
          TextSearch seeks specified text and if found sends the path and file name to
          Display.  The Display package turns the sequence of successful search completion events
          into useful user information.
        </t-b>
        <t-b>
          In this step we will create the TextSearch package.  It contains a <c-s>Finder</c-s> type that:
          <ol>
            <li>
              Accepts a search string in method Finder::set_txt.
            </li>
            <li>
              Accepts a directory name in DirEvent::do_dir which it stores and passes on to an instance
              of the <c-s>GenOut</c-s> type, which will move to the Display package in Step #4.
            </li>
            <li>
              Accepts a file name in DirEvent::do_file.
            </li>
            <li>
              Attempts to open the file.
            </li>
            <li>
              If successful, searches the file for the specified text.
            </li>
            <li>
              Sends a tuple of file name, boolean found value, and the search text to the
              <c-s>GenOut</c-s> type.
              The boolean value is true if specified text was found in the file, otherwise false.
            </li>
          </ol>
        </t-b>
        <t-b>
          TextSearch package defines struct <c-s>Finder</c-s> that provides the methods:
          <indent-block>
            <c-s>fn do_dir(&mut self, dir: &Path)</c-s><br />
            <c-s>fn do_file(&mut self, file: &Path)</c-s><br />
            <c-s>fn set_txt(&mut self, srctxt: &str)</c-s>
          </indent-block>
          Method <c-s>do_file</c-s> sends its results directly to <c-s>GenOut</c-s>, below, rather than 
          returning them to DirNav.
        </t-b>
        <t-b>
          It defines, in this Step, struct <c-s>GenOut</c-s> to provide methods:
          <indent-block>
            <c-s>fn set_dir(&mut self, dir: &Path)</c-s><br />
            <c-s>/* rslt args, below, are: filename, found, and search_text */</c-s><br />
            <c-s>fn set_file(&mut self, rslt:(&Path, bool, &str))</c-s>
          </indent-block>
          In this Step, <c-s>GenOut</c-s> is a test mock, supporting <c-s>Finder</c-s> testing.
          A completed version will migrate to Display package in Step&nbsp;#4.
          <!--<c-s>Finder</c-s> is a generic type with parameter <c-s>D</c-s>, e.g., 
          <c-s>struct Finder&lt;D&gt; { ... }</c-s>.
          For this application, <c-s>Finder</c-s>&apos;s creator, <c-s>Executive</c-s>, will configure 
          <c-s>Finder</c-s> with the type <c-s>Display</c-s>, e.g., <c-s>Finder&lt;Display&gt;</c-s>.-->
        </t-b>
        <h4>Notes:</h4>
        <t-b>
          <ol>
            <li>
              Passing the boolean along with file name supports displaying files with the search text 
              or files without the text, depending on how Display is configured.
              We might wish to use the later option to find files that do not provide comment
              prologues, for example.
            </li>
            <li>
              TextSearch package&apos;s <c-s>Finder</c-s> will create an instance of <c-s>GenOut</c-s> and send 
              its events directly to <c-s>GenOut</c-s> instead
              of passing them back to Executive to forward.
            </li>
            <li>
              In a later step, after looking at generics, we will show how this structure can allow the
              TextFinder program to be quite flexible in how its display processing is effected.
            </li>
            <li>
              <c-s>DirNav</c-s> is required to find all the files matching required patterns
              before recursing into child directories.  That ensures that TextSearch gets, and passes
              on to Display, the current directory name, and then supplies all of the matched files
              to Display before leaving the current directory.
              <ul>
                <li>
                  You don&apos;t need DirNav for this Step.  Instead, you will mock DirNav activities
                  in the test1.rs <c-s>main function</c-s>, feeding the <c-s>Finder</c-s> instance mock
                  values (see <a href="#code">starter code</a> below).
                </li>
              </ul>
            </li>
          </ol>
        </t-b>
        <div style="height:0.15em;">&nbsp;</div>
        <hr class="spread" />
        <a id="tooling"></a>
        <h3>Tooling</h3>
        <t-b>
          The Rust ecosystem has some very well designed tools that allow you to create, build, and execute
          code on Windows 10, Linux, and macOS.
        </t-b>
        <t-b>
          Rust comes with a tool called cargo that creates new packages for either executables or libraries.  
          It creates a metadata file called Cargo.toml that describes the package (Rust community calles them crates)
          and provides a section for describing dependencies.
        </t-b>
        <details>
          <summary>Cargo Commands</summary>
          <indent-block style="border:1px solid #5c2107; padding: 0em 1.0em; width:max-content;">
            <t-b>
              Create a package with the command:
              <indent-block class="code">cargo new pkgFolder [--lib | --bin] [--n pkgname]</indent-block>
              This creates a folder pkgFolder, builds metadata for package pkgname.  It also creates
              a /src directory that holds either lib.rs or main.rs.
            </t-b>
            <hr />
            <t-b>
              After building a package, containing an executable, with the command:
              <indent-block class="code">cargo run [arg1, ...]</indent-block>
              cargo invokes the executable it built with rustc, passing command line arguments, if any, to the
              executable.
            </t-b>
            <hr />
            <t-b>
              After building a libray package with the command:
              <indent-block class="code">cargo new pkgFolder --lib --n name</indent-block>
              cargo runs configured tests with the command:
              <indent-block class="code">cargo test</indent-block>
            </t-b>
            <hr />
            <t-b>
              If the project has an /examples sister directory to /src, any console application in that
              directory, say test1.rs,
              can be bound to the library and run with the command:
              <indent-block class="code">cargo run --example test1</indent-block>
            </t-b>
            <hr />
            <t-b>
              Get cargo help with the commands:
              <c-s>cargo --help</c-s>
              or
              <c-s>cargo cmd --help</c-s>.
              You can also find more details here: 
              <a href="https://doc.rust-lang.org/cargo/">Cargo Book</a>.
            </t-b>
          </indent-block>
        </details>
        <t-b>
          Rust does not come with an Integrated Development Environment (IDE), but you will find the
          Visual Studio Code editor, aka VSCode, to be effective; and it works on all three platforms, 
          Windows, Linux, and macOS.
        </t-b>
        <t-b>
          For more details check out this: <a href="../RustBites/RustBites_Tooling.html">Tooling</a> page.
        </t-b>
        <div style="height:1.0em;">&nbsp;</div>
        <hr class="spread" />
        <a id="code"></a>
        <h3>Starter Code</h3>
        <t-b>
          This section contains a code example showing how to:
          <ol>
            <li>
              Define a struct with methods - similar in use to a C++ or C# class.
            </li>
            <li>
              Build a library that contains the struct and test its methods.
            </li>
            <li>
              Link the static library to a test console application and run that.
            </li>
            <li>
              That is done for a project structure very similar to what you will use
              for TextFinder - Step #1
            </li>
          </ol>
        </t-b>
        <div style="height:0.75em">&nbsp;</div>
        <details>
          <summary class="dark" style="width:max-content;">Starter Code Example</summary>
          <t-b>
            This is a test mock for Step #1&apos;s project structure.  It gives you a good
            start for building Step #1 so you can focus on starting to learn the Rust
            programming language.
          </t-b>
        <two-column style="width:max-content;">
          <left-content class="code" style="font-size:0.9em;"><div style="font-size:1.15rem; font-weight:bold;">TextSearch Library Source</div><hr style="width:100%;" />
///////////////////////////////////////////////////////////
// BuildOnStructure::TextSearch.rs                       //
//   - demonstrate code structure for Step #1            //
// Jim Fawcett, https://JimFawcett.github.io, 14 Jan 21  //
///////////////////////////////////////////////////////////

use std::path::{Path, PathBuf};

/*-----------------------------------------------
  A trait is similar to an interface, most often
  used to convey a communication protocol for
  generic types.

  SearchEvent trait is not needed here, but will be in 
  Step #4
*/
pub trait SearchEvent {
    fn set_dir(&amp;mut self, dir: &amp;Path);
    fn set_file(&amp;mut self, rslt: (&amp;Path, bool, &amp;str));
}
/*-----------------------------------------------
  GenOut converts Finder's data into information
  for user.
*/
#[derive(Debug)]
pub struct GenOut {
    dir: PathBuf
}
/*-- implement trait --------------------------*/
impl SearchEvent for GenOut {
    fn set_dir(&amp;mut self, rdir: &amp;Path) {
        self.dir = rdir.to_path_buf();
        print!("\n  {:?}", rdir);
    }
    fn set_file(&amp;mut self, rslt: (&amp;Path, bool, &amp;str)) {
        let (file, found, text) = rslt;
        if found {
            print!("\n    {:?}: {:?} found", file, text);
        }
        else {
            print!("\n    {:?}: {:?} not found", file, text);
        }
    }
}
/*-- implement other member functions ---------*/
impl GenOut {
    pub fn new() -&gt; GenOut {
        GenOut {
            dir: PathBuf::new()
        }
    }
}
/*-----------------------------------------------
  Trait DirEvents specifies functions that
  Finder provides to support DirNav calls.

  Not used in this step.
*/
pub trait DirEvent {
    fn do_dir(&amp;mut self, dir: &amp;Path);
    fn do_file(&amp;mut self, file: &amp;Path);
}
/*-----------------------------------------------
  Finder searches for text in specified file
*/
#[derive(Debug)]
pub struct Finder {
      dir: PathBuf,
      srctxt: String,
      out: GenOut
}
/*-- implement DirEvent --*/
impl DirEvent for Finder {
    fn do_dir(&amp;mut self, dir: &amp;Path) {
        self.dir = dir.to_path_buf();
        self.out.set_dir(dir);
    }
    fn do_file(&amp;mut self, file: &amp;Path) {
        /* 
            Pretending to search for text in file.
            Function should:
              1. append flnm to dir
              2. attempt to open file
              3. search for text
              4. send result to out 
        */
        if self.srctxt == "BuildOn" {
            self.out.set_file((file, true, &amp;self.srctxt));
        }
        else {
            self.out.set_file((file, false, &amp;self.srctxt));
        }
    }
}
/*-- implement Finder methods -----------------*/
impl Finder {
    pub fn new() -&gt; Finder {
        Finder {
            dir: PathBuf::new(),
            srctxt: String::new(),
            out: GenOut::new()
        }
    }
    pub fn set_txt(&amp;mut self, txt: &amp;str) {
        self.srctxt = txt.to_string();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn construct_genout() {
        let g = GenOut::new();
        assert_eq!(g.dir , PathBuf::from(""));
    }
    #[test]
    fn construct_finder() {
        let f = Finder::new();
        assert_eq!(f.dir,  PathBuf::from(""));
    }
}

          <div style="font-size:1.15rem; font-weight:bold;">TextSearch Test Results</div><hr style="width:100%;" /><hr style="width:100%;" />
C:\su\temp\BuildOnStructure\Step1\TextSearch>
cargo test
   Compiling text_search v0.1.0 
     (C:\su\temp\BuildOnStructure\Step1\TextSearch)
    Finished test [unoptimized + debuginfo] 
      target(s) in 0.49s       
    Running 
      target\debug\deps\text_search-ebf377eb2c5e40d1.exe

running 2 tests
test tests::construct_finder ... ok
test tests::construct_genout ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 
                 0 measured; 0 filtered out

   Doc-tests text_search

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 
                 0 measured; 0 filtered out


          </left-content>
          <right-content class="code" style="font-size:0.9em;"><div style="font-size:1.15rem; font-weight:bold;">Test1 Example Source</div><hr style="width:100%;" />

///////////////////////////////////////////////////////////
// BuildOnStructure::Step1::test1.rs                     //
//   - demonstrate code structure for Step #1            //
// Jim Fawcett, https://JimFawcett.github.io, 14 Jan 21  //
///////////////////////////////////////////////////////////

use text_search::*;
use std::path::{Path};

fn main() {
    print!("\n  -- demonstrate structure for Step#1 --\n");
   let mut finder = Finder::new();
   finder.set_txt("BuildOn");
   finder.do_dir(&amp;Path::new("Dir1"));
   finder.do_file(&amp;Path::new("file1.txt"));
   finder.set_txt("BuildOff");
   finder.do_file(&amp;Path::new("file2.txt"));
   finder.do_dir(&amp;Path::new("Dir2"));
   finder.set_txt("abc");
   finder.do_file(&amp;Path::new("file3.txt"));
   finder.set_txt("123");
   finder.do_file(&amp;Path::new("file4.txt"));

   print!("\n\n  That's all Folks!\n\n");
}
<div style="font-size:1.15rem; font-weight:bold;">Test1 Example Output</div><hr style="width:100%;" />
C:\su\temp\BuildOnStructure\Step1\TextSearch>
cargo run --example test1
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target\debug\examples\test1.exe`

  -- demonstrate structure for Step#1 --

  Dir1
    file1.txt: "BuildOn" found
    file2.txt: "BuildOff" not found
  Dir2
    file3.txt: "abc" not found
    file4.txt: "123" not found

  That's all Folks!

C:\su\temp\BuildOnStructure\Step1\TextSearch>
cargo clean


<div style="font-size:1.15rem; font-weight:bold;">Project Structure</div><hr style="width:100%;" />

<div class="light" style="display:block; white-space:normal;">
  <photosizer-block 
    src="pictures/ProjectStep1.jpg" 
    width="400" class="photoSizerBlock left"
    style="background-color: #fefefa;"  
  >
    <span style="font-family:'Comic Sans MS';">Figure 1. Project Structure - Step #1</span>
  </photosizer-block>
</div>

<div style="font-size:1.15rem; font-weight:bold;">cargo.toml</div><hr style="width:100%;" />
[package]
name = "text_search"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at 
# https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
          </right-content>
        </two-column>
        </details>
        <t-b>
          You may wish to open this code in Visual Studio Code.  To do that, clone the 
          <a href="https://github.com/JimFawcett/BuildOn">BuildOn Repository</a>.  Then navigate to the cloned directory
          in a command window, cd into BuildOnStructure/Step1/TextSearch, and emit the command <c-s>code .</c-s>, e.g.:
          <indent-block class="code">code .</indent-block>
          That will bring up VSCode with the library and test1 code loaded.
        </t-b>
        <t-b>
          You can do the same thing with the <a href="https://github.com/JimFawcett/RustTextFinder">RustTextFinder</a> 
          code. Clone the repository, then navigate into it in a command Widnow, and emit the command:
          <indent-block class="code">code .</indent-block>
          You then select the directory of the package you want to examine and build.
        </t-b>
        <div style="height:0.15em;">&nbsp;</div>
        <hr class="spread" />
        <a id="refs"></a>
        <h3>Step #1 References</h3>
        <t-b>
          The table below provides references relevant for Step #1 : TextSearch.  The first links refer to specific
          regions of the Rust Story, from this site.  Other links go to Rust documentation. 
        </t-b>
        <t-b>
          You can look at the Rust Story
          by going to the Home page (Home link in the menu), clicking on the Stories menu item (at the top) and selecting
          the Rust Story link.
        </t-b>
        <div style="height:0.5rem;">&nbsp;</div>
        <h4>Table 1. - Step #1 References</h4>
        <div>
          <table style="width:100%;" class="lightItem">
            <tr>
              <th class="darkItem" style="width: 10em;">Topic</th>
              <th class="darkItem" style-"width: auto;">Description</th>
              <th class="darkItem" style="width: 15em;">Link</th>
            </tr>
            <tr>
              <td>Look here first</td>
              <td>
                Starts with quick to intermediate tutorials on the Rust language.
              </td>
              <td>
                <a href="../RustBites/RustBites_GettingStarted.html">Getting Started</a>
              </td>
            </tr>
            <tr>
              <td>Tooling</td>
              <td>
                The Rust environment comes with some great tools: cargo, clippy, doc.  You will want to
                add Visual Studio Code.
              </td>
              <td>
                <a href="../RustBites/RustBites_Tooling.html">Tooling</a><br />
                <a href="https://doc.rust-lang.org/cargo/">Cargo Book</a><br />
                <a href="https://code.visualstudio.com/">Visual Studio Code</a><br />
              </td>
            </tr>
            <tr>
              <td>File System</td>
              <td>
                Rust has a well engineered facility for accessing files and directories.<br />
                Some key types in std::fs are: DirEntry, File, OpenOptions, ReadDir, ...
              </td>
              <td>
                <a href="../../RustStory_Libraries.html#fs">Rust story File System</a><br />
                <a href="https://doc.rust-lang.org/std/fs/index.html">std::fs</a><br />
                <a href="https://doc.rust-lang.org/std/path/index.html">std::path</a>
                &nbsp;
              </td>
            </tr>
            <tr>
              <td>Error Handling</td>
              <td>
                Rust error handling is based on use of the enumeration:
                <demo-block>
                  <c-s>enum  Result&lt;T,E&gt; { Ok(T), Err(E), }</c-s>
                </demo-block>
                where T is the type of the returned value, E is the type of the expected error.  Rust enums are
                unique in that each of the enumertion items may be a wrapper for a specified type, like Ok and Err.
              </td>
              <td>
                <a href="../RustBites/RustBites_ErrHnd.html">RustBites Enums &amp; Err Hndlg</a><br />
                <a href="../../RustStory_Data.html#enums">RustStory Enums</a><br />
                <a href="../../RustStory_Operations.html#errors">RustStory Error Handling</a><br />
                <a href="https://stevedonovan.github.io/rust-gentle-intro/2-structs-enums-lifetimes.html">Gentle Introduction to Rust</a>
                <a href="https://doc.rust-lang.org/std/result/">std::Result</a>
              </td>
            </tr>
            <tr>
              <td>Data Operations</td>
              <td>
                Rust data operations copy, move, and clone.  These operations combined with Rust&apos;s
                ownership rules (discussed next time) are the defining characteristics of the language.  
                They are responsible for Rust&apos;s data safety and performance.
              </td>
              <td>
                <a href="../IdiomsAndPatterns/IaP_Data.html">Hello Data</a><br />
                <a href="../RustBites/RustBites_Data.html">Data types, copy, and move</a><br />
                <a href="../../RustStory_Data.html">Rust Story Data</a><br />
                <a href="https://doc.rust-lang.org/beta/core/marker/trait.Copy.html">Trait Copy</a><br />
                <a href="https://doc.rust-lang.org/std/keyword.move.html">keyword move</a><br />
                <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Trait Clone</a><br />
              </td>
            </tr>
            <tr>
              <td>Strings</td>
              <td>
                Rust strings come in two flavors: <c-s>String</c-s> and <c-s>str</c-s>, representing
                string objects and literal strings.  Each contains utf-8 characters.
              </td>
              <td>
                <a href="../../RustStory_Data.html#strings">Rust Story Strings</a><br />
                <a href="https://doc.rust-lang.org/std/string/struct.String.html">std::String</a><br />
                <a href="https://doc.rust-lang.org/std/primitive.str.html">Primitive Type str</a>
              </td>
            </tr>
            <tr>
              <td>struct</td>
              <td>
                Rust structs serve the same role as classes do in C++ and C#.  Struct methods are
                defined inside impl StructName {} blocks.
              </td>
              <td>
                <a href="../../RustStory_Data.html#structs">Rust Story structs</a><br />
                <a href="https://doc.rust-lang.org/std/keyword.struct.html">std::Stuct</a><br />
                <a href="https://doc.rust-lang.org/std/keyword.impl.html">keyword impl</a>
              </td>
            </tr>
          </table>
        </div>
        <t-b>
          You won&apos;t need all these references.  Scan them for each category and decide which work best for you.
        </t-b>
        <div style="height:10em;">&nbsp;</div>
        <a id="bottom"></a>
         </main-right>
       </main-wrapper>
     </grid-main>
     <grid-footer class="light">
       <footer-wrapper>
         <footer-left class="dark" onclick="togglemenus()">
           &nbsp;toggle&nbsp;menu&nbsp;
         </footer-left>
         <footer-right id="sects" style="display:flex; padding:0em 1em;">
           <ul>
             <!--<li><a href="#buildon">BuildOn</a></li>
             <li><a href="#rust">Why Rust?</a></li>-->
             <!--<li><a href="#textfinder">TextFinder Prj</a></li>-->
             <li><a href="#textsearch">TextSearch Pkg</a></li>
             <li><a href="#step1">Build TextSearch Pkg</a></li>
             <li><a href="#tooling">Tooling</a></li>
             <li><a href="#code">Starter Code</a></li>
             <li><a href="#refs">References</a></li>
           </ul>
         </footer-right>
       </footer-wrapper>
     </grid-footer>
   </grid-container>
</body>
</html>