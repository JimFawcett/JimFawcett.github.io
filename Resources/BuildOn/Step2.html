<!DOCTYPE html>
<!--
  TestGrid2.html
  -------------
  This page is a prototype for pages that provide:
  - Header block at the top
  - page menu in the left panel
  - content in the right panel
  - content section links in a footer block
  Its design uses:
  - CSS grid to lay out the page in three rows, header, main, footer
  - The grid is fixed to the viewport using margins and height attributes
  - flex grid in the main row to hold the page menu and content panels
  - flex grid in the footer holding a toggle button and section links
  - JavaScript to respond to the toggle button by:
    a. Setting the menu panel display to none or block which toggles
       its visibility and space
    b. Setting the right area in the footer to a menu of section links
       or a copyright notice.
  This is a test prototype for story pages.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BuildOn Step#2 - DN</title>
  <link rel="stylesheet" href="css/Styles_Basic.css" />
  <link rel="stylesheet" href="css/Styles_Structure.css" />
  <link rel="stylesheet" href="css/Styles_RustTheme.css" />
  <link rel="stylesheet" href="css/Styles_StoryPagesGrid.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/Scripts_StoryPageMenu.js"></script>
  <style>
    #github .refsep {
      font-weight: normal;
      text-align: left;
    }
  </style>
</head>
<body id="github" onload="init()">

  <a id="Next" href="Step3.html">N</a>
  <a id="Prev" href="Step1.html">P</a>

  <grid-container>
    <grid-header class="dark" onclick="togglemenus()">
       <h2 class="dark">BuildOn - Step #2:&nbsp;&nbsp;&nbsp;DirNav Pkg</h2>
     </grid-header>
     <grid-main>
       <a href="#top"></a>
       <main-wrapper>
         <main-left id="nav" class="light">
           <ul>
              <li><a href="../../index.html">Home</a></li>
              <li><a href="../../BuildOn.html">Repo</a></li>
              <li><a href="Intro.html">BuildOn Intro</a>&nbsp;&nbsp;</li>
              <li><a href="Step0.html">Step&nbsp;#0&nbsp;-&nbsp;TF</a>&nbsp;&nbsp;</li>
              <li><a href="Step1.html">Step&nbsp;#1&nbsp;-&nbsp;TS</a>&nbsp;&nbsp;</li>
              <li><a href="Step2.html">Step&nbsp;#2&nbsp;-&nbsp;DN</a>&nbsp;&nbsp;</li>
              <li><a href="Step3.html">Step&nbsp;#3&nbsp;-&nbsp;CP</a>&nbsp;&nbsp;</li>
              <li><a href="Step4.html">Step&nbsp;#4&nbsp;-&nbsp;Exc</a>&nbsp;&nbsp;</li>
              <li class="undefined"><a href="JavaScript:;">Step&nbsp;#5&nbsp;-&nbsp;REx</a>&nbsp;&nbsp;</li>
              <li class="undefined"><a href="JavaScript:;">Step&nbsp;#6&nbsp;-&nbsp;Par</a>&nbsp;&nbsp;</li>
              <li><a href="StepsRefs.html">StepsRefs</a>&nbsp;&nbsp;</li>
              <li><a href="../DesignBites/DesignBites_Intro.html">Design Bites</a>&nbsp;&nbsp;</li>
              <li><a href="../Animations/Anim_Features.html">Anim_Features</a>&nbsp;&nbsp;</li>
              <li><a href="../RustBites/RustBites_GettingStarted.html">Starting Rust</a>&nbsp;&nbsp;</li>
              <li><a href="../RustBites/RustBites_Intro.html">Rust Bites</a>&nbsp;&nbsp;</li>
              <li><a href="../../RustStory_Prologue.html">Rust Story</a>&nbsp;&nbsp;</li>
              <li><a href="../../IndexPage.html">Glossary</a>&nbsp;&nbsp;</li>
              <!--<li><a href="../../RustStory_References.html">References</a>&nbsp;&nbsp;</li>-->
           </ul>
         </main-left>
         <main-right id="content" class="light">
        <div style="height:1.0em;">&nbsp;</div>
        <a id="dirnav"></a>
        <h3>BuildOn Project - DirNav Package</h3>
        <div style="float:right;" class="light">
          <photosizer-block 
            src="pictures/TextFinderPackages.jpg" 
            width="300" class="photoSizerBlock left"
            style="background-color: #fefefa;"  
          >
            <span style="font-family:'Comic Sans MS';">Figure 1. TextFinder Packages</span>
          </photosizer-block>
        </div>
          <div style="float:right; clear:both; background-color: #fefefa;">
            <photosizer-block 
              src="pictures/TextFinderClassDiagram2.jpg" 
              width="400" class="photoSizerBlock left"
              style="background-color: #fefefa;"  
            >
              <span style="font-family:'Comic Sans MS';">Figure 2. TextFinder Structs</span>
            </photosizer-block>
          </div>
       <t-b>
         DirNav is a package in the first BuildOn project, TextFinder.  Figure 1 is a package diagram for
         Textfinder, discussed in Step #0.
        </t-b>
        <indent-block>
          <details>
            <summary class="darkItem" style="width:max-content;">TextFinder Specification</summary>
        <h4>TextFinder Specification:</h4>
        <t-b>
          <ol class="tight">
            <li>
              Identify all files in a directory subtree that match a pattern and contain a specified text.
            </li>
            <li>
              Specify root path, one or more file patterns (.h, .cpp, .cs, .rs, ...), and search text on command line.
            </li>
            <li>
              Specify options <c-s>/s [true|false]</c-s>, <c-s>/v [true|false]</c-s>, <c-s>/H [true|false]</c-s>
              <c-s>/h [true|false]</c-s> for recursive directory walk, verbose output header, Hidden dirs with no match,
              and help message, respectively.
            </li>
            <li>
              Display file name and path, without duplication of path name, e.g., organized by directory, for files
              containing the search text.
            </li>
            <li>
              Interesting extensions:
              <ul class="tight" style="margin-left:0.85rem;">
                <li>
                  Replace text by regular expressions for both search text and file patterns.
                </li>
                <li>
                  Replace sequential file searches with parallel searches to improve performance and useability.
                </li>
              </ul>
            </li>
          </ol>
        </t-b>
          </details>
        </indent-block>

        <t-b>
          TextSearch seeks files with specified text, using services of DirNav, and if found sends the path and 
          file name to Display.  The Display package turns the sequence of successful search completion events
          into useful user information.
        </t-b>
        <div style="height:0.15em;">&nbsp;</div>
        <hr class="spread" />
        <a id="step2"></a>
        <h3>Step #2 - Build DirNav Package</h3>
        <t-b>
          In this step we will create the DirNav package and integrate it with a mock test application.  It:
          <ol>
            <li>
              Implements a struct <c-s>DirNav</c-s> that is responsible for walking the directory tree.
            </li>
            <li>
              <c-s>DirNav</c-s> accepts a path and set of file patterns, e.g., ".rs,.h,.cpp...".
            </li>
            <li>
              Searches the directory tree rooted at the specified path, looking for files matching 
              specified pattern(s):
              <indent-block class="code">Pseudo Code:
fn visit(&mut self, path: &Path) {
    app.do_dir(path);
    find all files matching pattern
        app.do_file(filename);
    find all subdirs
        dir_store.push(subdir);
    for each subdir in store
        visit(subdir);
}</indent-block>
            </li>
            <li>
              Search is conducted with a recursive Depth First Search (DFS) policy, as shown above.
            </li>
            <li>
              Each time a directory is entered it invokes <c-s>DirEvent::do_dir(...)</c-s>.
            </li>
            <li>
              Each time a file matching the pattern(s) is encountered it invokes <c-s>DirEvent::do_file(...)</c-s>.
            </li>
          </ol>
        </t-b>
        <h4>Notes:</h4>
              <!--<div style="float:right; clear:both; background-color: #fefefa;">
                <photosizer-block 
                  src="pictures/TextFinderClassDiagram2.jpg" 
                  width="300" class="photoSizerBlock left"
                  style="background-color: #fefefa;"  
                >
                  <span style="font-family:'Comic Sans MS';">Figure 2. TextFinder Structs</span>
                </photosizer-block>
              </div>-->
        <t-b>
          <ol>
            <li>
              DirEvent is a Rust trait, similar to a C# constraint specifying an interface:
              <indent-block class="code">pub trait DirEvent {
    fn new() -> Self                    // factory function
    fn do_dir(&mut self, dn: &Path);    // dir event handler
    fn do_file(&mut self, fn: &Path);   // file event handler
}</indent-block>
              <c-s>DirNav</c-s> is parameterised with a generic type that is constrained to implement the 
              <c-s>DirEvent</c-s> trait:
              <div style="margin:0.25rem 1.5rem 0.5rem 1.5rem;">
                <c-s>struct DirNav&lt;T&gt where T:DirEvent { ... }</c-s>
              </div>
              For this BuildOn project,
              <c-s>DirNav</c-s> will be parameterized on a mock of TextSearcher&apos;s <c-s>Finder</c-s> type
              which implements the <c-s>DirEvent</c-s> trait, as shown in Figure 2.
            </li>
            <li>
              Parameterization of <c-s>DirNav&lt;T&gt;</c-s> with <c-s>T</c-s> simply makes <c-s>T</c-s> available
              to <c-s>DirNav</c-s>, but doesn&apos;t specify what that type is.  It instead specifies
              conditions that <c-s>T</c-s> must satisfy with constraints, as shown in the previous item.
            </li>
            <li>
              Any struct may implement the <c-s>DirEvent</c-s> trait, applying its application specific code to process
              directories and files.  So <c-s>DirNav</c-s> can carry out its function without ever needing to know
              the application&apos;s details.  It just needs to get access to an instance of the implementing
              struct, which it can do using the <c-s>DirEvent::new()</c-s> factory function.
            </li>
            <li>
              For this Step #2 you don&apos;t need to use TextSearch&apos;s <c-s>Finder</c-s> type for <c-s>T</c-s>.  
              You can use a simple mock type that pretends to do what <c-s>Finder</c-s> does.  Of course, you can use
              the <c-s>Finder</c-s> you built in Step #1 if you wish.
            </li>
            <li>
              This structure implements the 
              <a href="https://stackify.com/dependency-inversion-principle/">Dependency Inversion Principle</a>. e.g.,
              <c-s>DirNav</c-s> doesn&apos;t depend on <c-s>Finder</c-s>.  Instead, both <c-s>DirNav</c-s> and
              <c-s>Finder</c-s> depend on the invariant <c-s>DirEvent</c-s>.
            </li>
            <li>
              Using the <c-s>DirEvent</c-s> trait allows <c-s>DirNav</c-s> to be reusable.  We can use 
              <c-s>DirNav&lt;T&gt;</c-s> without change for any application <c-s>T</c-s> that implements <c-s>DirEvent</c-s>.
            </li>
            <li>
              For this Step, you need to use <c-s>PathBuf</c-s> and <c-s>&Path</c-s> which you used in Step #1 - TS.
              Rust defines six string types, three owning types String, OsString, and PathBuf, and three literal types,
              str, OsStr, and Path:
              <div style="height:1.0rem;"></div>
              <table>
                <tr class="dark">
                  <th>String&nbsp;type</th><th>Description</th><th>Reference</th>
                </tr>
                <tr>
                  <td>String</td>
                  <td>
                    A collection of utf-8 characters, stored in the heap and managed with a control block on
                    the stack.
                  </td>
                  <td><a href="https://doc.rust-lang.org/std/string/struct.String.html">std::String</a></td>
                </tr>
                <tr>
                  <td>&str</td>
                  <td>
                    A collection of utf-8 characters in a contiguous block on the stack, sometimes in static memory too.
                  </td>
                  <td><a href="https://doc.rust-lang.org/std/str/index.html">std::str</a></td>
                </tr>
                <tr>
                  <td>OsString</td>
                  <td>
                    Same structure as std::String, but holding characters from the platform string type, used
                    most often to interoperate with C code through Rust&apos;s foreign function interface (ffi).
                  </td>
                  <td><a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html">std::ffi::OsString</a></td>
                </tr>
                <tr>
                  <td>OsStr</td>
                  <td>
                    A literal string with the same character encoding as OsString.
                  </td>
                  <td><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">std::ffi::OsStr</a></td>
                </tr>
                <tr>
                  <td>PathBuf</td>
                  <td>
                    Same structure as std::String, but holding characters from the platform string type, 
                    and providing methods for working with paths, e.g., extracting names, extensions, doing joins,
                    etc.
                  </td>
                  <td><a href="https://doc.rust-lang.org/std/path/struct.PathBuf.html">std::path::PathBuf</a></td>
                </tr>
                <tr>
                  <td>&Path</td>
                  <td>
                    A literal string with the same character encoding as PathBuf.
                  </td>
                  <td><a href="https://doc.rust-lang.org/std/path/struct.Path.html">std::path::Path</a></td>
                </tr>
              </table>
              <div style="height: 1.0rem;"></div>
              You will need to use <c-s>PathBuf</c-s> and <c-s>&Path</c-s> to work with the Rust file system.
            </li>
          </ol>
        </t-b>
        <div style="height:1.0em;">&nbsp;</div>
        <hr class="spread" />
        <a id="code"></a>
        <h3>Starter Code</h3>
        <t-b>
          This section contains a code example showing how to:
          <ol>
            <li>
              Define a generic struct <c-s>DirNav&lt;T&gt;</c-s> where <c-s>T</c-s> is constrained to implement 
              methods of the <c-s>DirEvent</c-s> trait, similar to an interface,
              as well as other methods it needs.
            </li>
            <li>
              Use the Dependency Inversion Principle to allow <c-s>DirNav</c-s> to avoid depending on TextSearch&apos;s
              <c-s>Finder</c-s> implementation details:
              <ul class="tight">
                <li>
                  Constrain generic type parameter <c-s>T</c-s> with trait <c-s>DirEvent</c-s>.
                </li>
                <li>
                  Create an instance, using the <c-s>DirEvent</c-s> factory function, of the generic parameter for 
                  use in <c-s>DirNav</c-s>&apos;s methods.
                </li>
              </ul>
              For demonstrations of the <strong>Dependency Inversion Principle</strong>, see
              <a href="../IdiomsAndPatterns/IaP_BasicDIP.html">Basic DIP</a> and
              <a href="../IdiomsAndPatterns/IaP_GenericDIP.html">Generic DIP</a>.
            </li>
            <li>
              Build a library that contains the struct and test its methods.
            </li>
            <li>
              Link the static library to a test console application and run that.
            </li>
            <li>
              That is done for a project structure very similar to what you used
              for TextFinder - Step #1
            </li>
          </ol>
        </t-b>
        <div style="height:0.75em">&nbsp;</div>
        <details>
          <summary class="dark" style="width:max-content;">Starter Code Example</summary>
          <t-b>
            This is a test mock for Step #2&apos;s project structure.  It gives you a good
            start for building Step #2 so you can focus on learning the Rust
            programming language.
          </t-b>
          <t-b>
            You will need to provide directory navigation code, using facilities of the
            <a href="https://doc.rust-lang.org/std/fs/index.html">std::fs</a> file system facilities.
            This demonstration focuses on its Dependency Inversion structure.
          </t-b>
        <two-column style="width:max-content;">
          <left-content class="code" style="font-size:0.9em;"><div style="font-size:1.15rem; font-weight:bold;">DirNav Library Source</div><hr style="width:100%;" />
/////////////////////////////////////////////////
// Step#2::DirNav::lib.rs                      //
//   - demos mock DirNav operations            //
//                                             //
// Jim Fawcett, 22 Jan 2021                    //
/////////////////////////////////////////////////

use std::path::{Path};

/*-----------------------------------------------
  Rust traits are similar to interfaces.

  Trait DirEvent requires implementer to be
  constructible and have members to handle
  DirNav events.

  Constructability allows DirNav to create an
  instance for a type defined by a generic 
  parameter.
*/
pub trait DirEvent {
    /*-- constructible --*/
    fn new() -&gt; Self;
    /*-- event handlers --*/
    fn do_dir(&amp;mut self, dir:&amp;Path);
    fn do_file(&amp;mut self, file: &amp;Path);
}

/*-----------------------------------------------
  DirNav searches directory tree looking for
  files with specified patterns (extensions).

  App is a DirNav member that implements 
  application specific processing of a 
  DirEvent sent by DirNav::visit.  
  
  See test1.rs in examples directory for an
  example App type.

  This DirNav is a mock type defined as an 
  illustration of what Step #2 needs.
*/
pub struct DirNav&lt;T&gt; 
       where T:DirEvent {
    app : T
}
impl&lt;T&gt; DirNav&lt;T&gt; 
       where T:DirEvent {
    pub fn new() -&gt; DirNav&lt;T&gt; {
        DirNav {
          app: T::new()  // factory function
        }
    }
    pub fn get_app(&amp;self) -&gt; &amp;T {
        &amp;self.app
    }
    pub fn visit(&amp;mut self, path: &amp;Path) {
        /* pretending to search a dir tree */
        self.app.do_dir(path);
        self.app.do_file(&amp;Path::new("file1"));
        self.app.do_file(&amp;Path::new("file2"));
        self.app.do_dir(&amp;Path::new("dir2"));
        self.app.do_file(&amp;Path::new("file3"));
    }
    pub fn path_to_string(
          path:&amp;Path) -&gt; String {
        format!("{:?}", path)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::{Path, PathBuf};
    struct App {
        test_file: PathBuf,
        test_dir: PathBuf
    }
    impl DirEvent for App {
        fn new() -&gt; App {
            App {
                test_file: PathBuf::from(""),
                test_dir: PathBuf::from("")
            }
        }
        fn do_dir(
          &amp;mut self, dir: &amp;Path
          ) {
            self.test_dir = dir.to_path_buf();
        }
        fn do_file(
          &amp;mut self, file: &amp;Path
          ) {
            self.test_file = file.to_path_buf();
        }
    }
    #[test]
    fn test_events() {
        let mut dn = DirNav::&lt;App&gt;::new();  
        let test_path = Path::new("test");
        dn.visit(test_path);
        let app = dn.get_app();
        let dir_app:String = 
          format!("{:?}", app.test_dir);
        let dir_rqt:String = 
          format!("{:?}", "dir2");
        assert_eq!(dir_app, dir_rqt);   
        let file_app = 
          format!("{:?}", app.test_file);
        let file_rqt = 
          format!("{:?}", "file3");
        assert_eq!(file_app, file_rqt);   
    }
}
          <div style="font-size:1.15rem; font-weight:bold;">DirNav Test Results</div><hr style="width:100%;" /><hr style="width:100%;" />
cargo test
    Finished test [unoptimized + debuginfo]
      target(s) in 0.01s
    Running target\debug\deps\...

running 1 test
test tests::test_events ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 
                 0 measured; 0 filtered out

          </left-content>
          <right-content class="code" style="font-size:0.9em;"><div style="font-size:1.15rem; font-weight:bold;">Test1 Example Source</div><hr style="width:100%;" />

/////////////////////////////////////////////////
// test1.rs - demonstrates mock DirNav ops     //
//                                             //
// Jim Fawcett, 22 Jan 2021                    //
/////////////////////////////////////////////////

use dir_nav::*;
use std::path::{Path};

/*-----------------------------------------------
  Type MyApp is a test type that:
  - is a generic parameter for DirNav&lt;App&gt;
  - responds to DirNav's events
  - can be retrieved with DirNav::get_app()
    and interrogated using its member functions.
*/
struct MyApp {}  // mock for TextSearch

impl DirEvent for MyApp {
    fn new() -&gt; Self {
        MyApp {}
    }
    fn do_dir(&amp;mut self, dir:&amp;Path) {
        print!("\n  directory: {:?}", dir);
    }
    fn do_file(&amp;mut self, file:&amp;Path) {
        print!("\n    file: {:?}", file);
    }
}
impl MyApp {
    pub fn show_type(&amp;self) {
        print!(
            "\n  my type is: {:?}", 
            std::any::type_name::&lt;MyApp&gt;()
        );
    }
}

fn main() {
    print!("\n  -- demonstrate mock DirNav --\n");

    let mut dn = DirNav::&lt;MyApp&gt;::new();
    let path = &amp;Path::new("dir1");
    dn.visit(path);
    println!();
    dn.get_app().show_type();

    print!("\n\n  That's all Folks!\n\n");
}<div style="font-size:1.15rem; font-weight:bold;">Test1 Example Output</div><hr style="width:100%;" />
C:\...\BuildOn\BuildOnStructure\Step2\DirNav>
cargo run --example test1
    Finished dev [unoptimized + debuginfo] 
      target(s) in 0.01s
    Running `target\debug\examples\test1.exe`

  -- demonstrate mock DirNav --

  directory: "dir1"
    file: "file1"
    file: "file2"
  directory: "dir2"
    file: "file3"

  my type is: "test1::MyApp"

  That's all Folks!


<div style="font-size:1.15rem; font-weight:bold;">Project Structure</div><hr style="width:100%;" />

<div class="light" style="display:block; white-space:normal;">
  <photosizer-block 
    src="pictures/ProjectStep2.jpg" 
    width="400" class="photoSizerBlock left"
    style="background-color: #fefefa;"  
  >
    <span style="font-family:'Comic Sans MS';">Figure 1. Project Structure - Step #2</span>
  </photosizer-block>
</div>

<div style="font-size:1.15rem; font-weight:bold;">cargo.toml</div><hr style="width:100%;" />
[package]
name = "dir_nav"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# comment elided

[lib]
doctest=false

[dependencies]
          </right-content>
        </two-column>
        </details>
        <t-b>
          You may wish to open this code in Visual Studio Code.  To do that, clone the 
          <a href="https://github.com/JimFawcett/BuildOn">BuildOn Repository</a>.  Then navigate to the cloned directory
          in a command window, cd into BuildOn/BuildOnStructure/Step2/DirNav, and emit the command <c-s>code .</c-s>, e.g.:
          <indent-block class="code">code .</indent-block>
          That will bring up VSCode with the library and test1 code loaded.
        </t-b>
        <t-b>
          You can do the same thing with the <a href="https://github.com/JimFawcett/RustTextFinder">RustTextFinder</a> 
          code. Clone the repository, then navigate into it in a command Widnow, and emit the command:
          <indent-block class="code">code .</indent-block>
          You then select the directory of the package you want to examine and build.
        </t-b>
        <div style="height:0.15em;">&nbsp;</div>
        <hr class="spread" />
        <a id="refs"></a>
        <h3>Step #2 References</h3>
        <t-b>
          The table below provides references relevant for Step #2 : DirNav.  The first links refer to specific
          regions of the Rust Story, from this site.  Other links go to Rust documentation. 
        </t-b>
        <t-b>
          You can look at the Rust Story by selecting the Rust Story link in the menu in the left panel.
        </t-b>
        <div style="height:0.5rem;">&nbsp;</div>
        <h4>Table 2. - Step #2 References</h4>
        <div>
          <table style="width:100%;" class="lightItem">
            <tr>
              <th class="darkItem" style="width: 10em;">Topic</th>
              <th class="darkItem" style-"width: auto;">Description</th>
              <th class="darkItem" style="width: 15em;">Link</th>
            </tr>
            <tr>
              <td>File System</td>
              <td>
                Rust has a well engineered facility for accessing files and directories.<br />
                Some key types in std::fs are: DirEntry, File, OpenOptions, ReadDir, ...
              </td>
              <td>
                <a href="../../RustStory_Libraries.html#fs">Rust story File System</a><br />
                <a href="https://doc.rust-lang.org/std/fs/index.html">std::fs</a><br />
                &nbsp;
              </td>
            </tr>
            <tr>
              <td>Error Handling</td>
              <td>
                Rust error handling is based on use of the enumeration:
                <demo-block>
                  <c-s>enum  Result&lt;T,E&gt; { Ok(T), Err(E), }</c-s>
                </demo-block>
                where T is the type of the returned value, E is the type of the expected error.  Rust enums are
                unique in that each of the enumertion items may be a wrapper for a specified type, like Ok and Err.
              </td>
              <td>
                <a href="../../RustStory_Data.html#enums">RustStory Enums</a><br />
                <a href="../../RustStory_Operations.html#errors">RustStory Error Handling</a><br />
                <a href="https://stevedonovan.github.io/rust-gentle-intro/2-structs-enums-lifetimes.html">Gentle Introduction to Rust</a>
                <a href="https://doc.rust-lang.org/std/result/">std::Result</a>
              </td>
            </tr>
            <tr>
              <td>Generics</td>
              <td>
                Generics in Rust are very similar to those in C# and Java, and simpler than C++ templates.
                They are code generators often do little more than substitute a specific type for a generic
                parameter.  Rust generics are often constrained with traits, as discussed above.
              </td>
              <td>
                <a href="../../RustStory_models.html#generics">Rust Story Generics</a><br />
                <a href="../RustBites/RustBites_Traits.html">Rust Bites Generics and Traits</a><br />
                <a href="https://doc.rust-lang.org/book/ch10-00-generics.html">The Rust Book</a><br />
              </td>
            </tr>
            <tr>
              <td>DesignBites</td>
              <td>
                A sequence of discussions of design structure alternatives with illustrating code:
                <div class="indent pad5">
                  Monolitic, Factored, DataFlow, Type Erasure, Plug-In
                </div>
              </td>
              <td>
                <a href="../DesignBites/DesignBites_Structure.html">Structure alternatives</a><br />
                <a href="../DesignBites/DesignBites_StructureDataFlow.html">Data Flow</a><br />
                <a href="../DesignBites/DesignBites_StructureTypeErasure.html">Type Erasure</a><br />
              </td>
            </tr>
            <tr>
              <th colspan="3" class="darkItem refsep">
                Start with first three refs, above.  Rest will be useful later.
              </th>
            </tr>
            <tr>
              <td>Ownership</td>
              <td>
                Rusts ownership rules: There is only one owner for any resource.  Owners deallocate their resources
                when they go out of scope.  Ownership can be transferred with a Move or borrowed with a reference.
                References don&apos;t own resources, they just borrow them, and so never deallocate.
                Rust ownership does not support simultaneously aliasing and mutation.
              </td>
              <td>
                <a href="../RustBites/RustBites_Ownrs.html">Rust Bites Ownership</a><br />
                <a href="../../RustStory_Models.html#ownership">Rust Story Ownership</a><br />
                <a href="https://depth-first.com/articles/2020/01/27/rust-ownership-by-example/">By Example</a><br />
                <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">Rust Book</a><br />
                <a href="https://doc.rust-lang.org/nomicon/ownership.html">Rust Nomicon</a><br />
              </td>
            </tr>
            <tr>
              <td>Strings</td>
              <td>
                Rust std strings come in two flavors: <c-s>String</c-s> and <c-s>str</c-s>, representing
                string objects and literal strings.  Each contains utf-8 characters.  The Rust library path
                also provides PathBuf, similar to String, and Path, similar to &str, but uses the encoding
                for paths provided by the current platform, e.g., Windows, Linux, or macOS.
              </td>
              <td>
                <a href="https://doc.rust-lang.org/std/path/index.html">std::path</a><br />
                <a href="https://doc.rust-lang.org/std/path/struct.PathBuf.html">std::path::PathBuf</a>
                <a href="https://doc.rust-lang.org/std/path/struct.Path.html">std::path::Path</a><br />
                <a href="https://doc.rust-lang.org/rust-by-example/std_misc/path.html">Rust by Example</a>
              </td>
            </tr>
            <tr>
              <td>struct</td>
              <td>
                Rust structs serve the same role as classes do in C++ and C#.  Struct methods are
                defined inside impl StructName {} blocks.
              </td>
              <td>
                <a href="../../RustStory_Data.html#structs">Rust Story structs</a><br />
                <a href="https://doc.rust-lang.org/std/keyword.struct.html">std::Stuct</a><br />
                <a href="https://doc.rust-lang.org/std/keyword.impl.html">keyword impl</a>
              </td>
            </tr>
          </table>
        </div>
        <t-b>
          You don&apos;t need to use all of the references in the right-most column.  Just look at
          each quickly and use the one(s) that work(s) best for you.
        </t-b>
        <!--<div style="height:1.0em;">&nbsp;</div>
        <hr class="spread" />
        <a id="code"></a>
        <h3>Starter Code</h3>
        <t-b>
          This section contains a simple code example showing how to:
          <ol>
            <li>
              Define a struct with methods - similar in use to a C++ or C# class.
            </li>
            <li>
              Build a library that contains the struct and test its methods.
            </li>
            <li>
              Link the static library to a test console application and run that.
            </li>
          </ol>
        </t-b>
        <div style="height:0.75em">&nbsp;</div>
        <details>
          <summary class="dark" style="width:max-content;">Starter Code Example</summary>
        <two-column style="width:max-content;">
          <left-content class="code" style="font-size:0.9em;">/////////////////////////////////////////////////////////////
/// BuildOn::step_1::lib.rs
///
/// Jim Fawcett, https://JimFawcett.github.io, 23 Nov 2020 
/////////////////////////////////////////////////////////////
/// This demo illustrates how you define structs and use them
/// like you do classes in C++ and C#.
/// 
/// This package builds a static library.  There is a console
/// application, called test1 in the examples directory, sister
/// to the src directory where this file resides.
/// 
/// test1 uses this library by declaring:
///   uses step_1::*;
/// e.g., use any of the facilities provided by this library.
/// The name, step_1, is defined in Cargo.toml.
/// 
/// You build test1 and link to this library with cargo command:
///   cargo run --example test1
/// Note that option is example (singular) even though directory
/// name is examples.
///////////////////////////////////////////////////////
/// Rust Notes:
/// 1. Two string types are defined in the std library
///    a. String is a type that manages a collection of
///       utf-8 characters in the native heap.
///    b. str is a type that represents literal strings
///       stored in stack or static memory, e.g., fixed
///       size arrays of utf-8 characters.
///    c. str instances are almost always managed through
///       references, e.g., &str
///    d. It is easy to convert between String and str 
///       types - see code below.
/// https://github.com/Dhghomon/easy_rust#strings
/// 2. Rust uses Structs where C++ and C# use classes.
///    e. Methods are defined using impl blocks, as shown
///       below.
///    f. Associated methods, like new are not declared 
///       with a reference to self.  They act like C++
///       static methods.
///    g. All other methods are declared with a reference
///       to self, which may be mutable.  On invocation,
///       &self or &mut self is passed to the method code
///       implicitly, e.g., not supplied by the using
///       code. 

/// Debug, Clone, and Default are traits, much like Java 
/// or C# interfaces.
/// Some traits, like these can be implemented by the 
/// compiler.  The
/// #[derive(Debug, Clone, Default)] annotation is asking
/// the compiler to do that.
/// 
#[derive(Debug, Clone, Default)]
pub struct Demo {
    value: f64,
    name: String
}

impl Demo {
    /// static constructor method
    /// -----------------------------------------
    pub fn new() -> Self {
        Demo {
            value: 0.0,
            name: String::from("un_named"),
        }
    }
    /// method that sets Demo::value to v
    /// -----------------------------------------
    pub fn set_value(&mut self, v:f64) {
        self.value = v
    }
    /// method that retrieves Demo::value
    /// -----------------------------------------
    pub fn get_value(&self) -> f64 {
        self.value
    }
    /// method that sets Demo::name
    /// -----------------------------------------
    /// Note that nm is passed by reference &str
    /// If we passed by value, e.g., nm:String
    /// that would move nm into the function and
    /// it would become invalid in the caller's scope
    /// -----------------------------------------
    pub fn set_name(&mut self, nm:&str) {
        self.name = String::from(nm);
    }
    /// method returns name as a reference
    /// -----------------------------------------
    pub fn get_name(&self) -> &str {
        &self.name
    }
}//////////////////////////////////////////////////////
/// Testing:
/// ---------------------------------------------------
/// Rust libraries can be configured with unit tests,
/// as you see below.  You run them with the command:
///   cargo test
/// By default, cargo runs each test on separate thread,
/// so you can not count on the ordering of tests.
/// If you want to run all tests on single thread, which
/// will preserve test order, use the command: 
///   cargo test -- --test-threads=1
#[cfg(test)]
/// Notes:
/// 1. test_construct() uses typ_name method from std::any
/// 2. All tests use the fact that private data in struct
///    is accessible (only) within the defining library
mod tests {
    use super::*;
    #[test]
    fn test_construct() {
        let demo = Demo::new();
        let tn = std::any::type_name::<Demo>();
        assert_eq!(tn, "step_1::Demo");
        assert_eq!(demo.value, 0.0);
        assert_eq!(demo.name, "un_named".to_string());
    }
   #[test]
   fn test_setters() {
        let mut demo = Demo::new();
        demo.set_name("test2");
        demo.set_value(3.14159);
        assert_eq!(demo.name, "test2".to_string());
        assert_eq!(demo.value, 3.14159);
   }
   #[test]
   fn test_getters() {
       let mut demo = Demo::new();
       demo.name = String::from("test3");
       demo.value = 0.33333;
       assert_eq!(demo.get_name(), "test3".to_string());
       assert_eq!(demo.get_value(), 0.33333);
   }
}
          </left-content>
          <right-content class="code" style="font-size:0.9em;">
Microsoft Windows [Version 10.0.19042.685]
(c) 2020 Microsoft Corporation. All rights reserved.

C:\github\JimFawcett\BuildOn\step_1>
cargo test
   Compiling step_1 v0.1.0 
     (C:\github\JimFawcett\BuildOn\step_1)
   Finished test [unoptimized + debuginfo] target(s)
     in 1.24s  
   Running target\debug\deps\step_1-acfe1e9cd7ec2332.exe      

running 3 tests
test tests::test_construct ... ok
test tests::test_getters ... ok
test tests::test_setters ... ok

test result: 
   ok. 3 passed; 0 failed; 0 ignored; 0 measured; 
       0 filtered out


C:\github\JimFawcett\BuildOn\step_1>
cargo run --example test1
    Finished dev [unoptimized + debuginfo] target(s)
      in 0.02s   
    Running `target\debug\examples\test1.exe`

  -- Demonstration of Demo type --

  demo.name  = "un_named"
  demo.value = 0.0

  demo.name  = "JoeDemo"
  demo.value = 0.5

  That's all Folks
          </right-content>
        </two-column>
        </details>
        <t-b>
          You will need to know how to implement code like this for Step #1, where we build the TextSearch package
          and test it.
        </t-b>
        <t-b>
          You may wish to open this code in Visual Studio Code.  To do that, clone the 
          <a href="https://github.com/JimFawcett/BuildOn">BuildOn Repository</a>.  Then navigate to the cloned directory
          in a command window, cd into step_1, and emit the command <c-s>code .</c-s>, e.g.:
          <indent-block class="code">code .</indent-block>
          That will bring up VSCode with the library and test1 code loaded.
        </t-b>
        <t-b>
          You can do the same thing with the <a href="https://github.com/JimFawcett/RustTextFinder">RustTextFinder</a> 
          code. Clone the repository, then navigate into it in a command Widnow, and emit the command:
          <indent-block class="code">code .</indent-block>
          You then select the directory of the package you want to examine and build.
        </t-b>-->
        <div style="height:10em;">&nbsp;</div>
        <a id="bottom"></a>
         </main-right>
       </main-wrapper>
     </grid-main>
     <grid-footer class="light">
       <footer-wrapper>
         <footer-left class="dark" onclick="togglemenus()">
           &nbsp;toggle&nbsp;menu&nbsp;
         </footer-left>
         <footer-right id="sects" style="display:flex; padding:0em 1em;">
           <ul>
             <li><a href="#dirnav">DirNav Pkg</a></li>
             <li><a href="#step2">Build DirNav</a></li>
             <li><a href="#refs">References</a></li>
           </ul>
         </footer-right>
       </footer-wrapper>
     </grid-footer>
   </grid-container>
</body>
</html>