<!DOCTYPE html>
<!--
  TestGrid2.html
  -------------
  This page is a prototype for pages that provide:
  - Header block at the top
  - page menu in the left panel
  - content in the right panel
  - content section links in a footer block
  Its design uses:
  - CSS grid to lay out the page in three rows, header, main, footer
  - The grid is fixed to the viewport using margins and height attributes
  - flex grid in the main row to hold the page menu and content panels
  - flex grid in the footer holding a toggle button and section links
  - JavaScript to respond to the toggle button by:
    a. Setting the menu panel display to none or block which toggles
       its visibility and space
    b. Setting the right area in the footer to a menu of section links
       or a copyright notice.
  This is a test prototype for story pages.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Step #0</title>
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <link rel="stylesheet" href="css/StylesStoryAbsGridPage.css" />
  <!--<script src="js/ScriptsStoryAbsGridPage.js"></script>-->
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <!--<script src="js/ScriptsMenuRustRepo.js"></script>-->
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <!--<link rel="stylesheet" href="css/StylesTemplate.css" />-->
  <link rel="stylesheet" href="css/StylesStoryDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <script>
    function init() {
      togglemenus();
    }
    let toggleState = 0;
    function togglemenus() {
      let nav = document.getElementById("nav");
      let sec = document.getElementById("sects");
      if (toggleState === 1) {
        nav.style = "display:none";
        sec.innerHTML = "Jim Fawcett &copy; 2020";
        sec.style = "text-align:center; padding: 0.25em 0em;";
        toggleState = 0;
      }
      else {
        nav.style = "display:block";
        sec.innerHTML = 
          "<div class='left' style='width:1em;'>&nbsp;</div>" +
          "<ul>" +
          "<li><a href='#buildon'>BuildOn</a></li>" +
          "<li><a href='#textfinder'>TextFinder</a></li>" +
          "<li><a href='#rust'>Why Rust?</a></li>" +
          "<li><a href='#tooling'>Tooling</a></li>" +
          "<li><a href='#code'>Code Starter</a></li>" +
          "<li><a href='#bottom'>Bottom</a></li>" +
          "</ul>";
        sec.style = "display:flex; padding:0em;";
        toggleState = 1;
      }
    }
  </script>
</head>
<body id="github" onload="togglemenus()">
   <grid-container>
     <grid-header class="dark" onclick="togglemenus()">
       <h2 class="dark">BuildOn Introduction</h2>
     </grid-header>
     <grid-main>
       <a href="#top"></a>
       <main-wrapper>
         <main-left id="nav" class="light">
           <ul>
            <li><a href="../../index.html">Home</a></li>
            <li><a href="../../BuildOn.html">Repo</a></li>
            <li><a href="Step0.html">Introduction</a>&nbsp;&nbsp;</li>
            <li class="undefined"><a href="JavaScript;:">Step #1</a>&nbsp;&nbsp;</li>
            <li class="undefined"><a href="JavaScript;:">Step #2</a>&nbsp;&nbsp;</li>
            <li class="undefined"><a href="JavaScript;:">Step #3</a>&nbsp;&nbsp;</li>
            <li class="undefined"><a href="JavaScript;:">Step #4</a>&nbsp;&nbsp;</li>
            <li class="undefined"><a href="JavaScript;:">Step #5</a>&nbsp;&nbsp;</li>
            <li class="undefined"><a href="JavaScript;:">Step #6</a>&nbsp;&nbsp;</li>
            <li><a href="../../IndexPage.html">Glossary</a>&nbsp;&nbsp;</li>
            <li><a href="../../RustStory_References.html">References</a>&nbsp;&nbsp;</li>
           </ul>
         </main-left>
         <main-right class="light">
         <a id="buildon" name="buildon"></a>
        <h3>BuildOn</h3>
        <t-b>
          BuildOn is a process for learning Rust programming by writing code.  You need to have
          some skill in a modern programming language, but need have no past experience with Rust. The
          process takes you through a series of steps building one interesting, not too complex,
          project.
        </t-b>
        <t-b>
          For each step you will find a specification for the step&apos;s final product, along with
          discussion and links to information you need to implement that part.  Each succeeding step
          adds another part to the project.  Steps are organized so that you only need to learn a 
          relatively small part of Rust to complete.  Later steps get into progressively more language
          details.
        </t-b>
        <div style="height:0.5em;">&nbsp;</div>
        <a id="textfinder"></a>
        <h3>TextFinder</h3>
        <div style="width:calc(100% - 1em);">
          <photosizer-block 
            src="pictures/TextFinderPackages.jpg" 
            width="300" class="photoSizerBlock right clear"
            style="    background-color: #fef9ee;"  
          >
            <span style="font-family:'Comic Sans MS';">Figure 1. TextFinder Packages</span>
          </photosizer-block>
        </div>
        <t-b>
          TextFinder is a program that accepts from its command line a path, a set of file patterns,
          a text specifier, and zero or more options.  It returns the path and name of each file that
          contains text matching the specifier.
        </t-b>
        <t-b>
          The TextFinder program is small enough to be relatively easy to understand, but rich enough
          to use a lot of the most important features of Rust.  The first four steps will build:
          TextSearch, DirNav, CmdlnParser, and Executive and Display packages, in that order.
          That is enough to build a fully function and useful tool.
        </t-b>
        <t-b>
          To that, we will add extensions for processing regular expressions for representing text to 
          match and file patterns.  Finally we wrap the TextSearch package with a package that supports
          parallel execution of text searches.
        </t-b>
        <indent-block>
        <h4>TextFinder Specification:</h4>
        <t-b>
          <ol class="tight">
            <li>
              Identify all files in a directory subtree that matcha a pattern and contain a specified text.
            </li>
            <li>
              Specify root path, one or more file patterns (.h, .cpp, .cs, .rs, ...), and search text on command line.
            </li>
            <li>
              Display file name and path, withou duplication of path name, e.g., organized by directory, for files
              containing the search text.
            </li>
            <li>
              Interesting externsions:
              <ul class="tight">
                <li>
                  Replace text by regular expressions for both search text and file patterns.
                </li>
                <li>
                  Replace sequential file searches with parallel searches to improve performance and useability.
                </li>
              </ul>
            </li>
          </ol>
        </t-b>
        </indent-block>
        <t-b>
          TextFinder structure is shown in the package diagram, Fig. 1.  The Executive uses
          CmdlnParser to extract parameters and options from the commandline.  Executive then
          creates instances of DirNav and TextSearch, passing a reference to TextSearch to DirNav,
          allowing DirNav to call TextSearch each time it finds a file of the specified patterns.
        </t-b>
        <t-b>
          TextSearch seeks specified text and if found sends the path and file name to
          Display.  The Dislay package turns the sequence of successful search completion events
          into useful information for the user.
        </t-b>
        <div style="height:0.5em;">&nbsp;</div>
        <a id="rust"></a>
        <h3>Why Rust?</h3>
        <t-b>
          Rust is an interesting language, combining memory safety of C# and Java with
          performance of C++.  Unlike these languages, Rust also provides data race safety.
        </t-b>
        <t-b>
          Using modern idioms, one can build, with C++, memory safe programs without data
          races.  But when building large systems, with many thousands of lines of code, it is easy to forget to use an idiom or
          unintentionally share data between threads without proper locking, in a handful of source
          code lines.  
        </t-b>
        <t-b>
          Rust, however,
          ensures memory and data safety by construction.  Code with unsafe memory access and
          data races will fail to compile.  It accomplishes that with an intersting ownership model
          that we will explore in later steps in this BuildOn process.
        </t-b>
        <div style="height:55em;">&nbsp;</div>
        <a id="bottom"></a>
         </main-right>
       </main-wrapper>
     </grid-main>
     <grid-footer class="light">
       <footer-wrapper>
         <footer-left class="dark" onclick="togglemenus()">
           &nbsp;toggle&nbsp;menus&nbsp;
         </footer-left>
         <footer-right id="sects" onclick="location.reload()">
           Jim Fawcett &copy; 2020
         </footer-right>
       </footer-wrapper>
     </grid-footer>
   </grid-container>
</body>
</html>