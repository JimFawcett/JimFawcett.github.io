<!DOCTYPE html>
<html>
<!--
  Bits_DataRust.html
-->
<head>
  <title>Bits_Data Rust</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeDefault.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBits.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding:0.75em 1.5em;
      margin-top:1.25em;
      margin-bottom:1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width:50em;
    }
    #github h2 {
      margin-top: 0.75em;
    }
    #github #pagetitle {
      border:2px double var(--dark);
    }
    #github form {
      border:none;
      padding:0.5em 1em;
    }
    #github form span {
      padding:0em 0.5em;
    }
    #github code-container {
      display: flex;
      position:relative;
      width:calc(100%);
      flex-direction: row;
      justify-content: space-between;
      /*border-top: 1px solid var(--dark);*/
    }
    #github code-banner {
      display: block;
      border: 2px solid var(--dark);
      border-top:none;
      border-bottom:none;
      padding: 0.25em 1em;
      font-family: 'Comic Sans MS', Tahoma;
      width: calc(100% + 0.5em);
      background-color: var(--atten);
    }
    #github code-display {
      display: block;
      border: 2px solid var(--dark);
      white-space: pre;
      padding: 0.75em 1em;
      font-family: Consolas, monospace;
      font-size:0.9em;
      width: calc(50% - 0.5em);
      overflow-x: auto;
      /*height:20em;*/
    }
    #github label {
      margin-right:1em;
    }
    #github fieldset {
      border:none;
    }
    #github #exeRight, #exeLeft {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github #hideLeft, #hideRight {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github .hide {
      display:none;
    }
    body {
      position:relative;
    }
    #github table.showcode {
      table-layout:fixed;
      width:calc(100% + 4em);
      margin-left:-2em;
    }
    #github th.leftblock {
      border: 2px solid var(--dark);
      /*border: 1px solid red;*/
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.rightblock {
      border: 2px solid var(--dark);
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.centerblock {
      border: none;
      padding: 0em;
      width:1em;
    }
    #github td.leftblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em);
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.leftblock summary {
      border:1px solid #ffffbb;
    }

    #github td.rightblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em) !important;
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.rightblock summary {
      border: 1px solid #ffffbb;
    }

    #github td.centerblock {
      border: none;
      padding: 0em;
    }
    #github pre {
      overflow-x: auto !important;
    }
    #github #left1 {
      /*height:45em;*/
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }

    #github #right1 {
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }
    #github #left2 {
      /*height:45em;*/
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right2 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github #left3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github .mover {
      width:2em;
      padding: 0.05em;
      position:relative;
      right:-1.5em;
      top:0.6em;
    }
    #github #ruler {

      width:calc(50% - 1.5em);
      height:0.001em;
      margin:-0.45em 0em;
    }
    #github .btns {
      width:3em;
      border:none;
    }
    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 10px;
    }
    #github .remotebutton {
      padding:0.25em 0.5em;
    }
    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }
    #github hr.spread {
      margin:0.75em 0em;
    }
    #github pre {
      width: max-content;
      min-width: 20em;
      max-width: 60em;
      user-select: all;
    }
    #github {
      user-select: none;
    }
    .code-container {
      display: flex;
      flex-direction: column;
      border: 1px solid red;
      width:max-content;
      margin:0em; padding:0em;
    }
    .code-block {
      /*display:flex;*/
      margin: 0.0em 1em;
      font-family: monospace;
    }
    .focus {
      padding:0.5em 1.0em 0.5em 1.0em;
      /*border:1px solid red;*/
    }
    *.focus ul {
      padding-top:-0.5em;
      /*background-color:green;*/
    }
    .cat {
      text-align:left;
      background-color: var(--menu);
    }
  </style>
  <script>
    function saveScroll() {
      let main = document.querySelector("main");
      localStorage.setItem("DataRust", main.scrollTop);
    }
    function getScroll() {
      let scroll = localStorage.getItem("DataRust");
      if (scroll) {
        scrollTop = parseInt(scroll, 10);
        let main = document.querySelector("main");
        main.scrollTop = scrollTop;
      }
    }
  </script>

  <script>
    function remote() {
      window.open('https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ac93fd553ca70f9f6258bf0253bea2b3', '_blank');
    }
  </script>
</head>
<body id="github" onload="initialize()" onbeforeunload="saveScroll()">

  <a id="Next" href="Bits_ObjectsRust.html">Next</a>
  <a id="Prev" href="Bits_HelloRust.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="page">Bits Data Rust</div>
      <div id="modified">08/06/2023</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content id="content">
        <div class="rightPanelLinks">
          <a href="Bits_DataCpp.html">C++</a>
          <a class="darkItem" href="Bits_DataRust.html">Rust</a>
          <a href="Bits_DataCSharp.html">C#</a>
          <a href="Bits_DataPython.html">Python</a>
          <a href="Bits_DataJs.html">JvScrpt</a>
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits_Data Rust</h1>
            <h3 id="subtitle" class="indent">
              code, output, and build for Rust on Windows, macOS, and Linux
            </h3>
          </hgroup>
        </header>
        <t-b>
          This page guides you through the rust type system in several sections:
          <ul class="tight">
            <li>
              <a href="#syn">Synopsis</a>
            </li>
            <li>
              <a href="#types">summary of Rust types</a>
            </li>
            <li>
              <a href="#typesys">type system</a>
            </li>
            <li>
              <a href="init">variable initialization</a>
            </li>
            <li>
              <a href="safety">Rust safety</a>
            </li>
            <li>
              <a href="own">Ownership</a>
            </li>
            <li>
              <a href="mutref">Rust References</a>
            </li>
            <li>
              <a href="move">Copy, Move, and Clone</a>
            </li>
          </ul>
          The menu bar at the lower right has links to each of these, so they are always in view
          anywhere in this page. It&apos;s view is toggled with the Sections bottom menu item.
          </t-b>
          <t-b style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
            <h4 id="syn" style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
            This page demonstrates simple uses of the most important Rust types.
            The purpose is to quickly acquire some familiarity with types and their uses.
            <hr class="spread" />
            <ul>
              <li>
                Rust provides two categories of types: copy and move. Copy types occupy a single contiguous
                block of stack memory. Move types have control blocks in stack memory used to manage
                resources in the heap.
              </li>
              <li>
                Primitive types and aggregates of primitive types are copy.  Construction, assignment, and
                pass-by-value copies the source&apos;s value to the destination.
              </li>
              <li>
                All other types are move. Construction, assignment, and pass-by-value move ownership
                of the value&apos;s heap resources to the destination.
                This makes the source invalid. Attempting to use a &quot;moved&quot; variable is a
                compile error.
              </li>
              <li>
                The source and destination of copy and move operations must have exactly the same type.
              </li>
              <li>
                More details about copy and move operations can be found 
                <a href="../RustBites/RustBites_Data.html">here</a>, including diagrams and code examples.
              </li>
              <li>
                Most move types provide clone operations that support making copies, but using
                code must explicitly call clone().
              </li>
              <li>
                Rust supports making fixed references to either copy or move types. These may
                refer to instances in a function&apos;s stack memory, in the native heap, 
                or in the program&apos;s static memory.
              </li>
              <li>
                Rust references are constrained by Rust ownership rules to support memory
                and data race safety by construction. All values in memory have a single owner,
                responsible for its creation, access, and deallocation.
              </li>
              <li>
                Ownership can be borrowed by creating a reference. Program code may create an
                arbitrary number of non-mutable references to some variable, but may only create
                a single mutable reference that borrows exclusive access to the variable.
              </li>
              <li>
                Here we begin to see significant differences between the languages, especially
                when comparing statically typed languages like C++, Rust, and C#, with dynamically typed
                languages like Python and JavaScript.
              </li>
            </ul>
            <div style="height:0.25em;"></div>
          </t-b>
        <div style="height:0.25em;"></div>
        <details id="types">
          <summary class="darkItem">Rust&nbsp;Types&nbsp;</summary>
          <h3>Table 1.0 Rust Types</h3>
          <table style="font-size: 0.9em; max-width: 71em;">
            <tr>
              <th style="width:15em;">Type</th><th>Comments</th><th>Example</th>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Integral types ----</th>
            </tr>
            <tr>
              <td><c-s>bool</c-s></td><td>values true and false</td><td><c-s>let b = true;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>i8, i16, i32, i64, isize, u8, u16, u32, u64, usize</c-s>
              </td>
              <td>signed and unsigned integer types</td><td><c-s>let i = 42i8;</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Floating point types ----</th>
            </tr>
            <tr>
              <td><c-s>f32, f64</c-s></td>
              <td>values have finite precision, and may have approximate values</td>
              <td><c-s>let f:f32 = 3.14159;</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- literal string types --</th>
            </tr>
            <tr>
              <td><c-s>&str</c-s></td>
              <td>A literal string</td>
              <td>
                <c-s>let ls = "literal string";<br />let second = ls.chars().nth(1);</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>&str</c-s></td>
              <td>Slice of a literal string</td>
              <td><c-s>let slice = &ls[1..5];<br /></c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Aggregate types ----</th>
            </tr>
            <tr>
              <td><c-s>[T; N]</c-s></td>
              <td>An array of N elements all of type <c-s>T</c-s></td>
              <td>
                <c-s>let arr = [1, 2, 3, 2, 1];<br />let first = arr[0];</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>&[T]</c-s></td>
              <td>Slice of array of elements of type <c-s>T</c-s></td>
              <td>
                <c-s>let arrs = &arr[1..3];<br />let second = arrs[1];</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>Tupl</c-s></td>
              <td>collection of heterogeneous types accessed by position</td>
              <td>
                <c-s>
                  let tu = (42i32, 3.14159f64, 'z');<br />let third = tu.2;
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>Result&lt;T,E&gt;</c-s></td>
              <td>Result enum holds result <c-s>Ok(t:T)</c-s> or <c-s>Err(e:E)</c-s></td>
              <td><c-s>fn doOp1(..args) -> Result&lt;r:R, e:Err&gt;</c-s></td>
            </tr>
            <tr>
              <td><c-s>Option&lt;T&gt;</c-s></td>
              <td>Option enum holds optional value <c-s>Some(t:T)</c-s> or <c-s>None</c-s></td>
              <td><c-s>fn doOp2(..args) -> Option&lt;T&gt;</c-s></td>
            </tr>
            <tr><th colspan="3" class="cat">-- Std::library types ----</th></tr>
            <tr>
              <td><c-s>String</c-s></td><td>Expandable collection of utf-8 characters allocated in the heap</td>
              <td><c-s>let strg = "a utf-8 String".to_string();</c-s></td>
            </tr>
            <tr>
              <td><c-s>Vec&lt;T&gt;</c-s></td>
              <td>Expandable generic collection of items of type <c-s>T</c-s></td>
              <td><c-s>let v = Vec::&lt;f64&gt;::new(), v.push(1.5); ...</c-s></td>
            </tr>
            <tr>
              <td><c-s>VecDeque&lt;T&gt;</c-s></td>
              <td>Expandable double-ended generic collection of items of type <c-s>T</c-s></td>
              <td>
                <c-s>let vd = VecDeque::&lt;f64&gt;::new(),<br /> 
                v.push_front(1.5); ...</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>HashMap&lt;K,V&gt;</c-s></td>
              <td>Associative container of Key-Value pairs, held in a table of bucket lists.</td>
              <td>
                <c-s>let map = HashMap::&lt;&str, int&gt;::new(),<br />  
                map.insert("zero", 0); ...</c-s>
              </td>
            </tr>
            <tr>
              <td>LinkedList, BTreeMap, HashSet, BTreeSet, BinaryHeap, ...</td>
              <td>
                The Rust std::library defines types for threading and synchronization,<br />
                reading and writing to streams, anonymous functions, ...
              </td>
              <td><a href="https://doc.rust-lang.org/std/">Crate std</a></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- User-defined Types --</th>
            </tr>
            <tr>
              <td>User-defined types</td>
              <td colspan="2">Based on structs and enums, these will be discussed in the next Bit.</td>
            </tr>
          </table>
          <div style="height:0.5em;"></div>
        </details>
        <div style="height:0.5em;"></div>
        <details id="typesys">
          <summary class="darkItem">Rust Type System</summary>
          <h3>Table 2. Rust Copy and Move Operations</h3>
          <table style="font-size:0.9em; max-width:65em;">
            <colgroup>
              <col span="1" style="width:12%;" />
              <col span="1" style="width:12%;" />
              <col span="1" style="width:38%;" />
              <col span="1" style="width:38%;" />
            </colgroup>
            <tr>
              <th>Operation</th><th>Example</th>
              <th><a target="_blank" href="../../Pictures/StrCopy.jpg">Copy type</a></th>
              <th><a target="_blank" href="../../Pictures/StringMove.jpg">Move type</a></th>
            </tr>
            <tr>
              <td>Construction</td>
              <td><c-s>let t:T = u:T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is copied to <c-s>t</c-s>,<br /><c-s>u</c-s> is still valid</td>
              <td><c-s>u</c-s>&apos;s value is moved to <c-s>t</c-s>,<br /><c-s>u</c-s> now invalid</td>
            </tr>
            <tr>
              <td>Assignment</td>
              <td><c-s>t:T = u:T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is copied to <c-s>t</c-s>,<br /><c-s>u</c-s> is still valid</td>
              <td><c-s>u</c-s>&apos;s value is moved to <c-s>t</c-s>,<br /><c-s>u</c-s> now invalid</td>
            </tr>
            <tr>
              <td>Pass-by-value</td>
              <td><c-s>fn doOp(t:T)</c-s></td>
              <td><c-s>t</c-s>&apos;s value is copied to doOp stack frame,<br /><c-s>t</c-s> is still valid</td>
              <td><c-s>t</c-s>&apos;s value is moved to doOp stack frame,<br /><c-s>t</c-s> is now invalid</td>
            </tr>
          </table>

          <h3>Table 3. Rust Copy and Move Types</h3>
          <table style="font-size:0.9em; max-width:65em;">
            <colgroup>
              <col span="1" style="width:20%;" />
              <col span="1" style="width:45%;" />
              <col span="1" style="width:35%;" />
            </colgroup>
            <tr>
              <th>Property</th><th>Members</th><th style="max-width:7em;">Notes</th>
            </tr>
            <tr>
              <td>Primitive types</td>
              <td>integers, floats, literal strings</td>
              <td>These are all copy types</td>
            </tr>
            <tr>
              <td>Aggregate types</td>
              <td>arrays, slices of arrays, tuples, Result&lt;T,E&gt;, Option&lt;T&gt;</td>
              <td>These are copy types if their members are copy, otherwise they are move types</td>
            </tr>
            <tr>
              <td>std::library collection types</td>
              <td>String, Vec&lt;T&gt;, VecDeque&lt;T&gt;, HashMap&lt;K,V&gt;, ...</td>
              <td>These are all move types</td>
            </tr>
          </table>
          <t-b>
            <h3>Table 4. Rust Type System Attributes</h3>
          </t-b>
          <table  style="font-size:0.9em; max-width:65em;">
            <tr>
              <td>Static typing</td>
              <td>
                All types are known at compile time and are fixed throughout program execution.
              </td>
            </tr>
            <tr>
              <td>Inference</td>
              <td>
                Compiler infers types in expressions if not explicitly annotated.
                Occasionally inference fails and explicit annotation is required.
              </td>
            </tr>
            <tr>
              <td>Strong typing</td>
              <td>
                Types are exhaustively checked and there are very few implicit conversions.
                <ul class="tight">
                  <li>Numeric and boolean literals coerce to their correspoinding type, e.g., 42 to i32.</li>
                  <li>Variables without type annotations are coerced to their minimal types</li>
                  <li>Values can be coerced to a more specific type of same or larger size.</li>
                  <li>
                    Smart pointers like Box, Rc, Arc, ... implement the DeRef trait, supplying a method
                    deref() that returns a reference to their inner values. Applying * to these types
                    automatically calls deref() to return an inner reference.
                  </li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Algebraic data types</td>
              <td>
                Types created using enums and structs. Unlike other languages, Rust enums can
                hold named discriminants with associated data of arbitrary type. That combined with Rust&apos;s
                matching operations simplify state and error handling.<br />
                Examples: <c-s>Result&lt;T,E&gt; { Ok(T), Err(E), }, Option&lt;T&gt; { Some(T), None, }</c-s><br />
                Matching:<pre><c-s>    match result {
       Ok(value) => { // do something with value },
       Err(error) => { // do something with error }
    }
</c-s></pre>
              </td>
            </tr>
            <tr>
              <td>Generics</td>
              <td>
                Generics provide types and functions with unspecified parameters, 
                supporting code reuse and abstraction 
                over types. Generic parameters are specified at the call site, often bound by constraints,
                e.g., <c-s>fn doOp&lt;T:Debug, Clone&gt;(t:T)</c-s>.<br />
                The function <c-s>doOp</c-s> compiles only if <c-s>T</c-s> satisfies its named trait bounds
                <c-s>Debug</c-s> supporting use of format <c-s>{:?}</c-s> and 
                <c-s>Clone</c-s> supporting explicit copy with <c-s>clone()</c-s>.
              </td>
            </tr>
            <tr>
              <td>Traits</td>
              <td>
                Traits are similar to Java and C# interfaces. They defined shared behavior that types can 
                implement, supporting abstraction over behavior. Traits define behavior by declaring trait
                specific functions. A trait may, but need not, define its function&apos;s contents.
                Generics and Traits are covered <a href="Bits_GenericRust.html">here</a>.
              </td>
            </tr>
          </table>
        </details>
        <div style="height:0.5em;"></div>
        <h2 id="init">1.0 Initialization</h2>
        <t-b>
          Rust types are initialized with a let statement that binds a variable name to a memory location
          with specified value.
        </t-b>
        <h3>Example: primitive type initializations</h3>
        <div style="float:left; margin-left:1em; padding-right:2em;">
          <pre><code class="language-rust">let i = 42i8;         // data type specified
  // size: 1 byte => 8bits
let f:f32 = 3.14159;  // variable type specified
  // size: 4 bytes
let c:char = 'z';
  // size: 4 bytes, enough to hold utf-8 character 
let sl:&str = "a literal string";
  // size: 16 bytes, all its characters are 1 byte
let arr:[i32; 3] = [1, 2, 3];
  // array size: 12 bytes
let tp: (i32, f64, char) = (1, 2.5, 'a');
  // tuple size: 16 bytes
let iref: &i8 = &amp;i;
  // size: 8 bytes, a reference to i&apos;s value
let aref: &[i32; 3] = &arr;
  // size: 8 bytes, a reference to arr&apos;s values
/*--------------------------------------------
  All sizes are space allocated in local
  stack frame.
*/</code></pre>
        </div>
        <t-b>
          Type specifications like i8 and f64 can be applied to the variable name or to it&apos;s initializing
          data, as shown here. 
        </t-b>
        <t-b>
          Rust can usually infer appropriate types for data, but a code developer can
          explicitly define them.
          If the type annotations were removed in this example, Rust would infer i to be i32 and f to be f64.
        </t-b>
        <t-b>
          The char type occupies 4 bytes of storage, large enough to hold any of the utf-8 characters.
        </t-b>
        <t-b>
          The type <c-s>&str</c-s> is a reference to a fixed-size immutable literal string in stack memory. 
          It may hold
          any of the utf-8 characters. It&apos;s size is the sum of the actual literal character sizes.
          For the literal string shown, all of the characters are 1 byte.
        </t-b>
        <t-b>
          Arrays are fixed size sequences of values of the specified type.  They are indexable and individual
          element values may be changed if the array has mutable type.
        </t-b>
        <t-b>
          Tuples are sequences of values of heterogeneous types.  Elements are accessed via position
          arguments, e.g., tp.1 accesses the second element, a float.
        </t-b>
        <t-b>
          References like &arr are fixed pointers to the beginning of the variable&apos;s data storage. 
        </t-b>
        <div style="clear:both;"></div>
        <h3>Example: Specifying locations</h3>
        <div style="clear:both; float:left; margin-left:1em; padding-right:2em;">
          <pre><code class="language-rust">static PI:f64 = 3.1415927;      // static memory
// static address: &PI = 0x7ff730eb7668
------------------------------------
let f:f64 = 3.1415927;          // stack memory
// stack address:   &f =   0x40a1cff8c0
------------------------------------
let s:&str = "3.1415927";       // stack memory
// stack address: &str =   0x40a1cff910
------------------------------------
let g = box::new(3.1415927f64); // heap memory
// heap address:   &*g =  0x1b78cc05bd0</code></pre>
        </div>
        <t-b>
          Variables can be bound to locations in static memory, stack memory, or heap memory.
        </t-b>
        <t-b>
          Static memory is allocated at compile-time and so contents live for the duration of
          the program. 
        </t-b>
        <t-b>
          Stack memory is implicitly allocated at run-time for each function call, including main.
          That serves as scratch-pad storage for input parameters and locally declared data. It is
          implicitly deallocated when the thread of execution leaves it&apos;s function&apos;s scope. 
        </t-b>
        <t-b>
          Heap memory is explicitly allocated with construction of a smart Box pointer. That  
          allocation is returned when the smart pointer g goes out of scope.
        </t-b>
        <div style="clear:both;"></div>
        <h3>Example: Initializing standard library types</h3>
        <div style="clear:both; float:left; margin-left:1em; padding-right:2em;">
          <pre><code class="language-rust">let v:Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1];
  // size: 24 bytes, control block holds
  // ptr to ints on heap, length, capacity
------------------------------------
let st:String = "an owned string".to_string();
  // size: 24 bytes, control block holds
  // ptr to chars on heap, length, capacity
------------------------------------
let mut vecdeq = VecDeque::&lt;f64&gt;::new();
vecdeq.push_front(1.0);
vecdeq.push_front(1.5);
vecdeq.push_front(2.0);
vecdeq.push_front(1.5);
vecdeq.push_front(1.0);
------------------------------------
let mut map = HashMap::<&str,i32>::new();
map.insert("zero", 0);
map.insert("one", 1);
map.insert("two", 2);</code></pre>
        </div>
        <t-b>
          Standard Library types are initialized with a call to new and possibly modified with
          subsequent additions of data.
        </t-b>
        <t-b>
          Here, <c-s>vec!</c-s> is a std::library macro that initializes variable <c-s>v</c-s> by 
          creating a <c-s>Vec&lt;int&gt;</c-s>
          and pushing the elements 1, 2, ...  
        </t-b>
        <t-b>
          <c-s>Vec</c-s>s consist of a control block in stack memory
          that holds a pointer to a resizeable array of elements in the heap, a count of the number of
          elements currently stored, and a count of the available capacity for data.  
        </t-b>
        <t-b>
          When the length
          equals the <c-s>Vec</c-s>&apos;s capacity and a new element is pushed the <c-s>Vec</c-s>
          allocates a new heap array of twice the size of the current capacity, copies the elements
          to the new storage and deallocates the original heap array.
        </t-b>
        <t-b>
          The string, st, is initialized by converting a literal string to a
          String type.  Strings are sequences of utf-8 characters, each of which may contain
          from one to four bytes.  That supports representing characters from non-roman languages,
          e.g., arabic, kanji, etc., as well as emoji&apos;s and symbols.
        </t-b>
        <t-b>
          The structure of a <c-s>String</c-s> is very similar to a <c-s>Vec</c-s>. It has a control
          block in stack memory and a collection of characters in the heap. The main difference is that
          vectors hold elements of a fixed size, and so are indexable.  Strings hold utf-8 characters
          which vary in size from one to four bytes.  They are not indexable, but provide an iterator,
          <c-s>chars</c-s> that steps through the character collection.
        </t-b>
        <t-b>
          The statement <c-s>let mut vecdeq = ...</c-s>
          creates a double ended <c-s>VecDeque</c-s> queue.  It must be declared <c-s>mut</c-s> 
          to allow later modifications with <c-s>push-front</c-s> statements. Data is stored
          in a circular buffer in the heap, supporting efficiently pushing data onto either front or back of the queue.
        </t-b>
        <t-b>
          <c-s>HashMap</c-s> is an associative container with, in this example, <c-s>Key:&str</c-s>, and <c-s>Value:i32</c-s>.
          The <c-s>&str</c-s> type is a reference to a literal string like <c-s>"zero"</c-s>.
          Key-value pairs are stored in a table of buckets which are linked lists.  Lookup
          applies a hash function to a unique key to find the table address of the bucket holding
          that key.  The HashMap retrieval API provides methods that use the hash to walk the
          bucket list searching for the specified key.
        </t-b>
        <t-b>
          The code block, below, displays some of the output of a demonstration program in 
          Bits/Rust/rust_data, stored in a <a href="https://github.com/JimFawcett/Bits">Bits repository</a> 
          for all the code used in the Bits for C++, Rust, C#, Python, and JavaScript.
          You are invited to clone or download the repository and explore these examples using Visual Studio Code.
        </t-b>
        <div style="clear:both; height:0.5em;"></div>
        <div style="float:left; margin-left:1em; padding-right:2em;">
          <h4 style="margin-top: 0em;">Example: Output</h4>
          <pre><code class="language-rust">--- initialize std::lib types ---
vec, alloc::vec::Vec<i32>
value: [1, 2, 3, 2, 1], size: 24
st, alloc::string::String
value: "an owned string", size: 24
vecdeq, alloc::collections::vec_deque::VecDeque<f64>
value: [1.0, 1.5, 2.0, 1.5, 1.0], size: 32
map, std::collections::hash::map::HashMap<&str, i32>
value: {"one": 1, "zero": 0, "two": 2}, size: 48</code></pre>
        </div>
        <div style="clear:both; height:1em;"></div>
        <div style="float:left; margin-left:1em; padding-right:2em;">
          <h4 style="margin-top: 0em;">Example: Code used to generate output</h4>
          <pre><code class="language-rust">use std::fmt::Debug;

/*-- show_type --------------------------------------------
  Shows compiler recognized type and data value
*/
pub fn show_type&lt;T: Debug&gt;(t: &T, nm: &str) {
  let typename = std::any::type_name::<T>();
  print!("  {nm}, {typename}");
  println!(
    "\n  value: {:?}, size: {}",
    t, std::mem::size_of::&lt;T&gt;()
  ); 
  // smart Debug formatting {:?} 
  // handles both scalars and collections
}
          </code></pre>
        </div>
        <div style="clear:both; height:1em;"></div>
        <t-b>
          The function <c-s>show_type</c-s>, above, accepts a generic type <c-s>T</c-s>, not specified until
          the compiler sees its argument type at the call site. It uses a function 
          <c-s>std::any::type_name::&lt;T&gt;()</c-s> that returns a string describing
          the argument <c-s>t</c-s>&apos;s type <c-s>T</c-s>. It also uses
          <c-s>std::mem::size_of::&lt;T&gt;()</c-s> that
          evaluates the size of a primitive type.  If T is a non-primative type with
          contents on the heap, <c-s>size_of</c-s> returns the size of its control block in stack memory
          but does not count heap allocation for its stored data members.
        </t-b>
        <t-b>
          We discuss generic types and functions in more detail <a href="Bits_GenericRust.html">here</a>.
        </t-b>
        <div style="clear:both;"></div>
        <h2 id="safe">2.0 Safety and Ownership</h2>
        <t-b>
          The design of the Rust programming language and especially its type system focuses
          on memory and data race safety. That means:
          <div class="focus">
            <ul style="margin-left:1em;">
              <li>
                Read and write operations happen only within program allocated memory.
              </li>
              <li>
                References are guaranteed to refer to valid targets.
              </li>
              <li>
                Threads may share data only within the confines of a lock.
                Each thread must acquire a lock to access data and then
                release it to enable other threads acess. 
              </li>
            </ul>
          </div>
          These properties are guaranteed by construction.  The compiler will not
          build code that violates them.
        </t-b>
        <h3 id="own">2.1 Single Ownership Policy</h3>
        <t-b>
          To support safety Rust has a &quot;single ownership&quot; policy. Each value in memory has
          a single owner that manages its allocation, initialization, deallocation and lifetime.
          this means that:
          <ul>
            <li>
              Binding a name to a value assigns ownership of the value to the named variable.
              Only the owner has the authority to modify, use, or deallocate the value. No other
              variable can access or modify the value without borrowing the priviledge to do so
              from the owner.
            </li>
            <li>
              A collection like <c-s>Vec&lt;T&gt;</c-s> owns its members. 
              In the code segment below, <c-s>v</c-s> owns the vector, and the vector owns the 
              elements <c-s>[1, 2, 3]</c-s>.
              Program code can access them by taking a reference:
              <div style="height:0.50em;"></div>
        <div style="float:left; margin-left:0em; padding-right:2em;">
          <!--<h4 style="margin-top: 0em;">Example: Vector with reference to member</h4>-->
          <pre><code class="language-rust">  let v = vec![1, 2, 3];
  let rv = &v3[1];
</code></pre>
        </div>
            </li>
          </ul>
          <div style="height:0.25em; clear:both;"></div>
          <h3 id="mutref" class="clear">2.2 References</h3>
          <ul>
            <li>
              References are used to borrow access to a variable from its owner. Rust enforces 
              strict rules for the use of references in order to guarantee memory and thread
              safety.
            </li>
            <li>
              Non-mutable references can share read-only access to a value.  Multiple
              shared references to a single owned value are valid.
            </li>
            <li>
              Mutable references, often called exclusive references,
              provide exclusive access to the value. No other references can access the value
              until the end of the mutable reference&apos;s lifetime.  That usually occurs when
              the mutable reference goes out of scope.
            </li>
            <li>
              This is a strong constraint that may occasionally affect the way programs are designed.
              No shared mutability ensures that references to a collection, like <c-s>Vec&lt;T&gt;</c-s>,
              don&apos;t dangle when
              the collection reallocates its resource memory to provide more capacity.
              <div style="height:1.0em;"></div>
        <div style="float:left; margin-left:0em; padding-right:2em;">
          <h4 style="margin-top: 0em;">Example: Attempt to mutate collection with active reference</h4>
          <pre><code class="language-rust">  show_op("attempt to mutate Vec while immutable ref exists");
  let mut v3 = vec![1, 2, 3];
  let rv3 = &v3[1]; // ok to declare
  v3.push(4);  // v3 will reallocate if capacity is 3
  println!("  rv3: {rv3:?}"); // not ok to use
</code></pre>
          <div style="clear:both; height:0.5em;"></div>
          <h4 style="margin-top: 0em;">Example: Compiler error message</h4>
          <pre><code class="language-rust">C:\github\JimFawcett\Bits\Rust\rust_data
> cargo run
   Compiling rust_data v0.1.0 (C:\github\JimFawcett\Bits\Rust\rust_data)
error[E0502]: cannot borrow `v3` as mutable because it is also borrowed as immutable
   --> src\main.rs:417:3
    |
416 |   let rv3 = &v3[1]; // ok to declare
    |              -- immutable borrow occurs here
417 |   v3.push(4);  // v3 will reallocate if capacity is 3
    |   ^^^^^^^^^^ mutable borrow occurs here
418 |   println!("  rv3: {rv3:?}"); // not ok to use
    |                     ------- immutable borrow later used here    

For more information about this error, try `rustc --explain E0502`.   
error: could not compile `rust_data` (bin "rust_data") due to previous error
</code></pre>
          </div>
            </li>
          </ul>
          <div style="clear:both; height:1em;"></div>
          <h3 id="move">2.3 Copy, Move, and Clone Operations</h3>
          <ul>
            <li>
              Copy of primitives and Move are efficient because they copy only a few bytes. Clone is
              expensive for a collection as it copies both the collection control block and all its
              heap resources.
            </li>
            <li>
              Some Rust types implement the Copy trait. All primitives and aggregations of primitives
              are <a target="_blank" href="../../Pictures/StrCopy.jpg">&quot;copy&quot;</a> types.  
              All other types are <a target="_blank" href="../../Pictures/StringMove.jpg">&quot;move&quot;</a>.
            </li>
            <li>
              For all copy types, construction, assignment, and pass-by-value results in data copy
              with no transfer of ownership, so the source is still valid.
              <div style="height:0.75em;"></div>
              The <c-s>str</c-s> type represents a constant literal string in memory. All <c-s>str</c-s>&apos;s
              are accessed by a reference, <c-s>&str</c-s>. Both <c-s>str</c-s> and <c-s>&</c-s> are copy.
              So copying an <c-s>&str</c-s> results in a second reference pointing to the original address.
                      <photosizer-block src="../../Pictures/StrCopy.jpg" width="300" class="photoSizerBlock" style="margin-top:0;">
                        <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS', Tahoma;
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
                          Figure 1. Str Copy
                        </span>
                      </photosizer-block>
              <div style="height:1.0em;"></div>
              <div style="float:left; margin-left:0em; padding-right:2em;">
          <h4 style="margin-top: 0em;">Example: &str copy</h4>
          <pre><code class="language-rust">  let lstrs = "literal string";  // copy type
  let lstrd = lstrs;
  println!("  source: {lstrs:?}, address: {:p}", lstrs);
  println!("  destin: {lstrd:?}, address: {:p}", lstrd);
  nl();
  println!("  Note: a literal string is a fixed value in memory.
  All access occurs through a reference, so copies just copy
  the reference. Both variables point to the same address." 
  );</code></pre>
        </div>
        <div style="height:1.0em; clear:both;"></div>
        <div style="float:left; margin-left:0em; padding-right:2em;">
          <h4 style="margin-top: 0em;">Example: Results of &str copy</h4>
          <pre><code class="language-rust">--- direct copy &str ---
  source: "literal string", address: 0x7ff7e742b590
  destin: "literal string", address: 0x7ff7e742b590

  Note: a literal string is a fixed value in memory.
  All access occurs through a reference, so copies just copy
  the reference. Both variables point to the same address.
</code></pre>
          </div>
              <div style="height:1.0em; clear:both;"></div>
            </li>
            <li>
              For all move types ownership will be transferred to another variable by construction, 
              assignment, or pass-by-value as a function argument.  A &quot;moved-from&quot; variable
              is invalid. Any use of that will result in a compile error.
              <div style="height:0.75em;"></div>
              Move is a very efficient operation, copying only a few bites instead of the entire object.
              When a copy is needed, the developer can choose to explicitly clone the original value.
                      <photosizer-block src="../../Pictures/StringMove.jpg" width="400" class="photoSizerBlock" style="margin-top:0;">
                        <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS', Tahoma;
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
                          Figure 2. String Move
                        </span>
                      </photosizer-block>
              <t-b>
        <div style="float:left; margin-left:0em; padding-right:2em;">
          <h4 style="margin-top: 0em;">Example: String Move</h4>
          <pre><code class="language-rust">let s = String::from("a string");
let addrvec = &s;
let addrzero = std::ptr::addr_of!(s.as_bytes()[0]);
println!("address of s: {:p}", addrvec);
println!("address of first byte of s&apos;s char buffer: {:p}\n", addrzero);

let t = s;  // move
let addrvec = &t;
let addrzero = std::ptr::addr_of!(t.as_bytes()[0]);
println!("address of t: {:p}", addrvec);
println!("address of first byte of t&apos;s char buffer: {:p}\n", addrzero);</code></pre>
        </div>
        <div style="clear:both; height:1em;"></div>
        <div style="float:left; margin-left:0em; padding-right:2em;">
          <h4 style="margin-top: 0em;">Example: Results of String Move</h4>
          <pre><code class="language-rust">--- demo_move for String ---

--- let s = String::from("a string") ---
address of s: 0x25758ff558
address of first byte of s&apos;s char buffer: 0x1725ee5dcd0

--- let t:String = s; // move ---
address of t: 0x25758ff600
address of first byte of t&apos;s char buffer: 0x1725ee5dcd0

Note: s and t are unique objects
that share same buffer
but now, s is invalid
</code></pre>
          <div style="clear:both; height:1em;"></div>
        </div>
              </t-b>
              <div style="clear:both;"></div>
            </li>
            <li>
              Move types usually implement the <c-s>Clone</c-s> trait with the function <c-s>clone()</c-s>.
              Calling clone makes an independent copy of the source. The original and clone are independent
              entities with different owners. They have the same values immediately following the clone
              operation, but may mutate to different values, independently.
              <photosizer-block src="../../Pictures/StringClone.jpg" width="400" class="photoSizerBlock" style="margin-top:0;">
                        <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS', Tahoma;
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
                          Figure 3. String Clone
                        </span>
                      </photosizer-block>
              <div style="clear:both; height:1.0em;"></div>
        <div style="float:left; margin-left:0em; padding-right:2em;">
          <h4 style="margin-top: 0em;">Example: String Clone</h4>
          <pre><code class="language-rust">let s_src = String::from("a string");
let s_src_addr = &s_src;
let s_src_bufaddr = std::ptr::addr_of!(s_src.as_bytes()[0]);
println!("  s_src: {:?}, address: {:p}", s_src, s_src_addr);
println!("  s_src_bufaddr: {:p}", s_src_bufaddr);
let s_cln = s_src.clone();
let s_cln_addr = &s_cln;
let s_cln_bufaddr = std::ptr::addr_of!(s_cln.as_bytes()[0]);
println!("  s_cln: {:?}, address: {:p}", s_cln, s_cln_addr);
println!("  s_cln_bufaddr: {:p}", s_cln_bufaddr);
nl();
println!("  Note: s_src and s_cln have different addresses
and their buffers have different addresses.
So they are unique entities.");
</code></pre>
          </div>
              <div style="clear:both; height:1em;"></div>
        <div style="float:left; margin-left:0em; padding-right:2em;">
          <h4 style="margin-top: 0em;">Example: Results of String Clone</h4>
          <pre><code class="language-rust">--- string clone ---
s_src: "a string", address: 0x7610d0f390
s_src_bufaddr: 0x229473682f0
s_cln: "a string", address: 0x7610d0f448
s_cln_bufaddr: 0x22947375d00

Note: s_src and s_cln have different addresses
and their buffers have different addresses.
So they are unique entities.
</code></pre>
          </div>
            </li>
          </ul>
        </t-b>
        <div style="clear:both; height:1em;"></div>
        <t-b>
          <h3 id="epilogue">3.0 Epilogue</h3>
          Most of the operations for language-defined and std::library types dicussed in this
          page will be covered again for user-defined types in <a href="Bits_ObjectsRust.html">Bits_ObjectsRust</a>.
        </t-b>
        <t-b>
          <h3 id="ref">4.0 References</h3>
        </t-b>


        <!--<div style="height:2em;"></div>
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote()" />
        <div style="display:flex; flex-direction:column;">
          <h4 id="source">Source Code: main.rs</h4>
          <pre><code class="language-rust">/*---------------------------------------------------------
 rust_data::src::main.rs
 - demonstrate move, copy, and borrow for
   primitives and selected std::library types
---------------------------------------------------------*/
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(clippy::approx_constant)]
/*
  Static Data Types:
    bool, char
    i8, i16, i32, i64, i128, isize
    u8, u16, u32, u64, u128, usize
    f32, f64
    (), reference
    array, tuple, struct, enum
  Qualifiers:
    mutable, const

  Additional Library Types:
    std::String, std::Vec&lt;T&gt;, std::HashMap&lt;K,V&gt;,
    std::VecDeque&lt;T&gt;, std::BTreeSet&lt;T&gt;, std::BTreeMap&lt;K,V&gt;,
    std::LinkedList&lt;T&gt;, std::BinaryHeap&lt;T&gt;

  Operations:
    Primitive types can all be copied.
    Most library and user-defined types can be moved,
    cloned, but only aggregates with all copyable members
    can be copied.  Values can only be changed if declared
    mutable.

  Processing:
    All types are static, operations run as native code,
    and no garbage collection is needed. Resources are
    returned at end of declr scope.
*/
/*-----------------------------------------------
Note:
Find all Bits code, including this in
https://github.com/JimFawcett/Bits
You can clone the repo from this link.
-----------------------------------------------*/

mod bits_data_analysis;
use bits_data_analysis::*;
use std::collections::*;

use std::fmt::Debug;

/*---------------------------------------------------------
  Primitive data types: i32, f64, ... occupy contiguous
  regions of memory, so they satisfy the Copy trait.

  Library types like String have a control block in stack
  and data in heap. So they do not satisfy the Copy trait.

  A move type can be cloned, but that requires an explicit
  call to clone(). Otherwise, assignment and pass by value
  result in move which transfers ownership of heap
  resources and invalidates the moved instance.

  Any attempt to use a moved instance results in compile
  failure.
---------------------------------------------------------*/

/*---------------------------------------------------------
  Demonstrate initialization of Rust's types
*/
fn create_initialize() {
  show_note(&quot;create and initialize&quot;);
  nl();

  show_op(&quot;initialize primitives&quot;);
  let int = 42i64;
  show_type(&int, &quot;int&quot;);
  let double:f64 = 3.15927;
  show_type(&double, &quot;double&quot;);
  let arr = [1, 2, 3];
  show_type(&arr, &quot;arr&quot;);
  nl();

  show_op(&quot;initialize std::lib types&quot;);
  let vec = vec![1, 2, 3, 2, 1];
  show_type(&vec, &quot;vec&quot;);
  let mut map = HashMap::&lt;&str,i32&gt;::new();
  map.insert(&quot;zero&quot;, 0);
  map.insert(&quot;one&quot;, 1);
  map.insert(&quot;two&quot;, 2);
  show_type(&map, &quot;map&quot;);
  nl();

  show_op(&quot;initialize user-defined type&quot;);
  #[derive(Debug)]
  struct Demo { name: String }
  let udt = Demo { name: &quot;demo&quot;.to_string() };
  show_type(&udt, &quot;udt&quot;);
}

/*---------------------------------------------------------
  pass argument by value
  - t is destination of move operation on caller's
    argument
  - t mutated in function to demonstrate that there
    are no side effects from calling this function
*/
fn pass_by_val&lt;T:Debug + Default&gt;(mut t:T) {
  show_type(&t,&quot;T&quot;);
  t = T::default();
  println!(&quot;  value mutated internally to {:?}&quot;, t);
  // no side effect since t was copied or moved
}
/*---------------------------------------------------------
  pass argument by reference
  - t is reference to caller's argument
  - t mutated in function to demonstrate that there
    are side effects from calling this function
*/
fn pass_by_ref&lt;T:Debug + Default&gt;(t:&mut T) {
  show_type(&t,&quot;T&quot;);
  *t = T::default();
  println!(&quot;  value mutated internally to {:?}&quot;, t);
  // has side effects since t is ref to caller's value
}
/*-- demonstrate variable has not been moved ------------*/
fn verify&lt;T&gt;(_t:T) {  // can only call this if t is valid
  /* t is valid */
}

/*-- demonstrate copy types -------------------------------
  Primitives and arrays of primitives are Copy types so
  construction, assignment, and pass-by-value result in
  copying entire source to destination.

  Most non-primitive types are not Copy, but provide a
  clone() function to make copies explicitly.
*/
fn demo_copy() {
  show_note(&quot;demonstrate copy and pass-by-value&quot;);
  nl();

  show_op(&quot;direct integer copy&quot;);
  let i_src = 42i64;  // copy literal 42 into i
  let i_dst = i_src;
  println!(&quot;  source: {i_src:?}&quot;);
  println!(&quot;  destin: {i_dst:?}&quot;);
  nl();

  show_op(&quot;direct copy of array of f64&quot;);
  let arr_src = [3.14f64, 0.5, -0.75];  // copy type
  let arr_dst = arr_src;
  println!(&quot;  source: {arr_src:?}&quot;);
  println!(&quot;  destin: {arr_dst:?}&quot;);
  nl();

  show_op(&quot;direct vector clone&quot;);
  let v_src = vec![1, 2, 3, 2, 1];
  let v_dst = v_src.clone();
  // let v_dst = v_src;  moves v_src resources to v_dst
  // does not copy
  println!(&quot;  source: {v_src:?}&quot;);
  println!(&quot;  destin: {v_dst:?}&quot;);
  nl();

  show_op(&quot;pass-by-value copies integer&quot;);
  pass_by_val(i_src);
  nl();

  show_op(&quot;pass-by-value moves vector&quot;);
  pass_by_val(v_src);
  // println!(&quot;{:?}&quot;, v_src); fails to compile, v_scr moved

}

/*-- demonstrate references -------------------------------
  Illustrates  side affects of passing by reference
  - function pass_by_ref(&t) mutates t to illustrate
    that caller sees this change.
*/
fn demo_pass_by_ref() {
  show_label(&quot;demonstrate pass-by-reference&quot;, 50);

  show_label(&quot;these demos have side effects&quot;, 35);
  nl();

  show_op(&quot;pass integer reference&quot;);
  let mut i = 42i64;
  println!(&quot;  before pass_by_ref: {i:?}&quot;);
  pass_by_ref(&mut i);
  println!(&quot;  after pass_by_ref: {i:?}&quot;);
  nl();

  show_op(&quot;pass reference to vector&quot;);
  let mut v = vec![1, 2, 3, 4, 5];
  println!(&quot;  before pass_by_ref: {v:?}&quot;);
  pass_by_ref(&mut v);
  println!(&quot;  after pass_by_ref: {v:?}&quot;);
  nl();

  show_op(&quot;pass reference to HashMap&quot;);
  let mut m = HashMap::&lt;&str, i32&gt;::new();
  m.insert(&quot;zero&quot;, 0);
  m.insert(&quot;one&quot;, 1);
  m.insert(&quot;two&quot;, 2);
  println!(&quot;  before pass_by_ref: {m:?}&quot;);
  pass_by_ref(&mut m);
  println!(&quot;  after pass_by_ref: {m:?}&quot;);
}

/*-- demonstrate move types -------------------------------
  Construction, assignment, and pass-by-value all result
  in moving the source resources to the destination.

  That is fast, usually only a few bytes are copied.

  This demo shows that move source and destination are
  unique, but source and destination share same heap buffer.
*/
fn show_addresses&lt;'a, T:Debug + AsRef&lt;[u8]&gt;&gt;(t:&T, nm:&str) {
  println!(&quot;  {}: {:?}&quot;, nm, t);  // show value of t
  let addr_t = std::ptr::addr_of!(*t);
  println!(&quot;  static address of {}: {:?}&quot;, nm, addr_t);
  let byte_ref = t.as_ref();
  let addr_res = std::ptr::addr_of!(byte_ref[0]);
  println!(&quot;  heap address of {}'s buffer: {:?}&quot;, nm, addr_res);
}
fn demo_move() {
  show_note(&quot;demonstrate move&quot;);
  nl();

  show_op(&quot;demo_move for String&quot;);
  let s = String::from(&quot;a string&quot;);
  show_addresses(&s, &quot;s&quot;);
  let addrzero = std::ptr::addr_of!(s.as_bytes()[0]);
  println!(&quot;  check - address of first byte of chars: {:?}&quot;, addrzero);

  let t = s;  // move
  show_op(&quot;let t:String = s; // move&quot;);
  show_addresses(&t, &quot;t&quot;);
  nl();

  println!(&quot;  Note: s and t are unique objects&quot;);
  println!(&quot;  that share same buffer&quot;);
  println!(&quot;  but now, s is invalid&quot;);
  nl();

  show_op(&quot;demo_move for Vec&quot;);
  let u = vec![1, 2, 3, 2, 1];
  show_addresses(&u, &quot;u&quot;);
  let addrzero = std::ptr::addr_of!(u[0]);
  println!(&quot;  check - address of u[0]: {:?}&quot;, addrzero);

  show_op(&quot;let v:Vec&lt;u8&gt; = u; // move&quot;);
  let v = u;  // move
  show_addresses(&v, &quot;v&quot;);
}

/*---------------------------------------------------------
  Demonstrate mutability
*/
fn demo_mutable() {
  show_note(&quot;demonstrate mutability&quot;);
  nl();

  show_op(&quot;demo_mutable for primitives&quot;);
  let mut i = 42i32;
  print!(&quot;  original value: {i:?}&quot;);
  i += 1;
  println!(&quot;, changed value:  {i:?}&quot;);

  let mut f = 3.14159f64;
  print!(&quot;  original value: {f:?}&quot;);
  f += 1.0;
  println!(&quot;, changed value:  {f:?}&quot;);
  nl();

  show_op(&quot;demo_mutable for std::lib types&quot;);
  let mut v = vec![1, 2, 3];
  print!(&quot;  original value: {v:?}&quot;);
  v[1] += 1;
  println!(&quot;, changed value:  {v:?}&quot;);

  let mut m = HashMap::&lt;&str,i32&gt;::new();
  m.insert(&quot;zero&quot;, 0);
  m.insert(&quot;one&quot;, 1);
  m.insert(&quot;two&quot;, 2);
  println!(&quot;  original value: {m:?}&quot;);
  /* entry returns reference to value of supplied key */
  let mut value = m.entry(&quot;one&quot;).or_insert(1);
  *value += 1;
  println!(&quot;  changed value:  {m:?}&#92;n&quot;);
}
/*---------------------------------------------------------
  Demonstrate references
  - illustrates that mutability cannot be shared using
    references
*/
fn demo_ref() {
  show_note(&quot;demonstrate references&quot;);
  nl();

  show_op(&quot;demo_ref immutable&quot;);
  let v1 = vec![1, 2, 3, 2, 1];
  /* can use any number of immutable referenes */
  let r1v1 = &v1;
  println!(&quot;  r1v1: {r1v1:?}&quot;);
  let r2v1 = &v1;
  println!(&quot;  r2v1: {r2v1:?}&quot;);
  nl();

  show_op(&quot;demo_ref mutable&quot;);
  /* can't mutate data through shared references */
  let mut v2 = vec![1, 2, 3, 4, 5];
  /* immutable borrow */
  let r1v2 = &v2;
  println!(&quot;  r1v2: {r1v2:?}&quot;);
  /* mutable borrow ok if we don't use immutable borrow later */
  let mr2v2 = &mut v2;
  mr2v2.push(42);
  println!(&quot;  mr2v2: {mr2v2:?}&quot;);
  /*
    Use of immutable borrow in println! illegal with active
    mutable borrow. Try uncommenting line below.
  */
  // println!(&quot;  r1v2: {r1v2:?}&quot;);
}
/*-- execute demonstrations -----------------------------*/
fn main() {
    show_note(
      &quot;Demonstrate Rust types&quot;
    );

    create_initialize();
    demo_copy();
    demo_pass_by_ref();
    demo_move();
    demo_mutable();
    demo_ref();

    println!(&quot;&#92;n&#92;nThat's all Folks!!&#92;n&#92;n&quot;);
}</code></pre>
          <h4 id="anal">Source Code: bits_data_analysis.rs</h4>
          <pre><code class="language-rust">#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(clippy::approx_constant)]

/* rust_data::bits_data_analysis.rs */
/*-----------------------------------------------
Note:
Find all Bits code, including this in
https://github.com/JimFawcett/Bits
You can clone the repo from this link.
-----------------------------------------------*/

use std::fmt::Debug;

/*-- show_type --------------------------------------------
  Shows compiler recognized type and data value
*/
pub fn show_type&lt;T: Debug&gt;(t: &T, nm: &str) {
  let typename = std::any::type_name::&lt;T&gt;();
  print!(&quot;  {nm}, {typename}&quot;);
  println!(
    &quot;&#92;n  value: {:?}, size: {}&quot;,  // smart formatting {:?}
    t, std::mem::size_of::&lt;T&gt;()   // handles both scalars
  );                              // and collections
}
/*---------------------------------------------------------
  show string wrapped with long dotted lines above and below
*/
pub fn show_label(note: &str, n:usize) {
  let mut line = String::new();
  for _i in 0..n {
    line.push('-');
  }
  print!(&quot;&#92;n{line}&#92;n&quot;);
  print!(&quot;  {note}&quot;);
  print!(&quot;&#92;n{line}&#92;n&quot;);
}
pub fn show_label_def(note:&str) {
  show_label(note, 50);
}
/*---------------------------------------------------------
  show string wrapped with dotted lines above and below
*/
pub fn show_note(note: &str) {
  print!(&quot;&#92;n-------------------------&#92;n&quot;);
  print!(&quot; {note}&quot;);
  print!(&quot;&#92;n-------------------------&#92;n&quot;);
}
/*---------------------------------------------------------
  show string wrapped in short lines
*/
pub fn show_op(opt: &str) {
  println!(&quot;--- {opt} ---&quot;);
}
/*---------------------------------------------------------
  print newline
*/
pub fn nl() {
  println!();
}</code></pre>
          <h4 id="out">Output</h4>
          <pre class="codeSnaps"><code class="language-shell">C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_data
&gt; cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target&#92;debug&#92;rust_data.exe`

-------------------------
 Demonstrate Rust types
-------------------------

-------------------------
 create and initialize
-------------------------

--- initialize primitives ---
  int, i64
  value: 42, size: 8
  double, f64
  value: 3.15927, size: 8
  arr, [i32; 3]
  value: [1, 2, 3], size: 12

--- initialize std::lib types ---
  vec, alloc::vec::Vec&lt;i32&gt;
  value: [1, 2, 3, 2, 1], size: 24
  map, std::collections::hash::map::HashMap&lt;&str, i32&gt;
  value: {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;zero&quot;: 0}, size: 48

--- initialize user-defined type ---
  udt, rust_data::create_initialize::Demo
  value: Demo { name: &quot;demo&quot; }, size: 24

-------------------------
 demonstrate copy and pass-by-value
-------------------------

--- direct integer copy ---
  source: 42
  destin: 42

--- direct copy of array of f64 ---
  source: [3.14, 0.5, -0.75]
  destin: [3.14, 0.5, -0.75]

--- direct vector clone ---
  source: [1, 2, 3, 2, 1]
  destin: [1, 2, 3, 2, 1]

--- pass-by-value copies integer ---
  T, i64
  value: 42, size: 8
  value mutated internally to 0

--- pass-by-value moves vector ---
  T, alloc::vec::Vec&lt;i32&gt;
  value: [1, 2, 3, 2, 1], size: 24
  value mutated internally to []

--------------------------------------------------
  demonstrate pass-by-reference
--------------------------------------------------

-----------------------------------
  these demos have side effects
-----------------------------------

--- pass integer reference ---
  before pass_by_ref: 42
  T, &mut i64
  value: 42, size: 8
  value mutated internally to 0
  after pass_by_ref: 0

--- pass reference to vector ---
  before pass_by_ref: [1, 2, 3, 4, 5]
  T, &mut alloc::vec::Vec&lt;i32&gt;
  value: [1, 2, 3, 4, 5], size: 8
  value mutated internally to []
  after pass_by_ref: []

--- pass reference to HashMap ---
  before pass_by_ref: {&quot;zero&quot;: 0, &quot;two&quot;: 2, &quot;one&quot;: 1}
  T, &mut std::collections::hash::map::HashMap&lt;&str, i32&gt;
  value: {&quot;zero&quot;: 0, &quot;two&quot;: 2, &quot;one&quot;: 1}, size: 8
  value mutated internally to {}
  after pass_by_ref: {}

-------------------------
 demonstrate move
-------------------------

--- demo_move for String ---
  s: &quot;a string&quot;
  static address of s: 0x6a4c5af440
  heap address of s's buffer: 0x1d0d45282e0
  check - address of first byte of chars: 0x1d0d45282e0
--- let t:String = s; // move ---
  t: &quot;a string&quot;
  static address of t: 0x6a4c5af4a0
  heap address of t's buffer: 0x1d0d45282e0

  Note: s and t are unique objects
  that share same buffer
  but now, s is invalid

--- demo_move for Vec ---
  u: [1, 2, 3, 2, 1]
  static address of u: 0x6a4c5af550
  heap address of u's buffer: 0x1d0d4534980
  check - address of u[0]: 0x1d0d4534980
--- let v:Vec&lt;u8&gt; = u; // move ---
  v: [1, 2, 3, 2, 1]
  static address of v: 0x6a4c5af5b0
  heap address of v's buffer: 0x1d0d4534980

-------------------------
 demonstrate mutability
-------------------------

--- demo_mutable for primitives ---

--- demo_mutable for primitives ---
  original value: 42, changed value:  43
  original value: 3.14159, changed value:  4.14159

--- demo_mutable for std::lib types ---
  original value: [1, 2, 3], changed value:  [1, 3, 3]
  original value: {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;zero&quot;: 0}
  changed value:  {&quot;one&quot;: 2, &quot;two&quot;: 2, &quot;zero&quot;: 0}


-------------------------
 demonstrate references
-------------------------

--- demo_ref immutable ---
  r1v1: [1, 2, 3, 2, 1]
  r2v1: [1, 2, 3, 2, 1]

--- demo_ref mutable ---
  r1v2: [1, 2, 3, 4, 5]
  mr2v2: [1, 2, 3, 4, 5, 42]


That's all Folks!!


C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_data
</code></pre>
          <h4 id="build">Build</h4>
          <pre class="codeSnaps"><code class="language-shell">C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_data
&gt; cargo run
   Compiling rust_data v0.1.0 (C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_data)
    Finished dev [unoptimized + debuginfo] target(s) in 0.37s
     Running `target&#92;debug&#92;rust_data.exe`
          </code></pre>
        </div>
        <h3 id="ide">2.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in 
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Rust\rust_hello_data.
        </t-b>
        <photosizer-block src="pictures/VS_Code_Rust_Data.JPG" width="800" class="photoSizerBlock left"
          style="overflow-x:auto;"
        >
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE</span>
        </photosizer-block>
        <photosizer-block src="pictures/LaunchJSON_Rust_Data.JPG" width="700" class="photoSizerBlock left"
          style="overflow-x:auto;"
        >
          <span style="font-family:'Comic Sans MS';">Figure 2. Launch.JSON</span>
        </photosizer-block>-->
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
          <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
        </photosizer-block>-->

        <!--<div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th><th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../RustStoryRepo.html">Rust Story</a>
            </td>
            <td>
              E-book with seven chapters covering most of intermediate Rust
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../RustBites/RustBites_Intro.html">Rust Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>-->
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <!--<menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ops">ops</a></menu-elem>-->
        <menu-elem class="secElem"><a href="#ref">ref</a></menu-elem>
        <menu-elem class="secElem"><a href="#epilogue">epilogue</a></menu-elem>
        <menu-elem class="secElem"><a href="#move">cpy-mv-cln</a></menu-elem>
        <menu-elem class="secElem"><a href="#mutref">Rust refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#own">ownership</a></menu-elem>
        <menu-elem class="secElem"><a href="#safe">safety</a></menu-elem>
        <menu-elem class="secElem"><a href="#init">init</a></menu-elem>
        <menu-elem class="secElem"><a href="#typesys">typesys</a></menu-elem>
        <menu-elem class="secElem"><a href="#types">types</a></menu-elem>
        <menu-elem class="secElem"><a href="#syn">syn</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
  <script>
    //localStorage.clear();
    getScroll();
  </script>
</body>
</html>