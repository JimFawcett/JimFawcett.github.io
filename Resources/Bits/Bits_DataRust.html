<!DOCTYPE html>
<html>
<!--
  Bits_DataRust.html
-->
<head>
  <title>Bits_Data Rust</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeDefault.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBits.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding:0.75em 1.5em;
      margin-top:1.25em;
      margin-bottom:1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width:50em;
    }
    #github h2 {
      margin-top: 0.75em;
    }
    #github #pagetitle {
      border:2px double var(--dark);
    }
    #github form {
      border:none;
      padding:0.5em 1em;
    }
    #github form span {
      padding:0em 0.5em;
    }
    #github code-container {
      display: flex;
      position:relative;
      width:calc(100%);
      flex-direction: row;
      justify-content: space-between;
      /*border-top: 1px solid var(--dark);*/
    }
    #github code-banner {
      display: block;
      border: 2px solid var(--dark);
      border-top:none;
      border-bottom:none;
      padding: 0.25em 1em;
      font-family: 'Comic Sans MS', Tahoma;
      width: calc(100% + 0.5em);
      background-color: var(--atten);
    }
    #github code-display {
      display: block;
      border: 2px solid var(--dark);
      white-space: pre;
      padding: 0.75em 1em;
      font-family: Consolas, monospace;
      font-size:0.9em;
      width: calc(50% - 0.5em);
      overflow-x: auto;
      /*height:20em;*/
    }
    #github label {
      margin-right:1em;
    }
    #github fieldset {
      border:none;
    }
    #github #exeRight, #exeLeft {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github #hideLeft, #hideRight {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github .hide {
      display:none;
    }
    body {
      position:relative;
    }
    #github table.showcode {
      table-layout:fixed;
      width:calc(100% + 4em);
      margin-left:-2em;
    }
    #github th.leftblock {
      border: 2px solid var(--dark);
      /*border: 1px solid red;*/
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.rightblock {
      border: 2px solid var(--dark);
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.centerblock {
      border: none;
      padding: 0em;
      width:1em;
    }
    #github td.leftblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em);
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.leftblock summary {
      border:1px solid #ffffbb;
    }

    #github td.rightblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em) !important;
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.rightblock summary {
      border: 1px solid #ffffbb;
    }

    #github td.centerblock {
      border: none;
      padding: 0em;
    }
    #github pre {
      overflow-x: auto !important;
    }
    #github #left1 {
      /*height:45em;*/
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }

    #github #right1 {
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }
    #github #left2 {
      /*height:45em;*/
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right2 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github #left3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github .mover {
      width:2em;
      padding: 0.05em;
      position:relative;
      right:-1.5em;
      top:0.6em;
    }
    #github #ruler {

      width:calc(50% - 1.5em);
      height:0.001em;
      margin:-0.45em 0em;
    }
    #github .btns {
      width:3em;
      border:none;
    }
    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 10px;
    }
    #github .remotebutton {
      padding:0.25em 0.5em;
    }
    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }
    #github hr.spread {
      margin:0.75em 0em;
    }
    #github pre {
      width: max-content;
      min-width: 20em;
      max-width: 60em;
      user-select: all;
    }
    #github {
      user-select: none;
    }
    .code-container {
      display: flex;
      flex-direction: column;
      border: 1px solid red;
      width:max-content;
      margin:0em; padding:0em;
    }
    .code-block {
      /*display:flex;*/
      margin: 0.0em 1em;
      font-family: monospace;
    }
  </style>
  <script>
    function saveScroll() {
      let main = document.querySelector("main");
      localStorage.setItem("DataRust", main.scrollTop);
    }
    function getScroll() {
      let scroll = localStorage.getItem("DataRust");
      if (scroll) {
        scrollTop = parseInt(scroll, 10);
        let main = document.querySelector("main");
        main.scrollTop = scrollTop;
      }
    }
  </script>

  <script>
    function remote() {
      window.open('https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ac93fd553ca70f9f6258bf0253bea2b3', '_blank');
    }
  </script>
</head>
<body id="github" onload="initialize()" onbeforeunload="saveScroll()">

  <a id="Next" href="Bits_ObjectsRust.html">Next</a>
  <a id="Prev" href="Bits_HelloRust.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="page">Bits Data Rust</div>
      <div id="modified">08/06/2023</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content id="content">
        <div class="rightPanelLinks">
          <a href="Bits_DataCpp.html">C++</a>
          <a class="darkItem" href="Bits_DataRust.html">Rust</a>
          <a href="Bits_DataCSharp.html">C#</a>
          <a href="Bits_DataPython.html">Python</a>
          <a href="Bits_DataJs.html">JvScrpt</a>
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits_Data Rust</h1>
            <h3 id="subtitle" class="indent">
              code, output, and build for Rust on Windows, macOS, and Linux
            </h3>
          </hgroup>
        </header>
        <t-b>
          These pages support comparison of fragments of code in several different
          languages, much as you might compare a sentence of English with one in Spanish to help you learn
          Spanish.
          </t-b>
          <t-b style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
            <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
            This page demonstrates simple uses of the most important Rust types.
            The purpose is to quickly acquire some familiarity with types and their uses.
            <hr class="spread" />
            <ul>
              <li>
                Rust provides two kinds of types: copy and move.
              </li>
              <li>
                Primitive types and aggregates of primitive types are copy.  Construction, assignment, and
                pass-by-value copies the source&apos;s value to the destination.
              </li>
              <li>
                All other types are move. Construction, assignment, and pass-by-value moves the source&apos;s
                resources to the destination. This is a transfer of ownership and
                makes the source invalid. Attempting to use a &quot;moved&quot; variable is a
                compile error.
              </li>
              <li>
                The source and destination of copy and move operations must have exactly the same type.
              </li>
              <li>
                Most move types provide clone operations that support making copies, but using
                code must explicitly call clone().
              </li>
              <li>
                Rust supports making fixed references to either copy or move types. These may
                refer to instances in stack memory or in the native heap.
              </li>
              <li>
                Rust references are constrained by Rust ownership rules to support memory
                and data race safety by construction.
              </li>
              <li>
                Here we begin to see significant differences between the languages, especially
                when comparing statically typed languages like C++, Rust, and C#, with dynamically typed
                languages like Python and JavaScript.
              </li>
            </ul>
            <div style="height:0.25em;"></div>
          </t-b>
        <div style="height:0.25em;"></div>
        <details>
          <summary class="darkItem">Rust Types&nbsp;</summary>
          <h3>Table 1.0 Rust Types</h3>
          <table style="font-size:0.9em;">
            <tr>
              <th style="width:15em;">Type</th><th>Comments</th><th>Example</th>
            </tr>
            <tr>
              <th colspan="3" align="left">-- Integral types ----</th>
            </tr>
            <tr>
              <td><c-s>bool</c-s></td><td>values true and false</td><td><c-s>let b = true;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>i8, i16, i32, i64, isize, u8, u16, u32, u64, usize</c-s>
              </td>
              <td>signed and unsigned integer types</td><td><c-s>let i = 42i8;</c-s></td>
            </tr>
            <tr>
              <th colspan="3" align="left">-- Floating point types ----</th>
            </tr>
            <tr>
              <td><c-s>f32, f64</c-s></td>
              <td>values have finite precision, and may have approximate values</td>
              <td><c-s>let f:f32 = 3.14159;</c-s></td>
            </tr>
            <tr>
              <th colspan="3" align="left">-- Aggregate types ----</th>
            </tr>
            <tr>
              <td><c-s>[T; N]</c-s></td><td>An array of N elements all of type <c-s>T</c-s></td><td><c-s>let arr = [1, 2, 3, 2, 1];</c-s></td>
            </tr>
            <tr>
              <td><c-s>&[T]</c-s></td><td>Slice of array of elements of type <c-s>T</c-s></td><td><c-s>let arrs = &arr[1..3];</c-s></td>
            </tr>
            <tr>
              <td><c-s>&str</c-s></td><td>A literal string</td><td><c-s>let sl = "literal string";</c-s></td>
            </tr>
            <tr>
              <td><c-s>&str</c-s></td><td>Slice of a literal string</td><td><c-s>let slice = &sl[1..5];</c-s></td>
            </tr>
            <tr><td colspan="3" align="left">-- Std::library types ----</td></tr>
            <tr>
              <td><c-s>String</c-s></td><td>Expandable collection of utf-8 characters allocated in the heap</td>
              <td><c-s>let strg = "a utf-8 String".to_string();</c-s></td>
            </tr>
            <tr>
              <td><c-s>Vec&lt;T&gt;</c-s></td>
              <td>Expandable generic collection of items of type <c-s>T</c-s></td>
              <td><c-s>let v = Vec::&lt;f64&gt;::new(), v.push(1.5); ...</c-s></td>
            </tr>
            <tr>
              <td><c-s>VecDeque&lt;T&gt;</c-s></td>
              <td>Expandable double-ended generic collection of items of type <c-s>T</c-s></td>
              <td>
                <c-s>let vd = VecDeque::&lt;f64&gt;::new(),<br /> 
                v.push_front(1.5); ...</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>HashMap&lt;K,V&gt;</c-s></td>
              <td>Associative container of Key-Value pairs, held in a table of bucket lists.</td>
              <td>
                <c-s>let map = HashMap::&lt;&str, int&gt;::new(),<br />  
                map.insert("zero", 0); ...</c-s>
              </td>
            </tr>
          </table>
        </details>
        <h2 id="code">1.0 Initialization</h2>
        <t-b>
          Rust types are initialized with a let statement that binds a variable name to a memory location
          with specified value.
        </t-b>
        <h3>Example: primitive type initializations</h3>
        <div style="float:left; margin-left:1em; padding-right:2em;">
          <pre><code class="language-rust">let i = 42i8;         // data type specified
  // size: 1 byte => 8bits
let f:f32 = 3.14159;  // variable type specified
  // size: 4 bytes
let c:char = 'z';
  // size: 4 bytes, enough to hold utf-8 character 
let sl:&str = "a literal string";
  // size: 16 bytes, all its characters are 1 byte
let arr:[i32; 3] = [1, 2, 3];
  // array size: 12 bytes
let tp: (i32, f64, char) = (1, 2.5, 'a');
  // tuple size: 16 bytes
let iref: &i8 = &amp;i;
  // size: 8 bytes, a reference to i&apos;s value
let aref: &[i32; 3] = &arr;
  // size: 8 bytes, a reference to arr&apos;s values
/*--------------------------------------------
  All sizes are space allocated in local
  stack frame.
*/</code></pre>
        </div>
        <t-b>
          Type specifications like i8 and f64 can be applied to the variable name or to it&apos;s initializing
          data, as shown here. 
        </t-b>
        <t-b>
          Rust can usually infer appropriate types for data, but a code developer can
          explicitly define them.
          If the type annotations were removed in this example, Rust would infer i to be i32 and f to be f64.
        </t-b>
        <t-b>
          The char type occupies 4 bytes of storage, large enough to hold any of the utf-8 characters.
        </t-b>
        <t-b>
          The type <c-s>&str</c-s> is a reference to a fixed-size immutable literal string in stack memory. 
          It may hold
          any of the utf-8 characters. It&apos;s size is the sum of the actual literal character sizes.
          For the literal string shown, all of the characters are 1 byte.
        </t-b>
        <t-b>
          Arrays are fixed size sequences of values of the specified type.  They are indexable and individual
          element values may be changed if the array has mutable type.
        </t-b>
        <t-b>
          Tuples are sequences of values of heterogeneous types.  Elements are accessed via position
          arguments, e.g., tp.1 accesses the second element, a float.
        </t-b>
        <t-b>
          References like &arr are fixed pointers to the beginning of the variable&apos;s data storage. 
        </t-b>
        <div style="clear:both;"></div>
        <h3>Example: Specifying locations</h3>
        <div style="clear:both; float:left; margin-left:1em; padding-right:2em;">
          <pre><code class="language-rust">static PI:f64 = 3.1415927;      // static memory
// static address: &PI = 0x7ff730eb7668
------------------------------------
let f:f64 = 3.1415927;          // stack memory
// stack address:   &f =   0x40a1cff8c0
------------------------------------
let s:&str = "3.1415927";       // stack memory
// stack address: &str =   0x40a1cff910
------------------------------------
let g = box::new(3.1415927f64); // heap memory
// heap address:   &*g =  0x1b78cc05bd0</code></pre>
        </div>
        <t-b>
          Variables can be bound to locations in static memory, stack memory, or heap memory.
        </t-b>
        <t-b>
          Static memory is allocated at compile-time and so contents live for the duration of
          the program. 
        </t-b>
        <t-b>
          Stack memory is implicitly allocated at run-time for each function call, including main.
          That serves as scratch-pad storage for input parameters and locally declared data. It is
          implicitly deallocated when the thread of execution leaves it&apos;s function&apos;s scope. 
        </t-b>
        <t-b>
          Heap memory is explicitly allocated with construction of a smart Box pointer. That  
          allocation is returned when the smart pointer g goes out of scope.
        </t-b>
        <div style="clear:both;"></div>
        <h3>Example: Initializing standard library types</h3>
        <div style="clear:both; float:left; margin-left:1em; padding-right:2em;">
          <pre><code class="language-rust">let v:Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1];
  // size: 24 bytes, control block holds
  // ptr to ints on heap, length, capacity
------------------------------------
let st:String = "an owned string".to_string();
  // size: 24 bytes, control block holds
  // ptr to chars on heap, length, capacity
------------------------------------
let mut vecdeq = VecDeque::&lt;f64&gt;::new();
vecdeq.push_front(1.0);
vecdeq.push_front(1.5);
vecdeq.push_front(2.0);
vecdeq.push_front(1.5);
vecdeq.push_front(1.0);
------------------------------------
let mut map = HashMap::<&str,i32>::new();
map.insert("zero", 0);
map.insert("one", 1);
map.insert("two", 2);</code></pre>
        </div>
        <t-b>
          Standard Library types are initialized with a call to new and possibly modified with
          subsequent additions of data.
        </t-b>
        <t-b>
          Here, <c-s>vec!</c-s> is a std::library macro that initializes variable <c-s>v</c-s> by 
          creating a <c-s>Vec&lt;int&gt;</c-s>
          and pushing the elements 1, 2, ...
        </t-b>
        <t-b>
          The string, st, is initialized by converting a literal string to a
          String type.  Strings are sequences of utf-8 characters, each of which may contain
          from one to four bytes.  That supports representing characters from non-roman languages,
          e.g., arabic, kanji, etc., as well as emoji&apos;s and symbols.
        </t-b>
        <t-b>
          The statement <c-s>let mut vecdeq = ...</c-s>
          creates a double ended <c-s>VecDeque</c-s> queue.  It must be declared <c-s>mut</c-s> 
          to allow later modifications with <c-s>push-front</c-s> statements. Data is stored
          in a circular buffer, supporting efficiently pushing data onto either front or back of the queue.
        </t-b>
        <t-b>
          HashMap is an associative container with <c-s>Key:&str</c-s>, and <c-s>Value:i32</c-s>.
          The <c-s>&str</c-s> type is a reference to a literal string like <c-s>"zero"</c-s>.
          Key, value pairs are stored in a table of buckets which are linked lists.  Lookup
          applies a hash function to a unique key to find the table address of the bucket holding
          that key.  The HashMap retrieval API provides methods that use the hash to walk the
          bucket list searching for the specified key.
        </t-b>
        <t-b>
          The code block, below, displays some of the output of a demonstration program in 
          Bits/Rust/rust_data, stored in a <a href="https://github.com/JimFawcett/Bits">Bits repository</a> 
          for all the code used in the Bits for C++, Rust, C#, Python, and JavaScript.
          You are invited to clone or download the repository and explore these examples using Visual Studio Code.
        </t-b>
        <div style="clear:both; height:0.5em;"></div>
        <div style="float:left; margin-left:1em; padding-right:2em;">
          <h4 style="margin-top: 0em;">Example: Output</h4>
          <pre><code class="language-rust">--- initialize std::lib types ---
vec, alloc::vec::Vec<i32>
value: [1, 2, 3, 2, 1], size: 24
st, alloc::string::String
value: "an owned string", size: 24
vecdeq, alloc::collections::vec_deque::VecDeque<f64>
value: [1.0, 1.5, 2.0, 1.5, 1.0], size: 32
map, std::collections::hash::map::HashMap<&str, i32>
value: {"one": 1, "zero": 0, "two": 2}, size: 48</code></pre>
        </div>
        <div style="clear:both; height:1em;"></div>
        <div style="float:left; margin-left:1em; padding-right:2em;">
          <h4 style="margin-top: 0em;">Example: Code used to generate output</h4>
          <pre><code class="language-rust">use std::fmt::Debug;

/*-- show_type --------------------------------------------
  Shows compiler recognized type and data value
*/
pub fn show_type&lt;T: Debug&gt;(t: &T, nm: &str) {
  let typename = std::any::type_name::<T>();
  print!("  {nm}, {typename}");
  println!(
    "\n  value: {:?}, size: {}",
    t, std::mem::size_of::&lt;T&gt;()
  ); 
  // smart Debug formatting {:?} 
  // handles both scalars and collections
}
          </code></pre>
        </div>
        <div style="clear:both; height:1em;"></div>
        <t-b>
          The function <c-s>show_type</c-s>, above, accepts a generic type <c-s>T</c-s>, not specified until
          the compiler sees its argument type at the call site. It uses a function 
          <c-s>std::any::type_name::&lt;T&gt;()</c-s> that returns a string describing
          the argument <c-s>t</c-s>&apos;s type <c-s>T</c-s>. It also uses
          <c-s>std::mem::size_of::&lt;T&gt;()</c-s> that
          evaluates the size of a primitive type.  If T is a non-primative type with
          contents on the heap, <c-s>size_of</c-s> returns the size of its control block
          but does not count its heap allocation for stored data members.
        </t-b>
        <t-b>
          We will discuss generic types and functions in more detail in a subsequent Bit.
        </t-b>
        <div style="clear:both;"></div>
        <h2>2.0 Basic Data Operations</h2>
        <div style="height:2em;"></div>
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote()" />
        <div style="display:flex; flex-direction:column;">
          <h4 id="source">Source Code: main.rs</h4>
          <pre><code class="language-rust">/*---------------------------------------------------------
 rust_data::src::main.rs
 - demonstrate move, copy, and borrow for
   primitives and selected std::library types
---------------------------------------------------------*/
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(clippy::approx_constant)]
/*
  Static Data Types:
    bool, char
    i8, i16, i32, i64, i128, isize
    u8, u16, u32, u64, u128, usize
    f32, f64
    (), reference
    array, tuple, struct, enum
  Qualifiers:
    mutable, const

  Additional Library Types:
    std::String, std::Vec&lt;T&gt;, std::HashMap&lt;K,V&gt;,
    std::VecDeque&lt;T&gt;, std::BTreeSet&lt;T&gt;, std::BTreeMap&lt;K,V&gt;,
    std::LinkedList&lt;T&gt;, std::BinaryHeap&lt;T&gt;

  Operations:
    Primitive types can all be copied.
    Most library and user-defined types can be moved,
    cloned, but only aggregates with all copyable members
    can be copied.  Values can only be changed if declared
    mutable.

  Processing:
    All types are static, operations run as native code,
    and no garbage collection is needed. Resources are
    returned at end of declr scope.
*/
/*-----------------------------------------------
Note:
Find all Bits code, including this in
https://github.com/JimFawcett/Bits
You can clone the repo from this link.
-----------------------------------------------*/

mod bits_data_analysis;
use bits_data_analysis::*;
use std::collections::*;

use std::fmt::Debug;

/*---------------------------------------------------------
  Primitive data types: i32, f64, ... occupy contiguous
  regions of memory, so they satisfy the Copy trait.

  Library types like String have a control block in stack
  and data in heap. So they do not satisfy the Copy trait.

  A move type can be cloned, but that requires an explicit
  call to clone(). Otherwise, assignment and pass by value
  result in move which transfers ownership of heap
  resources and invalidates the moved instance.

  Any attempt to use a moved instance results in compile
  failure.
---------------------------------------------------------*/

/*---------------------------------------------------------
  Demonstrate initialization of Rust's types
*/
fn create_initialize() {
  show_note(&quot;create and initialize&quot;);
  nl();

  show_op(&quot;initialize primitives&quot;);
  let int = 42i64;
  show_type(&int, &quot;int&quot;);
  let double:f64 = 3.15927;
  show_type(&double, &quot;double&quot;);
  let arr = [1, 2, 3];
  show_type(&arr, &quot;arr&quot;);
  nl();

  show_op(&quot;initialize std::lib types&quot;);
  let vec = vec![1, 2, 3, 2, 1];
  show_type(&vec, &quot;vec&quot;);
  let mut map = HashMap::&lt;&str,i32&gt;::new();
  map.insert(&quot;zero&quot;, 0);
  map.insert(&quot;one&quot;, 1);
  map.insert(&quot;two&quot;, 2);
  show_type(&map, &quot;map&quot;);
  nl();

  show_op(&quot;initialize user-defined type&quot;);
  #[derive(Debug)]
  struct Demo { name: String }
  let udt = Demo { name: &quot;demo&quot;.to_string() };
  show_type(&udt, &quot;udt&quot;);
}

/*---------------------------------------------------------
  pass argument by value
  - t is destination of move operation on caller's
    argument
  - t mutated in function to demonstrate that there
    are no side effects from calling this function
*/
fn pass_by_val&lt;T:Debug + Default&gt;(mut t:T) {
  show_type(&t,&quot;T&quot;);
  t = T::default();
  println!(&quot;  value mutated internally to {:?}&quot;, t);
  // no side effect since t was copied or moved
}
/*---------------------------------------------------------
  pass argument by reference
  - t is reference to caller's argument
  - t mutated in function to demonstrate that there
    are side effects from calling this function
*/
fn pass_by_ref&lt;T:Debug + Default&gt;(t:&mut T) {
  show_type(&t,&quot;T&quot;);
  *t = T::default();
  println!(&quot;  value mutated internally to {:?}&quot;, t);
  // has side effects since t is ref to caller's value
}
/*-- demonstrate variable has not been moved ------------*/
fn verify&lt;T&gt;(_t:T) {  // can only call this if t is valid
  /* t is valid */
}

/*-- demonstrate copy types -------------------------------
  Primitives and arrays of primitives are Copy types so
  construction, assignment, and pass-by-value result in
  copying entire source to destination.

  Most non-primitive types are not Copy, but provide a
  clone() function to make copies explicitly.
*/
fn demo_copy() {
  show_note(&quot;demonstrate copy and pass-by-value&quot;);
  nl();

  show_op(&quot;direct integer copy&quot;);
  let i_src = 42i64;  // copy literal 42 into i
  let i_dst = i_src;
  println!(&quot;  source: {i_src:?}&quot;);
  println!(&quot;  destin: {i_dst:?}&quot;);
  nl();

  show_op(&quot;direct copy of array of f64&quot;);
  let arr_src = [3.14f64, 0.5, -0.75];  // copy type
  let arr_dst = arr_src;
  println!(&quot;  source: {arr_src:?}&quot;);
  println!(&quot;  destin: {arr_dst:?}&quot;);
  nl();

  show_op(&quot;direct vector clone&quot;);
  let v_src = vec![1, 2, 3, 2, 1];
  let v_dst = v_src.clone();
  // let v_dst = v_src;  moves v_src resources to v_dst
  // does not copy
  println!(&quot;  source: {v_src:?}&quot;);
  println!(&quot;  destin: {v_dst:?}&quot;);
  nl();

  show_op(&quot;pass-by-value copies integer&quot;);
  pass_by_val(i_src);
  nl();

  show_op(&quot;pass-by-value moves vector&quot;);
  pass_by_val(v_src);
  // println!(&quot;{:?}&quot;, v_src); fails to compile, v_scr moved

}

/*-- demonstrate references -------------------------------
  Illustrates  side affects of passing by reference
  - function pass_by_ref(&t) mutates t to illustrate
    that caller sees this change.
*/
fn demo_pass_by_ref() {
  show_label(&quot;demonstrate pass-by-reference&quot;, 50);

  show_label(&quot;these demos have side effects&quot;, 35);
  nl();

  show_op(&quot;pass integer reference&quot;);
  let mut i = 42i64;
  println!(&quot;  before pass_by_ref: {i:?}&quot;);
  pass_by_ref(&mut i);
  println!(&quot;  after pass_by_ref: {i:?}&quot;);
  nl();

  show_op(&quot;pass reference to vector&quot;);
  let mut v = vec![1, 2, 3, 4, 5];
  println!(&quot;  before pass_by_ref: {v:?}&quot;);
  pass_by_ref(&mut v);
  println!(&quot;  after pass_by_ref: {v:?}&quot;);
  nl();

  show_op(&quot;pass reference to HashMap&quot;);
  let mut m = HashMap::&lt;&str, i32&gt;::new();
  m.insert(&quot;zero&quot;, 0);
  m.insert(&quot;one&quot;, 1);
  m.insert(&quot;two&quot;, 2);
  println!(&quot;  before pass_by_ref: {m:?}&quot;);
  pass_by_ref(&mut m);
  println!(&quot;  after pass_by_ref: {m:?}&quot;);
}

/*-- demonstrate move types -------------------------------
  Construction, assignment, and pass-by-value all result
  in moving the source resources to the destination.

  That is fast, usually only a few bytes are copied.

  This demo shows that move source and destination are
  unique, but source and destination share same heap buffer.
*/
fn show_addresses&lt;'a, T:Debug + AsRef&lt;[u8]&gt;&gt;(t:&T, nm:&str) {
  println!(&quot;  {}: {:?}&quot;, nm, t);  // show value of t
  let addr_t = std::ptr::addr_of!(*t);
  println!(&quot;  static address of {}: {:?}&quot;, nm, addr_t);
  let byte_ref = t.as_ref();
  let addr_res = std::ptr::addr_of!(byte_ref[0]);
  println!(&quot;  heap address of {}'s buffer: {:?}&quot;, nm, addr_res);
}
fn demo_move() {
  show_note(&quot;demonstrate move&quot;);
  nl();

  show_op(&quot;demo_move for String&quot;);
  let s = String::from(&quot;a string&quot;);
  show_addresses(&s, &quot;s&quot;);
  let addrzero = std::ptr::addr_of!(s.as_bytes()[0]);
  println!(&quot;  check - address of first byte of chars: {:?}&quot;, addrzero);

  let t = s;  // move
  show_op(&quot;let t:String = s; // move&quot;);
  show_addresses(&t, &quot;t&quot;);
  nl();

  println!(&quot;  Note: s and t are unique objects&quot;);
  println!(&quot;  that share same buffer&quot;);
  println!(&quot;  but now, s is invalid&quot;);
  nl();

  show_op(&quot;demo_move for Vec&quot;);
  let u = vec![1, 2, 3, 2, 1];
  show_addresses(&u, &quot;u&quot;);
  let addrzero = std::ptr::addr_of!(u[0]);
  println!(&quot;  check - address of u[0]: {:?}&quot;, addrzero);

  show_op(&quot;let v:Vec&lt;u8&gt; = u; // move&quot;);
  let v = u;  // move
  show_addresses(&v, &quot;v&quot;);
}

/*---------------------------------------------------------
  Demonstrate mutability
*/
fn demo_mutable() {
  show_note(&quot;demonstrate mutability&quot;);
  nl();

  show_op(&quot;demo_mutable for primitives&quot;);
  let mut i = 42i32;
  print!(&quot;  original value: {i:?}&quot;);
  i += 1;
  println!(&quot;, changed value:  {i:?}&quot;);

  let mut f = 3.14159f64;
  print!(&quot;  original value: {f:?}&quot;);
  f += 1.0;
  println!(&quot;, changed value:  {f:?}&quot;);
  nl();

  show_op(&quot;demo_mutable for std::lib types&quot;);
  let mut v = vec![1, 2, 3];
  print!(&quot;  original value: {v:?}&quot;);
  v[1] += 1;
  println!(&quot;, changed value:  {v:?}&quot;);

  let mut m = HashMap::&lt;&str,i32&gt;::new();
  m.insert(&quot;zero&quot;, 0);
  m.insert(&quot;one&quot;, 1);
  m.insert(&quot;two&quot;, 2);
  println!(&quot;  original value: {m:?}&quot;);
  /* entry returns reference to value of supplied key */
  let mut value = m.entry(&quot;one&quot;).or_insert(1);
  *value += 1;
  println!(&quot;  changed value:  {m:?}&#92;n&quot;);
}
/*---------------------------------------------------------
  Demonstrate references
  - illustrates that mutability cannot be shared using
    references
*/
fn demo_ref() {
  show_note(&quot;demonstrate references&quot;);
  nl();

  show_op(&quot;demo_ref immutable&quot;);
  let v1 = vec![1, 2, 3, 2, 1];
  /* can use any number of immutable referenes */
  let r1v1 = &v1;
  println!(&quot;  r1v1: {r1v1:?}&quot;);
  let r2v1 = &v1;
  println!(&quot;  r2v1: {r2v1:?}&quot;);
  nl();

  show_op(&quot;demo_ref mutable&quot;);
  /* can't mutate data through shared references */
  let mut v2 = vec![1, 2, 3, 4, 5];
  /* immutable borrow */
  let r1v2 = &v2;
  println!(&quot;  r1v2: {r1v2:?}&quot;);
  /* mutable borrow ok if we don't use immutable borrow later */
  let mr2v2 = &mut v2;
  mr2v2.push(42);
  println!(&quot;  mr2v2: {mr2v2:?}&quot;);
  /*
    Use of immutable borrow in println! illegal with active
    mutable borrow. Try uncommenting line below.
  */
  // println!(&quot;  r1v2: {r1v2:?}&quot;);
}
/*-- execute demonstrations -----------------------------*/
fn main() {
    show_note(
      &quot;Demonstrate Rust types&quot;
    );

    create_initialize();
    demo_copy();
    demo_pass_by_ref();
    demo_move();
    demo_mutable();
    demo_ref();

    println!(&quot;&#92;n&#92;nThat's all Folks!!&#92;n&#92;n&quot;);
}</code></pre>
          <h4 id="anal">Source Code: bits_data_analysis.rs</h4>
          <pre><code class="language-rust">#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(clippy::approx_constant)]

/* rust_data::bits_data_analysis.rs */
/*-----------------------------------------------
Note:
Find all Bits code, including this in
https://github.com/JimFawcett/Bits
You can clone the repo from this link.
-----------------------------------------------*/

use std::fmt::Debug;

/*-- show_type --------------------------------------------
  Shows compiler recognized type and data value
*/
pub fn show_type&lt;T: Debug&gt;(t: &T, nm: &str) {
  let typename = std::any::type_name::&lt;T&gt;();
  print!(&quot;  {nm}, {typename}&quot;);
  println!(
    &quot;&#92;n  value: {:?}, size: {}&quot;,  // smart formatting {:?}
    t, std::mem::size_of::&lt;T&gt;()   // handles both scalars
  );                              // and collections
}
/*---------------------------------------------------------
  show string wrapped with long dotted lines above and below
*/
pub fn show_label(note: &str, n:usize) {
  let mut line = String::new();
  for _i in 0..n {
    line.push('-');
  }
  print!(&quot;&#92;n{line}&#92;n&quot;);
  print!(&quot;  {note}&quot;);
  print!(&quot;&#92;n{line}&#92;n&quot;);
}
pub fn show_label_def(note:&str) {
  show_label(note, 50);
}
/*---------------------------------------------------------
  show string wrapped with dotted lines above and below
*/
pub fn show_note(note: &str) {
  print!(&quot;&#92;n-------------------------&#92;n&quot;);
  print!(&quot; {note}&quot;);
  print!(&quot;&#92;n-------------------------&#92;n&quot;);
}
/*---------------------------------------------------------
  show string wrapped in short lines
*/
pub fn show_op(opt: &str) {
  println!(&quot;--- {opt} ---&quot;);
}
/*---------------------------------------------------------
  print newline
*/
pub fn nl() {
  println!();
}</code></pre>
          <h4 id="out">Output</h4>
          <pre class="codeSnaps"><code class="language-shell">C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_data
&gt; cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target&#92;debug&#92;rust_data.exe`

-------------------------
 Demonstrate Rust types
-------------------------

-------------------------
 create and initialize
-------------------------

--- initialize primitives ---
  int, i64
  value: 42, size: 8
  double, f64
  value: 3.15927, size: 8
  arr, [i32; 3]
  value: [1, 2, 3], size: 12

--- initialize std::lib types ---
  vec, alloc::vec::Vec&lt;i32&gt;
  value: [1, 2, 3, 2, 1], size: 24
  map, std::collections::hash::map::HashMap&lt;&str, i32&gt;
  value: {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;zero&quot;: 0}, size: 48

--- initialize user-defined type ---
  udt, rust_data::create_initialize::Demo
  value: Demo { name: &quot;demo&quot; }, size: 24

-------------------------
 demonstrate copy and pass-by-value
-------------------------

--- direct integer copy ---
  source: 42
  destin: 42

--- direct copy of array of f64 ---
  source: [3.14, 0.5, -0.75]
  destin: [3.14, 0.5, -0.75]

--- direct vector clone ---
  source: [1, 2, 3, 2, 1]
  destin: [1, 2, 3, 2, 1]

--- pass-by-value copies integer ---
  T, i64
  value: 42, size: 8
  value mutated internally to 0

--- pass-by-value moves vector ---
  T, alloc::vec::Vec&lt;i32&gt;
  value: [1, 2, 3, 2, 1], size: 24
  value mutated internally to []

--------------------------------------------------
  demonstrate pass-by-reference
--------------------------------------------------

-----------------------------------
  these demos have side effects
-----------------------------------

--- pass integer reference ---
  before pass_by_ref: 42
  T, &mut i64
  value: 42, size: 8
  value mutated internally to 0
  after pass_by_ref: 0

--- pass reference to vector ---
  before pass_by_ref: [1, 2, 3, 4, 5]
  T, &mut alloc::vec::Vec&lt;i32&gt;
  value: [1, 2, 3, 4, 5], size: 8
  value mutated internally to []
  after pass_by_ref: []

--- pass reference to HashMap ---
  before pass_by_ref: {&quot;zero&quot;: 0, &quot;two&quot;: 2, &quot;one&quot;: 1}
  T, &mut std::collections::hash::map::HashMap&lt;&str, i32&gt;
  value: {&quot;zero&quot;: 0, &quot;two&quot;: 2, &quot;one&quot;: 1}, size: 8
  value mutated internally to {}
  after pass_by_ref: {}

-------------------------
 demonstrate move
-------------------------

--- demo_move for String ---
  s: &quot;a string&quot;
  static address of s: 0x6a4c5af440
  heap address of s's buffer: 0x1d0d45282e0
  check - address of first byte of chars: 0x1d0d45282e0
--- let t:String = s; // move ---
  t: &quot;a string&quot;
  static address of t: 0x6a4c5af4a0
  heap address of t's buffer: 0x1d0d45282e0

  Note: s and t are unique objects
  that share same buffer
  but now, s is invalid

--- demo_move for Vec ---
  u: [1, 2, 3, 2, 1]
  static address of u: 0x6a4c5af550
  heap address of u's buffer: 0x1d0d4534980
  check - address of u[0]: 0x1d0d4534980
--- let v:Vec&lt;u8&gt; = u; // move ---
  v: [1, 2, 3, 2, 1]
  static address of v: 0x6a4c5af5b0
  heap address of v's buffer: 0x1d0d4534980

-------------------------
 demonstrate mutability
-------------------------

--- demo_mutable for primitives ---

--- demo_mutable for primitives ---
  original value: 42, changed value:  43
  original value: 3.14159, changed value:  4.14159

--- demo_mutable for std::lib types ---
  original value: [1, 2, 3], changed value:  [1, 3, 3]
  original value: {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;zero&quot;: 0}
  changed value:  {&quot;one&quot;: 2, &quot;two&quot;: 2, &quot;zero&quot;: 0}


-------------------------
 demonstrate references
-------------------------

--- demo_ref immutable ---
  r1v1: [1, 2, 3, 2, 1]
  r2v1: [1, 2, 3, 2, 1]

--- demo_ref mutable ---
  r1v2: [1, 2, 3, 4, 5]
  mr2v2: [1, 2, 3, 4, 5, 42]


That's all Folks!!


C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_data
</code></pre>
          <h4 id="build">Build</h4>
          <pre class="codeSnaps"><code class="language-shell">C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_data
&gt; cargo run
   Compiling rust_data v0.1.0 (C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_data)
    Finished dev [unoptimized + debuginfo] target(s) in 0.37s
     Running `target&#92;debug&#92;rust_data.exe`
          </code></pre>
        </div>
        <h3 id="ide">2.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in 
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Rust\rust_hello_data.
        </t-b>
        <photosizer-block src="pictures/VS_Code_Rust_Data.JPG" width="800" class="photoSizerBlock left"
          style="overflow-x:auto;"
        >
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE</span>
        </photosizer-block>
        <photosizer-block src="pictures/LaunchJSON_Rust_Data.JPG" width="700" class="photoSizerBlock left"
          style="overflow-x:auto;"
        >
          <span style="font-family:'Comic Sans MS';">Figure 2. Launch.JSON</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
          <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
        </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th><th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../RustStoryRepo.html">Rust Story</a>
            </td>
            <td>
              E-book with seven chapters covering most of intermediate Rust
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../RustBites/RustBites_Intro.html">Rust Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ide">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">bld</a></menu-elem>
        <menu-elem class="secElem"><a href="#out">out</a></menu-elem>
        <menu-elem class="secElem"><a href="#anal">anal</a></menu-elem>
        <menu-elem class="secElem"><a href="#source">src</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">codeSnaps</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
  <script>
    //localStorage.clear();
    getScroll();
  </script>
</body>
</html>