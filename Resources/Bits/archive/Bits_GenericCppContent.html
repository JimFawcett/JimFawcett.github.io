<!DOCTYPE html>
<html>
<!--
  Bits_GenericsCpp.html
-->
<head>
  <title>Bits_Generics C++</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeCpp.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBitsCpp.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <link rel="stylesheet" href="css/StylesSplitterBar.css" />
  <script src="js/ScriptsSplitterBar.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding: 0.75em 1.5em;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width: 50em;
    }

    #github h2 {
      margin-top: 0.75em;
    }

    #github #pagetitle {
      border: 2px double var(--dark);
    }

    #github form {
      border: none;
      padding: 0.5em 1em;
    }

      #github form span {
        padding: 0em 0.5em;
      }

    #github code-container {
      display: flex;
      position: relative;
      width: calc(100%);
      flex-direction: row;
      justify-content: space-between;
      /*border-top: 1px solid var(--dark);*/
    }

    #github code-banner {
      display: block;
      border: 2px solid var(--dark);
      border-top: none;
      border-bottom: none;
      padding: 0.25em 1em;
      font-family: 'Comic Sans MS', Tahoma;
      width: calc(100% + 0.5em);
      background-color: var(--atten);
    }

    #github code-display {
      display: block;
      border: 2px solid var(--dark);
      white-space: pre;
      padding: 0.75em 1em;
      font-family: Consolas, monospace;
      font-size: 0.9em;
      width: calc(50% - 0.5em);
      overflow-x: auto;
      /*height:20em;*/
    }

    #github label {
      margin-right: 1em;
    }

    #github fieldset {
      border: none;
    }

    #github #exeRight, #exeLeft {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }

    #github #hideLeft, #hideRight {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }

    #github .hide {
      display: none;
    }

    body {
      position: relative;
    }

    #github table.showcode {
      table-layout: fixed;
      width: calc(100% + 4em);
      margin-left: -2em;
    }

    #github th.leftblock {
      border: 2px solid var(--dark);
      /*border: 1px solid red;*/
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.rightblock {
      border: 2px solid var(--dark);
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.centerblock {
      border: none;
      padding: 0em;
      width: 1em;
    }

    #github td.leftblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em);
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

      #github td.leftblock summary {
        border: 1px solid #ffffbb;
      }

    #github td.rightblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em) !important;
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

      #github td.rightblock summary {
        border: 1px solid #ffffbb;
      }

    #github td.centerblock {
      border: none;
      padding: 0em;
    }

    #github pre {
      overflow-x: auto !important;
    }

    #github #left1 {
      /*height:45em;*/
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }

    #github #right1 {
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }

    #github #left2 {
      /*height:45em;*/
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right2 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #left3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github .mover {
      width: 2em;
      padding: 0.05em;
      position: relative;
      right: -1.5em;
      top: 0.6em;
    }

    #github #ruler {
      width: calc(50% - 1.5em);
      height: 0.001em;
      margin: -0.45em 0em;
    }

    #github .btns {
      width: 3em;
      border: none;
    }

    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 10px;
    }

    #github .remotebutton {
      padding: 0.25em 0.5em;
    }

    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }

    #github hr.spread {
      margin: 0.75em 0em;
    }
  </style>
  <script>
    function setScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = main.scrollTop;
      localStorage.setItem('scrollPositionHelloRust', scrollPosition);
      let body = document.getElementById("github");
      let style = window.getComputedStyle(body, null).getPropertyValue('line-height');
      let fontsize = parseFloat(style);
      let scroller = document.getElementById("scrollY")
      scroller.innerHTML = Math.trunc(scrollPosition / fontsize);
    }
    function gotoLastScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = localStorage.getItem('scrollPositionHelloRust');
      if (scrollPosition) {
        main.scrollTo(0, scrollPosition);
      }
      main.addEventListener('scroll', setScroll);
    }
    function load() {
      //initialize();
      gotoLastScroll();
    }
  </script>

  <script>
    function remote() {
      window.open('https://godbolt.org/z/7fsjjoW9W', '_blank');
    }
  </script>
</head>
<body id="github" onload="load()">

  <a id="Next" href="Bits_IterCpp.html">Next</a>
  <a id="Prev" href="Bits_ObjectsCpp.html">Prev</a>

  <page-frame>
    <!-- <frame-header>
      <nav id="navbar"></nav>
    </frame-header> -->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits Generics C++</div>
      <div id="modified">02/11/2024</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.750em; width:max-content; height:1.5em;
             text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits_Generics C++</h1>
            <h3 id="subtitle" class="indent">
              code, output, and build for C++ on Windows, macOS, and Linux
            </h3>
          </hgroup>
        </header>
        <t-b style="border:2px solid red; padding:0.5em 1.5em;">
          This page is a prototype used to decide which language features to emphasize. It will
          be replaced with a final version soon.
        </t-b>
        <t-b style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          This page demonstrates creation and uses of C++ generic types and their objects.
          The purpose is to quickly acquire some familiarity with generic types
          and their implementations.
          <hr class="spread" />
          <ul>
            <li>
              C++ Generics are defined with template functons, patterns for defining functions, and template
              classes, patterns for defining types.
            </li>
            <li>
              Templates are compiled in two phases<sup>1</sup>:
              <ol>
                <li>
                  Compilation of template patterns with unknown parameter types:<br />
                  template code is checked for syntax errors.  Unknow names that don't depend on
                  template parameters are discovered, and static assertions that don't depend on template
                  patterns are checked.
                </li>
                <li>
                  Instantiation with specific parameter types in using code:<br />
                  When translating user code<sup>2</sup>, the compiler must see pattern definitions as well
                  as specific types for parameters<sup>3</sup>. Using that, code is generted if there are no
                  errors.
                </li>
              </ol>
            </li>
          </ul>
          <hr class="spread" />
          <div class="indent">
            <ol class="indent tight">
              <li>
                C++ Templates, The Complete Guide, Second Edition, Vandevoorde, Josuttis, Gregor
              </li>
              <li>
                Each *.cpp file and its included *.h files is compiled separately from
                all other *.cpp filies, then resulting object code is linked together as the final stage
                of translation, if statically linked.
              </li>
              <li>
                That means that each included file must contain, directly, or indirectly, all of the template
                definitions on which it depends.
              </li>
            </ol>
          </div>
          <div style="height:0.5em;"></div>
        </t-b>
        <details>
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <t-b><hr /></t-b>
          <t-b>
            Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
            is a pattern for defining functions and classes of a specific type.  Thus a generic class is a
            pattern for making patterns.
          </t-b>
          <t-b>
            The other two, Python and JavaScript, are dynamically typed and already support defining
            functions and classes for multiple types, e.g., no need for generics.
          </t-b>
          <t-b>
            This demonstration illustrates use of generic classes and objects, which for C++, Rust, and C#,
            are defined in a stackframe or in the heap or both. <strongs>All</strongs> data for Python and JavaScript are
            stored in managed heaps.
          </t-b>
          <t-b><hr /></t-b>
        </details>
        <t-b>
          The examples below show how to use library and user defined generic types with emphasis on
          illustrating syntax and basic operations.
        </t-b>
        <div style="height:0.25em;"></div>
        <h3 id="code">1.0 CodeSnaps</h3>
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote()" />
        <div style="display:flex; flex-direction:column;">
          <h4 id="source">Source Code - Bits_Generics.cpp</h4>
          <pre class="codeSnap">
/*-------------------------------------------------------------------
  Cpp_Generics.cpp
  - depends on PointsGen.h to provide user-defined point class
  - depends on Analysis.h for several display and analysis functions
*/
#include &lt;iostream&gt;       // std::cout
#include &lt;memory&gt;         // std::unique_ptr
#include &lt;vector&gt;         // vector&lt;T&gt; class
#include &lt;array&gt;          // array&lt;T&gt; class
#include &lt;map&gt;            // map&lt;K,V&gt; class
#include &lt;set&gt;            // set&lt;T&gt; class
#include &quot;AnalysisGen.h&quot;  // Analysis functions
#include &quot;PointsGen.h&quot;    // PointN&lt;T&gt; class declaration
#include &quot;Stats.h&quot;        // Stats class declaration
/*
  This demo uses std::basic_string&lt;char&gt; and std::vector&lt;T&gt;
  classes and user defined classes, Stats&lt;T&gt; and PointN&lt;T&gt;, to
  illustrate how objects are defined and instantiated.

  Operations:
    All the classes discussed here provide operations for:
      T t2 = t1          // copy construction
      T t3 = temporary   // move construction
      t1 = t2            // copy assignment
      t3 = temporary     // move assignment

    All instances return their resources when they go out of
    scope by implicitly calling their destructor.
    Primitive types can all be copied.

    Most library and user-defined types can be copied, moved,
    and deleted by providing member constructors and destructor.
    Often compiler generation works well, but for classes with
    pointer members developers must provide them.

  Processing:
    All types are static, operations run as native code, and no
    garbage collection is needed. Resources are returned at end
    of their declaration scope.
*/
#pragma warning(disable: 4984)  // warns about C++17 extension

/*-----------------------------------------------
  alias type names
  - pU&lt;T&gt; is the same type as std::unique_ptr&lt;T&gt;
  - this just provides a shorter name
*/
template&lt;typename T&gt;
using pU = std::unique_ptr&lt;T&gt;;
/*
  The std library uses aliases:
  using string = basic_string&lt;char&gt;;
  using wstring = basic_string&lt;wchar_t&gt;;
*/
/*-------------------------------------------------------------------
  Demonstration starts here
*/
void testFormats();

int main() {

    print(&quot;Demonstrate C++ Generic Objects&#92;n&quot;);

    showNote(&quot;std library types string and vector&lt;T&gt;&quot;);
    /* create and display std::basic_string&lt;char&gt; object */
    auto str = std::basic_string&lt;char&gt;(&quot;&#92;&quot;Wile E. Coyote&#92;&quot;&quot;);
    auto out = std::basic_string&lt;char&gt;(&quot;contents of str = &quot;) + str;
    print(out);
    print(&quot;--- showType(str, &#92;&quot;str&#92;&quot;); ---&quot;);
    showType(str, &quot;str&quot;, nl);

    /* create and display std::vector&lt;double&gt; */
    auto vec = std::vector&lt;double&gt;{ 3.5, 3, 2.5, 2 };
    std::cout &lt;&lt; vec;
    showOp(&quot;showType(vec, &#92;&quot;vec&#92;&quot;);&quot;);
    showType(vec, &quot;vec&quot;, nl);

    showOp(&quot;vec[2] = -2.5;&quot;);
    vec[2] = -2.5;
    std::cout &lt;&lt; &quot;&#92;n  vec:&quot; &lt;&lt; vec;

    showOp(&quot;auto vec2 = vec : copy construction&quot;);
    /* copy construction */
    auto vec2 = vec;
    std::cout &lt;&lt; &quot;&#92;n  vec2:&quot; &lt;&lt; vec2;

    showOp(&quot;vec2[0] = 42;&quot;);
    vec2[0] = 42;
    std::cout &lt;&lt; &quot;&#92;n  vec2: &quot; &lt;&lt; vec2;
    std::cout &lt;&lt; &quot;&#92;n  vec: &quot; &lt;&lt; vec;

    showNote(
      &quot;Copy construction, auto vec2 = vec, creates&#92;n    &quot;
      &quot;independent instance. So changing target vec2&#92;n    &quot;
      &quot;has no affect on source vec.&quot;, nl
    );

    showNote(&quot;User-defined Types&quot;, nl);

    showOp(&quot;statistics for integer types&quot;);

    auto v1 = std::vector&lt;int&gt;{1, 2, 3, 4, 5, 6};
    auto s1 = Stats&lt;int&gt;(v1);
    s1.show(&quot;s1&quot;);
    std::cout &lt;&lt; &quot;&#92;n  s1.size() = &quot; &lt;&lt; s1.size();
    std::cout &lt;&lt; &quot;&#92;n  s1.max() = &quot; &lt;&lt; s1.max();
    std::cout &lt;&lt; &quot;&#92;n  s1.min() = &quot; &lt;&lt; s1.min();
    std::cout &lt;&lt; &quot;&#92;n  s1.sum() = &quot; &lt;&lt; s1.sum();
    std::cout &lt;&lt; &quot;&#92;n  s1.avg() = &quot; &lt;&lt; s1.avg();
    print();

    showOp(&quot;statistics for float types&quot;);

    auto v2 = std::vector&lt;double&gt;{1.0, 2.1, 3.2, 4.3, 5.4, 6.5};
    auto s2 = Stats&lt;double&gt;(v2);
    s2.show(&quot;s2&quot;);
    std::cout &lt;&lt; &quot;&#92;n  s2.size() = &quot; &lt;&lt; s2.size();
    std::cout &lt;&lt; &quot;&#92;n  s2.max() = &quot; &lt;&lt; s2.max();
    std::cout &lt;&lt; &quot;&#92;n  s2.min() = &quot; &lt;&lt; s2.min();
    std::cout &lt;&lt; &quot;&#92;n  s2.sum() = &quot; &lt;&lt; s2.sum();
    std::cout &lt;&lt; &quot;&#92;n  s2.avg() = &quot; &lt;&lt; s2.avg();
    print();

  showOp(&quot;user-defined type PointN&lt;T&gt;&quot;, nl);

    PointN&lt;double&gt; p1(5);
    p1.show(&quot;p1&quot;);
    print();

    showNote(
      &quot;p1.coords() = std::vector&lt;double&gt;&#92;n    &quot;
      &quot;{ 1.0, -2.0, 3.0, 4.5, -42.0 }&quot;, nl
    );
    p1.coords() = std::vector&lt;double&gt;{1.0, -2.0, 3.0, 4.5, -42.0 };
    p1.show(&quot;p1&quot;);
    print();

    showOp(&quot;showType(p1, &#92;&quot;p1&#92;&quot;, nl);&quot;);
    showType(p1, &quot;p1&quot;, nl);
    std::cout &lt;&lt; &quot;  p1.coords()[2] = &quot; &lt;&lt; p1.coords()[2] &lt;&lt; &quot;&#92;n&quot;;

    /*-- copy construction --*/

    auto p2 = p1;
    showOp(&quot;auto p2 = p1&quot;);
    p2.show(&quot;p2&quot;);
    showOp(&quot;p2[1] = 5.5&quot;);
    p2[1] = 5.5;
    p2.show(&quot;p2&quot;);
    p1.show(&quot;p1&quot;);
    print();

    showNote(&quot;heap-based string instance&quot;);

    /* standard library type std::basic_string&lt;char&gt; */
    /* uses alias pU for std::unique_ptr, defined above */
    showOp(
      &quot;pU&lt;std::basic_string&lt;char&gt;&gt; &quot;
      &quot;pStr(new std::basic_string&lt;char&gt;(&#92;&quot;&#92;&#92;&#92;&quot;Road Runner&#92;&#92;&#92;&quot;&#92;&quot;)&quot;
    );
    pU&lt;std::basic_string&lt;char&gt;&gt; pStr(new std::basic_string&lt;char&gt;(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;));
    std::cout &lt;&lt; &quot;&#92;n  pStr contents = &quot; &lt;&lt; *pStr &lt;&lt; &quot;&#92;n&quot;;

    showOp(&quot;showType(*pStr, &#92;&quot;*pStr&#92;&quot;)&quot;);
    showType(*pStr, &quot;*pStr&quot;, nl);

    /* std::unique_ptr&lt;T&gt; cannot be copied but can be moved */
    showOp(&quot;showType(move(pStr), &#92;&quot;pStr&#92;&quot;)&quot;);
    showType(move(pStr), &quot;pStr&quot;, nl);

    /* standard library type std::vector&lt;T&gt; */
    showNote(&quot;heap-based vector instance&quot;);
    showOp(
      &quot;pU&lt;std::vector&lt;double&gt;&gt;&#92;n &quot;
      &quot;     pVec(new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 });&quot;
    );
    pU&lt;std::vector&lt;double&gt;&gt; pVec(
      new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }
    );
    std::cout &lt;&lt; &quot;&#92;n  *pVec = &quot; &lt;&lt; *pVec;
    showType(*pVec, &quot;*pVec&quot;, nl);
    std::cout &lt;&lt; &quot;&#92;n  pVec = &quot; &lt;&lt; pVec;
    showType(move(pVec), &quot;move(pVec)&quot;, nl);

    /* custom point type */

    showNote(&quot;heap-based PointN&lt;T&gt; instance&quot;);

    showOp(&quot;pU&lt;PointN&lt;double&gt;&gt; pPointN(new PointN&lt;double&gt;(4))&quot;);
    pU&lt;PointN&lt;double&gt;&gt; pPointN(new PointN&lt;double&gt;(4));
    pPointN-&gt;show(&quot;*pPointN&quot;);

    showOp(
      &quot;pPointN-&gt;coords() = &#92;n&quot;
      &quot;      std::vector&lt;double&gt;{ 1.0, 3.5, -2.0, 42.0 };&quot;
    );
    pPointN-&gt;coords() = std::vector&lt;double&gt;{ 1.0, 3.5, -2.0, 42.0 };
    pPointN-&gt;show(&quot;*pPointN&quot;);
    std::cout &lt;&lt; &quot;&#92;n  value of pPointN-&gt;coords()[1] is &quot;
              &lt;&lt; pPointN-&gt;coords()[1];

    showOp(&quot;showType(*pPointN, &#92;&quot;*pPointN&#92;&quot;);&quot;);
    showType(*pPointN, &quot;*pPointN&quot;);

    showOp(&quot;showType(std::move(pPointN), &#92;&quot;pPointN&#92;&quot;);&quot;);
    showType(std::move(pPointN), &quot;pPointN&quot;);
    /* pPointN moved, so now invalid */
    print();

    //#define TEST
    #ifdef TEST
      testFormats();
    #endif

    print(&quot;&#92;n  That's all Folks!&#92;n&#92;n&quot;);
}

void testFormats() {

    showNote(&quot;Test and demonstrate formatting functions&quot;);

    showOp(&quot;demonstrate PointN show()&quot;);
    print(&quot;default indent = 4 and width = 7:&quot;);
    PointN&lt;int&gt; p1a(15);
    p1a.show(&quot;p1a&quot;);
    size_t saveLeft = p1a.left();
    size_t saveWidth = p1a.width();
    print(&quot;&#92;n  indent = 6, width = 12:&quot;);
    p1a.left() = 6;
    p1a.width() = 12;
    p1a.show(&quot;p1a&quot;);

    showOp(
      &quot;demonstrate operator&lt;&lt; overload for PointN ---&quot;
    );
    p1a.left() = saveLeft;
    p1a.width() = saveWidth;
    print(&quot;default indent = 4 and width = 7:&quot;);
    std::cout &lt;&lt; p1a;
    print(&quot;&#92;n  indent = 6, width = 12:&quot;);
    p1a.left() = 6;
    p1a.width() = 12;
    std::cout &lt;&lt; p1a;

    showOp(
      &quot;demonstrate operator&lt;&lt; overload for vector&quot;
    );
    auto vtest = std::vector&lt;int&gt;{1, 2, 3, 4, 5, 6, 7, 8, 9 };
    print(&quot;default indent = 4 and width = 7:&quot;);
    std::cout &lt;&lt; vtest;
    DisplayParams.left = 2;
    DisplayParams.width = 5;
    print(&quot;indent = 2, width = 5:&quot;);
    std::cout &lt;&lt; vtest;

    std::cout &lt;&lt; formatColl(vtest, &quot;vtest&quot;, nl, 2, 5);
    std::cout &lt;&lt; formatColl(vtest, &quot;vtest&quot;, nl, 4, 7);
    std::cout &lt;&lt; formatColl(vtest, &quot;vtest&quot;, nl, 2, 9);
    std::cout &lt;&lt; formatColl(vtest, &quot;vtest: vector&lt;int&gt;&quot;, nl, 2, 10);

    std::array&lt;double, 5&gt; arrtest = { 1, 2, 3, 4.5, -3.14159 };
    std::cout &lt;&lt; formatColl(arrtest, &quot;arrtest&quot;, nl, 2, 4);

    std::map&lt;int, std::basic_string&lt;char&gt;&gt; amap {
       {1, &quot;one&quot;}, {2, &quot;two&quot;}, {3, &quot;three&quot;}
    };
    std::cout &lt;&lt; formatColl(amap, &quot;amap&quot;, nl, 2, 4);

    std::set&lt;std::basic_string&lt;char&gt;&gt; aset {
      &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;
    };
    std::cout &lt;&lt; formatColl(aset, &quot;aset&quot;, nl, 2, 4);

    std::basic_string&lt;char&gt; astring = &quot;this is a string&quot;;
    std::cout &lt;&lt; formatString(astring, &quot;astring&quot;, nl, 2);

    double adouble { 3.1415927 };
    std::cout &lt;&lt; formatScalar(adouble, &quot;adouble&quot;, nl);

    showNote(&quot;Using consolidated format function&quot;, nl);

    std::cout &lt;&lt; format(adouble, &quot;adouble&quot;, nl);
    std::cout &lt;&lt; format(astring, &quot;astring&quot;, nl);
    std::vector&lt;double&gt; avec{ 1, 2, 3, 4.5, -3.14159 };
    std::cout &lt;&lt; format(avec, &quot;avec&quot;, nl);
    std::cout &lt;&lt; format(amap, &quot;amap&quot;, nl);
}
          </pre>
          <h4 id="stats">Source Code - Stats.h</h4>
          <pre class="codeSnap">
/*-------------------------------------------------------------------
  Stats.h defines Stats&lt;T&gt; class
  - Stats&lt;T&gt; holds a std::vector&lt;T&gt; and provides methods for
    computing max, min, average of this collection
    of unspecified type T
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;exception&gt;
/*-------------------------------------------------------------------
  Stats&lt;T&gt; class provides several simple computational services on
  a vector of items who's type provides required arithmetic operations.
*/
template &lt;typename T&gt;
class Stats {
public:
    Stats(const std::vector&lt;T&gt;& v);
    size_t size();
    T max();
    T min();
    T sum();
    double avg();
    void show(const std::string& name=&quot;&quot;);
private:
    bool check();
    const std::vector&lt;T&gt;& items;
};

template&lt;typename T&gt;
Stats&lt;T&gt;::Stats(const std::vector&lt;T&gt;& v) : items(v) {}

template&lt;typename T&gt;
bool Stats&lt;T&gt;::check() {
    return items.size() &gt; 0;
}
template&lt;typename T&gt;
size_t Stats&lt;T&gt;::size() {
    if(!check()) {
        throw &quot;Stats is empty&quot;;
    }
    return items.size();
}
template&lt;typename T&gt;
T Stats&lt;T&gt;::max() {
    if(!check()) {
        throw &quot;Stats is empty&quot;;
    }
    auto max = items[0];
    for( auto item : items) {
        if (item &gt; max) {
            max = item;
        }
    }
    return max;
}
template&lt;typename T&gt;
T Stats&lt;T&gt;::min() {
    if(!check()) {
        throw &quot;Stats is empty&quot;;
    }
    auto min = items[0];
    for( auto item : items) {
        if (item &lt; min) {
            min = item;
        }
    }
    return min;
}
template&lt;typename T&gt;
T Stats&lt;T&gt;::sum() {
    if(!check()) {
        throw &quot;Stats is empty&quot;;
    }
    auto sum = T{0};
    for( auto item : items) {
        sum += item;
    }
    return sum;
}
template&lt;typename T&gt;
double Stats&lt;T&gt;::avg() {
    if(!check()) {
        throw &quot;Stats is empty&quot;;
    }
    auto sum = T{0};
    for( auto item : items) {
        sum += item;
    }
    return double(sum)/double(items.size());
}
template&lt;typename T&gt;
void Stats&lt;T&gt;::show(const std::string& name) {
    if(!check()) {
        throw &quot;Stats is empty&quot;;
    }
    std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; name &lt;&lt; &quot; {&#92;n    &quot;;
    auto iter = items.begin();
    std::cout &lt;&lt; *iter++;
    while(iter != items.end()) {
        std::cout &lt;&lt; &quot;, &quot; &lt;&lt; *iter++;
        std::cout.flush();
    }
    std::cout &lt;&lt; &quot;&#92;n  }&#92;n&quot;;
}
          </pre>
          <h4 id="points">Source Code - PointsGen.h</h4>
          <pre class="codeSnap">
/*-------------------------------------------------------------------
  PointsGen.h defines point classe PointN&lt;T&gt;
  - PointN&lt;T&gt; represents points with many coordinates of
    unspecified type T
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
/*-------------------------------------------------------------------
  PointN&lt;T&gt; class represents a point in an n-Dimensional hyperspace.
  It uses a template parameter to support a variety of coordinate
  types, and uses a vector to hold any finite number of
  coordinates.

  Its default constructor PointN() is declared delete so it won't
  be provided here nor generated by the compiler.

  It does not provide an iterator nor begin() and end() members.
  Those will come with the iteration bit.
*/
template&lt;typename T&gt;
class PointN {
public:
  PointN() = delete;                              // default ctor
  PointN(size_t N);
  PointN(const PointN& pt) = default;             // copy ctor
  PointN(PointN&& pt) = default;                  // move ctor
  PointN& operator=(const PointN& pt) = default;  // copy assignment
  PointN& operator=(PointN&& pt) = default;       // move assignemnt
  ~PointN() = default;                            // dtor

  size_t size() const;
  T& operator[](size_t index);                    // index oper
  T operator[](size_t index) const;               // const index oper

  void push_back(T r);
  T pop_back();
  std::vector&lt;T&gt;& coords() { return coord; }

  void show(const std::string& name);             // display contents
  size_t& left() { return _left; }                // display indent
  size_t& width() { return _width; }              // display width
private:
  std::vector&lt;T&gt; coord;
  size_t _left = 2;   // default display indent
  size_t _width = 7;  // default display row width
};
/*-----------------------------------------------
  PointN&lt;T&gt; constructor with size
*/
template&lt;typename T&gt;
PointN&lt;T&gt;::PointN(size_t N) {
  for(size_t i=0; i&lt;N; i++) {
    coord.push_back(T{0});
  }
}
template&lt;typename T&gt;
size_t PointN&lt;T&gt;::size() const {
  return coord.size();
}
template&lt;typename T&gt;
T& PointN&lt;T&gt;::operator[](size_t index) {
  if (index &lt; 0 || coord.size() &lt;= index) {
    throw &quot;indexing error&quot;;
  }
  return coord[index];
}
template&lt;typename T&gt;
T PointN&lt;T&gt;::operator[](size_t index) const {
  if (index &lt; 0 || coord.len() &lt;= index) {
    throw &quot;indexing error&quot;;
  }
  return coord[index];
}
template&lt;typename T&gt;
void PointN&lt;T&gt;::push_back(T t) {
  coord.push_back(t);
}
template&lt;typename T&gt;
T PointN&lt;T&gt;::pop_back() {
  return coord.pop_back();
}
/*-----------------------------------------------
  PointtN&lt;T&gt; display function
*/
template&lt;typename T&gt;
void PointN&lt;T&gt;::show(const std::string& name) {
  std::cout &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(_left) &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; &quot;PointN&lt;T&gt;&quot;;
  std::cout &lt;&lt; &quot; {&#92;n&quot;;
  std::cout &lt;&lt; fold(coord, _left + 2, _width);
  std::cout &lt;&lt; indent(_left) &lt;&lt; &quot;}&quot;;
}
/*-----------------------------------------------
  Overload operator&lt;&lt; required for
  showType(PointN&lt;T&gt; t, const std::string& nm)
*/
template&lt;typename T&gt;
std::ostream& operator&lt;&lt;(std::ostream& out, PointN&lt;T&gt;& t2) {
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(t2.left()) &lt;&lt; &quot;PointN&lt;T&gt;&quot;;
  out &lt;&lt; &quot; {&#92;n&quot;;
  out &lt;&lt; fold(t2.coords(), t2.left() + 2, t2.width());
  out &lt;&lt; indent(t2.left()) &lt;&lt; &quot;}&quot;;
  return out;
}
          </pre>
          <h4 id="analysis">Source Code - AnalysisGen.h</h4>
          <pre class="codeSnap">
/*-------------------------------------------------------------------
  AnalysisGen.h
  - Provides functions that analyze types, display results
    and other program defined information.
  - Some of this code requires complex template operations.
    Those will be discussed in the generics bit.
  - You can skip the hard parts until then, without loss
    of understanding.
*/

#include &lt;typeinfo&gt;     // typeid
#include &lt;utility&gt;      // move()
#include &lt;sstream&gt;      // stringstream
#include &lt;type_traits&gt;  // is_scalar, if constexpr
#include &lt;iostream&gt;     // cout
#include &lt;vector&gt;       // vector

/*-------------------------------------------------------------------
  Analysis function declarations are provided here so that
  definitions below may be placed in any order. That's
  needed because C++ requires declaration before use.
*/
template&lt;typename T&gt;
void showType(T t, const std::string &nm, const std::string& suffix = &quot;&quot;);
void showNote(const std::string& txt, const std::string& suffix = &quot;&quot;);
void showOp(const std::string& opstr, const std::string& suffix = &quot;&quot;);
void print(const std::string& txt = &quot;&quot;);
void println(const std::string& txt = &quot;&quot;);
std::string truncate(size_t N, const char* pStr);
std::string indent(size_t n);
template&lt;typename T&gt;
std::string fold(std::vector&lt;T&gt;& v, size_t left, size_t width);
template&lt;typename T&gt;
std::string formatColl(
  const T& t, const std::string& nm,
  const std::string& suffix = &quot;&quot;, size_t left = 2, size_t width = 7
);
template&lt;typename T&gt;
std::string formatScalar(
  const T& t, const std::string& nm,
  const std::string& suffix = &quot;&quot;, size_t left = 2
);
template&lt;typename T&gt;
std::string formatString(
  const T& t, const std::string& nm, const std::string& suffix,
  size_t left = 2
);
template&lt;typename T&gt;
std::string format(
  const T& t, const std::string& nm, const std::string& suffix = &quot;&quot;,
  size_t left = 2, size_t width = 7
);
/*-- end of function definitions --*/

/*-------------------------------------------------------------------
  Display and Analysis functions and global definitions
-------------------------------------------------------------------*/

const std::string nl = &quot;&#92;n&quot;;
/*-------------------------------------------------------------------
  Mutable globals are a common source of bugs.  We try not
  to use them, but will use DisplayParams here to control how
  the insertion operator sends instances to standard output.
*/
struct displayParams {
  size_t left = 2;    // number of spaces to indent
  size_t width = 7;   // width of display row
  size_t trunc = 40;  // replace text after trunc with ...
} DisplayParams;      // global object

/*-----------------------------------------------
  Overload operator&lt;&lt; required for
  showType(std::vector&lt;T&gt; v, const std::vector&lt;T&gt;& nm)
*/
template&lt;typename T&gt;
std::ostream& operator&lt;&lt;(std::ostream& out, std::vector&lt;T&gt;& v) {
  out &lt;&lt; format(v, &quot;vector&lt;T&gt;&quot;, &quot;&quot;, DisplayParams.left, DisplayParams.width);
  return out;
}
/*-----------------------------------------------
  Display calling name, static class, and size
*/
template&lt;typename T&gt;
void showType(T t, const std::string &callname, const std::string& suffix) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; callname;          // show name at call site
  std::cout &lt;&lt; &quot; type: &quot;
            &lt;&lt; truncate(DisplayParams.trunc,typeid(t).name());  // show type
  std::cout &lt;&lt; &quot;&#92;n  size:  &quot; &lt;&lt; sizeof(t);  // show size on stack
  std::cout &lt;&lt; suffix;
}
/*-----------------------------------------------
  Display emphasized text
*/
inline void showNote(const std::string& txt, const std::string& suffix) {
  print(&quot;--------------------------------------------------&quot;);
  print(&quot;  &quot; + txt);
  print(&quot;--------------------------------------------------&quot;);
  std::cout &lt;&lt; suffix;
}
/*-----------------------------------------------
  Display emphasized line
*/
inline void showOp(const std::string& opstr, const std::string& suffix) {
  std::cout &lt;&lt; &quot;&#92;n  --- &quot; &lt;&lt; opstr &lt;&lt; &quot; ---&quot; &lt;&lt; suffix;
}
/*-----------------------------------------------
  Helper function for formatting output
  - truncates line to N chars and adds ellipsis
*/
inline std::string truncate(size_t N, const char* pStr) {
  std::string temp(pStr);
  if(temp.length() &gt; N) {
    temp.resize(N);
    return temp + &quot;...&quot;;
  }
  return temp;
}
/*-----------------------------------------------
  Helper function for formatting output
  - generates string of n blanks to offset text
*/
inline std::string indent(size_t n) {
  return std::string(n, ' ');
}
/*-----------------------------------------------
  Helper function for formatting output
  - folds lines after width elements
*/
template&lt;typename T&gt;
std::string fold(std::vector&lt;T&gt;& v, size_t left, size_t width) {
  std::stringstream out(&quot;&#92;n&quot;);
  out &lt;&lt; indent(left);
  for(int i=0; i&lt;v.size(); ++i) {
    if((i % width) == 0 && i != 0 && i != width - 1) {
      out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left);
    }
    if(i &lt; v.size() - 1) {
      out &lt;&lt; v[i] &lt;&lt; &quot;, &quot;;
    }
    else {
      out &lt;&lt; v[i] &lt;&lt; &quot;&#92;n&quot;;
      break;
    }
  }
  return out.str();
}
/*-----------------------------------------------
  Helper function for formatColl
  - defines out &lt;&lt; std::pair&lt;K,V&gt;
  - used in formatColl for associative containers
*/
template&lt;typename K, typename V&gt;
std::stringstream& operator&lt;&lt;(
  std::stringstream& out, const std::pair&lt;K,V&gt;& p
) {
  out &lt;&lt; &quot;{&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot;}&quot;;
  return out;
}
/*-----------------------------------------------
  Format output for Collection types
  - any type with begin() and end() like
    all the STL containers.
*/
template&lt;typename Coll&gt;
std::string formatColl(
  const Coll& c, const std::string& nm, const std::string& suffix,
  size_t left, size_t width
) {
  std::stringstream out;
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: {&#92;n&quot; &lt;&lt; indent(left + 2);
  size_t i = 0;
  for(const Coll::value_type& elem : c) {
    if((i % width) == 0 && i != 0 && i != width - 1) {
      out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left + 2);
    }
    if(i &lt; c.size() - 1) {
      out &lt;&lt; elem &lt;&lt; &quot;, &quot;;
    }
    else {
      out &lt;&lt; elem &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; &quot;}&quot; &lt;&lt; suffix;
      break;
    }
    ++i;
  }
  return out.str();
}
/*-----------------------------------------------
  Format output for scalar types like primitives
*/
template&lt;typename T&gt;
std::string formatScalar(
  const T& t, const std::string& nm, const std::string& suffix,
  size_t left
) {
  std::stringstream out;
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: &quot; &lt;&lt; t &lt;&lt; suffix;
  return out.str();
}
/*-----------------------------------------------
  Format output for strings
  - indent and embed in quotation marks
*/
template&lt;typename T&gt;
std::string formatString(
  const T& t, const std::string& nm, const std::string& suffix,
  size_t left
) {
  std::stringstream out;
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: &#92;&quot;&quot; &lt;&lt; t &lt;&lt; &quot;&#92;&quot;&quot; &lt;&lt; suffix;
  return out.str();
}
/*-----------------------------------------------
  Defines is_iterable trait
  - uses template metaprogramming, e.g., user code
    that runs during compilation
  - detects STL containers and user-defined types
    that provide iteration
https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable
*/
template &lt;typename T, typename = void&gt;
struct is_iterable : std::false_type {};

// this gets used only when we can call
// std::begin() and std::end() on that type
template &lt;typename T&gt;
struct is_iterable&lt;
  T,
  std::void_t
    &lt;decltype(std::begin(std::declval&lt;T&gt;())),
     decltype(std::end(std::declval&lt;T&gt;()))&gt;
&gt; : std::true_type {};

template &lt;typename T&gt;
constexpr bool is_iterable_v = is_iterable&lt;T&gt;::value;

/*-----------------------------------------------
  Displays almost everything.
  - strings work better with formatString(...)
  https://www.cppstories.com/2018/03/ifconstexpr/
  Iteration is discussed in Bit Cpp_iter
*/
template&lt;typename T&gt;
std::string format(
  const T& t, const std::string& nm, const std::string& suffix,
  size_t left, size_t width
) {
  if constexpr(is_iterable_v&lt;T&gt;) {  // decision at compile-time
    return formatColl(t, nm, suffix, left, width);
  }
  else {
    return formatScalar(t, nm, suffix, left);
  }
}
/*-----------------------------------------------
  Display text after newline and indentation
*/
inline void print(const std::string& txt) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt;
}
/*-----------------------------------------------
  Display text after newline and indentation
  - provides trailing newline
*/
inline void println(const std::string& txt) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt &lt;&lt; &quot;&#92;n&quot;;
}
          </pre>
          <h4 id="out">Output</h4>
          <pre class="codeSnap">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Generics&#92;build
&gt; debug/Cpp_Generics

  Demonstrate C++ Generic Objects

  --------------------------------------------------
    std library types string and vector&lt;T&gt;
  --------------------------------------------------
  contents of str = &quot;Wile E. Coyote&quot;
  --- showType(str, &quot;str&quot;); ---
  str type: class std::basic_string&lt;char,struct std:...
  size:  40

  vector&lt;T&gt;: {
    3.5, 3, 2.5, 2
  }
  --- showType(vec, &quot;vec&quot;); ---
  vec type: class std::vector&lt;double,class std::allo...
  size:  32

  --- vec[2] = -2.5; ---
  vec:
  vector&lt;T&gt;: {
    3.5, 3, -2.5, 2
  }
  --- auto vec2 = vec : copy construction ---
  vec2:
  vector&lt;T&gt;: {
    3.5, 3, -2.5, 2
  }
  --- vec2[0] = 42; ---
  vec2:
  vector&lt;T&gt;: {
    42, 3, -2.5, 2
  }
  vec:
  vector&lt;T&gt;: {
    3.5, 3, -2.5, 2
  }
  --------------------------------------------------
    Copy construction, auto vec2 = vec, creates
    independent instance. So changing target vec2
    has no affect on source vec.
  --------------------------------------------------

  --------------------------------------------------
    User-defined Types
  --------------------------------------------------

  --- statistics for integer types ---
  s1 {
    1, 2, 3, 4, 5, 6
  }

  s1.size() = 6
  s1.max() = 6
  s1.min() = 1
  s1.sum() = 21
  s1.avg() = 3.5

  --- statistics for float types ---
  s2 {
    1, 2.1, 3.2, 4.3, 5.4, 6.5
  }

  s2.size() = 6
  s2.max() = 6.5
  s2.min() = 1
  s2.sum() = 22.5
  s2.avg() = 3.75

  --- user-defined type PointN&lt;T&gt; ---

  p1: PointN&lt;T&gt; {
    0, 0, 0, 0, 0
  }

  --------------------------------------------------
    p1.coords() = std::vector&lt;double&gt;
    { 1.0, -2.0, 3.0, 4.5, -42.0 }
  --------------------------------------------------

  p1: PointN&lt;T&gt; {
    1, -2, 3, 4.5, -42
  }

  --- showType(p1, &quot;p1&quot;, nl); ---
  p1 type: class PointN&lt;double&gt;
  size:  48
  p1.coords()[2] = 3

  --- auto p2 = p1 ---
  p2: PointN&lt;T&gt; {
    1, -2, 3, 4.5, -42
  }
  --- p2[1] = 5.5 ---
  p2: PointN&lt;T&gt; {
    1, 5.5, 3, 4.5, -42
  }
  p1: PointN&lt;T&gt; {
    1, -2, 3, 4.5, -42
  }

  --------------------------------------------------
    heap-based string instance
  --------------------------------------------------
  --- pU&lt;std::basic_string&lt;char&gt;&gt; pStr(new std::basic_string&lt;char&gt;(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;) ---
  pStr contents = &quot;Road Runner&quot;

  --- showType(*pStr, &quot;*pStr&quot;) ---
  *pStr type: class std::basic_string&lt;char,struct std:...
  size:  40

  --- showType(move(pStr), &quot;pStr&quot;) ---
  pStr type: class std::unique_ptr&lt;class std::basic_s...
  size:  8

  --------------------------------------------------
    heap-based vector instance
  --------------------------------------------------
  --- pU&lt;std::vector&lt;double&gt;&gt;
      pVec(new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }); ---
  *pVec =
  vector&lt;T&gt;: {
    1.5, 2.5, 3.5
  }
  *pVec type: class std::vector&lt;double,class std::allo...
  size:  32

  pVec = 00000269B47695C0
  move(pVec) type: class std::unique_ptr&lt;class std::vector&lt;...
  size:  8

  --------------------------------------------------
    heap-based PointN&lt;T&gt; instance
  --------------------------------------------------
  --- pU&lt;PointN&lt;double&gt;&gt; pPointN(new PointN&lt;double&gt;(4)) ---
  *pPointN: PointN&lt;T&gt; {
    0, 0, 0, 0
  }
  --- pPointN-&gt;coords() =
      std::vector&lt;double&gt;{ 1.0, 3.5, -2.0, 42.0 }; ---
  *pPointN: PointN&lt;T&gt; {
    1, 3.5, -2, 42
  }
  value of pPointN-&gt;coords()[1] is 3.5
  --- showType(*pPointN, &quot;*pPointN&quot;); ---
  *pPointN type: class PointN&lt;double&gt;
  size:  48
  --- showType(std::move(pPointN), &quot;pPointN&quot;); ---
  pPointN type: class std::unique_ptr&lt;class PointN&lt;doubl...
  size:  8


  That's all Folks!

C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Generics&#92;build
&gt;
          </pre>
          <h4 id="build">Build</h4>
          <pre class="codeSnap">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Generics&#92;build
&gt; cmake ..
-- Selecting Windows SDK version 10.0.22000.0 to target Windows 10.0.22621.
-- Configuring done
-- Generating done
-- Build files have been written to: C:/github/JimFawcett/Bits/Cpp/Cpp_Generics/build
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Generics&#92;build
&gt; cmake --build .
MSBuild version 17.5.1+f6fdcf537 for .NET Framework

  Checking Build System
  Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Generics/CMake
  Lists.txt
  Bits_Generics.cpp
  Cpp_Generics.vcxproj -&gt; C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Generics&#92;bu
  ild&#92;Debug&#92;Cpp_Generics.exe
  Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Generics/CMake
  Lists.txt
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Generics&#92;build
&gt;
          </pre>
        </div>
        <h3 id="ide">2.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Cpp\Cpp_Generics.
        </t-b>
        <photosizer-block src="pictures/VS_Code_Cpp_Generics.JPG" width="800" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE - Debugging Cpp_Generics.cpp</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/LaunchJSON_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
          style="overflow-x:auto;"
        >
          <span style="font-family:'Comic Sans MS';">Figure 2. Launch.JSON</span>
        </photosizer-block>
        <photosizer-block src="pictures/VS_Code_Debugging_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
          style="overflow-x:auto;"
        >
          <span style="font-family:'Comic Sans MS';">Figure 3. Debugging Objects</span>
        </photosizer-block>-->
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
          <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
        </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../CppStory_templates.html">C++ Story, Chapter 7</a>
            </td>
            <td>
              template functions, classes, specialization
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://en.wikipedia.org/wiki/Template_%28C%2B%2B%29">C++ Templates - Wikipedia</a>
            </td>
            <td>
              Relatively short feature discussions with examples
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <!-- <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ide">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">bld</a></menu-elem>
        <menu-elem class="secElem"><a href="#out">out</a></menu-elem>
        <menu-elem class="secElem"><a href="#analysis">anal</a></menu-elem>
        <menu-elem class="secElem"><a href="#points">pts</a></menu-elem>
        <menu-elem class="secElem"><a href="#stats">sts</a></menu-elem>
        <menu-elem class="secElem"><a href="#source">src</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">codeSnaps</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections> -->
    </main>
    <!-- <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer> -->
  </page-frame>
  <!-- <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
  <script>
    getScroll();
  </script> -->
  <script>
    var scrollables = document.querySelectorAll('.scrollable');
    for (let scrollable of scrollables) {
      //alert('adding listener');
      scrollable.addEventListener('wheel', function (event) {
        var deltaY = event.deltaY;
        var contentHeight = scrollable.scrollHeight;
        var visibleHeight = scrollable.offsetHeight;
        var scrollTop = scrollable.scrollTop;

        if (scrollTop === 0 && deltaY < 0)
          event.preventDefault();
        else if (visibleHeight + scrollTop === contentHeight && deltaY > 0)
          event.preventDefault();
      });
    }
    // https://stackoverflow.com/questions/7600454/how-to-prevent-page-scrolling-when-scrolling-a-div-element
  </script>
  <script>
    onLoadSplitter("fig2");
    onLoadSplitter("fig3");
    onLoadSplitter("fig4");
    onLoadSplitter("fig5");
    onLoadSplitter("fig6");
  </script>
</body>
</html>