<!DOCTYPE html>
<html>
<!--
  Bits_GenericRustContent.html
-->
<head>
  <title>Bits Generic Rust</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeRust.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBitsRust.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <link rel="stylesheet" href="css/Styles_BitsContent.css" />
  <script src="js/Scripts_BitsContent.js"></script>
  <link rel="stylesheet" href="css/StylesSplitterBar.css" />
  <script src="js/ScriptsSplitterBar.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
<!--   <style>
    #github .note {
      border: 2px solid red;
      padding: 0.75em 1.5em;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      background-color: var(--light);
      color: var(--dark);
      width: max-content;
      max-width: 50em;
    }

    #github h2 {
      margin-top: 0.75em;
    }

    #github #pagetitle {
      border: 2px double var(--dark);
      /* line-height:1.5em; */
    }

    #github .hide {
      display: none;
    }

    body {
      position: relative;
      line-height: 1.25em;
    }

    #github .remotebutton {
      padding: 0.25em 0.5em;
    }

    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }

    #github hr.spread {
      margin: 0.75em 0em;
    }

    #github {
      user-select: none;
    }

    .focus {
      padding: 0.5em 1.0em 0.5em 1.0em;
      /*border:1px solid red;*/
    }

    *.focus ul {
      padding-top: -0.5em;
      /*background-color:green;*/
    }

    .cat {
      text-align: left;
      background-color: var(--menu);
    }

    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 1em 1.5em;
      margin-right: 0.5em;
    }

    #github pre {
      overflow-x: auto;
      background-color:rgb(0,0,0,0.95);
      background-color:rgb(0,0,0,0.95);
      /* width:100%; */
      /* user-select: all; */
    }

    #github code {
      width: 100%;
    }

    code-style {
      white-space: pre;
      font-family: Consolas;
      font-size: 0.95em;
      font-weight: bold;
    }

    .blockDouble {
      position: relative;
      display: grid;
      grid-template-columns: 1fr 1fr;
      border: 1px solid var(--dark);
      overflow-x: auto;
      overflow-y: hidden;
      margin-right: 0.75em;
      padding: 0.75em;
      padding-right: 0em;
    }

    .blockSingle {
      position: relative;
      border: 1px solid var(--dark);
      overflow-x: auto;
      overflow-y: hidden;
      margin-top: 1.5em;
      margin-right: 0.75em;
      padding: 0.0em;
      padding-right: 0em;
    }

    .codewrap {
      padding: 0.5em;
      padding-right: 0em;
      margin-right: 0.0em;
      overflow-y: auto;
      border: 1px dashed blue;
      font-size: 0.80em;
      background-color:rgb(0,0,0);
    }
 
    #github div.block t-b {
      max-width: 100%;
      padding-left: 0.5em;
    }

    .textwrap {
      padding-right: 1em;
      padding-left: 1em;
      margin-right: 0.5em;
      overflow-y: scroll;
      border: 1px dashed red;
      font-size: 0.9em;
    }

    #github .inset {
      padding:0.25em 1.5em;
    }
 
    table {
      margin-right: 0.75em;
    }

    #github .scrollable {
      overflow: auto;
    }
  </style>
  <style>
    #github .info {
      position: relative;
      top: 0em;
      float: right;
      font-size: large;
      font-weight: bold;
      text-align: center;
      background-color: var(--dark);
      border-radius: 8px;
      color: var(--light);
      width: 1.25em;
      cursor: pointer;
      user-select: none;
    }

    #github .infoKill {
      position: relative;
      top: 0.05em;
      float: right;
      font-size: large;
      font-weight: bold;
      text-align: center;
      background-color: var(--light);
      border-radius: 8px;
      color: var(--dark);
      width: 1.25em;
      cursor: pointer;
      user-select: none;
      margin: 0.25em;
    }

    #github .txt {
      display: none;
      position: absolute;
      right: 4.5em;
      width: 20em;
      z-index: 10;
      color: var(--dark);
      font-size: small;
      background-color: var(--light);
      border: 2px solid var(--dark);
      padding: 0em 0.5em;
      overflow-y: visible;
    }
    #github t-b .tight {
      margin-top: 0.25em;
      margin-bottom: 0.5em;
    }
  </style>
  <script>
    function closeInfos() {
      var elems = document.querySelectorAll('.txt');
      for (let i = 0; i < elems.length; ++i) {
        if (elems[i].style.display === "block") {
          elems[i].style.display = "none";
        }
      }
    }
    function toggleInfo(dst) {
      var elem = document.getElementById(dst);
      if (elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = "block";
      }
      else {
        elem.style.display = "none";
      }
    }
    function toggleInfoRel(src, dst, adj = 0) {
      var txtcont = document.getElementById(dst);
      var elemtop = src.offsetTop;
      txtcont.style.top = parseInt(elemtop - 25 - adj) + 'px';
      var top = txtcont.style.top;
      if (txtcont.style.display === "none" || txtcont.style.display === "") {
        txtcont.style.display = "block";
      }
      else {
        txtcont.style.display = "none";
      }
    }
  </script>
  <script>
    function setScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = main.scrollTop;
      localStorage.setItem('scrollPositionHelloRust', scrollPosition);
      let body = document.getElementById("github");
      let style = window.getComputedStyle(body, null).getPropertyValue('line-height');
      let fontsize = parseFloat(style);
      let scroller = document.getElementById("scrollY")
      scroller.innerHTML = Math.trunc(scrollPosition / fontsize);
    }
    function gotoLastScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = localStorage.getItem('scrollPositionHelloRust');
      if (scrollPosition) {
        main.scrollTo(0, scrollPosition);
      }
      main.addEventListener('scroll', setScroll);
    }
    function load() {
      //initialize();
      gotoLastScroll();
    }
  </script>
 --> 
 <script>
   function load() {
     //initialize();
     gotoLastScroll();
   }
    function remote() {
      window.open('https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=8e994f9f6fc188f237277592474ac828', '_blank');
    }
  </script>
</head>
<body id="github" onload="load()">

  <a id="Next" href="Bits_IterRust.html">Next</a>
  <a id="Prev" href="Bits_ObjectsRust.html">Prev</a>

  <page-frame>
    <!-- <frame-header>
      <nav id="navbar"></nav>
    </frame-header> -->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits Generic Rust</div>
      <div id="modified">04/15/2024</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <!-- <div class="rightPanelLinks">
    <a href="Bits_GenericCpp.html">C++</a>
    <a class="darkItem" href="Bits_GenericRust.html">Rust</a>
    <a href="Bits_GenericCSharp.html">C#</a>
    <a href="Bits_GenericPython.html">Python</a>
    <a class="undefined" href="#Bits_GenericJs.html">JvScrpt</a>
  </div> -->
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.50em; width:max-content; height:1.5em;
           text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits: Generic Rust</h1>
            <h3 id="subtitle" class="indent">
              generic types, traits, and functions
            </h3>
          </hgroup>
        </header>
        <t-b style="border:2px solid red; padding:0.25em 1em 0.5em 1em; width:max-content;">
          This page is being refactored; there&apos;s construction clutter right now.
        </t-b>
        <t-b style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          <t-b class="tight">
            Each generic function or struct
            is a pattern for defining functions and structs of a specific type.  Thus a generic struct is a
            pattern for making patterns.
          </t-b>
          <t-b class="tight">
            This page demonstrates creation and uses of generic Rust functions and User-Defined types.
            The purpose is to quickly acquire some familiarity with generic types and their implementations.
          </t-b>
          <hr class="spread" />
          <ul>
            <li>
              Rust generics support definition of function and class patterns, which can
              be instantiated for a variety of different concrete types.
            </li>
            <li>
              Each instantiation must use types that provide all the facilities used
              in the pattern.
            </li>
            <li>
              The pattern can provide constraints, using traits, on its type parameters that guarantee methods
              required by the pattern.
            </li>
          </ul>
          <div style="height:0.5em;"></div>
        </t-b>
        <details id="notes">
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <t-b><hr /></t-b>
          <t-b>
            Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
            is a pattern for defining functions and classes of a specific type.  Thus a generic class is a
            pattern for making patterns.
          </t-b>
          <t-b>
            The other two, Python and JavaScript, are dynamically typed and already support defining
            functions and classes for multiple types, e.g., no need for generics.
          </t-b>
          <t-b>
            This demonstration illustrates use of generic structs and objects, which for C++, Rust, and C#,
            are defined in a stackframe or in the heap or both. <strongs>All</strongs> data for Python and JavaScript are
            stored in managed heaps.
          </t-b>
          <t-b><hr /></t-b>
        </details>
        <h3 id="generics">1.0 Generics and Traits</h3>
        <t-b>
          Generics are patterns for functions and structs that use placeholder generic types, like <c-s>T</c-s>
          below. The patterns become
          specific functions and structs when the placeholders are replaced with specific defined types.
        </t-b>
        <t-b>
          <hr />
        </t-b>
        <t-b>
          <strong>Generic functions</strong> use the syntax:
          <div class="inset">
            <div style="float:right;margin-right:1em;">Examples in <a target="_blank" href="#funcsdef">Section 2.6.1</a></div>
            <c-s>
              pub fn f&lt;T: Tr1 + Tr2 + ..&gt (t:T, ...) {<br />
              &nbsp;&nbsp;&nbsp;/* implementing code using T */<br />
              }
            </c-s>
          </div>
          Tr1, Tr2, ... are traits that place requirements on the generic parameter T, usually to implement
          specified methods. If the body of f invokes methods on T that are not required by
          specified traits then compilation fails. We say that traits are bounds on T because
          they narrow the range of valid generic parameters.
        </t-b>
        <t-b>
          <hr />
        </t-b>
        <t-b>
          A <strong>Rust trait</strong> is a declaration that requires any generic type that implements the trait to
          implement methods defined by the trait, e.g.:
          <div class="inset">
            <div style="float:right;margin-right:1em;">Example in <a target="_blank" href="#statsdef">Section 2.4.1</a></div>
            <c-s>
              pub trait Default: Sized {<br />
              &nbsp;&nbsp;&nbsp;fn default() -&gt; Self;<br />
              }
            </c-s>
          </div>
          <c-s>Sized</c-s> is a base trait that requires an implementing type to have a size known at
          compile time. <c-s>Default</c-s> requires that an implementing type provide a default value
          using the static method T::default(). That returns a particular value, e.g., 0 for
          integers and 0.0 for floating point numbers.
        </t-b>
        <t-b>
          <hr />
        </t-b>
        <t-b>
          <strong>Generic structs</strong> are defined with the syntax:
          <div class="inset">
            <div style="float:right;margin-right:1em;">Examples in <a target="_blank" href="#point">Section 2.5</a></div>
            <c-s>
              // derive(...) are traits compiler implements<br />
              #[derive(Debug, Clone)]&nbsp;&nbsp;&nbsp;<br />
              pub struct SomeType&lt;T&gt;<br />
              &nbsp;&nbsp;&nbsp;where T: Tr1 + Tr2 + ...<br />
              {<br />
              &nbsp;&nbsp;&nbsp;/* code declaring SomeType methods and data */<br />
              }<br />
              <br />
              impl&lt;T&gt; SomeType&lt;T&gt;<br />
              &nbsp;&nbsp;&nbsp;where T: Tr1 + Tr2 + ...<br />
              {<br />
              &nbsp;&nbsp;&nbsp;/* implementation of SomeType methods */<br />
              }<br />
            </c-s>
          </div>
        </t-b>
        <h3 id="code">2.0 Code</h3>
        <t-b>
          Examples below show how to use library and user defined types with emphasis on
          illustrating syntax and basic operations.
        </t-b>
        <t-b>
          These demonstrations of generic Rust code are partitioned into modules main.rs, hello_generic.rs, stats.rs,
          points_generic.rs, and analysis_generics.rs. Discussion of each of these will be
          presented in separate sections of the page, below, accessed from links in the left panel.
        </t-b>
        <h3 id="structure">2.1 Main Module Structure</h3>
        <t-b>
          This first panel block illustrates structure of this demonstration of generic Rust.
          Most of the code definitions have been elided for clarity, but those details will
          be shown in later blocks.
        </t-b>
        <t-b>
          Alter panel widths by dragging splitter bar or clicking in either panel
          to expand that panel&apos;s width.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig1-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig1-first')" style="width:200em;"><code class="language-cpp">
#![allow(dead_code)]
#![allow(clippy::approx_constant)]

mod analysis_generic;     // identify module source file
use analysis_generic::*;  // import public functions and types
mod hello_generic;
use hello_generic::*;
mod stats;
use stats::*;
mod points_generic;
use points_generic::*;

use std::{fmt::*, collections::HashMap};

/*------------------------------------------
definition of type Demo has been elided
(shown below)
------------------------------------------*/

fn demo_std_generic_types() {
  /* defs elided */
}
fn demo_user_defined_generic_types() {
  /* defs elided */
}
fn demo_generic_functions() {
  /* defs elided */
}

fn main() {

  show_label(&quot;generic functions and types&quot;, 50);

  demo_std_generic_types();
  demo_user_defined_generic_types();
  demo_generic_functions();

  print!(&quot;&#92;n&#92;n  That's all Folks!&#92;n&#92;n&quot;);
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig1-seperator"></splitter-bar>
            <second-item id="fig1-second" style="width:40em; padding-right:0.5em; background-color:var(--light);">
              <div onclick="obubbleup('fig1-first')" class="textwrap">
                <t-b>
                  ----- modules -----------------
                </t-b>
                <t-b>
                  The main module, main.rs, opens by importing definitions from four modules defined for
                  this demonstraion:
                  <ul>
                    <li>
                      analysis_generic.rs defines type analysis and display functions
                    </li>
                    <li>
                      hello_generic.rs defines simple type <c-s>HelloGeneric&lt;T&gt;</c-s> to illustrate generics syntax
                    </li>
                    <li>
                      stats.rs provides type definition for <c-s>Stats&lt;T&gt;</c-s> and trait <c-s>Arithmetic</c-s>.
                    </li>
                    <li>
                      points_generic defines a user type <c-s>PointN&lt;T&gt;</c-s> representing points in an
                      N dimensional hyperspace.
                    </li>
                  </ul>
                </t-b>
                <t-b>
                  ----- code structure ----------
                </t-b>
                <t-b class="indent">
                  Code for this demonstration consists of:
                  <ul>
                    <li>
                      Definitions of user-defined types
                    </li>
                    <li>
                      Functions for analysis and display of specified objects
                    </li>
                    <li>
                      Three functions that demonstrate generics for standard types,
                      user-defined types, and generic functions
                    </li>
                  </ul>
                  Program execution begins in the main function of the main module. It simply invokes
                  these functions as shown in the left panel.
                </t-b>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="stdgen">2.2 Standard Generic Types</h3>
        <t-b>
          Standard generic types are defined in the
          <a target="_blank" href="https://doc.rust-lang.org/std/index.html">Rust Standard Library</a>
          and include many more than shown here. We have selected four frequently used types for
          demonstration: arrays, slices, vectors, and hashmaps. You can find details of the others from the <a href="#refs">references</a>.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig2-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig2-first')" style="width:200em;"><code class="language-cpp">
  fn demo_std_generic_types() {

  show_label(&quot;demo standard generic types&quot;, 32);
  println!();

  show_op(&quot;arrays: [T; N]&quot;);
  println!();
  let arri = [1, 2, 3, 2, 1];
  println!(&quot;  {:?}&quot;, arri);
  let arrf = [1.0, 1.5, 2.0, 1.5, 1.0];
  println!(&quot;  {:?}&#92;n&quot;, arrf);

  show_op(&quot;slices: &T[m..n]&quot;);
  println!();
  let slicei = &arri[1..5]; // [2, 3, 4, 5]
  println!(&quot;  {:?}&quot;, slicei);
  let slicef = &arrf[2..4]; // [2.0, 1.5]
  println!(&quot;  {:?}&#92;n&quot;, slicef);

  show_op(&quot;vectors: Vec&lt;T&gt;&quot;);
  println!();

  /*-- vector of copy type --*/
  let mut v = Vec::&lt;i32&gt;::new();
  let s = &vec![1, 2, 3, 2, 1];
  v.extend_from_slice(s);
  /*
  This works because the elements are i32, i.e., copy.
  To load a vector with non-copy types use:
  v.extend(s.iter().cloned());
  */
  println!(&quot;  Vec&lt;i32&gt; {:?}&quot;, v);

  /*--- vector of tuple (i32, &str) --*/
  let mut v2 = Vec::&lt;(i32,&str)&gt;::new();
  v2.push((1, &quot;one&quot;));
  v2.push((2, &quot;two&quot;));
  println!(&quot;  Vec&lt;(i32, &str)&gt; {:?}&#92;n&quot;, v2);

  show_op(&quot;maps: HashMap&lt;K,V&gt;&quot;);
  println!();
  let mut m = HashMap::&lt;&str, i32&gt;::new();
  m.insert(&quot;zero&quot;, 0);
  m.insert(&quot;one&quot;, 1);
  m.insert(&quot;two&quot;, 2);
  m.insert(&quot;three&quot;, 3);
  println!(&quot;  maps: HashMap&lt;&str, i32&gt;&quot;);
  println!(&quot;    {:?}&quot;, m);
  }
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig2-seperator"></splitter-bar>
            <second-item id="fig2-second" style="width:40em; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="obubbleup('fig2-first')" style="width:200em;"><code class="language-shell">
-------------------------
 demo standard generic types
-------------------------

--- arrays: [T; N] ---

  [1, 2, 3, 2, 1]
  [1.0, 1.5, 2.0, 1.5, 1.0]



--- slices: &T[m..n] ---

  [2, 3, 2, 1]
  [2.0, 1.5]



--- vectors: Vec&lt;T&gt; ---

  Vec&lt;i32&gt; [1, 2, 3, 2, 1]
  Vec&lt;(i32, &str)&gt; [(1, &quot;one&quot;), (2, &quot;two&quot;)]










--- maps: HashMap&lt;K,V&gt; ---

  maps: HashMap&lt;&str, i32&gt;
    {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;zero&quot;: 0, &quot;three&quot;: 3}













</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="hellogen">2.3 HelloGeneric</h3>
        <t-b>
          <c-s>HelloGeneric&lt;T&gt;</c-s> is a simple generic type defined in the module hello_generic.rs.
          It is included here to introduce basic syntax required for generic types.
        </t-b>
        <h3 id="hellodef">2.3.1 HelloGeneric Definition</h3>
        <t-b>
          Rust generics usually require trait declarations. A trait declares one or more methods that
          are used to specify that specific method calls are valid on a generic parameter.
        </t-b>
        <t-b>
          In <c-s>HelloGeneric&lt;T&gt;</c-s>, <c-s>T</c-s> is required to implement the traits <c-s>Clone</c-s>
          and <c-s>Default</c-s>.
          That insures that if <c-s>t&epsilon;T</c-s> then <c-s>data: T::default()</c-s> and
          <c-s>t.clone()</c-s> are valid expressions.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig3-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig3-first')" style="width:200em;"><code class="language-cpp">/*---------------------------------------------------------
  HelloGeneric: user-defined generic type
  - Not very useful except as a demonstration of how
    to create a generic type.
  - HelloGeneric instances hold a single value of T
  - Generic parameter T is required to implement traits
      Debug   - supports using debug format {:?}
      Default - supports using a default value, T:default()
      Clone   - implements a copy of an instance with clone()
  - Specified traits, like those above, are often called
    bounds because they limit the types that can be used
    as function and method arguments.
*/
#[derive(Debug, Clone)]  // compiler generated code
struct HelloGeneric&lt;T&gt;
  where T: Debug + Default + Clone
{
  datum: T,
}
impl&lt;T&gt; HelloGeneric&lt;T&gt;
  where T: Debug + Default + Clone
{
  /* construct new instance with datum = d */
  fn new(d:T) -&gt; Self {
    HelloGeneric::&lt;T&gt; {
      datum: d,
    }
  }
  /* construct new instance with default data value */
  fn default_new() -&gt; Self {
    HelloGeneric::&lt;T&gt; {
      datum: T::default(),
    }
  }
  /*
    As shown, value() is equivalent to making datum public.
    However value method supports adding code to modify the
    return value.
  */
  fn value(&mut self) -&gt; &mut T {
    &mut self.datum
  }
  /* print representation of an instance */
  fn show(&self) {
    println!(&quot;  HelloGeneric {{ {:?} }}&quot;, self.datum);
  }
}



















</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig3-seperator"></splitter-bar>
            <second-item id="fig3-second" style="width:40em; padding-right:0.5em; background-color:var(--light);">
              <div onclick="obubbleup('fig3-first')" class="textwrap">
                <t-b>
                  ----- defining generic types -----------------
                </t-b>
                <t-b>
                  Rust types can be defined with generic data members:
                  <ul>
                    <li>
                      <c-s>struct HelloGeneric&lt;T: Debug + Default + Clone&gt;</c-s>
                      defines the data member &quot;<c-s>datum: T</c-s>&quot; in the left panel.
                    </li>
                    <li>
                      Methods cannot be called on <c-s>T</c-s> unless <c-s>T</c-s> is bounded by traits that
                      declare those methods. That guarantees that the invocation is well defined.
                    </li>
                    <li>
                      <c-s>Debug</c-s> means that <c-s>HelloGeneric</c-s> instances can be written using the
                      debug format &quot;<c-s>{:?}</c-s>&quot;
                    </li>
                    <li>
                      <c-s>Default</c-s> guarantees that <c-s>d::default()</c-s> has a defined value,
                      e.g., 0 for ints and 0.0 for floats.
                    </li>
                    <li>
                      <c-s>Clone</c-s> ensures that the invocation clone() on <c-s>HelloGeneric</c-s>
                      and <c-s>T</c-s> is well defined. Those invocations should return an independent
                      copy of their instances.
                    </li>
                  </ul>
                  If <c-s>HelloGeneric</c-s> is declared with a parameter <c-s>T</c-s> that does not meet all
                  of these requirements, the declaration will fail to compile. Note that this is very
                  similar to the use of <c-s>C#</c-s> constraints.
                </t-b>
                <t-b>
                  ----- <c-s>HelloGeneric</c-s> declaration ------
                </t-b>
                <t-b>
                  <c-s>
                    #[derive(Debug, Clone)]<br />
                    struct HelloGeneric&lt;T&gt;<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;where: T: Debug + Default + Clone {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;datum: T,<br />
                    }
                  </c-s><br />
                  <t-b>
                    instructs the compiler to lay out <c-s>HelloGeneric</c-s> instances in memory with
                    room to hold a <c-s>T</c-s>
                  </t-b>
                  <t-b>
                    The derive declaration instructs the compiler to implement <c-s>Debug</c-s>
                    and <c-s>Clone</c-s> traits for <c-s>HelloGeneric</c-s>.
                  </t-b>
                  <t-b>
                    The <c-s>Clone</c-s> trait declares a method <c-s>clone()</c-s>
                    that copies its instance when <c-s>clone()</c-s> is invoked.
                  </t-b>
                </t-b>
                <t-b>
                  ----- <c-s>HelloGeneric</c-s> methods ----------
                </t-b>
                <t-b class="indent">
                  <c-s>HelloGeneric</c-s> implements the methods:
                  <ul>
                    <li>
                      <c-s>new(d:T) -&gt; HelloGeneric&lt;T&gt;</c-s>, a constructor that accepts an instance d
                      of <c-s>T</c-s> and returns a newly constructed <c-s>HelloGeneric&lt;T&gt;</c-s> instance
                      holding value d in datum.
                    </li>
                    <li>
                      <c-s>default_new() -&gt; HelloGeneric&lt;T&gt;</c-s>, a constructor that returns a newly
                      constructed <c-s>HelloGeneric&lt;T&gt;</c-s> instance with default value for datum.
                    </li>
                    <li>
                      <c-s>value(&amp;mut self) -&gt; &amp;mut T</c-s> returns a mutable reference to datum;
                    </li>
                    <li>
                      <c-s>show(&self)</c-s> displays a text representation of instance.
                    </li>
                    <li>
                      <c-s>clone(&amp;self) -&gt; HelloGeneric&lt;T&gt;</c-s> implemented by compiler.
                    </li>
                  </ul>
                  Since all methods but the constructors accept a reference, <c-s>&amp;self</c-s>,
                  invocations do not consume the <c-s>Stats</c-s> instance.
                </t-b>
                <div style="height:0.75em;"></div>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="hellodemo">2.3.2 HelloGeneric Demonstration</h3>
        <t-b>
          The panels below demonstrate creation and use of <c-s>HelloGeneric</c-s>. The left panel
          contains a function, <c-s>demo_HelloGeneric</c-s> found in module hello_generic.rs, that
          defines the demonstration.
          The right panel contains output when the function is invoked.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig4-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig4-first')" style="width:200em;"><code class="language-cpp">/*---------------------------------------------------------
  Demonstrate creation of HelloGeneric type and use
  of its methods.
*/
#[allow(non_snake_case)]
pub fn demo_HelloGeneric() {

  show_label(&quot; demo user defined HelloGeneric type&quot;, 40);
  println!();
  show_op(&quot;HelloGeneric&lt;T&gt;&quot;);
  println!();

  show_op(&quot;let mut h = HelloGeneric::&lt;i32&gt;::new(42)&quot;);
  let mut h = HelloGeneric::&lt;i32&gt;::new(42);
  h.show();
  println!();

  show_op(&quot;*h.value() = 84&quot;);
  *h.value() = 84;
  h.show();
  println!();

  show_op(&quot;let c = h.clone()&quot;);
  let c = h.clone();  // h still valid
  c.show();
  println!();

  show_op(&quot;let n = h : transfer ownership of datum&quot;);
  let n = h;  // move ownership of datum to h
  n.show();

  //h.show();  // h invalid, been moved
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig4-seperator"></splitter-bar>
            <second-item id="fig4-second" style="width:40em; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="obubbleup('fig4-first')" style="width:200em;"><code class="language-shell">





----------------------------------------
   demo user defined HelloGeneric type
----------------------------------------

--- HelloGeneric&lt;T&gt; ---

--- let mut h = HelloGeneric::&lt;i32&gt;::new(42) ---
  HelloGeneric { 42 }

--- *h.value() = 84 ---
  HelloGeneric { 84 }

--- let c = h.clone() ---
  HelloGeneric { 84 }

--- let n = h : transfer ownership of datum ---
  HelloGeneric { 84 }










</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="stats">2.4 Stats</h3>
        <t-b>
          <c-s>Stats&lt;T&gt;</c-s> is a relatively simple generic type defined in the module stats.rs.
          It is included here to show how to provide indexing for a custom type.
        </t-b>
        <h3 id="statsdef">2.4.1 Stats Definition</h3>
        <t-b>
          A Rust trait is a declaration that requires any generic type that implements the trait to
          implement methods defined by the trait.
          In <c-s>Stats&lt;T&gt;</c-s>, <c-s>T</c-s> is required to implement the trait <c-s>Arithmetic</c-s>.
          That insures that arithmetic operations can be applied to T.
        </t-b>
        <t-b>
          The <c-s>Arithmetic</c-s> trait is simply a union of traits defined in modules std::ops and
          std::cmp + traits <c-s>Default</c-s>, <c-s>Into</c-s>, <c-s>Debug</c-s>, and <c-s>Copy</c-s>.
        </t-b>
        <t-b>
          The <c-s>Stats</c-s> struct holds a vector of data of type <c-s>T</c-s> and its operations
          evaluate simple arithmetic properties of that data.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig5-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap" style="height:100%;">
                <pre onclick="cbubbleup('fig5-first')" style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------
  stats.rs
  - defines type Stats containing Vec of generic Type
    bounded by Arithmetic trait
  - Works as is only for i32 and f64, but easy to extend to
    all integers and floats
  - Can also be extended to complex numbers
-------------------------------------------------------------------*/

use std::ops::*;
use std::cmp::*;
use std::convert::{Into};
use std::fmt::Debug;

pub trait Arithmetic&lt;T = Self&gt;: Add&lt;Output=T&gt; + Sub&lt;Output=T&gt;
    + Mul&lt;Output=T&gt; + Div&lt;Output=T&gt; + PartialEq + PartialOrd
    + Default + Copy + Debug + Into&lt;f64&gt; {}

impl Arithmetic&lt;f64&gt; for f64 {}
impl Arithmetic&lt;i32&gt; for i32 {}

#[derive(Debug, Clone)]
pub struct Stats&lt;T: Arithmetic + Debug&gt; {
  items: Vec&lt;T&gt;
}

impl&lt;T: Arithmetic&gt; Stats&lt;T&gt;
    where T: Arithmetic + Debug
{
  pub fn new(v:Vec&lt;T&gt;) -&gt; Stats&lt;T&gt; {
    Stats {
      items: v,
    }
  }
  pub fn max(&self) -&gt; T {
    let mut biggest = self.items[0];
    for item in &self.items {
      if biggest &lt; *item {
        biggest = *item;
      }
    }
    biggest
  }
  pub fn min(&self) -&gt; T {
    let mut smallest = self.items[0];
    for item in &self.items {
      if smallest &gt; *item {
        smallest = *item;
      }
    }
    smallest
  }
  pub fn sum(&self) -&gt; T {
    let mut sum = T::default();
    for item in &self.items {
      sum = sum + *item;
    }
    sum
  }
  pub fn avg(&self) -&gt; f64 {
    let mut sum = T::default();
    for item in &self.items {
      sum = sum + *item;
    }
    /*-- cast usize to f64 --*/
    let den:f64 = self.items.len() as f64;
    /*-- can't cast non-primitive to primitive --*/
    let num:f64 = sum.into();
    num/den
  }
}


</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig5-seperator"></splitter-bar>
            <second-item id="fig5-second" style="width:40em; padding-right:0.5em; background-color:var(--light);">
              <div onclick="obubbleup('fig5-first')" class="textwrap">
                <t-b>
                  ----- defining generic types -----------------
                </t-b>
                <t-b>
                  Rust types can be defined with generic data members:
                  <ul>
                    <li>
                      <c-s>struct Stats&lt;T: Arithmetic + Debug&gt;</c-s>
                      defines the data member &quot;<c-s>items: Vec&lt;T&gt;</c-s>&quot; in the left panel.
                    </li>
                    <li>
                      Methods cannot be called on <c-s>T</c-s> unless <c-s>T</c-s> is bounded by traits that
                      declare those methods. That guarantees that the invocation is well defined.
                    </li>
                    <li>
                      This stats.rs module defines a trait &quot;<c-s>Arithmetic</c-s>&quot; as a union of
                      traits defined in <c-s>std::ops</c-s>:
                      <c-s>Add, Sub, Mul, Div</c-s> plus traits in <c-s>std::cmd</c-s>:
                      <c-s>PartialEq, PartialOrd</c-s> plus traits
                      <c-s>Default, Copy, Debug, Into</c-s>.
                    </li>
                    <li>
                      That means that T implements operators &quot;<c-s>+, -, *, /</c-s>&quot; and can be
                      compared and put into at least a partial order.
                    </li>
                    <li>
                      <c-s>Default</c-s> guarantees that <c-s>T::default()</c-s> has a defined value,
                      e.g., 0 for ints and 0.0 for floats.
                    </li>
                    <li>
                      <c-s>Copy</c-s> is a marker trait, e.g., no methods, but requires construction and
                      assignment to use copy operations instead of move operations. All the primitives
                      are <c-s>Copy</c-s> types.
                    </li>
                    <li>
                      <c-s>Debug</c-s> means that <c-s>Stats</c-s> instances can be written using the
                      debug format &quot;<c-s>{:?}</c-s>&quot;
                    </li>
                    <li>
                      <c-s>Into&lt;f64&gt;</c-s> means that any type will be implicitly converted to
                      <c-s>f64</c-s> if needed, as in dividing an instance of <c-s>T</c-s> by an
                      integer.
                    </li>
                  </ul>
                  If <c-s>Stats</c-s> is declared with a parameter <c-s>T</c-s> that does not meet all
                  of these requirements, the declaration will fail to compile. Note that this is very
                  similar to the use of <c-s>C#</c-s> constraints.
                </t-b>
                <t-b>
                  Note that <c-s>Arithmetic</c-s> has only been implemented in <c-s>Stats</c-s> for the
                  types <c-s>i32</c-s> and <c-s>f64</c-s>.  Implementing for other integers and floats is
                  simply a matter of copying the impl statements for those types.
                </t-b>
                <t-b>
                  ----- <c-s>Stats</c-s> declaration ------
                </t-b>
                <t-b>
                  <c-s>
                    #[derive(Debug, Clone)]<br />
                    pub struct Stats&lt;T: Arithmetic + Debug&gt; {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;items: Vec&lt;T&gt;;<br />
                    }
                  </c-s><br />
                  <t-b>
                    instructs the compiler to lay out <c-s>Stats</c-s> instances with a <c-s>Vec</c-s>
                    control block pointing to a mutable array of <c-s>T</c-s> values in the native heap.
                  </t-b>
                  <t-b>
                    The derive declaration instructs the compiler to implement <c-s>Debug</c-s> and
                    <c-s>Clone</c-s> traits for <c-s>Stats</c-s>.
                  </t-b>
                  <t-b>
                    The <c-s>Clone</c-s> trait implements a method <c-s>clone()</c-s> for <c-s>Stats</c-s>
                    that copies the instance when <c-s>clone</c-s> is invoked.
                  </t-b>
                </t-b>
                <t-b>
                  ----- <c-s>Stats</c-s> methods ----------
                </t-b>
                <t-b class="indent">
                  <c-s>Stats</c-s> implements the methods:
                  <ul>
                    <li>
                      <c-s>new(v:Vec&lt;T&gt;) -&gt;Stats&lt;T&gt;</c-s>, a constructor that accepts a vector
                      of <c-s>T</c-s> values
                    </li>
                    <li>
                      <c-s>max(&amp;self) -&gt; T</c-s> returns most positive value in <c-s>items</c-s>.
                    </li>
                    <li>
                      <c-s>min(&amp;self) -&gt; T</c-s> returns most negative value in <c-s>items</c-s>.
                    </li>
                    <li>
                      <c-s>sum(&amp;self) -&gt; T</c-s> returns sum of values in <c-s>items</c-s>.
                    </li>
                    <li>
                      <c-s>avg(&amp;self) -&gt; T</c-s> returns average of values in <c-s>items</c-s>.
                    </li>
                    <li>
                      <c-s>clone(&amp;self) -&gt; Stats&lt;T&gt;</c-s>
                    </li>
                  </ul>
                  Since all methods but the constructor accept a reference, <c-s>&amp;self</c-s>,
                  invocations do not consume the <c-s>Stats</c-s> instance.
                </t-b>
                <div style="height:0.75em;"></div>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="statsdemo">2.4.2 Stats Demonstration</h3>
        <t-b>

        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig6-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig6-first')" style="width:200em;"><code class="language-cpp">/*---------------------------------------------------------
  Demonstrate user-defined Stats&lt;T&gt; type
*/
pub fn demo_stats() {
  show_label(&quot;demo Arithmetic Trait with Stats&lt;T&gt;&quot;, 40);
  println!();

  show_op(&quot;Stats&lt;T&gt;&quot;);
  println!();
  let s = Stats::&lt;f64&gt;::new(vec![1.5, 2.5, 3.0, -1.25, 0.5]);
  println!(&quot;  {:?}&quot;, s);
  println!(&quot;  max: {:?}&quot;, s.max());
  println!(&quot;  min: {:?}&quot;, s.min());
  println!(&quot;  sum: {:?}&quot;, s.sum());
  println!(&quot;  avg: {:?}&quot;, s.avg());
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig6-seperator"></splitter-bar>
            <second-item id="fig6-second" style="width:40em; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="obubbleup('fig6-first')" style="width:200em;"><code class="language-shell">


----------------------------------------
  demo Arithmetic Trait with Stats&lt;T&gt;
----------------------------------------

--- Stats&lt;T&gt; ---

  Stats { items: [1.5, 2.5, 3.0, -1.25, 0.5] }
  max: 3.0
  min: -1.25
  sum: 6.25
  avg: 1.25


</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="point">2.5 Point&lt;T, N&gt;</h3>
        <t-b>
          <c-s>Point&lt;T, N&gt;</c-s> represents an N-dimensional point by wrapping a vector of coordinates
          call <c-s>coor</c-s>. It provides methods for initialization, modification, and indexing.
        </t-b>
        <h3 id="pointdef">2.5.1 Point&lt;T, N&gt; Definition</h3>
        <t-b>
          <c-s>PointN&lt;T&gt;</c-s> is the first useful generic type presented here. It&apos;s defined in
          the module points_generic.rs and has almost all the functionality needed for a working type.
          Only an iterator is needed, and that will be added in the next <a target="_blank" href="Bits_IterRust.html">Bit</a>.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig7-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig7-first')" style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------
  points_generic.rs
  - defines type Point&lt;T, N&gt;
-------------------------------------------------------------------*/

use std::default::*;
use std::fmt::*;

use crate::analysis_generic;    // identify source code
use analysis_generic::*;        // import public functions and types

/*---------------------------------------------------------
  - Declare Point&lt;T, N&gt; struct, like a C++ template class
  - Request compiler implement traits Debug & Clone
*/
#[derive(Debug, Clone)]
pub struct Point&lt;T, const N: usize&gt;
where
  T: Debug + Default + Clone
{
  coor: Vec&lt;T&gt;,
}
impl&lt;T, const N: usize&gt; Point&lt;T, N&gt;
where
T: Debug + Default + Clone
{
  /*-- constructor --*/
  pub fn new() -&gt; Point&lt;T, N&gt; {
    Point::&lt;T, N&gt; {
      coor: vec![T::default(); N],
    }
  }
  /*-------------------------------------------------------
    Point&lt;T, N&gt;::init(&self, v:Vec&lt;T&gt;) fills coor with
    first N values from v and sets any remainder to
    T::default().
  -------------------------------------------------------*/
  pub fn init(mut self, coord: &Vec&lt;T&gt;) -&gt; Point&lt;T, N&gt; {
    for i in 1..N {
      if i &lt; coord.len() {
        self.coor[i] = coord[i].clone();
      }
      else {
        self.coor[i] = T::default();
      }
    }
    self
  }
  pub fn len(&self) -&gt; usize {
    self.coor.len()
  }
  /*-- acts as both get_coor() and set_coor(some_vector) --*/
  pub fn coors(&mut self) -&gt; &mut Vec&lt;T&gt; {
    &mut self.coor
  }
  /*-- displays name, type, and coordinates --*/
  pub fn show(&self, nm:&str, left: usize, width:usize) {
    println!(&quot;  {nm:?}: Point&lt;T, N&gt; {{&quot;);
    show_fold(&self.coor, left + 2, width);
    println!(&quot;  }}&quot;)
  }
}
/*-- implements const indexer -----------------*/
impl&lt;T:Debug, const N:usize, Idx&gt; std::ops::Index&lt;Idx&gt; for Point&lt;T, N&gt;
    where
        T:Debug + Default + Clone,
        Idx: std::slice::SliceIndex&lt;[T]&gt;
{
    type Output = Idx::Output;

    fn index(&self, index:Idx) -&gt; &Self::Output {
        &self.coor[index]
    }
}
/*-- implements mutable indexer ---------------*/
impl&lt;T, const N: usize, Idx&gt; std::ops::IndexMut&lt;Idx&gt; for Point&lt;T, N&gt;
    where
        T:Debug + Default + Clone,
        Idx: std::slice::SliceIndex&lt;[T]&gt;
{
    fn index_mut(&mut self, index:Idx) -&gt; &mut Self::Output {
        &mut self.coor[index]
    }
}
/* explicit conversion to slice &[T] */
impl&lt;T, const N: usize&gt; AsRef&lt;[T]&gt; for Point&lt;T, N&gt;
  where
    T: ?Sized,
    T: Debug + Display + Default + Clone,
{
  fn as_ref(&self) -&gt; &[T] {
    &self.coor
  }
}
/* implicit conversion to slice &[T] */
impl&lt;T, const N: usize&gt; std::ops::Deref for Point&lt;T, N&gt;
  where T: Debug + Default + Clone,
{
  type Target = [T];

  fn deref(&self) -&gt; &Self::Target {
    &self.coor
  }
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig7-seperator"></splitter-bar>
            <second-item id="fig7-second" style="width:40em; padding-right:0.5em; background-color:var(--light);">
              <div onclick="obubbleup('fig7-first')" class="textwrap">
                <t-b>
                  ----- <c-s>Point&lt;T, N&gt;</c-s> declaration ------
                </t-b>
                <t-b>
                  <c-s>
                    #[derive(Debug, Clone)]<br />
                    pub struct Point&lt;T, const N: usize&gt;<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;where T: Debug + Default + Clone<br />
                    {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;coor: Vec&lt;T&gt;,<br />
                    }
                  </c-s><br />
                  <t-b>
                    instructs the compiler to lay out <c-s>PointN&lt;T&gt;</c-s> instances with a <c-s>Vec</c-s>
                    control block pointing to a mutable array of <c-s>T</c-s> values in the native heap.
                  </t-b>
                  <t-b>
                    The derive declaration instructs the compiler to implement <c-s>Debug</c-s> and
                    <c-s>Clone</c-s> traits.
                  </t-b>
                </t-b>
                <t-b>
                  ----- <c-s>Point&lt;T, N&gt;</c-s> methods ----------
                </t-b>
                <t-b class="indent">
                  <c-s>Point&lt;T, N&gt;</c-s> implements methods:
                  <ul>
                    <li>
                      <c-s>new() -&gt;Point&lt;T, N&gt;</c-s>, a constructor that builds <c-s>coor</c-s> with
                      <c-s>N T::default()</c-s> values.
                    </li>
                    <li>
                      <c-s>init(mut self, coord: &Vec&lt;T&gt;) -&gt; Point&lt;T, N&gt;</c-s>
                      accepts a reference to a vector of coordinates, returns new instance with
                      the specified coordinates.
                    </li>
                    <li>
                      <c-s>len(&amp;self) -&gt; usize</c-s> returns length of <c-s>coor</c-s>
                    </li>
                    <li>
                      <c-s>coors(&amp;mut self) -&gt; &mut Vec&lt;T&gt;</c-s> returns mutable reference
                      to internal coordinates, allowing both reading and writing coordinate values.
                    </li>
                  </ul>
                  ----- <c-s>Point&lt;T, N&gt;</c-s> traits ----------
                  <ul>
                    <li>
                      <c-s>std::ops::Index&lt;Idx&gt;</c-s> supports non-mutable indexing with index notation.
                    </li>
                    <li>
                      <c-s>std::ops::IndexMut&lt;Idx&gt;</c-s> supports mutable indexing with index notation.
                    </li>
                    <li>
                      <c-s>std::ops::AsRef&lt;[T]&gt;</c-s> provides explicit conversion to array slice
                      using <c-s>Vec</c-s> AsRef&lt;[T]&gt;
                    </li>
                    <li>
                      <c-s>std::ops::DeRef</c-s> implicit conversion to array slice using <c-s>Vec</c-s>
                      DeRef.
                    </li>
                    <li>
                      <c-s>clone(&amp;self) -&gt; Point&lt;T, N&gt;</c-s> returns independent copy, implemented
                      by compiler.
                    </li>
                  </ul>
                  Since all methods but the constructor and initializer accept a reference, <c-s>&amp;self</c-s>,
                  invocations do not consume the <c-s>Point</c-s> instance.
                </t-b>
                <div style="height:0.75em;"></div>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="pointdemo">2.5.2 Point&lt;T, N&gt; Demonstration</h3>
        <t-b>
          Demonstration of <c-s>PointN&lt;T&gt;</c-s> is provided by the function <c-s>demo_pointn()</c-s>
          in module points_generic.rs, shown in the left panel. When that is executed the results are
          the content of the right panel.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig8-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig8-first')" style="width:200em;"><code class="language-cpp">/*---------------------------------------------------------
  Demonstrate user-defined Point&lt;T, N&gt; type
*/
pub fn demo_pointn() {

  show_label(&quot;demo indexing with Point&lt;132, 5&gt;&quot;, 40);
  println!();

  show_op(&quot;Point&lt;i32, 5&gt;&quot;);
  println!();
  let mut p = Point::&lt;i32, 5&gt;::new()
         .init(&vec![1, 2, 3, 2, 1]);
  p.show(&quot;p&quot;, 2, 12);
  println!();
  show_op(&quot;*p.coors() = vec![1, 0, -1, 0, 1]&quot;);
  *p.coors() = vec![1, 0, -1, 0, 1];
  p.show(&quot;p&quot;, 2, 12);

  println!(&quot;&#92;n  using immutable indexer:&quot;);
  println!(&quot;  value of p[0] is {}&#92;n&quot;, p[0]);
  println!(&quot;  using mutable indexer:&quot;);
  show_op(&quot;p[0] = 3&quot;);
  p[0] = 3;
  p.show(&quot;p&quot;, 2, 12);
  show_op(&quot;p[1] = 4&quot;);
  p[1] = 4;
  p.show(&quot;p&quot;, 2, 12);

}


</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig8-seperator"></splitter-bar>
            <second-item id="fig8-second" style="width:40em; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="obubbleup('fig8-first')" style="width:200em;"><code class="language-shell">

----------------------------------------
  demo indexing with PointN&lt;132, 5&gt;
----------------------------------------

--- PointN&lt;i32, 5&gt; ---

  &quot;p&quot;: Point&lt;T, N&gt; {
    0, 2, 3, 2, 1
  }

--- *p.coors() = vec![1, 0, -1, 0, 1] ---
  &quot;p&quot;: Point&lt;T, N&gt; {
    1, 0, -1, 0, 1
  }

  using immutable indexer:
  value of p[0] is 1

  using mutable indexer:
--- p[0] = 3 ---
  &quot;p&quot;: Point&lt;T, N&gt; {
    3, 0, -1, 0, 1
  }
--- p[1] = 4 ---
  &quot;p&quot;: Point&lt;T, N&gt; {
    3, 4, -1, 0, 1
  }


</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="funcs">2.6 Generic Functions</h3>
        <t-b>
          The preceding demonstrations have used several generic functions for analysis of type
          and display, along with a few non-generic helper functions.
          These are provided in module analysis_generic.rs and discussed below.
        </t-b>
        <h3 id="funcsdef">2.6.1 Generic Functions Definition</h3>
        <t-b>
          Code for generic functions, <c-s>show_type&lt;T&gt;</c-s>, <c-s>demo_indexer&lt;T&gt;</c-s>,
          <c-s>fold&lt;T, I&gt;</c-s>, and <c-s>show_fold&lt;T, I&gt;</c-s> is presented in the left panel.
          Four non-generic functions are also part of the analysis_generic.rs module.
        </t-b>
        <t-b>
          Generic functions like <c-s>demo_indexer&lt;T&gt;</c-s> allow us to write one function that can
          accept aguments of many different types. That improves code ergonomics and developer productivity.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig9-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig9-first')" style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------
  analysis_generics.rs
  - provides analysis and display functions for Generics demo.
  - a few of these require advanced generics code.
  - You don't need to know how these work to understand this
    demo.
  - We will come back to these functions in rust_iter.
-------------------------------------------------------------------*/

use std::fmt::*;

/*---------------------------------------------------------
  Show input's call name and type
  - doesn't consume input
  - show_type is generic function with Debug bound.
    Using format &quot;{:?}&quot; requires Debug.
*/
pub fn show_type&lt;T:Debug&gt;(_t: &T, nm: &str) {
  let typename = std::any::type_name::&lt;T&gt;();
  println!(&quot;call name: {nm:?}, type: {typename:?}&quot;);
}
/*---------------------------------------------------------
  show_indexer&lt;T:Debug&gt;(nm:&str, s:&[T])
  - accepts any collection that implements Deref to slice
  - that includes array [T;N], slice T[N], Vec&lt;T&gt;, PointN&lt;T&gt;
*/
#[allow(clippy::needless_range_loop)]
pub fn demo_indexer&lt;T&gt;(nm:&str, s:&[T])
  where T: Debug + Display
{
  print!(&quot;  {}&quot;, nm);
  let max = s.len();
  print!{&quot;  [ {:?}&quot;, s[0]};
  /* 1..max is range iterator */
  for i in 1..max {
      print!(&quot;, {:?}&quot;, s[i]);
  }
  println!(&quot; ]&quot;);
  /*---------------------------------------------
    The code above is not idiomatic Rust.
    Rust style prefers using iterators over indexing
    like this:
    for item in s.iter() {
      print!(&quot;{item} &quot;);
    }
  */
}
/*---------------------------------------------------------
  build indent string with &quot;left&quot; spaces
*/
pub fn offset(left: usize) -&gt; String {
  let mut accum = String::new();
  for _i in 0..left {
    accum += &quot; &quot;;
  }
  accum
}
/*---------------------------------------------------------
  find index of last occurance of chr in s
  - returns option in case chr is not found
  https://stackoverflow.com/questions/50101842/how-to-find-the-last-occurrence-of-a-char-in-a-string
*/
fn find_last_utf8(s: &str, chr: char) -&gt; Option&lt;usize&gt; {
  s.chars().rev().position(|c| c== chr)
    .map(|rev_pos| s.chars().count() - rev_pos - 1)

    /*-- alternate implementation --*/
  // if let Some(rev_pos) =
  //   s.chars().rev().position(|c| c == chr) {
  //     Some(s.chars().count() - rev_pos - 1)
  // } else {
  //     None
  // }
}
/*---------------------------------------------------------
  fold an enumerable's elements into rows of w elements
  - indent by left spaces
  - does not consume t since passed as reference
  - returns string
  https://users.rust-lang.org/t/generic-code-over-iterators/10907/3
*/
pub fn fold&lt;T, I:Debug&gt;(
  t: &T, left: usize, width: usize
) -&gt; String
    where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;, T:Debug
{
  let mut accum = String::new();
  accum += &offset(left);

  for (i, item) in t.into_iter().enumerate() {
    accum += &format!(&quot;{item:?}, &quot;);
    if ((i + 1) % width) == 0 && i != 0 {
        accum += &quot;&#92;n&quot;;
        accum += &offset(left);
    }
  }
  /*-- Alternate direct implementation --*/
  //let mut i = 0usize;
  // for item in t {
  //   accum += &format!(&quot;{item:?}, &quot;);
  //   if ((i + 1) % width) == 0 && i != 0 {
  //       accum += &quot;&#92;n&quot;;
  //       accum += &offset(left);
  //   }
  //   i += 1;
  // }

  let opt = find_last_utf8(&accum, ',');
  if let Some(index) = opt {
    accum.truncate(index);
  }
  accum
}
/*---------------------------------------------------------
  show enumerables's elements as folded rows
  - width is number of elements in each row
  - left is indent from terminal left
*/
pub fn show_fold&lt;T:Debug, I:Debug&gt;(t:&T, left:usize, width:usize)
  where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;
{
  println!(&quot;{}&quot;,fold(t, left, width));
}
/*------------------------------------------------------------
  show string wrapped with long dotted lines above and below
*/
pub fn show_label(note: &str, n:usize) {
  let line =
    std::iter::repeat('-').take(n).collect::&lt;String&gt;();
  print!(&quot;&#92;n{line}&#92;n&quot;);
  print!(&quot;  {note}&quot;);
  print!(&quot;&#92;n{line}&#92;n&quot;);
}
pub fn show_label_def(note:&str) {
  show_label(note, 50);
}
/*---------------------------------------------------------
  show string wrapped with dotted lines above and below
*/
pub fn show_note(note: &str) {
  print!(&quot;&#92;n-------------------------&#92;n&quot;);
  print!(&quot; {note}&quot;);
  print!(&quot;&#92;n-------------------------&#92;n&quot;);
}
/*---------------------------------------------------------
  show string wrapped in short lines
*/
pub fn show_op(opt: &str) {
  println!(&quot;--- {opt} ---&quot;);
}
/*---------------------------------------------------------
  print newline
*/
pub fn nl() {
  println!();
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig9-seperator"></splitter-bar>
            <second-item id="fig9-second" style="width:40em; padding-right:0.5em; background-color:var(--light);">
              <div onclick="obubbleup('fig9-first')" class="textwrap">
                <t-b>
                  ----- generic functions -----------------
                </t-b>
                <ul>
                  <li>
                    <c-s>show_type&lt;T&gt;</c-s> prints the second argument string, expected to be the name
                    at the call-site of the first argument, then prints the compiler generated type representation
                    of the first argument.
                  </li>
                  <li>
                    <c-s>demo_indexer&lt;T&gt;</c-s> prints a representation of the slice returned by an
                    implicit call to std::ops::deref on the second argument. This invocation will fail to
                    compile if the type of the second argument does not implement trait DeRef.
                  </li>
                  <li>
                    <c-s>show_fold&lt;T&gt;</c-s> prints a column of rows of values for enumerable types,
                    like the std::collections, making output more readable.
                  </li>
                </ul>
                <t-b>
                  ----- helper functions ----------
                </t-b>
                <ul>
                  <li>
                    <c-s>fold&lt;T&gt;</c-s> does all the computation to partition a slice into a column
                    of rows of values.
                  </li>
                  <li>
                    <c-s>offset</c-s> builds a string of blank spaces to prepend to display lines.
                  </li>
                  <li>
                    <c-s>find_last_utf8</c-s> finds the last occurance of a character in a given string.
                    It is used to find and remove the last trailing comma in a string of comma separated
                    list of values.
                  </li>
                </ul>
                <t-b>
                  Five of these functions use iterators, which are explained in the next
                  <a target="_blank" href="Bits_IterRust.html">Bit</a>.
                </t-b>
                <div style="height:0.75em;"></div>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="funcsdemo">2.6.2 Generic Functions Demonstration</h3>
        <t-b>
          The demonstration code and its output illustrate how effective generic functions like
          <c-s>demo_indexer</c-s> can be to help make code readable and save time by avoiding
          creation of multiple
          functions that use the same code except for type declarations.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig10-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig10-first')" style="width:200em;"><code class="language-cpp">fn demo_generic_functions() {
  show_note(&quot;demo_generic_functions&quot;);
  println!();

  show_op(&quot;show_type&lt;T:Debug&gt;(_t, &#92;&quot;name&#92;&quot;)&quot;);
  println!();

  let v = vec![1, 2, 3];
  show_type(&v, &quot;v&quot;);
  let m = HashMap::&lt;&str, i32&gt;::new();
  show_type(&m, &quot;m&quot;);
  println!();

  show_op(&quot;demo_indexer&quot;);
  println!();
  demo_indexer(&quot;[i32; 3]&quot;, &[1, 2, 3]);
  demo_indexer(&quot;Vec&lt;i32&gt;&quot;, &v);
  let p = PointN::&lt;f64&gt;::new(3).init(vec![1.0, 2.0, -0.5]);
  demo_indexer(&quot;PointN&lt;f64&gt;&quot;, &p);
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig10-seperator"></splitter-bar>
            <second-item id="fig10-second" style="width:40em; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="obubbleup('fig10-first')" style="width:200em;"><code class="language-shell">
-------------------------
 demo_generic_functions
-------------------------

--- show_type&lt;T:Debug&gt;(_t, &quot;name&quot;) ---

call name: &quot;v&quot;, type: &quot;alloc::vec::Vec&lt;i32&gt;&quot;
call name: &quot;m&quot;, type: &quot;std::collections::hash::map::HashMap&lt;&str, i32&gt;&quot;

--- demo_indexer ---

  [i32; 3]  [ 1, 2, 3 ]
  Vec&lt;i32&gt;  [ 1, 2, 3 ]
  PointN&lt;f64&gt;  [ 1.0, 2.0, -0.5 ]





</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h4 id="build">3.0 Build</h4>
        <div style="border:1px solid var(--dark); padding:0.25em 0.75em; width:max-content;">
          <pre class="language-shell" style="width:max-content;">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_generics
&gt; cargo build
   Compiling rust_hello_objects v0.1.0 (C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_generics)
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_generics
&gt;
          </pre>
        </div>
        <h3 id="vscode">4.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Rust">Rust\rust_generics</a>.
        </t-b>
        <photosizer-block src="pictures/VS_Code_Debugging_Rust_Generics.png" width="800" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE - Rust Debug Generics</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/LaunchJSON_Rust_Objects.JPG" width="700" class="photoSizerBlock left"
    style="overflow-x:auto;"
  >
    <span style="font-family:'Comic Sans MS';">Figure 2. Rust Launch.JSON</span>
  </photosizer-block>
  <photosizer-block src="pictures/VS_Code_Debugging_Rust_Objects.JPG" width="700" class="photoSizerBlock left"
    style="overflow-x:auto;"
  >
    <span style="font-family:'Comic Sans MS';">Figure 3. Debugging Rust Objects</span>
  </photosizer-block>-->
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
  </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">5.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../RustBites/RustBites_Traits.html">RustBite_Generics</a>
            </td>
            <td>
              RustBite on Generics
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../RustStoryRepo.html">Rust Story</a>
            </td>
            <td>
              E-book with seven chapters covering most of intermediate Rust
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../RustBites/RustBites_Intro.html">Rust Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/index.html">std library</a>
            </td>
            <td>
              Comprehensive guide organized into primitive types, modules, macros, and keywords
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/index.html#modules">std modules</a>
            </td>
            <td>
              Definition of non-primitive types like <c-s>Vec&lt;T&gt;</c-s> and <c-s>String</c-s>
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/collections/index.html#modules">st::collections</a>
            </td>
            <td>
              Definition of collection types like <c-s>HashMap&lt;K, V&gt;</c-s> and
              <c-s>VecDeque&lt;T&gt;</c-s>
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <!-- <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ide">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">bld</a></menu-elem>
        <menu-elem class="secElem"><a href="#out">out</a></menu-elem>
        <menu-elem class="secElem"><a href="#analysis">anal</a></menu-elem>
        <menu-elem class="secElem"><a href="#points">pts</a></menu-elem>
        <menu-elem class="secElem"><a href="#stats">stats</a></menu-elem>
        <menu-elem class="secElem"><a href="#source">src</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">codeSnaps</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections> -->
    </main>
    <!-- <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer> -->
  </page-frame>
  <script>
    var scrollables = document.querySelectorAll('.scrollable');
    for (let scrollable of scrollables) {
      //alert('adding listener');
      scrollable.addEventListener('wheel', function (event) {
        var deltaY = event.deltaY;
        var contentHeight = scrollable.scrollHeight;
        var visibleHeight = scrollable.offsetHeight;
        var scrollTop = scrollable.scrollTop;

        if (scrollTop === 0 && deltaY < 0)
          event.preventDefault();
        else if (visibleHeight + scrollTop === contentHeight && deltaY > 0)
          event.preventDefault();
      });
    }
    // https://stackoverflow.com/questions/7600454/how-to-prevent-page-scrolling-when-scrolling-a-div-element
  </script>
  <script>
    onLoadSplitter("fig1");
    onLoadSplitter("fig2");
    onLoadSplitter("fig3");
    onLoadSplitter("fig4");
    onLoadSplitter("fig5");
    onLoadSplitter("fig6");
    onLoadSplitter("fig7");
    onLoadSplitter("fig8");
    onLoadSplitter("fig9");
    onLoadSplitter("fig10");
  </script>
</body>
</html>