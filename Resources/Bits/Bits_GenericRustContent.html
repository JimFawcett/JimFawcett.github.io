<!DOCTYPE html>
<html>
<!--
  Bits_GenericRustContent.html
-->
<head>
  <title>Bits Generic Rust</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeRust.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesSplitterBar.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsSplitterBar.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBitsRust.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <link rel="stylesheet" href="css/StylesSplitterBar.css" />
  <script src="js/ScriptsSplitterBar.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <style>
    #github .note {
      border: 2px solid red;
      padding: 0.75em 1.5em;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      background-color: var(--light);
      color: var(--dark);
      width: max-content;
      max-width: 50em;
    }

    #github h2 {
      margin-top: 0.75em;
    }

    #github #pagetitle {
      border: 2px double var(--dark);
      /* line-height:1.5em; */
    }

    #github .hide {
      display: none;
    }

    body {
      position: relative;
      line-height: 1.25em;
    }

    #github .remotebutton {
      padding: 0.25em 0.5em;
    }

    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }

    #github hr.spread {
      margin: 0.75em 0em;
    }

    #github {
      user-select: none;
    }

    .focus {
      padding: 0.5em 1.0em 0.5em 1.0em;
      /*border:1px solid red;*/
    }

    *.focus ul {
      padding-top: -0.5em;
      /*background-color:green;*/
    }

    .cat {
      text-align: left;
      background-color: var(--menu);
    }

    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 1em 1.5em;
      margin-right: 0.5em;
    }

    #github pre {
      overflow-x: auto;
      /* width:100%; */
      /* user-select: all; */
    }

    #github code {
      width: 100%;
    }

    code-style {
      white-space: pre;
      font-family: Consolas;
      font-size: 0.95em;
      font-weight: bold;
    }

    .blockDouble {
      position: relative;
      display: grid;
      grid-template-columns: 1fr 1fr;
      border: 1px solid var(--dark);
      overflow-x: auto;
      overflow-y: hidden;
      margin-right: 0.75em;
      padding: 0.75em;
      padding-right: 0em;
    }

    .blockSingle {
      position: relative;
      border: 1px solid var(--dark);
      overflow-x: auto;
      overflow-y: hidden;
      margin-top: 1.5em;
      margin-right: 0.75em;
      padding: 0.0em;
      padding-right: 0em;
    }

    .codewrap {
      padding: 0.5em;
      padding-right: 0em;
      margin-right: 0.15em;
      overflow-y: auto;
      border: 1px dashed blue;
      font-size: 0.80em;
    }

    #github div.block t-b {
      max-width: 100%;
      padding-left: 0.5em;
    }

    .textwrap {
      position: relative;
      padding-right: 1em;
      padding-left: 1em;
      margin-right: 0.5em;
      overflow-y: scroll;
      border: 1px dashed red;
      font-size:0.8em;
    }

    table {
      margin-right: 0.75em;
    }

    #github .scrollable {
      overflow: auto;
    }
  </style>
  <style>
    #github .info {
      position: relative;
      top: 0em;
      float: right;
      font-size: large;
      font-weight: bold;
      text-align: center;
      background-color: var(--dark);
      border-radius: 8px;
      color: var(--light);
      width: 1.25em;
      cursor: pointer;
      user-select: none;
    }

    #github .infoKill {
      position: relative;
      top: 0.05em;
      float: right;
      font-size: large;
      font-weight: bold;
      text-align: center;
      background-color: var(--light);
      border-radius: 8px;
      color: var(--dark);
      width: 1.25em;
      cursor: pointer;
      user-select: none;
      margin: 0.25em;
    }

    #github .txt {
      display: none;
      position: absolute;
      right: 4.5em;
      width: 20em;
      z-index: 10;
      color: var(--dark);
      font-size: small;
      background-color: var(--light);
      border: 2px solid var(--dark);
      padding: 0em 0.5em;
      overflow-y: visible;
    }

  </style>
  <script>
    function closeInfos() {
      var elems = document.querySelectorAll('.txt');
      for (let i = 0; i < elems.length; ++i) {
        if (elems[i].style.display === "block") {
          elems[i].style.display = "none";
        }
      }
    }
    function toggleInfo(dst) {
      var elem = document.getElementById(dst);
      if (elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = "block";
      }
      else {
        elem.style.display = "none";
      }
    }
    function toggleInfoRel(src, dst, adj = 0) {
      var txtcont = document.getElementById(dst);
      var elemtop = src.offsetTop;
      txtcont.style.top = parseInt(elemtop - 25 - adj) + 'px';
      var top = txtcont.style.top;
      if (txtcont.style.display === "none" || txtcont.style.display === "") {
        txtcont.style.display = "block";
      }
      else {
        txtcont.style.display = "none";
      }
    }
  </script>
  <script>
    function setScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = main.scrollTop;
      localStorage.setItem('scrollPositionHelloRust', scrollPosition);
      let body = document.getElementById("github");
      let style = window.getComputedStyle(body, null).getPropertyValue('line-height');
      let fontsize = parseFloat(style);
      let scroller = document.getElementById("scrollY")
      scroller.innerHTML = Math.trunc(scrollPosition / fontsize);
    }
    function gotoLastScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = localStorage.getItem('scrollPositionHelloRust');
      if (scrollPosition) {
        main.scrollTo(0, scrollPosition);
      }
      main.addEventListener('scroll', setScroll);
    }
    function load() {
      //initialize();
      gotoLastScroll();
    }
  </script>
  <script>
    function remote() {
      window.open('https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=8e994f9f6fc188f237277592474ac828', '_blank');
    }
  </script>
</head>
<body id="github" onload="load()">

  <a id="Next" href="Bits_IterRust.html">Next</a>
  <a id="Prev" href="Bits_ObjectsRust.html">Prev</a>

  <page-frame>
    <!-- <frame-header>
      <nav id="navbar"></nav>
    </frame-header> -->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits Generic Rust</div>
      <div id="modified">04/15/2024</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <!-- <div class="rightPanelLinks">
    <a href="Bits_GenericCpp.html">C++</a>
    <a class="darkItem" href="Bits_GenericRust.html">Rust</a>
    <a href="Bits_GenericCSharp.html">C#</a>
    <a href="Bits_GenericPython.html">Python</a>
    <a class="undefined" href="#Bits_GenericJs.html">JvScrpt</a>
  </div> -->
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.50em; width:max-content; height:1.5em;
           text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits: Generic Rust</h1>
            <h3 id="subtitle" class="indent">
              generic types, traits, and functions
            </h3>
          </hgroup>
        </header>
        <t-b style="border:2px solid red; padding:0.5em 1.5em;">
          This page is a prototype used to decide which language features to emphasize. It will
          be replaced with a final version soon.
        </t-b>
        <t-b style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          This page demonstrates creation and uses of generic Rust functions and User-Defined types.
          The purpose is to quickly acquire some familiarity with generic types and their implementations.
          <hr class="spread" />
          <ul>
            <li>
              Rust generics support definition of function and class patterns, which can
              be instantiated for a variety of different concrete types.
            </li>
            <li>
              Each instantiation must use types that provide all the facilities used
              in the pattern.
            </li>
            <li>
              The pattern can provide constraints, using traits, on its type parameters that guarantee methods
              required by the pattern.
            </li>
          </ul>
          <div style="height:0.5em;"></div>
        </t-b>
        <details>
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <t-b><hr /></t-b>
          <t-b>
            Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
            is a pattern for defining functions and classes of a specific type.  Thus a generic class is a
            pattern for making patterns.
          </t-b>
          <t-b>
            The other two, Python and JavaScript, are dynamically typed and already support defining
            functions and classes for multiple types, e.g., no need for generics.
          </t-b>
          <t-b>
            This demonstration illustrates use of generic classes and objects, which for C++, Rust, and C#,
            are defined in a stackframe or in the heap or both. <strongs>All</strongs> data for Python and JavaScript are
            stored in managed heaps.
          </t-b>
          <t-b><hr /></t-b>
        </details>
        <t-b>
          The examples below show how to use library and user defined types with emphasis on
          illustrating syntax and basic operations.
        </t-b>
        <h3>1.0 Code</h3>
        <t-b>
          Demonstrations of generic Rust code are partitioned into modules main.rs, stats.rs, 
          points_generic.rs, and analysis_generics.rs. Discussion of each of these will be
          presented in a section of page, below.
        </t-b>
        <h3 id="structure">1.1 Main Module Structure</h3>
        <t-b>
          This first panel block illustrates structure of this demonstration of generic Rust.
          Most of the code definitions have been elided for clarity, but those details will
          be shown in later blocks.
        </t-b>
        <t-b>
          Alter panel widths by dragging splitter bar or clicking in either panel
          to expand that panel&apos;s width.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig1-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig1-first')" style="width:200em;"><code class="language-cpp">
#![allow(dead_code)]
#![allow(clippy::approx_constant)]

mod analysis_generic;     // identify module source file
use analysis_generic::*;  // import public functions and types
mod stats;
use stats::*;
mod points_generic;
use points_generic::*;

use std::{fmt::*, collections::HashMap};

/*------------------------------------------
definition of type Demo has been elided
(shown below)
------------------------------------------*/

fn demo_std_generic_types() {
  /* defs elided */
}
fn demo_user_defined_generic_types() {
  /* defs elided */
}
fn demo_generic_functions() {
  /* defs elided */
}

fn main() {

  show_label(&quot;generic functions and types&quot;, 50);

  demo_std_generic_types();
  demo_user_defined_generic_types();
  demo_generic_functions();

  print!(&quot;&#92;n&#92;n  That's all Folks!&#92;n&#92;n&quot;);
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig1-seperator"></splitter-bar>
            <second-item id="fig1-second" style="width:40em; padding-right:0.5em; background-color:var(--light);" onclick="obubbleup('fig2-first')">
              <div onclick="obubbleup('fig1-first')" class="textwrap">
                <t-b>
                  ----- modules -----------------
                </t-b>
                <t-b>
                  The main module, main.rs, opens by importing definitions from three modules defined for
                  this demonstraion:
                  <ul>
                    <li>
                      analysis_generic.rs defines type analysis and display functions
                    </li>
                    <li>
                      stats.rs provides type definition of a simple user-defined type.
                    </li>
                    <li>
                      points_generic defines a user type PointN&lt;T&gt; representing points in an
                      N dimensional hyperspace.
                    </li>
                  </ul>
                </t-b>
                <t-b>
                  ----- code structure ----------
                </t-b>
                <t-b class="indent">
                  Code for this demonstration consists of:
                  <ul>
                    <li>
                      Definitions of user-defined types
                    </li>
                    <li>
                      Functions for analysis and display of specified objects
                    </li>
                    <li>
                      Three functions that demonstrate generics for standard types,
                      user-defined types, and generic functions
                    </li>
                  </ul>
                  Program execution begins in the main function of the main module. It simply invokes 
                  these functions as shown in the left panel.
                </t-b>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="standard">1.1.1 Standard Generic Types</h3>
        <t-b>
          Standard generic types are defined in the Rust Standard Library and include many more
          than shown here. We have selected four frequently used types. You can find details of
          the others from the references.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="fig2-first" style="width:52%; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="cbubbleup('fig2-first')" style="width:200em;"><code class="language-cpp">fn demo_std_generic_types() {

  show_note(&quot;demo standard generic types&quot;);
  println!();

  show_op(&quot;arrays: [T; N]&quot;);
  println!();
  let arri = [1, 2, 3, 2, 1];
  println!(&quot;  {:?}&quot;, arri);
  let arrf = [1.0, 1.5, 2.0, 1.5, 1.0];
  println!(&quot;  {:?}&#92;n&quot;, arrf);

  show_op(&quot;slices: &T[m..n]&quot;);
  println!();
  let slicei = &arri[1..5]; // [2, 3, 4, 5]
  println!(&quot;  {:?}&quot;, slicei);
  let slicef = &arrf[2..4]; // [2.0, 1.5]
  println!(&quot;  {:?}&#92;n&quot;, slicef);

  show_op(&quot;vectors: Vec&lt;T&gt;&quot;);
  println!();
  let mut v = Vec::&lt;i32&gt;::new();
  v.push(1);
  v.push(2);
  v.push(3);
  v.push(2);
  v.push(1);
  println!(&quot;  Vec&lt;i32&gt; {:?}&quot;, v);
  let mut v2 = Vec::&lt;(i32,&str)&gt;::new();
  v2.push((1, &quot;one&quot;));
  v2.push((2, &quot;two&quot;));
  println!(&quot;  Vec&lt;(i32, &str)&gt; {:?}&#92;n&quot;, v2);

  show_op(&quot;maps: HashMap&lt;K,V&gt;&quot;);
  println!();
  let mut m = HashMap::&lt;&str, i32&gt;::new();
  m.insert(&quot;zero&quot;, 0);
  m.insert(&quot;one&quot;, 1);
  m.insert(&quot;two&quot;, 2);
  m.insert(&quot;three&quot;, 3);
  println!(&quot;  maps: HashMap&lt;&str, i32&gt;&quot;);
  println!(&quot;    {:?}&quot;, m);
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="fig2-seperator"></splitter-bar>
            <second-item id="fig2-second" style="width:40em; padding-right:0.5em;">
              <div class="codewrap">
                <pre onclick="obubbleup('fig2-first')" style="width:200em;"><code class="language-shell">
-------------------------
 demo standard generic types
-------------------------

--- arrays: [T; N] ---

  [1, 2, 3, 2, 1]
  [1.0, 1.5, 2.0, 1.5, 1.0]



--- slices: &T[m..n] ---

  [2, 3, 2, 1]
  [2.0, 1.5]



--- vectors: Vec&lt;T&gt; ---

  Vec&lt;i32&gt; [1, 2, 3, 2, 1]
  Vec&lt;(i32, &str)&gt; [(1, &quot;one&quot;), (2, &quot;two&quot;)]










--- maps: HashMap&lt;K,V&gt; ---

  maps: HashMap&lt;&str, i32&gt;
    {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;zero&quot;: 0, &quot;three&quot;: 3}






</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <h3 id="code">1.0 CodeSnaps</h3>
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote()" />
        <div style="display:flex; flex-direction:column;">
          <h4 id="source">Source Code - main.rs</h4>
          <pre class="codeSnap">
#![allow(dead_code)]
#![allow(clippy::approx_constant)]

/*-------------------------------------------------------------------
  rust_generics::main.rs
  - Demonstrates creation and use of generic Rust functions and structs
  - Rust uses struct instead of class to create objects
*/
mod analysis_generic;     // identify module source file
use analysis_generic::*;  // import public functions and types
mod points_generic;
use points_generic::*;
mod stats;
use stats::*;

/*---------------------------------------------------------
  Demo object instances in action
*/
fn main() {
    show_label(&quot;demonstrate generic functions and types&quot;, 50);

    show_label(
      &quot;std::library objects, string and vector&lt;T&gt;&quot;, 46
    );
    nl();

    show_op(&quot;let mut s1 = &#92;&quot;a string&#92;&quot;.to_string()&quot;);
    let mut s1 = &quot;a string&quot;.to_string();

    show_op(&quot;show_type_scalar(&s1, &#92;&quot;&s1&#92;&quot;)&quot;);
    show_type_scalar(&s1, &quot;&s1&quot;);
    nl();

    show_op(&quot;s1.push_str(&#92;&quot; and more&#92;&quot;);&quot;);
    s1.push_str(&quot; and more&quot;);
    show_type_scalar(&s1, &quot;&s1&quot;);
    nl();

    show_op(&quot;let mut v:Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1];&quot;);
    let mut v: Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1];
    show_type_scalar(&v, &quot;&v&quot;);
    nl();

    show_op(&quot;v.push(42);&quot;);
    v.push(42);
    show_type_scalar(&v, &quot;&v&quot;);

    show_label(&quot;instances of user-defined types&quot;, 35);
    nl();

    /*-----------------------------------------------------
      Type holding primitive arithmetic types, either
      i32 or f64.  Easy to extend to all integer and float
      types.
    */
    let v = vec![1.0, 2.5, -3.5, 4.0, 5.5];
    let s = Stats::&lt;f64&gt;::new(v);
    println!(&quot;s: {s:?}&quot;);
    println!(&quot;s.max() = {:?}&quot;, s.max());
    println!(&quot;s.min() = {:?}&quot;, s.min());
    println!(&quot;s.sum() = {:?}&quot;, s.sum());
    println!(&quot;s.avg() = {:?}&quot;, s.avg());
    println!();

    let v: Vec&lt;i32&gt; = vec![1, -2, 3, -4, 5];
    let s: Stats&lt;i32&gt; = Stats::&lt;i32&gt;::new(v);
    println!(&quot;s: {s:?}&quot;);
    println!(&quot;s.max() = {:?}&quot;, s.max());
    println!(&quot;s.min() = {:?}&quot;, s.min());
    println!(&quot;s.sum() = {:?}&quot;, s.sum());
    println!(&quot;s.avg() = {:?}&quot;, s.avg());
    println!();

    let mut p1 = PointN::&lt;f64&gt;::new(10);
    p1.show(&quot;p1&quot;, 2, 7);

    show_op(&quot;show_type(p1, &#92;&quot;p1&#92;&quot;)&quot;);
    show_type(&p1, &quot;p1&quot;);

    show_op(&quot;show_value_enum(p1.coors(), &#92;&quot;p1&#92;&quot;, 2, 7)&quot;);
    show_value_enum(p1.coors(), &quot;p1.coors()&quot;, 2, 7);
    nl();

    show_op(&quot;p1.coors()[2] = 3.1415&quot;);
    p1.coors()[2] = 3.1415;
    p1.show(&quot;p1&quot;, 2, 7);

    show_op(&quot;show_value_enum(p1.coors(), &#92;&quot;p1.coors()&#92;&quot;, 2, 7)&quot;);
    show_value_enum(p1.coors(), &quot;p1.coors()&quot;, 2, 7);
    nl();

    let p2 =
      PointN::&lt;i32&gt;::new(1).init(
        vec![0, 1, 2, 3, 4, 4, 3, 2, 1, 0]
      );
    p2.show(&quot;p2&quot;, 2, 7);
    nl();

    show_op(&quot;show_type_scalar(p2, &#92;&quot;p2&#92;&quot;)&quot;);
    show_type_scalar(&p2, &quot;p2&quot;);

    println!(&quot;p2.len() = {:?}&quot;, p2.len());
    nl();

    show_op(&quot;p2.show(&#92;&quot;p2&#92;&quot;, 2, 7)&quot;);
    p2.show(&quot;p2&quot;, 2, 7);

    show_label(&quot;Testing formats for collections&quot;, 35);
    nl();

    let v =
      vec![
        0i32, -1, 2, -3, 4, -5, 6, -7, 8, -9,
        10, -11, 12, -13, 14
      ];

    show_op(&quot;show_type_scalar(&v, &#92;&quot;&v&#92;&quot;)&quot;);
    show_type_scalar(&v, &quot;&v&quot;);
    nl();

    show_op(&quot;show_fold(&v, 2, 5)&quot;);
    show_fold(&v, 2, 5);
    nl();

    show_op(&quot;let v = vec![0i32, ... ];&quot;);
    show_op(&quot;fold(&v, 2, 12)&quot;);
    let stmp = fold(&v, 2, 12);
    println!(&quot;{stmp}&quot;);
    nl();

    show_op(&quot;let a = &[f64; 8];&quot;);
    let a =
      &[1.0, 2.5, -3.1, 4.3, 5.0, 6.0, 7.0, -8.0];
    show_op(&quot;show_fold(a, 4, 5)&quot;);
    show_fold(a, 4, 5);

    print!(&quot;&#92;n&#92;n  That's all Folks!&#92;n&#92;n&quot;);
}
          </pre>
          <h4 id="stats">Source Code - stats.rs</h4>
          <pre class="codeSnap">
/*-------------------------------------------------------------------
  stats.rs
  - defines type Stats containing Vec of generic Type
    bounded by Arithmetic trait
  - Works as is only for i32 and f64, but easy to extend to
    all integers and floats
  - Can also be extended to complex numbers
-------------------------------------------------------------------*/

use std::ops::*;
use std::cmp::*;
use std::convert::{Into};
use std::fmt::Debug;

pub trait Arithmetic&lt;T = Self&gt;: Add&lt;Output=T&gt; + Sub&lt;Output=T&gt;
    + Mul&lt;Output=T&gt; + Div&lt;Output=T&gt; + PartialEq + PartialOrd
    + Default + Copy + Debug + Into&lt;f64&gt; {}

impl Arithmetic&lt;f64&gt; for f64 {}
impl Arithmetic&lt;i32&gt; for i32 {}

#[derive(Debug, Clone)]
pub struct Stats&lt;T: Arithmetic + Debug&gt; {
  items: Vec&lt;T&gt;
}

impl&lt;T: Arithmetic&gt; Stats&lt;T&gt;
    where T: Arithmetic + Debug
{
  pub fn new(v:Vec&lt;T&gt;) -&gt; Stats&lt;T&gt; {
    Stats {
      items: v,
    }
  }
  pub fn max(&self) -&gt; T {
    let mut biggest = self.items[0];
    for item in &self.items {
      if biggest &lt; *item {
        biggest = *item;
      }
    }
    biggest
  }
  pub fn min(&self) -&gt; T {
    let mut smallest = self.items[0];
    for item in &self.items {
      if smallest &gt; *item {
        smallest = *item;
      }
    }
    smallest
  }
  pub fn sum(&self) -&gt; T {
    let mut sum = T::default();
    for item in &self.items {
      sum = sum + *item;
    }
    sum
  }
  pub fn avg(&self) -&gt; f64 {
    let mut sum = T::default();
    for item in &self.items {
      sum = sum + *item;
    }
    /*-- cast usize to f64 --*/
    let den:f64 = self.items.len() as f64;
    /*-- can't cast non-primitive to primitive --*/
    let num:f64 = sum.into();
    num/den
  }
}          </pre>
          <h4 id="points">Source Code - points_generic.rs</h4>
          <pre class="codeSnap">
/*-------------------------------------------------------------------
  points_generic.rs
  - defines types PointN&lt;T&gt;
-------------------------------------------------------------------*/

use std::default::*;
use std::fmt::*;

use crate::analysis_generic;    // identify source code
use analysis_generic::*;        // import public functions and types

/*---------------------------------------------------------
  - Declare PointN&lt;T&gt; struct, like a C++ template class
  - Request compiler implement traits Debug & Clone
*/
#[derive(Debug, Clone)]
pub struct PointN&lt;T&gt;
where
  T: Debug,
  T: Default,
  T: Clone,
{
  coor: Vec&lt;T&gt;,
}
impl&lt;T&gt; PointN&lt;T&gt;
where
  T: Debug,
  T: Default,
  T: Clone,
{
  /*-- constructor --*/
  pub fn new(n: usize) -&gt; PointN&lt;T&gt; {
    PointN::&lt;T&gt; {
      coor: vec![T::default(); n],
    }
  }
  /*-- moves new coordinate vector into coor --*/
  pub fn init(mut self, coord: Vec&lt;T&gt;) -&gt; PointN&lt;T&gt; {
    self.coor = coord;
    self
  }
  pub fn len(&self) -&gt; usize {
    self.coor.len()
  }
  /*-- acts as both get_coor() and set_coor(some_vector) --*/
  pub fn coors(&mut self) -&gt; &mut Vec&lt;T&gt; {
    &mut self.coor
  }
  /*-- displays name, type, and coordinates --*/
  pub fn show(&self, nm:&str, left: usize, width:usize) {
    println!(&quot;{nm:?}: PointN&lt;T&gt; {{&quot;);
    show_fold(&self.coor, left, width);
    println!(&quot;}}&quot;)
  }
}
          </pre>
          <h4 id="analysis">Source Code - analysis_generic.rs</h4>
          <pre class="codeSnap">
/*-------------------------------------------------------------------
  analysis_generic.rs
  - provides analysis and display functions for generic demo.
-------------------------------------------------------------------*/

use std::fmt::*;

/*---------------------------------------------------------
  Show input's call name and type
  - doesn't consume input
  - show_type is generic function with Debug bound.
    Using format &quot;{:?}&quot; requires Debug.
*/
pub fn show_type&lt;T:Debug&gt;(_t: &T, nm: &str) {
  let typename = std::any::type_name::&lt;T&gt;();
  println!(&quot;call name: {nm:?}, type: {typename:?}&quot;);
}
/*---------------------------------------------------------
  Show enumerable input's values
  - 'a is an annotation saying that T's lifetime
    is as long as the function's lifetime.
  - I is the type of T's elements, that is coll:T&lt;I&gt;.
  - T can be any iterable type and both T and I must
    satisfy Debug trait.
  - Does not consume input t since passed by reference.
*/
pub fn show_value_enum&lt;T:Debug, I:Debug&gt;(
  t: &T, nm: &str, left:usize, width:usize
)
  where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;
{
  println!(&quot;{nm:?} {{&quot;);
  show_fold(t, left, width);
  print!(&quot;}}&quot;);
  println!(&quot;&#92;nsize: {}&quot;, std::mem::size_of::&lt;T&gt;());
}
/*---------------------------------------------------------
  Show facts about a type's elements, e.g., name, type,
  value, and size.
  - show_type is generic function with Debug bound.
    Using format &quot;{:?} requires Debug.&quot;
  - works with small enumerable collections too because
    {:?} knows how to format them, but won't fold long
    sequences of elements. Use show_value_enum for that.
*/
pub fn show_type_scalar&lt;T:Debug&gt;(t: &T, nm: &str) {
  show_type(t, nm);
  println!(
    &quot;value: {t:?}, size: {}&quot;, std::mem::size_of::&lt;T&gt;()
  );
}
/*---------------------------------------------------------
Show facts about an enumerable type's elements, e.g.,
name, type, values, and size.
- show_type is generic function with Debug bound.
  Using format &quot;{:?} requires Debug.&quot;
*/
pub fn show_type_enum&lt;T:Debug, I:Debug&gt;(t: &T, nm: &str, left:usize, width:usize)
  where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;
{
  show_type(t, nm);
  show_value_enum(t, nm, left, width);
}
/*---------------------------------------------------------
  build indent string with &quot;left&quot; spaces
*/
pub fn offset(left: usize) -&gt; String {
  let mut accum = String::new();
  for _i in 0..left {
    accum += &quot; &quot;;
  }
  accum
}
/*---------------------------------------------------------
  find index of last occurance of chr in s
  - returns option in case chr is not found
  https://stackoverflow.com/questions/50101842/how-to-find-the-last-occurrence-of-a-char-in-a-string
*/
fn find_last_utf8(s: &str, chr: char) -&gt; Option&lt;usize&gt; {
/*-- alternate implementation --*/
  // if let Some(rev_pos) =
  //   s.chars().rev().position(|c| c == chr) {
  //     Some(s.chars().count() - rev_pos - 1)
  // } else {
  //     None
  // }
  s.chars().rev().position(|c| c== chr)
    .map(|rev_pos| s.chars().count() - rev_pos - 1)
}
/*---------------------------------------------------------
  fold an enumerable's elements into rows of w elements
  - indent by left spaces
  - does not consume t since passed as reference
  - returns string
  https://users.rust-lang.org/t/generic-code-over-iterators/10907/3
*/
pub fn fold&lt;T, I:Debug&gt;(
  t: &T, left: usize, width: usize
) -&gt; String
    where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;, T:Debug
{
  let mut accum = String::new();
  accum += &offset(left);

  /*-- Alternate direct implementation --*/
  //let mut i = 0usize;
  // for item in t {
  //   accum += &format!(&quot;{item:?}, &quot;);
  //   if ((i + 1) % width) == 0 && i != 0 {
  //       accum += &quot;&#92;n&quot;;
  //       accum += &offset(left);
  //   }
  //   i += 1;
  // }

  for (i, item) in t.into_iter().enumerate() {
    accum += &format!(&quot;{item:?}, &quot;);
    if ((i + 1) % width) == 0 && i != 0 {
        accum += &quot;&#92;n&quot;;
        accum += &offset(left);
    }
  }
  let opt = find_last_utf8(&accum, ',');
  if let Some(index) = opt {
    accum.truncate(index);
  }
  accum
}
/*---------------------------------------------------------
  show enumerables's elements as folded rows
  - width is number of elements in each row
  - left is indent from terminal left
*/
pub fn show_fold&lt;T:Debug, I:Debug&gt;(t:&T, left:usize, width:usize)
  where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;
{
  println!(&quot;{}&quot;,fold(t, left, width));
}
/*---------------------------------------------------------
  show string wrapped with long dotted lines above and below
*/
pub fn show_label(note: &str, n:usize) {
  let mut line = String::new();
  for _i in 0..n {
    line.push('-');
  }
  print!(&quot;&#92;n{line}&#92;n&quot;);
  print!(&quot;  {note}&quot;);
  print!(&quot;&#92;n{line}&#92;n&quot;);
}
pub fn show_label_def(note:&str) {
  show_label(note, 50);
}
/*---------------------------------------------------------
  show string wrapped with dotted lines above and below
*/
pub fn show_note(note: &str) {
  print!(&quot;&#92;n-------------------------&#92;n&quot;);
  print!(&quot; {note}&quot;);
  print!(&quot;&#92;n-------------------------&#92;n&quot;);
}
/*---------------------------------------------------------
  show string wrapped in short lines
*/
pub fn show_op(opt: &str) {
  println!(&quot;--- {opt} ---&quot;);
}
/*---------------------------------------------------------
  print newline
*/
pub fn nl() {
  println!();
}          </pre>
          <h4 id="out">Output</h4>
          <pre class="codeSnap">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_generics
&gt; cargo run
   Compiling rust_hello_objects v0.1.0 (C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_generics)
    Finished dev [unoptimized + debuginfo] target(s) in 0.37s
     Running `target&#92;debug&#92;rust_hello_objects.exe`

--------------------------------------------------
  demonstrate generic functions and types
--------------------------------------------------

----------------------------------------------
  std::library objects, string and vector&lt;T&gt;
----------------------------------------------

--- let mut s1 = &quot;a string&quot;.to_string() ---
--- show_type_scalar(&s1, &quot;&s1&quot;) ---
call name: &quot;&s1&quot;, type: &quot;alloc::string::String&quot;
value: &quot;a string&quot;, size: 24

--- s1.push_str(&quot; and more&quot;); ---
call name: &quot;&s1&quot;, type: &quot;alloc::string::String&quot;
value: &quot;a string and more&quot;, size: 24

--- let mut v:Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1]; ---
call name: &quot;&v&quot;, type: &quot;alloc::vec::Vec&lt;i32&gt;&quot;
value: [1, 2, 3, 2, 1], size: 24

--- v.push(42); ---
call name: &quot;&v&quot;, type: &quot;alloc::vec::Vec&lt;i32&gt;&quot;
value: [1, 2, 3, 2, 1, 42], size: 24

-----------------------------------
  instances of user-defined types
-----------------------------------

s: Stats { items: [1.0, 2.5, -3.5, 4.0, 5.5] }
s.max() = 5.5
s.min() = -3.5
s.sum() = 9.5
s.avg() = 1.9

s: Stats { items: [1, -2, 3, -4, 5] }
s.max() = 5
s.min() = -4
s.sum() = 3
s.avg() = 0.6

&quot;p1&quot;: PointN&lt;T&gt; {
  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
  0.0, 0.0, 0.0
}
--- show_type(p1, &quot;p1&quot;) ---
call name: &quot;p1&quot;, type: &quot;rust_hello_objects::points_generic::PointN&lt;f64&gt;&quot;
--- show_value_enum(p1.coors(), &quot;p1&quot;, 2, 7) ---
&quot;p1.coors()&quot; {
  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
  0.0, 0.0, 0.0
}
size: 24

--- p1.coors()[2] = 3.1415 ---
&quot;p1&quot;: PointN&lt;T&gt; {
  0.0, 0.0, 3.1415, 0.0, 0.0, 0.0, 0.0,
  0.0, 0.0, 0.0
}
--- show_value_enum(p1.coors(), &quot;p1.coors()&quot;, 2, 7) ---
&quot;p1.coors()&quot; {
  0.0, 0.0, 3.1415, 0.0, 0.0, 0.0, 0.0,
  0.0, 0.0, 0.0
}
size: 24

&quot;p2&quot;: PointN&lt;T&gt; {
  0, 1, 2, 3, 4, 4, 3,
  2, 1, 0
}

--- show_type_scalar(p2, &quot;p2&quot;) ---
call name: &quot;p2&quot;, type: &quot;rust_hello_objects::points_generic::PointN&lt;i32&gt;&quot;
value: PointN { coor: [0, 1, 2, 3, 4, 4, 3, 2, 1, 0] }, size: 24
p2.len() = 10

--- p2.show(&quot;p2&quot;, 2, 7) ---
&quot;p2&quot;: PointN&lt;T&gt; {
  0, 1, 2, 3, 4, 4, 3,
  2, 1, 0
}

-----------------------------------
  Testing formats for collections
-----------------------------------

--- show_type_scalar(&v, &quot;&v&quot;) ---
call name: &quot;&v&quot;, type: &quot;alloc::vec::Vec&lt;i32&gt;&quot;
value: [0, -1, 2, -3, 4, -5, 6, -7, 8, -9, 10, -11, 12, -13, 14], size: 24

--- show_fold(&v, 2, 5) ---
  0, -1, 2, -3, 4,
  -5, 6, -7, 8, -9,
  10, -11, 12, -13, 14

--- let v = vec![0i32, ... ]; ---
--- fold(&v, 2, 12) ---
  0, -1, 2, -3, 4, -5, 6, -7, 8, -9, 10, -11,
  12, -13, 14

--- let a = &[f64; 8]; ---
--- show_fold(a, 4, 5) ---
    1.0, 2.5, -3.1, 4.3, 5.0,
    6.0, 7.0, -8.0


  That's all Folks!

C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_generics
&gt;
          </pre>
          <h4 id="build">Build</h4>
          <pre class="codeSnap">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_generics
&gt; cargo build
   Compiling rust_hello_objects v0.1.0 (C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_generics)
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_generics
&gt;
          </pre>
        </div>
        <h3 id="ide">2.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Rust\rust_hello_objects.
        </t-b>
        <photosizer-block src="pictures/RustDebugGeneric.JPG" width="800" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE - Rust Debug Generics</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/LaunchJSON_Rust_Objects.JPG" width="700" class="photoSizerBlock left"
    style="overflow-x:auto;"
  >
    <span style="font-family:'Comic Sans MS';">Figure 2. Rust Launch.JSON</span>
  </photosizer-block>
  <photosizer-block src="pictures/VS_Code_Debugging_Rust_Objects.JPG" width="700" class="photoSizerBlock left"
    style="overflow-x:auto;"
  >
    <span style="font-family:'Comic Sans MS';">Figure 3. Debugging Rust Objects</span>
  </photosizer-block>-->
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
  </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../RustBites/RustBites_Traits.html">RustBite_Generics</a>
            </td>
            <td>
              RustBite on Generics
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../RustStoryRepo.html">Rust Story</a>
            </td>
            <td>
              E-book with seven chapters covering most of intermediate Rust
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../RustBites/RustBites_Intro.html">Rust Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <!-- <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ide">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">bld</a></menu-elem>
        <menu-elem class="secElem"><a href="#out">out</a></menu-elem>
        <menu-elem class="secElem"><a href="#analysis">anal</a></menu-elem>
        <menu-elem class="secElem"><a href="#points">pts</a></menu-elem>
        <menu-elem class="secElem"><a href="#stats">stats</a></menu-elem>
        <menu-elem class="secElem"><a href="#source">src</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">codeSnaps</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections> -->
    </main>
    <!-- <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer> -->
  </page-frame>
  <script>
    var scrollables = document.querySelectorAll('.scrollable');
    for (let scrollable of scrollables) {
      //alert('adding listener');
      scrollable.addEventListener('wheel', function (event) {
        var deltaY = event.deltaY;
        var contentHeight = scrollable.scrollHeight;
        var visibleHeight = scrollable.offsetHeight;
        var scrollTop = scrollable.scrollTop;

        if (scrollTop === 0 && deltaY < 0)
          event.preventDefault();
        else if (visibleHeight + scrollTop === contentHeight && deltaY > 0)
          event.preventDefault();
      });
    }
    // https://stackoverflow.com/questions/7600454/how-to-prevent-page-scrolling-when-scrolling-a-div-element
  </script>
  <script>
    onLoadSplitter("fig1");
    onLoadSplitter("fig2");
    onLoadSplitter("fig3");
    onLoadSplitter("fig4");
    onLoadSplitter("fig5");
  </script>
</body>
</html>