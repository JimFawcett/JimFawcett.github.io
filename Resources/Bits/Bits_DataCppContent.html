<!DOCTYPE html>
<html>
<!--
  Bits_DataCppContent.html
-->
<head>
  <title>Bits_Data C++</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeCpp.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBits.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding:0.75em 1.5em;
      margin-top:1.25em;
      margin-bottom:1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width:50em;
    }
    #github h2 {
      margin-top: 0.75em;
    }
    #github #pagetitle {
      border:2px double var(--dark);
    }
    #github .hide {
      display:none;
    }
    body {
      position:relative;
    }
    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 10px;
    }
    #github .remotebutton {
      padding:0.25em 0.5em;
    }
    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }
    #github hr.spread {
      margin: 0.75em 0em;
    }
    body {
      overflow-y:auto;
    }
    #github pre {
      min-width: 20em;
      max-width: 60em;
      user-select: all;
    }

    #github {
      user-select: none;
    }

    .focus {
      padding: 0.5em 1.0em 0.5em 1.0em;
      /*border:1px solid red;*/
    }

    *.focus ul {
      padding-top: -0.5em;
      /*background-color:green;*/
    }

    .cat {
      text-align: left;
      background-color: var(--menu);
    }

    #github pre {
      overflow-x: auto !important;
    }

    .block {
      border:1px solid var(--dark); 
      overflow: hidden;
      clear:both;
      max-width: 50em;
      margin-right:0.75em;
    }
    .codewrap {
      float: left;
      padding-left: 0.5em;
      padding-right: 0.75em;
    }
    .textwrap {
      padding:0.0em 0.75em 0.5em 0.5em;
      padding-left:0.5em;
      padding-right: 0.75em;
    } 
    table {
      margin-right:0.75em;
    }
  </style>
  <script>
    function setScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = main.scrollTop;
      localStorage.setItem('scrollPositionHelloRust', scrollPosition);
      let scroller = document.getElementById("scrollY")
      scroller.innerHTML = Math.trunc(scrollPosition);
    }
    function gotoLastScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = localStorage.getItem('scrollPositionHelloRust');
      if (scrollPosition) {
        main.scrollTo(0, scrollPosition);
      }
      main.addEventListener('scroll', setScroll);
    }
    function load() {
      //initialize();
      gotoLastScroll();
    }
  </script>

  <script>
    function remote() {
      window.open('https://godbolt.org/z/nvfbzMo9s', '_blank');
    }
  </script>
</head>
<!--<body id="github" onload="initialize()" onbeforeunload="saveScroll()">-->
<body id="github" onload="load()">

  <a id="Next" href="Bits_ObjectsCpp.html">Next</a>
  <a id="Prev" href="Bits_HelloCpp.html">Prev</a>

  <page-frame>
    <!--<frame-header>
      <nav id="navbar"></nav>
    </frame-header>-->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits Data C++</div>
      <div id="modified">09/28/2023</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content id="content">
       <!--  <div class="rightPanelLinks">
          <a target="_parent" class="darkItem" href="Bits_DataCpp.html">C++</a>
          <a target="_parent" href="Bits_DataRust.html">Rust</a>
          <a target="_parent" href="Bits_DataCSharp.html">C#</a>
          <a target="_parent" href="Bits_DataPython.html">Python</a>
          <a target="_parent" href="Bits_DataJs.html">JvScrpt</a>
        </div> -->
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.50em; width:max-content; height:1.5em;
           text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits: C++ Data</h1>
            <h3 id="subtitle" class="indent">
              types, initialization, construction, assignment
            </h3>
          </hgroup>
        </header>
        <t-b id="syn" style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          Most of a language&apos;s syntax and semantics derives directly from its type
          system design. This is true of all of the languages discussed in these Bits:
          C++, Rust, C#, Python, and JavaScript.
          <div style=height:0.5em;></div>
          C++ has a complex type system, followed in order by C#, Rust, JavaScript, and Python.
          We will spend more time with this Bit than with all of the others because of its
          complexities and importance.
          <div style=height:0.5em;></div>
          This page demonstrates simple uses of the most important C++ types.
          The purpose is to quickly acquire some familiarity with types and their uses.
          <hr class="spread" />
          <ul>
            <li>
              Primitive types and aggregates of primitive types are copyable.  Assignment and
              pass-by-value copies the source&apos;s value to the destination.
            </li>
            <li>
              For user-defined types
              C++ provides special class methods - constructors, operators, and destructors.
              When properly implemented they provide instance syntax that mimics that of primitives.
              We won&apos;t see that here, but will in the next <a target="_blank" href="Bits_ObjectsCpp.html">Bit page</a>.
            </li>
            <li>
              C++ supports move operations with move constructor and move assignment operator.
              temporaries are moved when assigned or passed-by-value to the destination
              using the resources of the move source.  This is a transfer of ownership and
              makes the source invalid. Attempting to use a &quot;moved&quot; variable is,
              unfortunately, not a compile error.
            </li>
            <li>
              C++ supports making fixed references to either primitive or user-defined types. These may
              refer to instances in stack memory, static memory, or in the native heap.
            </li>
            <li>
              C++ pointers and references are un-constrained and a frequent source of memory management
              errors. By convention these can be avoided by using range-based for loops and smart pointers.
              For very large code bases it can be challenging to insure that the conventions have been
              followed everywhere - think of projects with 100,000 source lines or more.
            </li>
            <li>
              Here we begin to see significant differences between the languages, especially
              when comparing statically typed languages like C++, Rust, and C#, with dynamically typed
              languages like Python and JavaScript.
            </li>
          </ul>
          <div style="height:0.25em;"></div>
        </t-b>
        <div style="height:0.75em;"></div>
        <details id="types">
          <summary class="darkItem">C++&nbsp;Types&nbsp;Details&nbsp;</summary>
          <h3>Table 1.0 C++ Types</h3>
          <table style="font-size: 0.9em; max-width: 71em;">
            <tr>
              <th style="width:15em;">Type</th>
              <th>Comments</th>
              <th>Example</th>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Integral types ----</th>
            </tr>
            <tr>
              <td><c-s>bool</c-s></td>
              <td>values true and false</td>
              <td><c-s>bool b = true;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>int<br />with signed, unsigned, short, long qualifiers</c-s>
              </td>
              <td>1 == sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)</td>
              <td><c-s>short int i = 42;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>size_t</c-s>
              </td>
              <td><c-s>2 ≤ sizeof(size_t)</c-s>,<br /><c-s>size_t</c-s> is used for indexing</td>
              <td><c-s>size_t i = 0;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>char<br />with signed and unsigned qualifiers</c-s>
              </td>
              <td>signedness of <c-s>char</c-s> depends on platform</td>
              <td><c-s>char c = 'a';</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>wchar_t, char16_t, char32_t</c-s>
              </td>
              <td>
                wchar_t is 16 bits and holds UTF-16 code units on Windows,
                32 bits and holds UTF-32 on Linux
              </td>
              <td><c-s>wchar_t c = L'\U263A';</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Floating point types ----</th>
            </tr>
            <tr>
              <td><c-s>float, double, long double</c-s></td>
              <td>values have finite precision, and may have approximate values</td>
              <td><c-s>double d = 3.14159;</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- literal string types --</th>
            </tr>
            <tr>
              <td><c-s>const&nbsp;char[], const&nbsp;wchar_t[]</c-s></td>
              <td>
                literal string, resides in static memory and is always null terminated.
                "Hello" is a const char[6] containing the chars: 'H', 'e', 'l', 'l', 'o', '\0'.
              </td>
              <td>
                <c-s>char* lst = "a literal string"</c-s>
              </td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Aggregate types ----</th>
            </tr>
            <tr>
              <td><c-s>T[N]</c-s></td>
              <td>Native array of N elements all of type <c-s>T</c-s></td>
              <td>
                <c-s>int arr[] = [1, 2, 3, 2, 1];<br />let first = arr[0];</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::tuple&lt;T1, T2, ...&gt;</c-s></td>
              <td>collection of heterogeneous types accessed by position</td>
              <td>
                <c-s>
                  std::tuple&lt;int, float, char&gt; tu&nbsp;=&nbsp;(42,&nbsp;3.14159,&nbsp;'z');<br />char third = get&lt;2&gt;(tu);
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::optional&lt;T&gt;</c-s></td>
              <td>std::optional holds optional value <c-s>t&epsi;T</c-s> or <c-s>std::nullopt</c-s></td>
              <td><c-s>fn doOp(..args) -> Optional&lt;T&gt;</c-s></td>
            </tr>
            <tr><th colspan="3" class="cat">-- Std::library types ----</th></tr>
            <tr>
              <td><c-s>std::string</c-s></td>
              <td>Expandable collection of ASCII characters allocated in the heap</td>
              <td><c-s>std::string strg = "a string";</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::wstring</c-s></td>
              <td>Expandable collection of Unicode characters allocated in the heap</td>
              <td><c-s>std::wstring strg = L"a wstring";</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::array&lt;T, N&gt;</c-s></td>
              <td>Fixed size generic array of items of type <c-s>T</c-s></td>
              <td><c-s>std::array&lt;int,3&gt; v { 1, 2, 3 };</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::vector&lt;T&gt;</c-s></td>
              <td>Expandable generic collection of items of type <c-s>T</c-s></td>
              <td><c-s>std::vector&lt;double&gt;&nbsp;v&nbsp;{&nbsp;1.0,&nbsp;1.5,&nbsp;2.0 }; v.push(2.5);</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::deque&lt;T&gt;</c-s></td>
              <td>
                Expandable double-ended generic collection of items of type <c-s>T</c-s>.
                Uses circular buffer internally.
              </td>
              <td>
                <c-s>
                  std::deque&lt;int&gt; vd { 1, 2, 3 }<br />
                  v.push_front(-1); ...
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::unordered_map&lt;K,V&gt;</c-s></td>
              <td>Unordered associative container of Key-Value pairs, held in a table of bucket lists.</td>
              <td>
                <c-s>
                  std::unordered_map&lt;std::string, int&gt; m {&nbsp;{"one",1},&nbsp;{"two",2}&nbsp;}<br />
                  map.insert("zero", 0); ...
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::map&lt;K,V&gt;</c-s></td>
              <td>Ordered associative container of Key-Value pairs, held in binary tree.</td>
              <td>
                <c-s>
                  std::map&lt;std::string, int&gt; m {&nbsp;{"one",1},&nbsp;{"two",2}&nbsp;}<br />
                  map.insert("zero", 0); ...
                </c-s>
              </td>
            </tr>
            <tr>
              <td>
                forward_list, list, unordered_map, unordered_set, unordered_multimap, unordered_multiset,
                set, multiset, and several adapters like stack and queue
              </td>
              <td>
                The C++ std::library also defines types for threading and synchronization,
                reading and writing to streams, anonymous functions, and many more.
              </td>
              <td><a href="https://en.cppreference.com/w/cpp/container">Containers library</a></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- User-defined Types --</th>
            </tr>
            <tr>
              <td>User-defined types</td>
              <td colspan="2">
                Based on classes and structs, these will be discussed in the <a href="Bits_ObjectsCpp.html">next Bit</a>.

              </td>
            </tr>
          </table>
          <div style="height:0.5em;"></div>
        </details>
        <div style="height:0.25em;"></div>
        <details id="typesys">
          <summary class="darkItem">C++&nbsp;Type&nbsp;System&nbsp;Details&nbsp;</summary>
          <h3>Table 2. C++ Copy and Move Operations</h3>
          <table style="font-size:0.9em; max-width:65em;">
            <colgroup>
              <col span="1" style="width:12%;" />
              <col span="1" style="width:16%;" />
              <col span="1" style="width:36%;" />
              <col span="1" style="width:36%;" />
            </colgroup>
            <tr>
              <th>Operation</th>
              <th>Example</th>
              <th>Primitive or Aggregate of Primitives</th>
              <th>Library or User-defined Type</th>
            </tr>
            <tr style="background-color:var(--menu);">
              <th colspan="4">If u&epsilon;T is a named variable</th>
            </tr>
            <tr>
              <td>Construction</td>
              <td><c-s>T t = u; u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>T</c-s>&apos;s copy constructor copies <c-s>u</c-s></td>
            </tr>
            <tr>
              <td>Assignment</td>
              <td><c-s>t = u, t&epsilon;T, u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>T</c-s>&apos;s assignment operator copies value of <c-s>u</c-s></td>
            </tr>
            <tr>
              <td>Pass-by-value</td>
              <td><c-s>fn doOp(T t)</c-s></td>
              <td><c-s>t</c-s>&apos;s value is mem-copy&apos;ed to doOp stack frame</td>
              <td><c-s>t</c-s>&apos;s value is copied to doOp stack frame,<br />using <c-s>T</c-s>&apos;s copy constructor</td>
            </tr>
            <tr style="background-color:var(--menu);">
              <th colspan="4">If u&epsilon;T is a temporary or u = std::move(v), v&epsilon;T</th>
            </tr>
            <tr>
              <td>Construction</td>
              <td><c-s>T t = u; u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>u</c-s>&apos;s value is moved to <c-s>t</c-s> using <c-s>T</c-s>&apos;s move constructor<br /><c-s>u</c-s>&apos;s value becomes undefined</td>
            </tr>
            <tr>
              <td>Assignment</td>
              <td><c-s>t = u, t&epsilon;T, u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>u</c-s>&apos;s value is moved to <c-s>t</c-s> using <c-s>T</c-s>&apos;s move assignment operator<br /><c-s>u</c-s>&apos;s value becomes undefined</td>
            </tr>
            <tr>
              <td>Pass-by-value</td>
              <td><c-s>fn doOp(T t)</c-s></td>
              <td><c-s>t</c-s>&apos;s value is mem-copy&apos;ed to doOp stack frame</td>
              <td><c-s>T</c-s>&apos;s move constructor copies <c-s>t</c-s> to doOp stack frame<br /><c-s>t</c-s>&apos;s value becomes undefined</td>
            </tr>
          </table>
          <t-b>
            <h3>Table 3. C++ Type System Attributes</h3>
          </t-b>
          <table style="font-size:0.9em; max-width:65em;">
            <tr>
              <td>Static&nbsp;typing</td>
              <td>
                All types are known at compile time and are fixed throughout program execution.
              </td>
            </tr>
            <tr>
              <td>Inference</td>
              <td>
                Compiler infers types in expressions if not explicitly annotated or if declared <c-s>auto</c-s>.
                Occasionally inference fails and explicit annotation is required.
              </td>
            </tr>
            <tr>
              <td>Intermediate&nbsp;strength typing</td>
              <td>
                Types are exhaustively checked but there are many implicit conversions.
                <ul class="tight">
                  <li>Numeric and boolean literals coerce to their correspoinding type, e.g., 42 to int.</li>
                  <li>Variables with auto type declarations are coerced to the type of their RHS&apos;s</li>
                  <li>Values can be coerced using user-defined conversion constructors.</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Generics</td>
              <td>
                Generics provide types and functions with unspecified parameters,
                supporting code reuse and abstraction
                over types. Generic parameters are specified at the call site, e.g., <c-s>doOp&lt;T, U&gt;(T t, U u)</c-s>
                The function <c-s>doOp</c-s> is checked for syntax before instantiating with specific type(s). Any
                use of <c-s>t</c-s> or <c-s>u</c-s> in the <c-s>doOp</c-s> body are not checked until the types
                of <c-s>t</c-s> and <c-s>u</c-s> are known.
                <div style="height:0.75em;"></div>
                Unlike all the other languages examined in these Bits, C++ generics use an internal meta language
                at compile time to implement generic facilities. That can be used to move some processing from
                run-time to compile-time using &quot;template metaprogramming&quot;.
              </td>
            </tr>
            <tr>
              <td>Class Relationships</td>
              <td>
                Class relationships are important tools for modeling both application and implementation
                domains.
                <ol>
                  <li>
                    Inheritance:
                    <t-b style="margin:0.25em 0.5em;">
                      A design process that uses a base type as part of a more specialized derived type,
                      automatically exposing public members of the base as public members of the derived.
                      An instance of the base type becomes part of the memory footprint of instances of
                      the derived type.
                    </t-b>
                    <t-b style="margin:0.5em 0.5em;">
                      Some languages allow use of base implementation as part of the derived implementation,
                      some languages allow only declarations of base members to be declarations of the derived.
                    </t-b>
                    <t-b style="margin:0.5em 0.5em;">
                      C++ supports multiple inheritance of base implementations and interface<sup>1</sup> 
                      declarations.
                    </t-b>
                  </li>
                  <li>
                    Composition:
                    <t-b style="margin:0.25em 0.5em;">
                      A design process that uses an instance of a composed child type as a member of the
                      composing type.
                    </t-b>
                    <t-b style="margin:0.5em 0.5em;">
                      Composition results in the child instance embedded in the memory footprint of the
                      composer. Construction, assignment, and pass-by-value
                      result in two independent instances, e.g., the source and destination<sup>1</sup>.
                    </t-b>
                    <t-b style="margin:0.5em 0.5em;">
                      C++ types can compose instances of arbitrary types.
                    </t-b>
                  </li>
                  <li>
                    Aggregation:
                    <t-b style="margin:0.25em 0.5em;">
                      A design process that uses a pointer or managed handle referring to an 
                      aggregated type as a member of the aggregator.
                    </t-b>
                    <t-b style="margin:0.5em 0.5em;">
                      Aggregation results in a child instance placed in a native or managed heap<sup>2</sup> at a location
                      distinct from its aggregator type and referred to with a handle. Construction, assignment,
                      and pass-by-value result in two references to the one source instance.
                    </t-b>
                    <t-b style="margin:0.5em 0.5em;">
                      C++ can use composition and aggregation with any type.
                    </t-b>
                  </li>
                </ol>
                <hr />
                <ol>
                  <li>
                    C++ does not have a unique interface type category.  It uses classes with no member data
                    and all public virtual method declarations for specifying interfaces.
                  </li>
                </ol>
              </td>
            </tr>
            <tr>
              <td>Concepts</td>
              <td>
                Concepts are similar to Rust traits and Java and C# interfaces.
                They define shared behavior that types can
                implement, supporting abstraction over behavior. Concepts define behavior by declaring concept
                specific functions. A template type can use a Requires clause with concept arguments to bound
                types that are valid for a class or function.
              </td>
            </tr>
          </table>
        </details>
        <div style="height:0.5em;"></div>

        <h3 id="init">1.0 Initialization</h3>
        <t-b>
          Several of the code blocks shown below have formatting and output code elided.  You can find
          complete code in the <a target="_blank" href="https://github.com/JimFawcett/Bits">Bits Repository</a>:&nbsp;&nbsp;
          <a target="_blank" href="https://github.com/JimFawcett/Bits/blob/master/Cpp/Cpp_Data/src/Bits_Data.cpp">Bits_Data.cpp</a>,
          <a target="_blank" href="https://github.com/JimFawcett/Bits/blob/master/Cpp/Cpp_Data/src/Bits_DataAnalysis.h">Bits_DataAnalysis.h</a>,
        </t-b>
        <h3 id="prim">1.1 Primitives</h3>
        <t-b>
          Initialization is the process of endowing a newly created type instance with a specified value.
          Uninitialized local instances have undefined values. Uninitialized variables at global
          scope are compiler-initialized to zero.
        </t-b>
        <t-b>
          To insure well defined behavior initialize all varibles where they are declared, as shown below.
        </t-b>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-cpp">  /*----------------------------------------------  
    All code used for output has been elided
  */
  /*-- scalars --*/
  bool b = true;
  std::byte byte { 0x0f };
    /*  std::byte =&gt; unsigned char {} */
  int i = 42;  // equiv to int i { 42 };
  double d = 3.1415927;
  char ch = 'z';
  const char* lst = &quot;a literal string&quot;;

</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              Instances of primitive types each occupy one block of contiguous memory.
            </t-b>
            <t-b>
              Scalars can be initialized by either assigning a value or with a braced initializer.
            </t-b>
            <t-b>
              The int type can be qualified with keywords short, long, and long long. Type double
              can be qualified with long. A&nbsp;complete list of types and their qualifiers are given in
              the &quot;C++ Types Details&quot; dropdown list, above.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre><code class="language-cpp">  --- bool ---
  b: true
  b: type: bool
  b: size = 1
  --- byte ---
  byte: 0xf
  byte: type: enum std::byte
  byte: size = 1
  --- int ---
  i: 42
  i: type: int
  i: size = 4
  --- double ---
  d: 3.141593
  d: type: double
  d: size = 8
  --- char ---
  ch: z
  ch: type: char
  ch: size = 1
  --- const char* ---
  lst: "a literal string"
  lst: type: char const * __ptr64  
  lst: size = 8
  lst: char count = 16

</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                Each type in the code block on the left is characterized by its value,
                type evaluated from the core C++ function <c-s>typeid(t).name()</c-s>,
                and size retrieved from the core C++ function <c-s>sizeof(t)</c-s>.
              </t-b>
              <t-b>
                <c-s>sizeof(t)</c-s> returns the number of bytes allocated by the compiler for
                the value&nbsp;of&nbsp;t.
              </t-b>
              <t-b>
                Note that the literal string, lst, at the bottom, is accessed from a pointer,
                which, for a 64 bit computer, is 8 bytes, not the count of characters.
              </t-b>
              <t-b>
                The actual length of lst is 17 bytes, because <c-s>strlen(lst)</c-s> ignores the
                trailing null terminator which all C++ strings have.
              </t-b>
            </div>
          </div>
        </details>
        <h3 id="aggr">1.2 Aggregates</h3>
        <t-b>
          Aggregate types each occupy one block of contiguous memory if and only if
          all their items are primitives. In that case they are copied byte-by-byte
          with std::memcopy.
          If they have any non-primitive items then they are copied with the type&apos;s
          Copy construction and copy assignment operators.
        </t-b>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-cpp">  /*---------------------------------------------------
    All code used for output has been elided
  */
  /*-- array --*/
  short int fa[] { 1, 2, 3, 4, 5 };
  short int fa_alt[5] { 1, 2, 3, 4, 5 };
  auto afirst = fa[0];

  /*-- struct --*/
  struct S { int a; char b; double c; };
  S strct { 1, 'a', 3.1415927 };
  auto sfirst = strct.a;

  /*-- tuple --*/
  std::tuple&lt;int, double, char&gt; tup { 1, 3.14, 'z' };
  auto tfirst = get<0>(tup);

  /*-- optional --*/
  std::optional&lt;double&gt; opt1 { 3.1415927 };
  std::optional&lt;double&gt; opt2; // { std::nullopt };
  if(opt2 == std::nullopt) {
    std::cout &lt;&lt; &quot;empty&#92;n&quot;;
  }
  else {
    std::cout &lt;&lt; *opt2 &lt;&lt; &quot;&#92;n&quot;;
  }
</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              All the aggregate types: array, struct, tuple, and optional, use a braced
              initializer list.
            </t-b>
            <t-b>
              <c-s>std::tuple</c-s> and <c-s>std::optional</c-s> are generic types defined in the
              std::library, not by the core C++ language.
              We discuss generic types in <a target="_blank" href="Bits_GenericCpp.html#top">Bits_GenericCpp</a>.
            </t-b>
            <t-b>
              All the aggregates occupy contiguous blocks of memory if and only if all their elements
              are primitive. Those are copied with a bit-wise copy supplied by <cos>std::memcopy</cos>.
            </t-b>
            <t-b>
              If any of their elements are non-primitive, e.g., a std::string element, the element is copied
              by its copy constructor or copy assignment operator.
            </t-b>
            <t-b>
              The <c-s>struct</c-s> and <c-s>tuple</c-s> types are similar in that they each contain a list
              of elements of heterogeneous types. Struct elements are retrieved by name while tuple elements
              are retrieved by position.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre><code class="language-cpp">  --- aggregate types ---

  --- native array ---
  fa[]: [ 1, 2, 3, 4, 5 ]
  fa[]: type: short const * __ptr64
  fa[]: size = 10
  afirst = 1
  --- struct ---
  strct: S { 42, a, 3.14159 }
  strct: type: struct `void __cdecl initialize_primitiv...
  strct: size = 16
  sizeof(strct.a) = 4
  sizeof(strct.b) = 1
  sizeof(strct.c) = 8
  sfirst = 42
  --- tuple ---
  tup: { -1, 3.14, z }
  tup: type: class std::tuple<int,double,char>
  tup: size = 24
  tfirst = -1
  --- optional ---
  opt1: 3.14159
  opt2: empty
  opt1: type: class std::optional<double>
  opt1: size = 16

</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                The variable fa is the name of a fixed size array of short interger elements stored in
                a contiguous block of memory, usually in the program&apos;s stack.
                When passed to functions its type decays to a pointer to the caller&apos;s array.
                That avoids potentially large copy operations.
              </t-b>
              <t-b>
                strct is a structure holding an integer, character, and double. The memory layout pads
                the character strct.b to 4 bytes so all the elements begin on word boundaries,
                improving read and write times.
              </t-b>
              <t-b>
                tup is a tuple with integer, double, and character elements respectively.  The memory layout
                adds padding to the last character element to improve performance.
              </t-b>
              <t-b>
                The std::optional&lt;T&gt; type represents a value that may or may not exist.  Commonly used
                to return values from a search function that may not find a match.
              </t-b>
            </div>
          </div>
        </details>
        <h3 id="initstdlib">1.3 Std::library Types</h3>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-cpp">  /*-- initialize std::library types --*/

  /*------------------------------------------------- 
    All code for output has been elided
  */
  /*-- generic array --*/
  std::array&lt;double, 7&gt;
  sarr { 1.0, 1.5, 2.0, 2.5, 2.0, 1.5, 1.0 };
  double afirst = sarr[0];

  /*-- expandable string --*/
  std::string sstr = &quot;a string&quot;;
  double sfirst = sstr[0];

  /*-- expandable indexable array --*/
  std::vector&lt;int&gt; vec { 1, 2, 3, 4 };
  vec.push_back(5);
  int vthird = vec[2];

  /*-- expandable double-ended queue --*/
  std::deque&lt;int&gt; dq { 1, 2, 3 };
  dq.push_front(0);
  dq.push_back(4);
  int qfirst = dq.front();

  /*-- expandable associative container --*/
  std::unordered_map&lt;std::string, int&gt; umap
  {{&quot;one&quot;, 1}, {&quot;two&quot;, 2}, {&quot;three&quot;, 3}};
  umap.insert({&quot;zero&quot;, 0});
  int uZero = umap["zero"];

</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              Of the many std::library types, we look here at a few of the collection
              types. Collections have a finite number of items, all of the same type.
            </t-b>
            <t-b>
              This code block illustrates how to initialize a collection and how to
              access its members.
            </t-b>
            <t-b>
              Collections all have copy contructors, copy assignment operators, and corresponding
              move construction and assignment operations.
            </t-b>
            <t-b>
              The next <a target="_blank" href="Bits_ObjectsCpp.html">Bits_ObjectsCpp</a> discusses
              user-defined types.  Definition of construction and assignment operations will be
              illustrated there.
            </t-b>
            <t-b>
              The <c-s>std::string</c-s>, <c-s>std::vector&lt;T&gt;</c-s>, and
              <c-s>std::unordered_map&lt;K,&nbsp;V&gt;</c-s> are the most frequently used
              of the collection types.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre><code class="language-cpp">  --- std::array&lt;double, 7> ---
  sarr:   [ 1.00, 1.50, 2.00, 2.50, 2.00, 1.50, 1.00 ]
  sarr:   type: class std::array&lt;double,7>
      
  --- std::string => std::basic_string&lt;char> ---
  sstr:   "a string"
  sstr:   type: class std::basic_string&lt;char,struct std:...

  --- std::vector&lt;int> ---
  vec:    [ 1, 2, 3, 4, 5 ]
  vec:    type: class std::vector&lt;int,class std::allocat...
  
  --- std::deque&lt;int> ---
  dq:     [ 0, 1, 2, 3, 4 ]
  dq:     type: class std::deque&lt;int,class std::allocato...
  
  --- std::unordered_map&lt;std::string, int> ---
  umap:   { {one, 1}, {two, 2}, {zero, 0}, {three, 3} }
  umap:   type: class std::unordered_map&lt;class std::basi...

</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                <c-s>std::array&lt;T, N&gt</c-s>; is similar to C++&apos;s native array <c-s>T[N]</c-s>, but
                also provides methods like <c-s>size_t size()</c-s>, <c-s>constexpr&nbsp;T&&nbsp;front()</c-s> and
                <c-s>constexpr&nbsp;T&&nbsp;back()</c-s>.  Both are stored in contiguous memory in the program&apos;
                stack.
              </t-b>
              <t-b>
                The <c-s>std::string</c-s>, <c-s>std::vector&lt;T&gt;</c-s>, <c-s>std::deque&lt;T&gt;</c-s>
                and <c-s>std::unordered_map&lt;K, V&gt;</c-s> all have control blocks stored in stack memory
                and data elements stored in the heap.  That is done so that their capacities are expandable and
                can be as large as available memory.
              </t-b>
              <t-b>
                Insertions into vector, string, and deque are linear time, while insertions into an unordered_map
                are nearly constant time.  A map insertion takes constant time to compute a table address and
                linear time to walk short bucket lists.
              </t-b>
              <t-b>
                All but the fixed-size array are subject to memory reallocations when an insertion is attempted
                when their data memory is full.  That includes the map which may have to reallocate its table
                to avoid long bucket lists.
              </t-b>
            </div>
          </div>
        </details>
        <h3 id="initheap">1.4 Heap Storage</h3>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-cpp">  /*-- initialized in heap memory --*/

  /*--------------------------------------------------
    All code for output has been elided
  */
  /*-- raw pointer --*/
  int* tmol = new int{42};
  // using code here
  delete tmol;  // forgetting this causes memory leak

  /*-- unique_ptr to scalar --*/
  std::unique_ptr&lt;int&gt; suni = 
    std::make_unique&lt;int&gt;(-1);
  int utmp = *suni;
  // std::unique_ptr deallocates heap storage when
  // it goes out of scope, so no memory leak.

  /*-- shared_ptr to scalar --*/
  std::shared_ptr&lt;int&gt; stmol 
    = std::make_shared&lt;int&gt;(42);
  int stmp = *stmol;
  // std::shared_ptr deallocates heap storage when
  // all references go out of scope, so no memory leak.

  /*-- shared_ptr to collection --*/
  std::shared_ptr&lt;std::vector&lt;int&gt;&gt; pVec =
    make_shared&lt;std::vector&lt;int&gt;&gt;(
      std::vector&lt;int&gt;{ 1, 2, 3 }
  );
  auto vtmp = *pVec;
  // only difference from scalar case is initialization

  /*-- using aliases to simplify --*/
  using VecI = std::vector&lt;int&gt;;
  using SPtr = std::shared_ptr&lt;VecI&gt;;
  SPtr pVec2 = make_shared&lt;VecI&gt;(VecI{ 1, 2, 3 });
  // equivalent to pVec, just abbreviates syntax

</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              Heap memory is used for on-demand allocation at run-time, most often for std::library
              and user-define collection types. Memory is
              allocated with the <c-s>new</c-s> operator and deallocted with <c-s>delete</c-s>;
            </t-b>
            <t-b>
              Modern C++ by convention replaces use of raw pointer for allocation and deallocation with the
              smart pointer <c-s>std::unique_ptr&lt;T&gt;</c-s>, its creational function
              <c-s>std::make_unique&lt;T&gt;(T t)</c-s>, or <c-s>std::shared_ptr&lt;T&gt;</c-s>, and its
              creational function <c-s>std::make_unique&lt;T&gt;(T t)</c-s>.
            </t-b>
            <t-b>
              The creational functions internally use the new operator to create an instance of the input
              type on the heap.
              Both call delete on their
              member pointers when they go out of scope.
            </t-b>
            <t-b>
              That eliminates one source of memory leaks, but depends on convention to advocate for its use.
            </t-b>
            <t-b>
              Syntax for the standard pointers and their creational functions is rather
              verbose.  That can be simplified by using alias declarations that provide
              shorter, but equivalent, syntax.
            </t-b>
            <t-b>
              Note that all of these declarations use literals or temporaries to initialize heap memory storage.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre><code class="language-cpp">  --- initialized in heap memory ---

  --- raw pointer ---
  *tmol: 42
  *tmol: type: int
  *tmol: size = 4
  tmol: 0000016E4A956D80
  tmol: type: int * __ptr64
  tmol: size = 8

  --- std::unique_ptr&lt;int&gt; ---
  *suni: -1
  *suni: type: int
  *suni: size = 4
  suni: 000001D7CFCE6300
  suni: type: class std::unique_ptr&lt;int,struct std::de...
  suni: size=8

  --- std::shared_ptr&lt;int&gt; ---
  *stmol: 42
  *stmol: type: int
  *stmol: size=4
  stmol: 0000016E4A967420
  stmol: type: class std::shared_ptr&lt;int&gt;
  stmol: size=16

  --- std::shared_ptr&lt;std::vector&lt;int&gt;&gt; ---
  *pVec: [ 1, 2, 3 ]
  *pVec: type: class std::vector&lt;int,class std::allocat...
  *pVec: size=32
  pVec: 0000016E4A968260
  pVec: type: class std::shared_ptr&lt;class std::vector&lt;...
  pVec: size=16

  --- using aliases to simplify ---
  *pVec2: [ 1, 2, 3 ]
  *pVec2: type: class std::vector&lt;int,class std::allocat...
  pVec2: 0000016E4A968880
  pVec2: type: class std::shared_ptr&lt;class std::vector&lt;...

</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                Smart pointers <c-s>std::unique_ptr&lt;T&gt;</c-s> and
                <c-s>std::shared_ptr&lt;T&gt;</c-s> are dereferenced using
                the same syntax as raw pointers.
              </t-b>
              <t-b>
                Note that the size of the raw pointer is 8 bytes and the size of
                the unique pointer is also 8 bytes.
              </t-b>
              <t-b>
                The shared pointer keeps both
                a pointer to the heap storage and a reference count, so its size is 16 bytes.
              </t-b>
              <t-b>
                There is very little size and performance penalty for using these
                smart pointers.
              </t-b>
            </div>
          </div>
        </details>
        <h3 id="copy">2.0 Copy Operations</h3>
        <t-b>
          C++ copy operations occur during construction, assignment, and pass-by-value.
          Primitive types and aggregates of primitive types occupy a contiguous block of memory and
          are copied bit-wise with <c-s>std::memcopy</c-s>.
          Non-primitives like all of the std::library collections have a control block in stack memory
          and values in heap memory.  They are copied with copy constructor and copy assignment
          operator.
        </t-b>
        <h3 id="copyprim">2.1 Copy Operations for Primitives</h3>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-cpp">  /*-- copy operations for primitives --*/

  /*-------------------------------------------------------
    All code for output has been elided
  */
  /*-- primitive copy construction - bit-wise copy --*/
  int ival = 42;      // initialization
  int jval = ival;    // here&apos;s the copy construction

  /*-- copy assignment, output elided --*/
  double dval = 3.1415927;  // create dst instance
  double eval = 1.33333;    // create src instance
  dval = eval;              // copy assignment operation

</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              Copy operations for primitive types are very simple - just copy bytes from
              source to destination.
            </t-b>
            <t-b>
              There are no side-effects and no context dependencies.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre><code class="language-cpp">  ------------------------------------------
    copy operations for primitives
  --------------------------------------------------

  --- copy construction ---
  ival:   42
  ival:   type: int
  ival:   address: 0000002E4DEFDAF4
  --- int jval = ival ---
  jval:   42
  jval:   type: int
  jval:   address: 0000002E4DEFDC04
  ---------------------------------------------
    Addresses of ival and jval are different,
    demonstrating copy, as expected.
  ---------------------------------------------

  --- copy assignment ---
  dval:   3.141593
  dval:   type: double
  dval:   address: 0000002E4DEFDD18
  eval:   1.333330
  eval:   type: double
  eval:   address: 0000002E4DEFDDD8
  --- dval = eval ---
  dval:   1.333330
  dval:   type: double
  dval:   address: 0000002E4DEFDD18
  ---------------------------------------------
    Addresses of dval and eval are different
    demonstrating copy.
  ---------------------------------------------

</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                Copy construction copies source values to a newly allocated memory location.
              </t-b>
              <t-b>
                Comparing addresses, it is clear that the value of ival was copied to
                the location of newly created jval.
              </t-b>
              <t-b>
                Assignment copies values from one existing memory location to another
                already existing location, e.g., same as copy construction except no
                new allocation.
              </t-b>
              <t-b>
                In this code, eval is created to be the source of an assignment to dval.
                The addresses demonstrate that assignment results in a copy.
              </t-b>
              <t-b>
                This demonstration of the near-obvious sets up the basis for more complex
                construction and assignment operations for std::library types.
              </t-b>
            </div>
          </div>
        </details>
        <h3 id="copystdlib">2.2 Copy Operations for Std::library Types</h3>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-cpp">  /*-- copy operations for std::library types --*/

  /*-------------------------------------------------------
    All code for output has been elided
  */
  /*-- vector copy construction --*/
  std::vector&lt;double&gt; vec { 1.0, 1.5, 2.0 };
  auto uec = vec;  // copy construction

  /*-- vector copy assignment --*/
  std::vector&lt;double&gt; tec { 1.0, 1.5, 2.0, 2.5 };
  uec = tec;       // copy assignment

</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              For std::library and user-defined types copy construction is defined as part of the
              type&apos;s class definition.
            </t-b>
            <t-b>
              The <c-s>std::vector&lt;double&gt;</c-s> uec is created with the copy constructor defined in the
              <c-s>std::vector&lt;T&gt;</c-s> class.
            </t-b>
            <t-b>
              The second example illustrates copy assignment in which <c-s>std::vector&lt;double&gt;</c-s>
              uec is assigned the value of tec, using the copy assignment operator of the vector class.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre><code class="language-cpp">  --------------------------------------------------  
    copy operations for std::library types
  --------------------------------------------------

  --- vector copy construction ---
  vec:    [ 1.00, 1.50, 2.00 ]
  vec:    address: 0000002E4DEFDFF8
  vec[0]: address: 0000016E4A967950
  --- auto uec = vec ---
  uec:    [ 1.00, 1.50, 2.00 ]
  uec:    address: 0000002E4DEFE198
  uec[0]: address: 0000016E4A967A10
  --------------------------------------------------
  Note:
  Both uec and vec and their resources are unique.
  That's because the vector copy constructor
  copies each element of vec to uec.

  Managed languages copy handles to instances,
  not the instances themselves, so construction
  does not create a new instance in those
  languages.  Resources are shared.
  --------------------------------------------------

  --- vector copy assignment ---
  tec:    [ 1.00, 1.50, 2.00, 2.50 ]
  tec:    address: 0000002E4DEFE338
  tec[0]: address: 0000016E4A967770
  --- uec = tec ---
  uec:    [ 1.00, 1.50, 2.00, 2.50 ]
  uec:    address: 0000002E4DEFE198
  uec[0]: address: 0000016E4A9673B0
  --- original source vec has not changed ---
  vec:    [ 1.00, 1.50, 2.00 ]
  vec:    address: 0000002E4DEFDFF8
  vec[0]: address: 0000016E4A967950
  --------------------------------------------------
  Note:
  Both uec and tec and their resources are unique.
  That's because vector copy assignment operator
  copies each element of tec to uec.

  Managed languages copy handles to instances,
  not the instances themselves, so assignment
  causes sharing of resources in those languages.
  --------------------------------------------------

</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                The examples shown here use the addresses of a library type, <c-s>std::vector</c-s> and its
                heap resources <c-s>vec[0]</c-s> to show that the source and destination are unique, e.g.,
                the type&apos;s control block and heap resources have indeed been copied.
              </t-b>
              <t-b>
                That&apos;s demonstrated for both copy construction and copy assignment.
              </t-b>
              <t-b>
                The next <a target="_blank" href="Bits_ObjectsCpp.html">Bits page</a> demonstrates how to
                implement construction and copy assignment for user-defined types.
              </t-b>
            </div>
          </div>
        </details>
        <h3 id="move">3.0 Move Operations</h3>
        <t-b>
          Move operations are used to improve performance over copy operations. Their use is usually
          context dependent and require the convention of never using an instance after it has &quot;moved&quot;
          to avoid undefined behavior.
        </t-b>
        <h3 id="movestr">Move std::string</h3>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-cpp">  /*-- move temporary string --*/
  auto first = std::string(&quot;first part&quot;);
  auto mid = std::string(&quot; and &quot;);
  auto last = std::string(&quot;last part&quot;);
  auto aggr = first + mid + last;
  /*-----------------------------------------------------
    first + mid + last is a temporary string that
    is moved to aggr using move constructor.
  ------------------------------------------------------*/

  /*-- forced string move --*/
  auto src = std::string(&quot;src string&quot;);
  auto dst = std::move(src);
  /*-----------------------------------------------------
    There is no guarantee that src will have valid
    state after move, so using src after has undefined
    behavior.
  ------------------------------------------------------*/

</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              Unlike copy, move operations move ownership of a type instance&apos;s resources to
              another instance, without actually copying the instance&apos;s resources.
            </t-b>
            <t-b>
              Instead,
              only the instance&apos;s control block is copied, so the new instance has all the
              same properties as the originial, including the pointer to its resources, without
              the expense of copying what may be a large collection of resources.
            </t-b>
            <t-b>
              C++ moves occur when a temporary (unnamed) instance is used to construct a new instance.
            </t-b>
            <t-b>
              The first example shows a <c-s>std::string</c-s> temporary, the sum of three string fragments,
              used to create a new string, aggr.
            </t-b>
            <t-b>
              A move can also be forced using the <c-s>std::move(t)</c-s> function. Forced moves are
              used to efficiently send an instance&apos;s value into a pass-by-value function if it
              won&apos;t be needed again. It is also used when the argument is not copyable, as we saw
              for <c-s>std::unique_ptr&lt;int&gt;</c-s> in the last section.
            </t-b>
            <t-b>
              Unforced moves may occur for return by value of an instance created within a function.
              That will only happen when &quot;return value optimization&quot; does not apply. This is
              another of C++&apos;s famous context dependencies.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre><code class="language-cpp">  --- move temporary string ---
  first:  "first part"
  mid:    " and "
  last:   "last part"
  --- auto aggr = first + mid + last ---
  aggr:   "first part and last part"
  --------------------------------------------------
   first + mid + last is a temporary string that
   is moved to aggr using move constructor.
  --------------------------------------------------

  --- forced string move ---
  src:    "src string"
  src:    type: class std::basic_string&lt;char,struct std:...
  --- auto dst=std::move(src) ---
  dst: "src string"
  dst: type: class std::basic_string&lt;char,struct std:...
  src:    &quot;&quot;  // DON&apos;T DO THIS
  src:    type: class std::basic_string&lt;char,struct std:...
  --------------------------------------------------
   There is no guarantee that src will have a valid
   state after move, so the src display, above, has
   undefined behavior - just happens to work on MSVC.
  --------------------------------------------------
</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                The first example creates a temporary <c-s>std::string</c-s> from
                three string fragments and moves the result to <c-s>aggr</c-s>.
              </t-b>
              <t-b>
                The second example shows the forced move of <c-s>src</c-s> to the
                <c-s>dst</c-s> string. It also shows the "value" Of the source string
                after it has been moved.
              </t-b>
              <t-b>
                THIS IS IMPLEMENTATION DEPENDENT.
              </t-b>
              <t-b>
                Using an instance after it has been moved
                has undefined results. It might have resulted in a segment fault on another
                platform or operating system.
              </t-b>
            </div>
          </div>
        </details>
        <h3 id="passvalref">4.0 Pass-by-value &amp; Pass-by-reference</h3>
        <t-b>
          This is the only code block on this page that shows all of the code, including formatting and
          output. Note that you can see all of the code for the other demos by looking at contents of the
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Data/src">Bits Repository</a>.
        </t-b>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-cpp">  /*-------------------------------------------
    All code is shown for this example, e.g.,
    includes formatting code and output.
  -------------------------------------------*/
  template&lt;typename T&gt;
  void pass_seq_by_value(T t) {
    std::cout &lt;&lt; formatOutput&lt;T&gt;(
                   t, &quot;   passed&quot;, seq_collectionToString&lt;T&gt;
                 );
    std::cout &lt;&lt; formatAddress&lt;T&gt;(t, &quot;   passed&quot;);
    std::cout &lt;&lt; formatAddress&lt;typename T::value_type&gt;(
                   t[0], &quot;passed[0]&quot;
                 );
  }
  template&lt;typename T&gt;
  void pass_seq_by_reference(T& t) {
    std::cout &lt;&lt; formatOutput&lt;T&gt;(
                   t, &quot;   passed&quot;, seq_collectionToString&lt;T&gt;
                 );
    std::cout &lt;&lt; formatAddress&lt;T&gt;(t, &quot;   passed&quot;);
    std::cout &lt;&lt; formatAddress&lt;typename T::value_type&gt;(
                   t[0], &quot;passed[0]&quot;
                 );
  }

  void pass_by_value_and_ref() {

    showLabel(&quot;pass-by-value and pass-by-reference&quot;);
    nl();

    showOp(&quot;std::vector&lt;int&gt; pass-by-value&quot;);
    nl();
    using VECI = std::vector&lt;int&gt;;
    auto v = std::vector&lt;int&gt;() = { 1, 2, 3 };
    std::cout &lt;&lt; formatOutput&lt;VECI&gt;(
                   v, &quot;     call&quot;, 
                   seq_collectionToString&lt;VECI&gt;
                 );
    std::cout &lt;&lt; formatAddress&lt;VECI&gt;(v, &quot;     call&quot;);
    std::cout &lt;&lt; formatAddress&lt;int&gt;(v[0], &quot;  call[0]&quot;);
    pass_seq_by_value(v);
    showLabel(
      &quot;passed has the same value as call.&#92;n&quot;
      &quot;  call and its resources are different from&#92;n&quot;
      &quot;  passed and its resources.  That demonstrates&#92;n&quot;
      &quot;  passed was copy constructed from call.&quot;
    );
    nl();

    showOp(&quot;std::vector&lt;int&gt; pass-by-reference&quot;);
    nl();
    using VECI = std::vector&lt;int&gt;;
    auto rv = std::vector&lt;int&gt;() = { 1, 2, 3 };
    std::cout &lt;&lt; formatOutput&lt;VECI&gt;(
                   rv, &quot;     call&quot;, 
                   seq_collectionToString&lt;VECI&gt;
                 );
    std::cout &lt;&lt; formatAddress&lt;VECI&gt;(rv, &quot;     call&quot;);
    std::cout &lt;&lt; formatAddress&lt;int&gt;(rv[0], &quot;  call[0]&quot;);
    pass_seq_by_reference(rv);
    showLabel(
      &quot;call and its resources are the same as&#92;n&quot;
      &quot;  passed and its resources.  That demonstrates&#92;n&quot;
      &quot;  that only reference was copied.&quot;
    );
}
</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              A &quot;pass-by-value&quot; function passes an instance unadorned with references, e.g.,
              <c-s>R&nbsp;f(T&nbsp;t)</c-s>. Arguments are passed by reference by passing a reference to an
              instance, e.g., <c-s>R&nbsp;g(T&&nbsp;t)</c-s>.
            </t-b>
            <t-b>
              Pass-by-value creates a copy of the argument in the function&apos;s stack frame.
              Pass-by-reference creates a reference to the caller&apos;s instance, so a possibly large
              copy is avoided. 
            </t-b>
            <t-b>
              Unless qualified by <c-s>const</c-s>, as in <c-s>R&nbsp;h(const&nbsp;T&&nbsp;t)</c-s>,
              passing by reference has side-effects. Any change to the referenced argument in the function is seen
              by the caller.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre><code class="language-cpp">  --------------------------------------------------
    pass-by-value and pass-by-reference
  --------------------------------------------------

  --- std::vector&lt;int> pass-by-value ---

       call: [ 1, 2, 3 ]
       call: type: class std::vector&lt;int,class std::allocat...
       call: address: 0000004A4276F3C8
    call[0]: address: 00000202AD1B4B80
     passed: [ 1, 2, 3 ]
     passed: type: class std::vector&lt;int,class std::allocat...
     passed: address: 0000004A4276F760
  passed[0]: address: 00000202AD1B4AE0
--------------------------------------------------
  passed has the same value as call.
  call and its resources are different from
  passed and its resources.  That demonstrates
  passed was copy constructed from call.
--------------------------------------------------

  --- std::vector&lt;int> pass-by-reference ---

       call: [ 1, 2, 3 ]
       call: type: class std::vector&lt;int,class std::allocat...
       call: address: 0000004A4276F578
    call[0]: address: 00000202AD1B45E0
     passed: [ 1, 2, 3 ]
     passed: type: class std::vector&lt;int,class std::allocat...
     passed: address: 0000004A4276F578
  passed[0]: address: 00000202AD1B45E0
--------------------------------------------------
  call and its resources are the same as
  passed and its resources.  That demonstrates
  that only reference was copied.
--------------------------------------------------
</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                Addresses tell the whole story. Pass-by-value results in two unique instances,
                the caller&apos;s object and its copy in the function&apos;s stack frame. 
              </t-b>
              <t-b>
                Pass-by-reference results in a reference created in the function&apos;s stack frame
                attached to the caller&apos;s object, so the adddresses are the same.
              </t-b>
            </div>
          </div>
        </details>
        <h3 id="displfunc">5.0 Display Functions</h3>
        <t-b style="margin-top:0em;">
          When you look at any of the &quot;Output&quot; details, you will see
          some output with detailed formatting, but you won&apos;t see code providing
          that output in corresponding code sections.
        </t-b>
        <t-b>
          Code responsible for formatting and supplying low-level details,
          like type information, has been elided from the code shown above.
          The elided code consists of calls to functions shown in the dropdown below.
        </t-b>
        <t-b>
          These functions use language features, like generics, that will be covered
          in later Bits. You can find the complete code, including all the elisions,
          in the <a target="_blank" href="https://github.com/JimFawcett/Bits">Bits Repository</a>.
        </t-b>
        <details>
          <summary class="darkItem">Display Functions</summary>
          <div class="block">
            <div class="codewrap">
              <pre><code class="language-cpp">  /*-- convert scalar to string ----------------------*/
  template &lt;typename T&gt;
  std::string scalarToString(const T& scalar) {
    /* format in-memory stringstream so formats 
       are temporary */
    std::ostringstream out;
    out.precision(3);
    out &lt;&lt; std::showpoint;
    out &lt;&lt; std::boolalpha;
    out &lt;&lt; scalar;
    return out.str();
  }
  /*-- convert sequential collection to string -------*/
  template &lt;typename C&gt;
  std::string seq_collectionToString(const C& coll) {
    /* format in-memory stringstream so formats 
       are temporary */
    std::ostringstream out;
    out.precision(3);
    out &lt;&lt; std::showpoint;
    out &lt;&lt; std::boolalpha;
    out &lt;&lt; &quot;[ &quot;;
    /*-- show comma only in interior of sequence --*/
    bool first = true;
    for(auto item : coll) {
      if(first) {
        out &lt;&lt; item;
        first = false;
      }
      else {
        out &lt;&lt; &quot;, &quot; &lt;&lt; item;
      }
    }
    out &lt;&lt; &quot; ]&quot;;
    return out.str();
  }

  /*-- several conversion functions elided --*/

  /*-- return formatted output string ----------------
    - third arg is lambda (aka closure) std::function
    - intent is to pass in format converter function
      customized for type T
    - examples of converter functions are given above
  */
  template &lt;typename T&gt;
  std::string formatOutput(
    const T& t,             // format t
    const std::string& nm,  // caller name
    std::function&lt;std::string(const T&)&gt; f, // format
    bool showtype = true    // default to show type
  ){
    std::stringstream out;
    out &lt;&lt; &quot;  &quot; &lt;&lt; nm + &quot;: &quot;
    &lt;&lt; f(t) &lt;&lt; &quot;&#92;n&quot;;
    if(showtype) {
      out &lt;&lt; getType(t, nm);
      out &lt;&lt; &quot;  &quot; &lt;&lt; nm + &quot;: size = &quot; 
          &lt;&lt; sizeof(t) &lt;&lt; &quot;&#92;n&quot;;
    }
    return out.str();
  }
  /*--------------------------------------------------
    return formatted address as string
  */
  static const size_t WIDTH = 8;

  /*-- return address of t --*/
  template&lt;typename T&gt;
  std::string formatAddress(
    const T& t, const std::string& nm
  ) {
    const T* ptrToArg = &t;
    std::stringstream out;
    out.precision(7);
    out &lt;&lt; &quot;  &quot; &lt;&lt; std::showpoint;
    out &lt;&lt; std::boolalpha;
    out &lt;&lt; std::setw(WIDTH) &lt;&lt; std::left 
        &lt;&lt; nm + &quot;: &quot; &lt;&lt; &quot;address: &quot;;
    out &lt;&lt; std::showbase &lt;&lt; std::hex 
        &lt;&lt; ptrToArg &lt;&lt; &quot;&#92;n&quot;;
    return out.str();
  }
</code></pre>
              <pre><code class="language-cpp">  /*-----------------------------------------------
    truncate string to length n
    - does nothing if string length is less than n
  */
  inline std::string truncate(
    const std::string& str, size_t n = 40
  ) {
    std::string tmp = str;
    if(tmp.size() &lt; n) {
      return tmp;
    }
    tmp.resize(n);
    tmp += &quot;...&quot;;
    return tmp;
  }
  /*-----------------------------------------------
    return type of t
  */
  template&lt;typename T&gt;
  std::string getType(T t, const std::string &nm) {
    std::ostringstream out;
    out &lt;&lt; &quot;  &quot; 
        &lt;&lt; nm + &quot;: &quot;;    // show name at call site
    out &lt;&lt; &quot;type: &quot; 
        &lt;&lt; truncate(typeid(t).name());  // show type  
    out &lt;&lt; &quot;&#92;n&quot;;
    return out.str();
  }
  /*-----------------------------------------------
    display text delimited with "---"
  */
  inline void showOp(
    const std::string& text, 
    const std::string& suffix = &quot;&quot;
  ) {
    std::cout &lt;&lt; &quot;  --- &quot; 
              &lt;&lt; text 
              &lt;&lt; &quot; ---&quot; 
              &lt;&lt; std::endl &lt;&lt; suffix;
  }
  /*-----------------------------------------------
    display text with lines above and below
  */
  inline void showLabel(
    const std::string& text, size_t n = 50
  ) {
    auto line = std::string(n, '-');
    std::cout &lt;&lt; line &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; text &lt;&lt; std::endl;
    std::cout &lt;&lt; line &lt;&lt; std::endl;
  }
  /*-----------------------------------------------
    send a text string to std::cout
  */
  inline void print(const std::string& txt) {
    std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt;
  }
  /*-----------------------------------------------
    send a line of text to std::cout
  */
  inline void println(const std::string& txt) {
    std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt &lt;&lt; &quot;&#92;n&quot;;
  }
  /*-----------------------------------------------
    emit newline
  */
  static void nl() {
  std::cout &lt;&lt; std::endl;
  }
</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                The first code block on the left shows:
                <table>
                  <tr>
                    <td style="padding-left:1em;">
                      functions for converting scalars and collections to strings.
                    </td>
                  </tr>
                  <tr>
                    <td style="padding-left:1em;">
                      a formatOutput function accepting an object and
                      one of the converter functions.
                    </td>
                  </tr>
                  <tr>
                    <td style="padding-left:1em;">
                      That function returns a formatted string representing the first argument.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      The first code block also shows a function used to format pointer addresses for display.
                    </td>
                  </tr>
                </table>
              </t-b>
              <t-b>
                The second code block provides two functions:
              </t-b>
              <table>
                <tr>
                  <td>
                    <c-s>template&lt;T&gt;</c-s><br />
                    <c-s>std::string getType(T t, ...)</c-s> returns a string representation of
                    the compiler&apos;s inferred type for t.
                  </td>
                </tr>
                <tr>
                  <td>
                    <c-s>std::string truncate(...)</c-s> truncates strings returned by <c-s>getType</c-s>
                    to fit the display medium.
                  </td>
                </tr>
              </table>
              <t-b>
                These functions are helpers for the formatting functions in the first block.
              </t-b>
           </div>
          </div>
        </details>

        <h3 id="build">6.0 Build</h3>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-shell">  C:\github\JimFawcett\Bits\Cpp\Cpp_Data\build
cmake --build .
MSBuild version 17.5.1+f6fdcf537 for .NET Framework

  Bits_Data.cpp
  Bits_DataAnalysis.cpp
  Generating Code...
  Cpp_Data.vcxproj -> 
    C:\github\JimFawcett\Bits\Cpp\Cpp_Data\build\Debug\Cpp_Data.exe
C:\github\JimFawcett\Bits\Cpp\Cpp_Data\build
</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                All C++ builds for the Bits demos use CMake invoked from the VS Code terminal.
              </t-b>
              <t-b>
                The first build needs CMake infrastructure created with the terminal command:<br />
                <c-s>cmake ..</c-s>
              </t-b>
              <t-b class="clear">
                Builds are created with the terminal command:<br />
                <c-s>cmake --build .</c-s>
              </t-b>
              <t-b>
                A build is executed with the command:<br />
                <c-s>debug/CppData.exe</c-s><br />
                where the executable name, here CppData.exe, is defined in CMakeLists.txt.
              </t-b>
            </div>
          </div>
        </div>
        <h3 id="cmake">6.1 CMakeLists.txt</h3>
        <div class="block">
          <div class="codewrap">
<pre><code class="language-shell">
  cmake_minimum_required(VERSION 3.25)
  project(CppData)
  #---------------------------------------------------
  set(CMAKE_BUILD_TYPE Debug)
  #---------------------------------------------------
  #   CppData dir
  #   -- CMakeLists.txt (this file)
  #   -- src dir
  #      -- Bits_Data.cpp
  #      -- Bits_DataAnalysis.h
  #      -- Bits_DataAnalysis.cpp
  #   -- build directory
  #      -- Debug directory
  #         -- Cpp_Data.exe
  #         -- ...
  #---------------------------------------------------

  # Wasn't able to get std::library modules to work with CMake.
  # - does work in Visual Studio, preview edition, non CMake project
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}
    /experimental:module /std:c++latest /EHsc /MD"
  )
  #-- Things I tried to get CMake to find str module --
  # set(CMAKE_MODULE_PATH "C:/Users/Public/std_modules")
  # set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /std:c++20")
  # set_property(TARGET $CppData PROPERTY CXX_STANDARD 20)
  # target_compile_features(CppData PUBLIC CXX_STANDARD 20)
  # set(CMAKE_CXX_FLAGS "${/experimental:module /std:c++latest}")
  # set(CMake_CXX_STANDARD 20)
  # set(CMAKE_CXX_STANDARD_REQUIRED ON)
  # set(CMAKE_CXX_EXTENSIONS OFF)

  #---------------------------------------------------
  # build Bits_Data.obj, Bits_DataAnalysis.obj
  #   in folder build/Cpp_Data.dir/debug
  #---------------------------------------------------
  set(SRC
    src/Bits_Data.cpp
  )
  include_directories(src)
  add_executable(CppData.exe ${SRC})
  #---------------------------------------------------

</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              Comments in CMakeLists.txt illustrate a fruitless search
              for means to compile C++ code that uses C++20 modules.
            </t-b>
            <t-b>
              I&apos;ve been able to build such code with Visual Studio projects,
              using the preview version of Visual Studio circa September 2023.
            </t-b>
            <t-b>
              I suspect that CMake will build them, but doesn&apos;t like my
              path specification.  I&apos;ll fix that eventually.
            </t-b>
          </div>
        </div>
        <h3 id="ide">7.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Cpp\Cpp_Data.
        </t-b>
        <photosizer-block src="pictures/VS_Code_Cpp_Data.JPG" width="800" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE</span>
        </photosizer-block>
        <photosizer-block src="pictures/LaunchJSON_Cpp_Data.JPG" width="700" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 2. Launch.JSON</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
  </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">8.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../CppStoryRepo.html">C++ Story</a>
            </td>
            <td>
              E-book with thirteen chapters covering most of intermediate C++
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../CppBites/CppBites_Intro.html">C++ Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <!--<page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ide">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#cmake">CMake</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">bld</a></menu-elem>
        <menu-elem class="secElem"><a href="#out">out</a></menu-elem>
        <menu-elem class="secElem"><a href="#src-BDAC">BDAnal.cpp</a></menu-elem>
        <menu-elem class="secElem"><a href="#src-BDAH">BDAnal.h</a></menu-elem>
        <menu-elem class="secElem"><a href="#src-BD">BitsData</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">codeSnaps</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>-->
    </main>
    <!--<frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="actions.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>-->
  </page-frame>
  <!--<script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>-->
  <script>
    //localStorage.clear();
    //getScroll();
  </script>
</body>
</html>