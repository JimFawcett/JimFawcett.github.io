<!DOCTYPE html>
<html>
<!--
  Bits_DataCppContent.html
-->
<head>
  <title>Bits_Data C++</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeBlue.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBits.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding:0.75em 1.5em;
      margin-top:1.25em;
      margin-bottom:1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width:50em;
    }
    #github h2 {
      margin-top: 0.75em;
    }
    #github #pagetitle {
      border:2px double var(--dark);
    }
    #github form {
      border:none;
      padding:0.5em 1em;
    }
    #github form span {
      padding:0em 0.5em;
    }
    #github code-container {
      display: flex;
      position:relative;
      width:calc(100%);
      flex-direction: row;
      justify-content: space-between;
      /*border-top: 1px solid var(--dark);*/
    }
    #github code-banner {
      display: block;
      border: 2px solid var(--dark);
      border-top:none;
      border-bottom:none;
      padding: 0.25em 1em;
      font-family: 'Comic Sans MS', Tahoma;
      width: calc(100% + 0.5em);
      background-color: var(--atten);
    }
    #github code-display {
      display: block;
      border: 2px solid var(--dark);
      white-space: pre;
      padding: 0.75em 1em;
      font-family: Consolas, monospace;
      font-size:0.9em;
      width: calc(50% - 0.5em);
      overflow-x: auto;
      /*height:20em;*/
    }
    #github label {
      margin-right:1em;
    }
    #github fieldset {
      border:none;
    }
    #github #exeRight, #exeLeft {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github #hideLeft, #hideRight {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github .hide {
      display:none;
    }
    body {
      position:relative;
    }
    #github table.showcode {
      table-layout:fixed;
      width:calc(100% + 4em);
      margin-left:-2em;
    }
    #github th.leftblock {
      border: 2px solid var(--dark);
      /*border: 1px solid red;*/
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.rightblock {
      border: 2px solid var(--dark);
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.centerblock {
      border: none;
      padding: 0em;
      width:1em;
    }
    #github td.leftblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em);
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.leftblock summary {
      border:1px solid #ffffbb;
    }

    #github td.rightblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em) !important;
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.rightblock summary {
      border: 1px solid #ffffbb;
    }

    #github td.centerblock {
      border: none;
      padding: 0em;
    }
    #github pre {
      overflow-x: auto !important;
    }
    #github #left1 {
      /*height:45em;*/
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }

    #github #right1 {
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }
    #github #left2 {
      /*height:45em;*/
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right2 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github #left3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github .mover {
      width:2em;
      padding: 0.05em;
      position:relative;
      right:-1.5em;
      top:0.6em;
    }
    #github #ruler {

      width:calc(50% - 1.5em);
      height:0.001em;
      margin:-0.45em 0em;
    }
    #github .btns {
      width:3em;
      border:none;
    }
    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 10px;
    }
    #github .remotebutton {
      padding:0.25em 0.5em;
    }
    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }
    #github hr.spread {
      margin: 0.75em 0em;
    }
    body {
      overflow-y:auto;
    }
    #github pre {
      width: max-content;
      min-width: 20em;
      max-width: 60em;
      user-select: all;
    }

    #github {
      user-select: none;
    }

    .code-container {
      display: flex;
      flex-direction: column;
      border: 1px solid red;
      width: max-content;
      margin: 0em;
      padding: 0em;
    }

    .code-block {
      /*display:flex;*/
      margin: 0.0em 1em;
      font-family: monospace;
    }

    .focus {
      padding: 0.5em 1.0em 0.5em 1.0em;
      /*border:1px solid red;*/
    }

    *.focus ul {
      padding-top: -0.5em;
      /*background-color:green;*/
    }

    .cat {
      text-align: left;
      background-color: var(--menu);
    }
  </style>
  <script>
    function setScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = main.scrollTop;
      localStorage.setItem('scrollPositionHelloRust', scrollPosition);
      let scroller = document.getElementById("scrollY")
      scroller.innerHTML = Math.trunc(scrollPosition);
    }
    function gotoLastScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = localStorage.getItem('scrollPositionHelloRust');
      if (scrollPosition) {
        main.scrollTo(0, scrollPosition);
      }
      main.addEventListener('scroll', setScroll);
    }
    function load() {
      //initialize();
      gotoLastScroll();
    }
  </script>

  <script>
    function remote() {
      window.open('https://godbolt.org/z/nvfbzMo9s', '_blank');
    }
  </script>
</head>
<!--<body id="github" onload="initialize()" onbeforeunload="saveScroll()">-->
<body id="github" onload="load()">

  <a id="Next" href="Bits_ObjectsCpp.html">Next</a>
  <a id="Prev" href="Bits_HelloCpp.html">Prev</a>

  <page-frame>
    <!--<frame-header>
      <nav id="navbar"></nav>
    </frame-header>-->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits Data C++</div>
      <div id="modified">09/04/2023</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content id="content">
        <div class="rightPanelLinks">
          <a target="_parent" class="darkItem" href="Bits_DataCpp.html">C++</a>
          <a target="_parent" href="Bits_DataRust.html">Rust</a>
          <a target="_parent" href="Bits_DataCSharp.html">C#</a>
          <a target="_parent" href="Bits_DataPython.html">Python</a>
          <a target="_parent" href="Bits_DataJs.html">JvScrpt</a>
        </div>
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.50em; width:max-content; height:1.5em;
           text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits: C++ Data</h1>
            <h3 id="subtitle" class="indent">
              types, initialization, construction, assignment
            </h3>
          </hgroup>
        </header>
        <t-b>
          These pages support comparison of fragments of code in several different
          languages, much as you might compare a sentence of English with one in Spanish to help you learn
          Spanish.
        </t-b>
        <t-b id="syn" style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          This page demonstrates simple uses of the most important C++ types.
          The purpose is to quickly acquire some familiarity with types and their uses.
          <hr class="spread" />
          <ul>
            <li>
              Primitive types and aggregates of primitive types are copyable.  Assignment and
              pass-by-value copies the source&apos;s value to the destination.
            </li>
            <li>
              For user-defined types
              C++ provides special class methods - constructors, operators, and destructors.
              When properly implemented they provide instance syntax that mimics that of primitives.
            </li>
            <li>
              C++ supports move operations with move constructor and move assignment operator.
              temporaries are moved when assigned or passed-by-value to the destination
              using the resources of the move source.  This is a transfer of ownership and
              makes the source invalid. Attempting to use a &quot;moved&quot; variable is,
              unfortunately, not a compile error.
            </li>
            <li>
              C++ supports making fixed references to either primitive or user-defined types. These may
              refer to instances in stack memory or in the native heap.
            </li>
            <li>
              C++ pointers and references are un-constrained and a frequent source of memory management
              errors. By convention these can be avoided by using range-based for loops and smart pointers.
              For very large code bases it can be challenging to insure that the conventions have been
              followed everywhere - think of projects with 100,000 source lines or more.
            </li>
            <li>
              Here we begin to see significant differences between the languages, especially
              when comparing statically typed languages like C++, Rust, and C#, with dynamically typed
              languages like Python and JavaScript.
            </li>
          </ul>
          We will see how the C++ special methods are implemented in the next example.
          <div style="height:0.25em;"></div>
        </t-b>
        <div style="height:0.25em;"></div>
        <under-construction>
          <div>
            This page is being restructured
            <ul style="font-size:0.85em;">
              <li>Revising type system details</li>
              <li>Will replace code with snippets and discussion</li>
            </ul>
          </div>
        </under-construction>
        <div style="height:0.75em;"></div>
        <details id="types">
          <summary class="darkItem">C++&nbsp;Types&nbsp;Details&nbsp;</summary>
          <h3>Table 1.0 C++ Types</h3>
          <table style="font-size: 0.9em; max-width: 71em;">
            <tr>
              <th style="width:15em;">Type</th>
              <th>Comments</th>
              <th>Example</th>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Integral types ----</th>
            </tr>
            <tr>
              <td><c-s>bool</c-s></td>
              <td>values true and false</td>
              <td><c-s>bool b = true;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>int<br />with signed, unsigned, short, long qualifiers</c-s>
              </td>
              <td>1 == sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)</td>
              <td><c-s>short int i = 42;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>size_t</c-s>
              </td>
              <td><c-s>2 ≤ sizeof(size_t)</c-s>,<br /><c-s>size_t</c-s> is used for indexing</td>
              <td><c-s>size_t i = 0;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>char<br />with signed and unsigned qualifiers</c-s>
              </td>
              <td>signedness of <c-s>char</c-s> depends on platform</td>
              <td><c-s>char c = 'a';</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>wchar_t, char16_t, char32_t</c-s>
              </td>
              <td>
                wchar_t is 16 bits and holds UTF-16 code units on Windows,
                32 bits and holds UTF-32 on Linux
              </td>
              <td><c-s>wchar_t c = L'\U263A';</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Floating point types ----</th>
            </tr>
            <tr>
              <td><c-s>float, double</c-s></td>
              <td>values have finite precision, and may have approximate values</td>
              <td><c-s>double d = 3.14159;</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- literal string types --</th>
            </tr>
            <tr>
              <td><c-s>const&nbsp;char[], const&nbsp;wchar_t[]</c-s></td>
              <td>
                literal string, resides in static memory and is always null terminated.
                "Hello" is a const char[6] containing the chars: 'H', 'e', 'l', 'l', 'o', '\0'.
              </td>
              <td>
                <c-s>char* lst = "a literal string"</c-s>
              </td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Aggregate types ----</th>
            </tr>
            <tr>
              <td><c-s>T[N]</c-s></td>
              <td>Native array of N elements all of type <c-s>T</c-s></td>
              <td>
                <c-s>int arr[] = [1, 2, 3, 2, 1];<br />let first = arr[0];</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::tuple&lt;T1, T2, ...&gt;</c-s></td>
              <td>collection of heterogeneous types accessed by position</td>
              <td>
                <c-s>
                  std::tuple&lt;int, float, char&gt; tu&nbsp;=&nbsp;(42,&nbsp;3.14159,&nbsp;'z');<br />char third = get&lt;2&gt;(tu);
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::optional&lt;T&gt;</c-s></td>
              <td>std::optional holds optional value <c-s>t&epsi;T</c-s> or <c-s>std::nullopt</c-s></td>
              <td><c-s>fn doOp(..args) -> Optional&lt;T&gt;</c-s></td>
            </tr>
            <tr><th colspan="3" class="cat">-- Std::library types ----</th></tr>
            <tr>
              <td><c-s>std::string</c-s></td>
              <td>Expandable collection of ASCII characters allocated in the heap</td>
              <td><c-s>std::string strg = "a string";</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::wstring</c-s></td>
              <td>Expandable collection of Unicode characters allocated in the heap</td>
              <td><c-s>std::wstring strg = L"a wstring";</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::array&lt;T, N&gt;</c-s></td>
              <td>Fixed size generic array of items of type <c-s>T</c-s></td>
              <td><c-s>std::array&lt;int,3&gt; v { 1, 2, 3 };</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::vector&lt;T&gt;</c-s></td>
              <td>Expandable generic collection of items of type <c-s>T</c-s></td>
              <td><c-s>std::vector&lt;double&gt;&nbsp;v&nbsp;{&nbsp;1.0,&nbsp;1.5,&nbsp;2.0 }; v.push(2.5);</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::deque&lt;T&gt;</c-s></td>
              <td>
                Expandable double-ended generic collection of items of type <c-s>T</c-s>.
                Uses circular buffer internally.
              </td>
              <td>
                <c-s>
                  std::deque&lt;int&gt; vd { 1, 2, 3 }<br />
                  v.push_front(-1); ...
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::unordered_map&lt;K,V&gt;</c-s></td>
              <td>Unordered associative container of Key-Value pairs, held in a table of bucket lists.</td>
              <td>
                <c-s>
                  std::unordered_map&lt;std::string, int&gt; m {&nbsp;{"one",1},&nbsp;{"two",2}&nbsp;}<br />
                  map.insert("zero", 0); ...
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::map&lt;K,V&gt;</c-s></td>
              <td>Ordered associative container of Key-Value pairs, held in binary tree.</td>
              <td>
                <c-s>
                  std::map&lt;std::string, int&gt; m {&nbsp;{"one",1},&nbsp;{"two",2}&nbsp;}<br />
                  map.insert("zero", 0); ...
                </c-s>
              </td>
            </tr>
            <tr>
              <td>forward_list, list, unordered_set, unordered_multiset, ...</td>
              <td>
                The C++ std::library defines types for threading and synchronization,<br />
                reading and writing to streams, anonymous functions, ...
              </td>
              <td><a href="https://en.cppreference.com/w/cpp/container">Containers library</a></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- User-defined Types --</th>
            </tr>
            <tr>
              <td>User-defined types</td>
              <td colspan="2">Based on classes and structs, these will be discussed in the next Bit.</td>
            </tr>
          </table>
          <div style="height:0.5em;"></div>
        </details>
        <div style="height:0.25em;"></div>
        <details id="typesys">
          <summary class="darkItem">C++&nbsp;Type&nbsp;System&nbsp;Details&nbsp;</summary>
          <h3>Table 2. C++ Copy and Move Operations</h3>
          <table style="font-size:0.9em; max-width:65em;">
            <colgroup>
              <col span="1" style="width:12%;" />
              <col span="1" style="width:16%;" />
              <col span="1" style="width:36%;" />
              <col span="1" style="width:36%;" />
            </colgroup>
            <tr>
              <th>Operation</th>
              <th>Example</th>
              <th>Primitive or Aggregate of Primitives</th>
              <th>Library or User-defined Type</th>
            </tr>
            <tr>
              <td>Construction</td>
              <td><c-s>T t = u; u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>T</c-s>&apos;s copy constructor copies <c-s>u</c-s></td>
            </tr>
            <tr>
              <td>Assignment</td>
              <td><c-s>t = u, t&epsilon;T, u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>T</c-s>&apos;s assignment operator copies value of <c-s>u</c-s></td>
            </tr>
            <tr>
              <td>Pass-by-value</td>
              <td><c-s>fn doOp(T t)</c-s></td>
              <td><c-s>t</c-s>&apos;s value is mem-copy&apos;ed to doOp stack frame</td>
              <td><c-s>t</c-s>&apos;s value is copied to doOp stack frame,<br />using <c-s>T</c-s>&apos;s copy constructor</td>
            </tr>
            <tr>
              <th colspan="4">If u&epsilon;T is a temporary or u = std::move(v), v&epsilon;T</th>
            </tr>
            <tr>
              <td>Construction</td>
              <td><c-s>T t = u; u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>u</c-s>&apos;s value is moved to <c-s>t</c-s> using <c-s>T</c-s>&apos;s move constructor<br /><c-s>u</c-s>&apos;s value becomes undefined</td>
            </tr>
            <tr>
              <td>Assignment</td>
              <td><c-s>t = u, t&epsilon;T, u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>u</c-s>&apos;s value is moved to <c-s>t</c-s> using <c-s>T</c-s>&apos;s move assignment operator<br /><c-s>u</c-s>&apos;s value becomes undefined</td>
            </tr>
            <tr>
              <td>Pass-by-value</td>
              <td><c-s>fn doOp(T t)</c-s></td>
              <td><c-s>t</c-s>&apos;s value is mem-copy&apos;ed to doOp stack frame</td>
              <td><c-s>T</c-s>&apos;s move constructor copies <c-s>t</c-s> to doOp stack frame<br /><c-s>t</c-s>&apos;s value becomes undefined</td>
            </tr>
          </table>
          <t-b>
            <h3>Table 3. C++ Type System Attributes</h3>
          </t-b>
          <table style="font-size:0.9em; max-width:65em;">
            <tr>
              <td>Static&nbsp;typing</td>
              <td>
                All types are known at compile time and are fixed throughout program execution.
              </td>
            </tr>
            <tr>
              <td>Inference</td>
              <td>
                Compiler infers types in expressions if not explicitly annotated or declared <c-s>auto</c-s>.
                Occasionally inference fails and explicit annotation is required.
              </td>
            </tr>
            <tr>
              <td>Intermediate&nbsp;strength typing</td>
              <td>
                Types are exhaustively checked but there are many implicit conversions.
                <ul class="tight">
                  <li>Numeric and boolean literals coerce to their correspoinding type, e.g., 42 to int.</li>
                  <li>Variables with auto type declarations are coerced to the type of their RHS&apos;s</li>
                  <li>Values can be coerced using user-defined conversion constructors.</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Generics</td>
              <td>
                Generics provide types and functions with unspecified parameters,
                supporting code reuse and abstraction
                over types. Generic parameters are specified at the call site, e.g., <c-s>doOp&lt;T, U&gt;(T t, U u)</c-s>
                The function <c-s>doOp</c-s> is checked for syntax before instantiating with specific type(s). Any
                use of <c-s>t</c-s> or <c-s>u</c-s> in the <c-s>doOp</c-s> body are not checked until the types
                of <c-s>t</c-s> and <c-s>u</c-s> are known.
                <div style="height:0.75em;"></div>
                Unlike all the other languages examined in these Bits, C++ generics use an internal meta language
                at compile time to implement generic facilities. That can be used to move some processing from
                run-time to compile-time using &quot;template metaprogramming&quot;.
              </td>
            </tr>
            <tr>
              <td>Concepts</td>
              <td>
                Concepts are similar to Rust traits and Java and C# interfaces.
                They define shared behavior that types can
                implement, supporting abstraction over behavior. Concepts define behavior by declaring concept
                specific functions. A template type can use a Requires clause with concept arguments to bound
                types that are valid for a class or function.
              </td>
            </tr>
          </table>
        </details>
        <div style="height:0.5em;"></div>
        <!--<details>
    <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
    <t-b><hr /></t-b>
    <t-b>
      All of the languages covered in this demonstration support classes.  Each class provides
      a pattern for laying out a memory footprint and defines how data within are accessed.
    </t-b>
    <t-b>
      Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
      is a pattern for defining functions and classes of a specific type.  Thus a generic is a
      pattern for making patterns.
    </t-b>
    <t-b>
      The other two, Python and JavaScript, are dynamically typed and already support defining
      functions and classes for multiple types, e.g., no need for generics.
    </t-b>
    <t-b>
      This demonstration illustrates use of classes and objects, which for C++, Rust, and C#,
      are defined in a stackframe or in the heap or both. <strongs>All</strongs> data for Python and JavaScript are
      stored in managed heaps.
    </t-b>
    <t-b><hr /></t-b>
  </details>
  <t-b>
    The examples below show how to use library and user defined types with emphasis on
    illustrating syntax and basic operations.
  </t-b>-->
        <!--<div style="height:0.25em;"></div>
  <h3 id="code">1.0 CodeSnaps</h3>
  <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote()" />-->
      <h3 id="init">1.0 Initialization of Primitives</h3>
      <div style="display:flex; flex-direction:row;">
        <div style="display:flex; flex-direction:column;">
          <!-- <div style="float:left; border:2px solid red; width:max-content;"> -->
          <pre><code class="language-cpp">  /*---------------------------------------------------  
    All code used for output has been elided
  */
  /*-- scalars --*/
  bool b = true;
  std::byte byte { 0x0f };
    /*  std::byte =&gt; unsigned char {} */
  int i = 42;  // equiv to int i { 42 };
  double d = 3.1415927;
  char ch = 'z';
  const char* lst = &quot;a literal string&quot;;

  /*-- array --*/
  short int fa[] { 1, 2, 3, 4, 5 };
  short int fa_alt[5] { 1, 2, 3, 4, 5 };

  /*-- struct --*/
  struct S { int a; char b; double c; };
  S strct { 1, 'a', 3.1415927 };

  /*-- tuple --*/
  std::tuple&lt;int, double, char&gt; tup { 1, 3.14, 'z' };

  /*-- optional --*/
  std::optional&lt;double&gt; opt1 { 3.1415927 };
  std::optional&lt;double&gt; opt2; // { std::nullopt };
  if(opt2 == std::nullopt) {
    std::cout &lt;&lt; &quot;empty&#92;n&quot;;
  }
  else {
    std::cout &lt;&lt; *opt2 &lt;&lt; &quot;&#92;n&quot;;
  }

</code></pre>
          <details>
            <summary class="darkItem">Output&nbsp;</summary>
            <pre><code class="language-cpp">  --- scalars ---

  --- bool ---
  b:      true
  b:      type: bool
  --- byte ---
  byte:   0xf
  byte:   type: enum std::byte
  --- int ---
  i:      42
  i:      type: int
  --- double ---
  d:      3.141593
  d:      type: double
  --- char ---
  ch:     z
  ch:     type: char
  --- const char* ---
  lst:    &quot;a literal string&quot;
  lst:    type: char const * __ptr64

  --- aggregate types ---

  --- native array ---
  fa[]:   [ 1, 2, 3, 4, 5 ]
  fa[]:   type: short const * __ptr64
  --- struct ---
  strct:  S { 1, a, 3.14159 }
  strct:  type: struct `void __cdecl initialize_primitiv...
  --- tuple ---
  tup:    { 1, 3.14, z }
  tup:    type: class std::tuple&lt;int,double,char&gt;
  --- optional ---
  opt1:   3.14159
  opt2:   empty
  opt1:   type: class std::optional&lt;double&gt;

</code></pre>
          </details>
        </div>
        <div style="padding-left:2em; max-width:25em;">
          <t-b>
            Instances of primitive types each occupy one block of contiguous memory.
            Copy construction and copy assignment copies the source value to the
            desgination using mem-copy, e.g., a byte-by-byte copy.
          </t-b>
          <t-b>
            Scalars can be initialized by either assigning a value or with a braced initializer.
            All the aggregate types: array, struct, tuple, and optional use a braced
            initializer list.
          </t-b>
          <t-b>
            
          </t-b>
        </div>
        </div>
        <h3 id="initheap">2.0 Initialization of data in heap storage</h3>
        <pre><code class="language-cpp">  /*-- initialized in heap memory --*/

  /*-------------------------------------------------------
    All code for output has been elided
  */
  /*-- raw pointer --*/
  int* tmol = new int{42};
  delete tmol;  // forgetting this causes memory leak

  /*-- shared-ptr to scalar --*/
  std::shared_ptr&lt;int&gt; stmol = std::make_shared&lt;int&gt;(42);
  int stmp = *stmol;
  // std::shared_ptr deallocates heap storage when
  // all references go out of scope. So no memory leak.

  /*-- shared-ptr to collection --*/
  std::shared_ptr&lt;std::vector&lt;int&gt;&gt; pVec =
    make_shared&lt;std::vector&lt;int&gt;&gt;(std::vector&lt;int&gt;{ 1, 2, 3 });
  auto vtmp = *pVec;

  /*-- using aliases to simplify --*/
  using VecI = std::vector&lt;int&gt;;
  using SPtr = std::shared_ptr&lt;std::vector&lt;int&gt;&gt;;
  SPtr pVec2 = make_shared&lt;VecI&gt;(VecI{ 1, 2, 3 });

</code></pre>
        <details>
          <summary class="darkItem">Output&nbsp;</summary>
          <pre><code class="language-cpp">  --- initialized in heap memory ---

  --- raw pointer ---
  *tmol:  42
  *tmol:  type: int
  tmol:   0000016E4A956D80
  tmol:   type: int * __ptr64

  --- std::shared_ptr ---
  *stmol: 42
  *stmol: type: int
  stmol:  0000016E4A967420
  stmol:  type: class std::shared_ptr<int>

    --- std::shared_ptr&lt;std::vector&lt;int>> ---
  *pVec:  [ 1, 2, 3 ]
  *pVec:  type: class std::vector&lt;int,class std::allocat...
  pVec:   0000016E4A968260
  pVec:   type: class std::shared_ptr&lt;class std::vector&lt;...

  --- using aliases to simplify ---
  *pVec2: [ 1, 2, 3 ]
  *pVec2: type: class std::vector&lt;int,class std::allocat...
  pVec2:  0000016E4A968880
  pVec2:  type: class std::shared_ptr&lt;class std::vector&lt;...

</code></pre>
        </details>
        <h3 id="initstdlib">3.0 Initialization of std::library types</h3>
        <pre><code class="language-cpp">
  /*-- initialize std::library types --*/

  /*-------------------------------------------------------
    All code for output has been elided
  */
  /*-- generic array --*/
  std::array&lt;double, 7&gt;
  sarr { 1.0, 1.5, 2.0, 2.5, 2.0, 1.5, 1.0 };

  /*-- expandable string --*/
  std::string sstr = &quot;a string&quot;;   // initialized from literal  

  /*-- expandable indexable array --*/
  std::vector&lt;int&gt; vec { 1, 2, 3, 4 };
  vec.push_back(5);

  /*-- expandable double-ended queue --*/
  std::deque&lt;int&gt; dq { 1, 2, 3 };
  dq.push_front(0);
  dq.push_back(4);

  /*-- expandable associative container --*/
  std::unordered_map&lt;std::string, int&gt; umap
  {{&quot;one&quot;, 1}, {&quot;two&quot;, 2}, {&quot;three&quot;, 3}};
  umap.insert({&quot;zero&quot;, 0});

</code></pre>
        <details>
          <summary class="darkItem">Output</summary>
          <pre><code class="language-cpp">  --- std::array&lt;double> ---
  sarr:   [ 1.00, 1.50, 2.00, 2.50, 2.00, 1.50, 1.00 ]
  sarr:   type: class std::array&lt;double,7>
      
  --- std::string => std::basic_string&lt;char> ---
  sstr:   "a string"
  sstr:   type: class std::basic_string&lt;char,struct std:...

  --- std::vector&lt;int> ---
  vec:    [ 1, 2, 3, 4, 5 ]
  vec:    type: class std::vector&lt;int,class std::allocat...
  
  --- std::deque&lt;int> ---
  dq:     [ 0, 1, 2, 3, 4 ]
  dq:     type: class std::deque&lt;int,class std::allocato...
  
  --- std::unordered_map&lt;std::string, int> ---
  umap:   { {one, 1}, {two, 2}, {zero, 0}, {three, 3} }
  umap:   type: class std::unordered_map&lt;class std::basi...

</code></pre>
        </details>
        <h3 id="copyprim">4.0 Copy operations for primitives</h3>
        <pre><code class="language-cpp">  /*-- copy operations for primitives --*/

  /*-------------------------------------------------------
    All code for output has been elided
  */
  /*-- primitive copy construction - bit-wise copy --*/
  int ival = 42;      // initialization
  int jval = ival;    // here&apos;s the copy construction

  /*-- copy assignment, output elided --*/
  double dval = 3.1415927;  // create dst instance
  double eval = 1.33333;    // create src instance
  dval = eval;              // copy assignment operation

</code></pre>
        <details>
          <summary class="darkItem">Output</summary>
          <pre><code class="language-cpp">  ------------------------------------------  
    copy operations for primitives
  --------------------------------------------------

  --- copy construction ---
  ival:   42
  ival:   type: int
  ival:   address: 0000002E4DEFDAF4
  --- int jval = ival ---
  jval:   42
  jval:   type: int
  jval:   address: 0000002E4DEFDC04

  --- copy assignment ---
  dval:   3.141593
  dval:   type: double
  dval:   address: 0000002E4DEFDD18
  eval:   1.333330
  eval:   type: double
  eval:   address: 0000002E4DEFDDD8
  --- dval = eval ---
  dval:   1.333330
  dval:   type: double
  dval:   address: 0000002E4DEFDD18

</code></pre>
        </details>
        <h3 id="copystdlib">5.0 Copy operations for std::library</h3>
        <pre><code class="language-cpp">  /*-- copy operations for std::library types --*/

  /*-------------------------------------------------------
    All code for output has been elided
  */
  /*-- vector copy construction --*/
  std::vector&lt;double&gt; vec { 1.0, 1.5, 2.0 };
  auto uec = vec;  // copy construction

  /*-- vector copy assignment --*/
  std::vector&lt;double&gt; tec { 1.0, 1.5, 2.0, 2.5 };
  uec = tec;       // copy assignment

</code></pre>
        <details>
          <summary class="darkItem">Output</summary>
          <pre><code class="language-cpp">  --------------------------------------------------  
    copy operations for std::library types
  --------------------------------------------------

  --- vector copy construction ---
  vec:    [ 1.00, 1.50, 2.00 ]
  vec:    address: 0000002E4DEFDFF8
  vec[0]: address: 0000016E4A967950
  --- auto uec = vec ---
  uec:    [ 1.00, 1.50, 2.00 ]
  uec:    address: 0000002E4DEFE198
  uec[0]: address: 0000016E4A967A10
  --------------------------------------------------
  Note:
  Both uec and vec and their resources are unique.
  That's because the vector copy constructor
  copies each element of vec to uec.

  Managed languages copy handles to instances,
  not the instances themselves, so construction
  does not create a new instance in those
  languages.  Resources are shared.
  --------------------------------------------------

  --- vector copy assignment ---
  tec:    [ 1.00, 1.50, 2.00, 2.50 ]
  tec:    address: 0000002E4DEFE338
  tec[0]: address: 0000016E4A967770
  --- uec = tec ---
  uec:    [ 1.00, 1.50, 2.00, 2.50 ]
  uec:    address: 0000002E4DEFE198
  uec[0]: address: 0000016E4A9673B0
  --- original source vec has not changed ---
  vec:    [ 1.00, 1.50, 2.00 ]
  vec:    address: 0000002E4DEFDFF8
  vec[0]: address: 0000016E4A967950
  --------------------------------------------------
  Note:
  Both uec and tec and their resources are unique.
  That's because vector copy assignment operator
  copies each element of tec to uec.

  Managed languages copy handles to instances,
  not the instances themselves, so assignment
  causes sharing of resources in those languages.
  --------------------------------------------------

</code></pre>
        </details>
        <h3 id="move">6.0 Move std::string</h3>
        <pre><code class="language-cpp">
  Coming Soon
        </code></pre>
        <details>
          <summary class="darkItem">Output</summary>
        </details>
        <h3 id="displfunc">7.0 Display Functions</h3>
        <t-b style="margin-top:0.5em;">
          When you look at any of the &quot;Output&quot; details, you will see
          some output with detailed formatting, but you won&apos;t see code providing
          that output in corresponding code sections.
        </t-b>
        <t-b>
          Code responsible for formatting and supplying low-level details,
          like type information, has been elided from the code shown above.
          The elided code consists of calls to functions shown in the dropdown below.
        </t-b>
        <t-b>
          These functions use language features, like generics, that will be covered
          in later Bits. You can find the complete code, including all the elisions,
          in the <a target="_blank" href="https://github.com/JimFawcett/Bits">Bits Repository</a>.
        </t-b>
        <details>
          <summary class="darkItem">Display Functions</summary>
          <pre><code class="language-cpp">  /*---------------------------------------------------------
    Show operation text surrounded by "---" strings
  */
  void showOp(const std::string& text, const std::string& suffix=="") {
    std::cout &lt;&lt; "  --- " &lt;&lt; text &lt;&lt; " ---" &lt;&lt; std::endl &lt;&lt; suffix;
  }
  /*---------------------------------------------------------
    Show text surrounded by long lines of '-' characters
  */
  void showLabel(const std::string& text, size_t n) {
    auto line = std::string(n, '-');
    std::cout &lt;&lt; line &lt;&lt; std::endl;
    std::cout &lt;&lt; "  " &lt;&lt; text &lt;&lt; std::endl;
    std::cout &lt;&lt; line &lt;&lt; std::endl;
  }
  /*-----------------------------------------------
    truncate string to length n
    - does nothing if string length is less than n
  */
  std::string truncate(const std::string& str, size_t n) {
    std::string tmp = str;
    if(tmp.size() &lt; n) {
      return tmp;
    }
    tmp.resize(n);
    tmp += "...";
    return tmp;
  }

  /*-----------------------------------------------
    show type of t
  */
  static const size_t WIDTH = 8;

  template&lt;typename T&gt;
  void showType(T t, const std::string &nm) {
    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; std::setw(WIDTH) &lt;&lt; std::left
    &lt;&lt; nm + &quot;: &quot;;      // show name at call site
    std::cout &lt;&lt; &quot;type: &quot; &lt;&lt; truncate(typeid(t).name());  // show type
    std::cout &lt;&lt; &quot;&#92;n&quot;;
  }
  /*-- format output --------------------------------------
    - third argument is the lambda (aka closure) std::function
    - intent is to pass in formatting customized for type T
    - lots of examples of that below
  */
  template &lt;typename T&gt;
  void formatOutput(
    const T& t,                               // being formatted
    const std::string& nm,                    // caller name
    std::function&lt;std::string(const T&)&gt; f,   // to formatted string
    bool showtype = true                      // default to show type
  ){
    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; std::setw(WIDTH) &lt;&lt; std::left &lt;&lt; nm + &quot;: &quot;
    &lt;&lt; f(t) &lt;&lt; &quot;&#92;n&quot;;
    if(showtype) {
      showType(t, nm);
    }
  }

  /*-- convert scalar to string -----------------------------
    - used as the third argument in <c-s>formatOutput</c-s>
  */
  template &lt;typename T&gt;
  std::string scalarToString(const T& scalar) {
    /* format in-memory stringstream so formats are temporary */
    std::ostringstream out;
    out.precision(3);
    out &lt;&lt; std::showpoint;
    out &lt;&lt; std::boolalpha;
    out &lt;&lt; scalar;
    return out.str();
  }

  /*-- convert sequential collection to string --------------
    - used as the third argument in <c-s>formatOutput</c-s>
  */
  template &lt;typename C&gt;
  std::string seq_collectionToString(const C& coll) {
    /* format in-memory stringstream so formats are temporary */
    std::ostringstream out;
    out.precision(3);
    out &lt;&lt; std::showpoint;
    out &lt;&lt; std::boolalpha;
    out &lt;&lt; &quot;[ &quot;;
    /*-- show comma only in interior of sequence --*/
    bool first = true;
    for(auto item : coll) {
      if(first) {
        out &lt;&lt; item;
        first = false;
      }
      else {
        out &lt;&lt; &quot;, &quot; &lt;&lt; item;
      }
    }
    out &lt;&lt; &quot; ]&quot;;
    return out.str();
  }
  /*-- other converters elided --*/

  /*-- return formatted address of t --*/
  template&lt;typename T>
  std::string formatAddress(const T& t, const std::string& nm) {
    const T* ptrToArg = &t;
    std::stringstream out;
    out.precision(7);
    out &lt;&lt;"  " &lt;&lt; std::showpoint;
    out &lt;&lt; std::boolalpha;
    out &lt;&lt; std::setw(WIDTH) &lt;&lt; std::left &lt;&lt; nm + ": " &lt;&lt; "address: ";
    out &lt;&lt; std::showbase &lt;&lt; std::hex &lt;&lt; ptrToArg &lt;&lt; "\n";
    return out.str();
  }

</code></pre>
        </details>

        <h3 id="build">7.0 Build</h3>
        <pre class="codeSnaps"><code class="language-shell">C:\github\JimFawcett\Bits\Cpp\Cpp_Data\build
> cmake --build .
MSBuild version 17.5.1+f6fdcf537 for .NET Framework

  Bits_Data.cpp
  Bits_DataAnalysis.cpp
  Generating Code...
  Cpp_Data.vcxproj -> C:\github\JimFawcett\Bits\Cpp\Cpp_Data\build\Debug\Cpp_Data.
  exe
C:\github\JimFawcett\Bits\Cpp\Cpp_Data\build
</code></pre>
        <h3 id="cmake">CMakeLists.txt</h3>
<pre><code class="language-shell">#---------------------------------------------------
# HelloCMake - Demonstrate building C++ with CMake
#   - Non-hierarchal version
#---------------------------------------------------

#---------------------------------------------------
cmake_minimum_required(VERSION 3.25)
project(DataCMake)
set(CMAKE_BUILD_TYPE Debug)
#---------------------------------------------------
#   CppData dir
#   -- CMakeLists.txt (this file)
#   -- src dir
#      -- Bits_Data.cpp
#      -- Bits_DataAnalysis.h
#      -- Bits_DataAnalysis.cpp
#   -- build directory
#      -- Debug directory
#         -- Cpp_Data.exe
#         -- ...
#      -- Cpp_Data.dir directory
#         -- Debug directory
#            -- Bits_Data.obj
#            -- Bits_DataAnalysis.obj
#            -- ...
#---------------------------------------------------

set(CMake_CXX_STANDARD 20)

#---------------------------------------------------
# build Bits_Data.obj, Bits_DataAnalysis.obj
#   in folder build/Cpp_Data.dir/debug
#---------------------------------------------------
set(SRC
  src/Bits_Data.cpp src/Bits_DataAnalysis.cpp
)
include_directories(src)
add_executable(Cpp_Data ${SRC})

</code></pre>
        <h3 id="ide">2.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Cpp\Cpp_Data.
        </t-b>
        <photosizer-block src="pictures/VS_Code_Cpp_Data.JPG" width="800" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE</span>
        </photosizer-block>
        <photosizer-block src="pictures/LaunchJSON_Cpp_Data.JPG" width="700" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 2. Launch.JSON</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
  </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../CppStoryRepo.html">C++ Story</a>
            </td>
            <td>
              E-book with thirteen chapters covering most of intermediate C++
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../CppBites/CppBites_Intro.html">C++ Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <!--<page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ide">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#cmake">CMake</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">bld</a></menu-elem>
        <menu-elem class="secElem"><a href="#out">out</a></menu-elem>
        <menu-elem class="secElem"><a href="#src-BDAC">BDAnal.cpp</a></menu-elem>
        <menu-elem class="secElem"><a href="#src-BDAH">BDAnal.h</a></menu-elem>
        <menu-elem class="secElem"><a href="#src-BD">BitsData</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">codeSnaps</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>-->
    </main>
    <!--<frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="actions.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>-->
  </page-frame>
  <!--<script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>-->
  <script>
    //localStorage.clear();
    //getScroll();
  </script>
</body>
</html>