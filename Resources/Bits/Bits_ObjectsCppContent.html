<!DOCTYPE html>
<html>
<!--
  Bits_ObjectsCpp.html
-->
<head>
  <title>Bits_Objects C++</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeCpp.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBits.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <link rel="stylesheet" href="css/StylesSplitterBar.css" />
  <script src="js/ScriptsSplitterBar.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding: 0.75em 1.5em;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width: 50em;
    }

    #github h2 {
      margin-top: 0.75em;
    }

    #github #pagetitle {
      border: 2px double var(--dark);
      /* line-height:1.5em; */
    }

    #github .hide {
      display: none;
    }

    body {
      position: relative;
      line-height: 1.25em;
    }

    #github .remotebutton {
      padding: 0.25em 0.5em;
    }

    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }

    #github hr.spread {
      margin: 0.75em 0em;
    }

    #github {
      user-select: none;
    }

    .focus {
      padding: 0.5em 1.0em 0.5em 1.0em;
      /*border:1px solid red;*/
    }

    *.focus ul {
      padding-top: -0.5em;
      /*background-color:green;*/
    }

    .cat {
      text-align: left;
      background-color: var(--menu);
    }

    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 1em 1.5em;
      margin-right: 0.5em;
    }

    #github pre {
      overflow-x: auto;
      /* user-select: all; */
    }

    code-style {
      white-space: pre;
      font-family: Consolas;
      font-size: 0.95em;
      font-weight: bold;
    }

    .blockDouble {
      position: relative;
      display: grid;
      grid-template-columns: 1fr 1fr;
      border: 1px solid var(--dark);
      overflow-x: auto;
      overflow-y: hidden;
      margin-right: 0.75em;
      padding: 0.75em;
      padding-right: 0em;
    }

    .blockSingle {
      position: relative;
      border: 1px solid var(--dark);
      overflow-x: auto;
      overflow-y: hidden;
      margin-right: 0.75em;
      margin-top:1.5em;
      padding: 0.0em;
      padding-right: 0em;
    }

    .codewrap {
      padding: 0.5em;
      padding-right: 0em;
      overflow-y: auto;
      /*border: 1px dashed blue;*/
      font-size:0.80em;
    }

    #github div.block t-b {
      max-width: 100%;
      padding-left: 0.5em;
    }

    .textwrap {
      position: relative;
      padding-right: 1em;
      padding-left: 1em;
      margin-right: 0.5em;
      overflow-y: scroll;
      /*border: 1px dashed red;*/
    }

    table {
      margin-right: 0.75em;
    }

    #github .scrollable {
      overflow: auto;
    }
  </style>
  <style>
    #github .info {
      position: relative;
      top: 0em;
      float: right;
      font-size: large;
      font-weight: bold;
      text-align: center;
      background-color: var(--light);
      border-radius: 8px;
      color: var(--dark);
      width: 1.25em;
      cursor: pointer;
      user-select: none;
    }

    #github .infoKill {
      position: relative;
      top: 0.05em;
      float: right;
      font-size: large;
      font-weight: bold;
      text-align: center;
      background-color: var(--light);
      border-radius: 8px;
      color: var(--dark);
      width: 1.25em;
      cursor: pointer;
      user-select: none;
      margin: 0.25em;
    }

    #github .txt {
      display: none;
      position: absolute;
      right: 4.5em;
      width: 25em;
      z-index: 10;
      color: var(--dark);
      font-size: small;
      background-color: var(--light);
      border: 2px solid var(--dark);
      padding: 0em 0.5em;
      overflow-y: visible;
    }
  </style>
  <script>
    function closeInfos() {
      var elems = document.querySelectorAll('.txt');
      for (let i = 0; i < elems.length; ++i) {
        if (elems[i].style.display === "block") {
          elems[i].style.display = "none";
        }
      }
    }
    function toggleInfo(dst) {
      var elem = document.getElementById(dst);
      if (elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = "block";
      }
      else {
        elem.style.display = "none";
      }
    }
    function toggleInfoRel(src, dst, adj = 0) {
      var txtcont = document.getElementById(dst);
      var elemtop = src.offsetTop;
      txtcont.style.top = parseInt(elemtop - 25 - adj) + 'px';
      var top = txtcont.style.top;
      if (txtcont.style.display === "none" || txtcont.style.display === "") {
        txtcont.style.display = "block";
      }
      else {
        txtcont.style.display = "none";
      }
    }
  </script>
  <script>
    function setScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = main.scrollTop;
      localStorage.setItem('scrollPositionHelloRust', scrollPosition);
      let scroller = document.getElementById("scrollY")
      scroller.innerHTML = Math.trunc(scrollPosition);
    }
    function gotoLastScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = localStorage.getItem('scrollPositionHelloRust');
      if (scrollPosition) {
        main.scrollTo(0, scrollPosition);
      }
      main.addEventListener('scroll', setScroll);
    }
    function load() {
      //initialize();
      gotoLastScroll();
    }
  </script>
  <script>
    function cwiden() {
      alert('cwiden');
      let out = document.getElementById("codepre");
      let widthr = out.style.width;
      let width = parseInt(widthr);
      width -= 5;
      out.style.width = width.toString() + "em";
    }
    function owiden() {
      alert('owiden');
      let out = document.getElementById("outpre");
      let widthr = out.style.width;
      let width = parseInt(widthr);
      width += 5;
      out.style.width = width.toString() + "em";
    }
  </script>

  <script>
    function remote() {
      window.open('https://godbolt.org/z/vrn4cP8Yn', '_blank');
    }
  </script>
</head>
<body id="github" onload="load()">

  <a id="Next" href="Bits_GenericCpp.html">Next</a>
  <a id="Prev" href="Bits_DataCpp.html">Prev</a>

  <page-frame>
    <!-- <frame-header>
      <nav id="navbar"></nav>
    </frame-header> -->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits Objects C++</div>
      <div id="modified">11/26/2023</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.750em; width:max-content; height:1.5em;
             text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits: C++ Objects</h1>
            <h3 id="subtitle" class="indent">
              library and user-defined classes and objects
            </h3>
          </hgroup>
        </header>
        <t-b id="syn" style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          This page demonstrates uses of C++ User-Defined types and their objects.
          The purpose is to quickly acquire some familiarity with user-defined types
          and their implementations.
          <hr class="spread" />
          <ul>
            <li>
              C++ defines special class methods: copy and move constructors, copy and move
              assignment operators, and other operators for indexing and comparison etc.
            </li>
            <li>
              The compiler will generate constructors and assignment operators if needed and
              not provided by the class.  Those are correct if, and only if, the class&apos;s
              members and bases have correct semantics for those operations.
              For other cases, like pointer members, developers must either implement them or
              prohibit them. We will show how in this example.
            </li>
            <li>
              Also, this is the first set of examples to partition code into several files.
              That supports readability, may improve translation times, and makes maintenance
              significantly easier.
            </li>
          </ul>
          <div style="height:0.5em;"></div>
        </t-b>
        <details id="notes">
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <div style="border:1px solid var(--dark); padding:0em 1em 0.5em; max-width:fit-content;">
            <t-b>
              All of the languages covered in this demonstration support classes<sup>1</sup>.  Each class provides
              a pattern for laying out a memory footprint and defines how data within are accessed.
            </t-b>
            <t-b>
              Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
              is a pattern for defining functions and classes of a specific type.  Thus a generic is a
              pattern for making patterns.
            </t-b>
            <t-b>
              The other two, Python and JavaScript, are dynamically typed and already support defining
              functions and classes that work for multiple types, e.g., no need for generics.
            </t-b>
            <t-b>
              This demonstration illustrates use of classes and objects, which for C++, Rust, and C#,
              are defined in a stackframe or in the heap or both. <strongs>All</strongs> data for Python and JavaScript are
              stored in managed heaps.
            </t-b>
            <t-b>
              A few functions in this code are generic, e.g., have type(s) to be specified by the caller
              at compile time. The next bit explores generics in greater detail with more discussion.
            </t-b>
            <div style="margin:0.25em 1em; font-size:0.85em; max-width:75%;">
              <hr />
              <ol>
                <li>
                  Rust uses structs to implement objects in the same way that the other languages
                  use classes.  Here we will just use the term class for all of them.
                </li>
              </ol>
            </div>
          </div>
        </details>
        <div style="height:0.25em;"></div>
        <t-b>
          The examples below show how to use library and user defined types with emphasis on
          illustrating syntax and basic operations.
        </t-b>
        <div style="height:0.15em;"></div>
        <h3 id="code">1.0 Source Code</h3>
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote()" />
        <t-b>
          The code for this &quot;objects&quot; Bit is presented in a three part sequence:
          <ol>
            <li>
              Code for a user-defined type, Point4D is presented in the first block. Much of the
              technical weight of this Bit is carried by the left and right panels in this block.
            </li>
            <li>
              That is followed by the execution code in <c-s>main</c-s> broken up into
              six blocks. The first block holds, like previous Bits, code in a left panel with
              text explanation in a right panel. The remaining blocks show executable code
              in the left panel with corresponding output in the right panel. That adjacency
              makes it easier to understand what the code is doing.
              <div style="height:0.5em;"></div>
              A splitter bar is provided between the code and output blocks to enable
              viewing any horizontal text overflow.
              <div style="height:0.5em;"></div>
              These blocks contain definitions and output for demos of std library
              String and Vector instances and also for instances of a user-defined Point4D
              class.
            </li>
            <li>
              The last part is devoted to a listing of all the analysis functions used in
              <c-s>main</c-s> in the left panel with some commentary in the right panel.
            </li>
          </ol>
        </t-b>
        <t-b>
          The source code is available
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
          Download the entire Bits repository
          <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
        </t-b>
        <div>
          <div style="height:0.25em;"></div>
          <h3 id="points">1.1 PointsObj.h</h3>
          <t-b>
            A C++ class is a pattern for laying out data in memory with member functions,
            called methods, for all of its operations.  Making data members private ensures
            that class methods have valid data for their operations. A class designer may
            choose to selectively allow user data modification.
          </t-b>
          <t-b style="margin-bottom:1em;">
            This block presents code that defines a C++ type, Point4D. It defines the
            data held by instances of the type, three double precision coordinates and
            a std::time_t variable, and methods to create, copy, assign, modify
            and destroy instances.
          </t-b>
          <div class="blockSingle">
            <div class="codewrap" style="float:left; width:60%;">
              <pre style="font-size:1.0em; margin-right:0.75em;"><code class="language-cpp">/*---------------------------------------------------------         
  Points.h defines a space-time point class:
  - Point4D represents points with three double spatial
    coordinates and std::time_t time coordinate.
*/
#pragma warning(disable:4996) // warning about ctime use
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
/*---------------------------------------------------------
  Point4D class represents a point in a 4-Dimensional 
  space-time lattice. Simple enough for illustration, 
  but still useful.

  It declares all of the special class methods, most with
  default qualifiers to indicate that the compiler will
  generate them as needed.

  The word ctor is an abbreviation of constructor and dtor
  an abbreviation for destructor.
*/
class Point4D {
public:
  Point4D();                              // void ctor
  Point4D(const Point4D& pt) = default;   // copy ctor
  Point4D(Point4D&& pt) = default;        // move ctor
  Point4D& operator=(const Point4D& pt) = default;
                                          // copy assignment
  Point4D& operator=(Point4D&& pt) = default;
                                          // move assignment
  ~Point4D() = default;                   // dtor
  std::string timeToString();
  void updateTime();
  void show();
  double& xCoor() { return x; }
  double& yCoor() { return y; }
  double& zCoor() { return z; }
  std::time_t& tCoor() { return t; }
private:
  double x;
  double y;
  double z;
  std::time_t t;
};

Point4D::Point4D() {
  x = y = z = 0.0;
  t = std::time(0);
}
std::string Point4D::timeToString() {
  return ctime(&t);
  /*
    ctime is depricated due to a thread-safety issue.
    That's not a problem here. Compiler warning
    recommends converting to ctime_s, which, unfortunately
    has a different and awkward interface.
  */
}
void Point4D::updateTime() {
  t = std::time(0);
}

void Point4D::show() {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; &quot;Point4D {&quot;;
  std::cout &lt;&lt; &quot;&#92;n    &quot; 
            &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; &quot;, &quot;;
  std::cout &lt;&lt; &quot;&#92;n    &quot; &lt;&lt; timeToString();
  std::cout &lt;&lt; &quot;  }&quot;;
}

/* required for showType(T t, const std::string& nm) */

std::ostream& operator&lt;&lt;(
  std::ostream& out, Point4D& t1
) {
  out &lt;&lt; &quot;Point4D {&quot;;
  out &lt;&lt; &quot;    &quot; &lt;&lt; t1.xCoor() &lt;&lt; &quot;, &quot; &lt;&lt; t1.yCoor() &lt;&lt; &quot;, &quot;
                &lt;&lt; t1.zCoor() &lt;&lt; std::endl
                &lt;&lt; &quot;    &quot; &lt;&lt; t1.timeToString() &lt;&lt; std::endl
                &lt;&lt; &quot;  }&quot; &lt;&lt; std::endl;
  return out;
}
</code></pre>
            </div>
            <div class="textwrap">
              <h4>Concept:</h4>
              <t-b>
                Point4D holds data for a point in 3 dimensional space and a time
                when something was at that point.
              </t-b>
              <t-b>
                These points could be collected into a vector to represent a trajectory
                of an aircraft or a machine tool cutting edge.
              </t-b>
              <h4>C++ class syntax:</h4>
              <t-b>
                C++ defines six special methods for construction, assignment, and destruction,
                all based on class name. They are illustrated in this block.
              </t-b>
              <t-b>
                The C++ compiler will implement default copy constructor, destructor, and assignment operator
                if using code implies a copy and/or assignment and the class designer has
                not provided them<sup>1</sup>.
                Destructors are always required
                and are generated if the class does not provide one.
              </t-b>
              <t-b>
                The compiler does this by using its member&apos;s and base&apos;s<sup>2</sup> construction, assignment,
                and destruction operations for all the parts of the class.  We say these operations are 
                applied member-wise.
              </t-b>
              <t-b>
                However, the implemented methods are correct if, and only if, class
                members and bases have correct copy, destruction, and assignment semantics. That is true
                for primitive types and collections from the Standard Template Library (STL),
                but otherwise designers must implement those methods<sup>3</sup>.
              </t-b>
              <t-b>
                This is a common source of errors so it is appropriate to use the
                &quot;default&quot; or &quot;delete&quot; qualifiers to indicate that the
                compiler generated methods will be correct - done to make clear to a
                maintainer that the default operation is intended, or to instruct the compiler
                not to generate those methods.
              </t-b>
              <h4>Function overloading:</h4>
              <t-b>
                C++ defines overloading of functions based on function signature.  Essentially
                a function overload is a new function with a name based on the original function
                name and the types of its arguments created by a process call &quot;name-mangling&quot;.
              </t-b>
              <t-b>
                The copy and move construction functions Point4D(...) are overloads of the
                void constructor, Point4D(), and the copy and move assignment operators are
                overloads.
              </t-b>
              <t-b>
                The <c-s>operator&lt;&lt;(std::ostream& out, T& t)</c-s> ostream operator
                converts objects of type <c-s>T</c-s> into parts that the default 
                <c-s>std::operator&lt;&lt;</c-s> can
                process. The overload for Point4D is needed by functions in the AnalysisObjects.h
                library.
              </t-b>
              <t-b>
                C++ operators are functions that are called when statements with operator symbols
                are encountered, e.g., <c-s>x&nbsp;=&nbsp;y</c-s> is equivalent to
                <c-s>x.operator=(y)</c-s> and <c-s>std::cout&nbsp;&lt;&lt;&nbsp;x</c-s> is
                equivalent to <c-s>operator&lt;&lt;(std::cout,&nbsp;x)</c-s>.
              </t-b>
            </div>
            <div id="txt0" class="txt">
              <t-b>
                This file is a header only library that defines a type, <c-s>Point4D</c-s>, representing
                a point in 3 dimensional space with a forth time dimension.
              </t-b>
              <t-b>
                A sequence of these instances could be used
                to capture flight trajectories for commercial aircraft, for example.
              </t-b>
              <t-b>
                User-defined C++ types are described by classes. A class is a pattern for laying out
                an instance&apos;s data in the stack or heap, and methods that access and modify the data.
              </t-b>
              <t-b>
                Code that implements class methods resides in static memory, and has lifetime essentially
                equal to program lifetime.
              </t-b>
              <t-b>
                Instances, i.e. objects, are created by invoking a constructor method, and are accessed
                and modified by other methods.
              </t-b>
            </div>
            <div id="txt1" class="txt">
              <t-b>
                <c-s>Point4D</c-s> declares all of the C++ special methods: void, copy,
                and move constructors, copy and move assignment, and a destructor.
                All but the void constructor are declared default.
              </t-b>
              <t-b>
                That
                means that the compiler implements them by doing member-wise operations, e.g.,
                the default copy constructor copies each of the class data members and any base
                class instances, using their copy constructors.
              </t-b>
              <t-b>
                Compiler generation works correctly only if all members have correct copy and assignment
                semantics. That is true for all primitive data types and all of the Standard Template
                Library containers, but not true for pointers or handles.
              </t-b>
              <t-b style="color:maroon;">
                All the special methods are described in detail in
                <a target="_blank" href="../../Resources/CppBites/CppBites_STR.html">STR</a>, code for a user-defined
                string class.
              </t-b>
            </div>
            <div id="txt2" class="txt">
              <t-b>
                Methods may be defined inline, like <c-s>xCoor</c-s> and <c-s>tCoor</c-s>.
                Class data, like <c-s>x</c-s> and <c-s>t</c-s>, are declared private so
                they can only be mutated by methods of the class.
              </t-b>
              <t-b>
                Methods like <c-s>xCoor</c-s> that return references allow a class designer
                to selectively expose class data to user modification.
              </t-b>
            </div>
            <div id="txt3" class="txt">
              <t-b>
                Class methods may also be defined outside the bounds of the class declaration,
                as shown for <c-s>Point4D()</c-s>, <c-s>timeToString()</c-s>, et al. Moving all
                complex method definitions below the class declaration makes the class
                interface easier to understand.
              </t-b>
              <t-b>
                Note that doesn&apos;t work for languages like C# and Java.
              </t-b>
            </div>
            <div id="txt4" class="txt">
              <t-b>
                The function:
                <code-style>
                  std::operator&lt;&lt;(
                  std::ostream&amp; out,
                  const T&amp; t
                  )
                </code-style>
                sends a text representation of its argument t to the std output stream.  It is
                defined in the std library.
              </t-b>
              <t-b>
                The second argument must
                be one of a common set of types known to the library.
              </t-b>
              <t-b>
                C++ provides a very nice operator syntax that makes the two statements:<code-style>
                  --------------------------
                  std::operator&lt;&lt;(
                  std::cout, x
                  );
                  --------------------------
                  std::cout << x;
                  --------------------------
                </code-style>
                equivalent.
              </t-b>
              <t-b>
                The function <c-s>operator&lt;&lt;</c-s> is overloaded here to accept a
                <c-s>Point4D</c-s> instance.  It breaks down the instance into parts that
                the <c-s>std::operator&lt;&lt;</c-s> can accept.
              </t-b>
              <t-b>
                This supports statements like <c-s>std::cout &lt;&lt; apoint;</c-s>.
              </t-b>
            </div>
            <div style="padding:1em;">
              <t-b class="clear">
                <hr />
                <ol>
                  <li>
                    Move operators may also be compiler generated. That happens in
                    certain, rather obscure, contexts.
                  </li>
                  <li>
                    C++ inherits base implementations, which become part of the memory
                    footprint of class instances. If the class is to be copied, these
                    base parts must also be copied.  It is standard practice to use the
                    base copy operations to copy its content into the copy&apos;s destination.
                    <div style="height:0.5em;"></div>
                    Point4D has no base classes, so we don&apos;t see code that copies
                    base parts. That is illustrated by code in the 
                    <a target="_blank" href="https://jimfawcett.github.io/CompoundObjects.html">
                      CompoundObjects Repository
                    </a>
                  </li>
                  <li>
                    An example definition of all of the special class methods is given in
                    the <a target="_blank" href="../../StrCode.html">STR class</a> web page.
                  </li>
                </ol>
              </t-b>
            </div>
          </div>
          <div style="height:1em;"></div>
          <h3 id="source">1.2 Bits_Objects.cpp - Include declarations</h3>
          <t-b style="margin-bottom:1em;">
            This block presents code that declares library include declarations
            and a declaration used to define a shorter alias for a template type.
          </t-b>
          <t-b>
            Source code is available
            <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
            Download the entire Bits repository
            <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
          </t-b>
          <div class="blockSingle">
            <div class="codewrap" style="float:left; width:60%;">
              <pre style="font-size:1.0em; margin-right:0.75em;"><code class="language-cpp">
/*------------------------------------------------          
  Cpp_Objects.cpp
  - depends on user-defined point class in Points.h
  - depends on several display and analysis functions
    in Analysis.h
*/
#include &lt;iostream&gt;     // std::cout
#include &lt;memory&gt;       // std::unique_ptr
#include &lt;vector&gt;       // vector&lt;T&gt; class
#include &lt;array&gt;        // array&lt;T&gt; class
#include &lt;map&gt;          // map&lt;K,V&gt; class
#include &lt;set&gt;          // set&lt;T&gt; class
#include &quot;Analysis.h&quot;   // Analysis functions
#include &quot;Points.h&quot;     // Point4D class declaration
/*
  This demo uses the std::string and std::vector&lt;T&gt; 
  classes and a user defined class, Point4D, to 
  illustrate how objects are defined and instantiated.

  Operations:
    All the classes discussed here provide operations:
      T t2 = t1          // copy construction
      T t3 = temporary   // move construction
      t1 = t2            // copy assignment
      t3 = temporary     // move assignment

    All instances return their resources when they
    go out of scope by implicitly calling their 
    destructor.
    
    Primitive types can all be copied.

    Most library and user-defined types can be copied, 
    moved, and deleted by providing member constructors 
    and destructor.
    
    Often compiler generation of these methods works
    well, but for classes with pointer members devs
    must provide them.

  Processing:
    All types are static, operations run as native code, 
    and no garbage collection is needed. Resources are 
    returned at end of their declaration scope.
*/
/*-----------------------------------------------
  alias type name
  - pU&lt;T&gt; is the same type as std::unique_ptr&lt;T&gt;
  - this just provides a shorter name
*/
template&lt;typename T&gt;
using pU = std::unique_ptr&lt;T&gt;;
                  </code></pre>
            </div>
            <div class="textwrap">
              <h4>Library declarations:</h4>
              <t-b>
                Code in the left panel begins with a series of #include statements
                that import declarations for the standard library and also for
                two header only libraries defined in other files in this Bit.
              </t-b>
              <t-b>
                The #include declaratons, shown on in the left panel, are being
                superceded by module imports, as of C++20.
              </t-b>
              <t-b>
                For example, all of
                the standard library includes like <c-s>#include &lt;iostream&gt;</c-s>
                are being replaced with a single <c-s>import std;</c-s>. Individual
                libraries can be imported with declarations like:
                <c-s>import &lt;iostream&gt;;</c-s>
              </t-b>
              <t-b>
                These modern declarations are not used in this demonstration because
                I haven&apos;t been able to help CMake find the import libraries provided
                by Visual Studio, which is installed on the machine used to develop all
                this code. They do work with code compiled in the Visual Studio IDE.
              </t-b>
              <t-b>
                This is a temporary setback, awaiting resolution until I have time to
                investigate the problem.  When it is resolved, I will update the code
                here.
              </t-b>
              <h4>Type alias declaration</h4>
              <t-b>
                At the bottom of the block you will find the declaration of an alias
                for a template type. The alias simply provides an shorter name for the
                type, but is otherwise equivalent.
              </t-b>
            </div>
          </div>
          <h3 id="libtyp">1.3 Bits_Objects.cpp - Declaration and use of std::library types</h3>
          <t-b>
            This block presents creation and use of instances of std library types.
            It&apos;s provided here for comparison with the code for user-defined
            type Point4D.
          </t-b>
          <t-b>
            Here you see a side-by-side view of executable code with the output
            it provides. That proximity makes it easier to understand how the code works.
          </t-b>
          <t-b>
            Source code is available
            <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
            Download the entire Bits repository
            <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
          </t-b>
          <div class="blockSingle" style="padding:0em;">
            <splitter-container id="container">
              <first-item id="fig2-first" style="width:52%; padding-right:0.5em;">
                <div class="codewrap">
                  <pre><code class="language-cpp">/*-------------------------------------------------------------------                              
  Demonstration starts here
*/
int main() {

    print(&quot;Demonstrate C++ Objects&#92;n&quot;);

    showNote(&quot;std library types string and vector&lt;T&gt;&quot;);

    /* create and display std::string object */
    auto str = std::string(&quot;&#92;&quot;Wile E. Coyote&#92;&quot;&quot;);
    auto out = std::string(&quot;contents of str = &quot;) + str;
    print(out);
    print(&quot;--- showType(str, &#92;&quot;str&#92;&quot;); ---&quot;);
    showType(str, &quot;str&quot;, nl);

    /* create and display std::vector&lt;double&gt; */
    auto vec = std::vector&lt;double&gt;{ 3.5, 3, 2.5, 2 };
    showOp(&quot;showType(vec, &#92;&quot;vec&#92;&quot;);&quot;);
    showType(vec, &quot;vec&quot;);
    std::cout &lt;&lt; &quot;&#92;n  vec:&quot; &lt;&lt; vec;
    // equivalent to:
    // operator&lt;&lt;(operator&lt;&lt;(std::cout, &quot;&#92;n  vec:&quot;), vec);
    // uncomment the preceeding line to see the output repeated

    showOp(&quot;vec[2] = -2.5;&quot;);
    vec[2] = -2.5;
    std::cout &lt;&lt; &quot;&#92;n  vec:&quot; &lt;&lt; vec;

    showOp(&quot;auto vec2 = vec : copy construction&quot;);
    /* copy construction */
    auto vec2 = vec;
    std::cout &lt;&lt; &quot;&#92;n  vec2:&quot; &lt;&lt; vec2;

    showOp(&quot;vec2[0] = 42;&quot;);
    vec2[0] = 42;
    std::cout &lt;&lt; &quot;&#92;n  vec2: &quot; &lt;&lt; vec2;
    std::cout &lt;&lt; &quot;&#92;n  vec: &quot; &lt;&lt; vec;

    showNote(
      &quot;Copy construction, auto vec2 = vec, creates&#92;n    &quot;
      &quot;independent instance. So changing target vec2&#92;n    &quot;
      &quot;has no affect on source vec.&quot;
    );

    showOp(&quot;vec = vec2 : copy assignment&quot;);
    vec = vec2;
    // equivalent to:
    // vec.operator=(vec2);
    // uncomment the preceeding line and observe no change
    std::cout &lt;&lt; &quot;&#92;n  vec: &quot; &lt;&lt; vec &lt;&lt; &quot;&#92;n&quot;;

</code></pre>
                </div>
              </first-item>
              <splitter-bar id="fig2-seperator"></splitter-bar>
              <second-item id="fig2-second" style="width:48%; padding-right:0.5em;">
                <div class="codewrap">
                  <pre><code class="language-shell">
                  


Demonstrate C++ Objects

--------------------------------------------------                                        
  std library types string and vector&lt;T&gt;
--------------------------------------------------
contents of str = &quot;Wile E. Coyote&quot;
--- showType(str, &quot;str&quot;); ---
str type: class std::basic_string&lt;char,struct std:...
size:  40

vector&lt;T&gt;: {
  3.5, 3, 2.5, 2
}
--- showType(vec, &quot;vec&quot;); ---
vec type: class std::vector&lt;double,class std::allo...
size:  32

--- vec[2] = -2.5; ---
vec:
vector&lt;T&gt;: {
  3.5, 3, -2.5, 2
}
--- auto vec2 = vec : copy construction ---
vec2:
vector&lt;T&gt;: {
  3.5, 3, -2.5, 2
}
--- vec2[0] = 42; ---
vec2:
vector&lt;T&gt;: {
  42, 3, -2.5, 2
}
vec:
vector&lt;T&gt;: {
  3.5, 3, -2.5, 2
}
--------------------------------------------------
  Copy construction, auto vec2 = vec, creates
  independent instance. So changing target vec2
  has no affect on source vec.
--------------------------------------------------
  --- vec = vec2 : copy assignment ---
  vec: [42, 3, -2.5, 2]




                  </code></pre>
                </div>
              </second-item>
            </splitter-container>
          </div>
          <h3 id="usrdef">1.4 Bits_Objects.cpp - User-defined type Point4D</h3>
          <t-b>
            The block below illustrates construction and operations of instances of
            the user-defined Point4D class.
          </t-b>
          <t-b>
            The void constructor, one with no arguments, is defined immediately below
            the Point4D class declaration.  All other operations, e.g., copy construction,
            assignment, and destruction are implemented by the compiler, using element-wise
            operations. That is, for copy construction, the compiler generated code uses the
            copy construction code for each element.
          </t-b>
          <t-b>
            Source code is available
            <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
            Download the entire Bits repository
            <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
          </t-b>
          <div class="blockSingle" style="padding:0em;">
            <splitter-container id="container">
              <first-item id="fig3-first" style="width:52%; margin-right:0.5em;">
                <div class="codewrap">
                  <pre><code class="language-cpp">/*------------------------------------------------*/                                        
  showNote(&quot;user-defined type Point4D&quot;);
  Point4D p1;
  p1.show();
  p1.xCoor() = 42;
  p1.zCoor() = -3.5;
  /*- t contains time of construction -*/
  p1.show();
  print();

  print(&quot;--- showType(p1, &#92;&quot;p1&#92;&quot;, nl) ---&quot;);
  showType(p1, &quot;p1&quot;, nl);
  std::cout &lt;&lt; &quot;  p1.xCoor() returns value &quot;
  &lt;&lt; p1.xCoor() &lt;&lt; &quot;&#92;n&quot;;

  showOp("Point4D p2 = p1 : copy construction");
  Point4D p2 = p1;  // copy construction
  p2.show();

  showOp("p2.xCoor() *= 2");
  p2.xCoor() *= 2;
  p2.show();

  showOp("p1 = p2 : copy assignment");
  p1 = p2;  // copy assignment
  p1.show();






</code></pre>
                </div>
              </first-item>
              <splitter-bar id="fig3-seperator"></splitter-bar>
              <second-item id="fig3-second" style="width:48%; margin-right:0.5em;">
                <div class="codewrap">
                  <pre><code class="language-shell">--------------------------------------------------
  user-defined type Point4D
--------------------------------------------------                                
  Point4D {
    0, 0, 0,
    Mon May  1 16:04:27 2023
  }
  Point4D {
    42, 0, -3.5,
    Mon May  1 16:04:27 2023
  }

  --- showType(p1, &quot;p1&quot;, nl) ---
  p1 type: class Point4D
  size:  32
  p1.xCoor() returns value 42

    --- Point4D p2 = p1 : copy construction---
  Point4D {
    42, 0, -3.5,
    Thu Dec  7 19:34:59 2023
  }
  --- p2.xCoor() *= 2 ---
  Point4D {
    84, 0, -3.5,
    Thu Dec  7 19:34:59 2023
  }
  --- p1 = p2 : copy assignment ---
  Point4D {
    84, 0, -3.5,
    Thu Dec  7 19:34:59 2023
  }
</code></pre>
                </div>
              </second-item>
            </splitter-container>
          </div>
          <h3 id="heap">1.5 Bits_Objects.cpp - Heap-based operations</h3>
          <t-b>
            C++ code does not use a garbage collector to support creating and releasing
            memory allocations. Therefore class designers must manage those operations.
          </t-b>
          <h3 id="heapstr">1.5.1 Managing std::String instances in the native heap</h3>
          <t-b>
            This block illustrates how that is done for instances of the std::String class,
            using the <c-s>std::unique_ptr&lt;T&gt;</c-s>.
          </t-b>
          <t-b>
            <c-s>std::unique_ptr&lt;T&gt;</c-s> instances are smart pointers that mimic standard
            C++ pointer operations, e.g., same interface for pointer operations, but automatically
            call delete on their internal pointer to heap instance when they go out of scope.
          </t-b>
          <t-b>
            That returns the allocation for future use by another program operation.
          </t-b>
          <t-b>
            Source code is available
            <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
            Download the entire Bits repository
            <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
          </t-b>
          <div class="blockSingle" style="padding:0em;">
            <splitter-container id="container">
              <first-item id="fig4-first" style="width:52%;margin-right:0.5em;">
                <div class="codewrap">
                  <pre><code class="language-cpp">
  /*------------------------------------------------*/                                        
  showNote(&quot;heap-based string instance&quot;);

  /* standard library type std::string */
  /* uses alias pU for std::unique_ptr */
  showOp(
  &quot;pU&lt;std::string&gt; &quot;
  &quot;pStr(new std::string(&#92;&quot;&#92;&#92;&#92;&quot;Road Runner&#92;&#92;&#92;&quot;&#92;&quot;)&quot;
  );
  pU&lt;std::string&gt; pStr(
  new std::string(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;)
  );
  std::cout &lt;&lt; &quot;&#92;n  pStr contents = &quot;
  &lt;&lt; *pStr &lt;&lt; &quot;&#92;n&quot;;

  showOp(&quot;showType(*pStr, &#92;&quot;*pStr&#92;&quot;)&quot;);
  showType(*pStr, &quot;*pStr&quot;, nl);

  /* std::unique_ptr&lt;T&gt; cannot be copied
  but can be moved */
  showOp(&quot;showType(move(pStr), &#92;&quot;pStr&#92;&quot;)&quot;);
  showType(move(pStr), &quot;pStr&quot;, nl);

  // showType(pStr, &quot;pStr&quot;) is an illegal call
  // since pStr cannot be copied to preserve uniqueness

</code></pre>
                </div>
              </first-item>
              <splitter-bar id="fig4-seperator"></splitter-bar>
              <second-item id="fig4-second" style="width:48%; margin-right:0.5em;">
                <div class="codewrap">
                  <pre><code class="language-shell">--------------------------------------------------
  heap-based string instance
--------------------------------------------------                                        
--- pU&lt;std::string&gt; pStr(new std::string(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;) ---
pStr contents = &quot;Road Runner&quot;

--- showType(*pStr, &quot;*pStr&quot;) ---
*pStr type: class std::basic_string&lt;char,struct std:...
size:  40

--- showType(move(pStr), &quot;pStr&quot;) ---
pStr type: class std::unique_ptr&lt;class std::basic_s...
size:  8














</code></pre>
                </div>
              </second-item>
            </splitter-container>
          </div>
          <h3 id="heapvec">1.5.2 Bits_Objects.cpp - Heap-based operations for std::Vector&lt;T&gt;</h3>
          <t-b>
            The code below substitutes <c-s>std::Vector&lt;T&gt;</c-s> for
            <c-s>std::String</c-s> in the code above.  The operation syntax is the
            same.  We show here that the address of the heap object is returned by
            sending the pointer to standard output, just like native pointers.
          </t-b>
          <t-b>
            Source code is available
            <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
            Download the entire Bits repository
            <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
          </t-b>
          <div class="blockSingle" style="padding:0em;">
            <splitter-container id="container">
              <first-item id="fig5-first" style="width:52%; margin-right:0.5em;">
                <div class="codewrap">
                  <pre><code class="language-cpp">/*------------------------------------------------*/                                         
    /* standard library type std::vector&lt;T&gt; */
    showNote(&quot;heap-based vector instance&quot;);
    showOp(
      &quot;pU&lt;std::vector&lt;double&gt;&gt;&#92;n &quot;
      &quot;     pVec(
              new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }
            );&quot;
    );
    pU&lt;std::vector&lt;double&gt;&gt; pVec(
      new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }
    );
    std::cout &lt;&lt; &quot;&#92;n  *pVec = &quot; &lt;&lt; *pVec;
    showType(*pVec, &quot;*pVec&quot;, nl);
    std::cout &lt;&lt; &quot;&#92;n  pVec = &quot; &lt;&lt; pVec;
    showType(move(pVec), &quot;move(pVec)&quot;, nl);
                  </code></pre>
                </div>
              </first-item>
              <splitter-bar id="fig5-seperator"></splitter-bar>
              <second-item id="fig5-second" style="width:48%; margin-right:0.5em;">
                <div class="codewrap">
                  <pre><code class="language-cpp">--------------------------------------------------
  heap-based vector instance
--------------------------------------------------                                        
--- pU&lt;std::vector&lt;double&gt;&gt;
    pVec(new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }); ---
*pVec =
vector&lt;T&gt;: {
  1.5, 2.5, 3.5
}
*pVec type: class std::vector&lt;double,class std::allo...
size:  32

pVec = 000002897B682AC0
move(pVec) type: class std::unique_ptr&lt;class std::vector&lt;...
size:  8


</code></pre>
                </div>
              </second-item>
            </splitter-container>
          </div>
          <h3 id="heappt">1.5.3 Bits_Objects.cpp - Heap-based operations for user-defined Point4D</h3>
          <t-b>
            Using the same plan for execution as in the two blocks above, we see that
            all the methods of the heap-based Point4D instance are accessible using
            pointer operations, e.g., <c-s>std::unique_ptr&lt;T&gt;</c-s> uses the same
            pointer syntax for operations as the native C++ pointer.
          </t-b>
          <t-b>
            Source code is available
            <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
            Download the entire Bits repository
            <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
          </t-b>
          <div class="blockSingle" style="padding:0em;">
            <splitter-container id="container">
              <first-item id="fig6-first" style="width:52%;margin-right:0.5em;">
                <div class="codewrap">
                  <pre><code class="language-cpp">/*------------------------------------------------*/                                        
    /* custom point types */
    showNote(&quot;heap-based Point4D instance&quot;);
    showOp(&quot;pU&lt;Point4D&gt; pPoint4D(new Point4D())&quot;);
    pU&lt;Point4D&gt; pPoint4D(new Point4D());
    pPoint4D-&gt;show();
    pPoint4D-&gt;xCoor() = 1;
    pPoint4D-&gt;yCoor() = 2;
    pPoint4D-&gt;zCoor() = -3;
    pPoint4D-&gt;updateTime();
    pPoint4D-&gt;show();

    std::cout &lt;&lt; &quot;&#92;n  pPoint4D-&gt;zCoor() = &quot; 
              &lt;&lt; pPoint4D-&gt;zCoor();
    showOp(&quot;showType(*pPoint4D, &#92;&quot;*pPoint4D&#92;&quot;);&quot;);
    showType(*pPoint4D, &quot;*pPoint4D&quot;);
    showOp(
      &quot;showType(std::move(pPoint4D), &#92;&quot;pPoint4D&#92;&quot;);&quot;
    );
    showType(std::move(pPoint4D), &quot;pPoint4D&quot;, nl);
    /* pPoint4D moved, so now invalid */

    print(&quot;&#92;n  That's all Folks!&#92;n&#92;n&quot;);
}
</code></pre>
                </div>
              </first-item>
              <splitter-bar id="fig6-seperator"></splitter-bar>
              <second-item id="fig6-second" style="width:48%; margin-right:0.5em;">
                <div class="codewrap">
                  <pre><code class="language-cpp">--------------------------------------------------
  heap-based Point4D instance
--------------------------------------------------                                        
--- pU&lt;Point4D&gt; pPoint4D(new Point4D()) ---
Point4D {
  0, 0, 0,
  Mon May  1 16:04:27 2023
}
Point4D {
  1, 2, -3,
  Mon May  1 16:04:27 2023
}
pPoint4D-&gt;zCoor() = -3
--- showType(*pPoint4D, &quot;*pPoint4D&quot;); ---
*pPoint4D type: class Point4D
size:  32
--- showType(std::move(pPoint4D), &quot;pPoint4D&quot;); ---
pPoint4D type: class std::unique_ptr&lt;class Point4D,stru...
size:  8


That's all Folks!


</code></pre>
                </div>
              </second-item>
            </splitter-container>
          </div>
          <!--                 <div class="textwrap" style="overflow-y:auto;">
                   <t-b>
                     Cpp_Objects.cpp is the code executive, loading PointsObj.h and AnalysisObj.h,
                     and using standard libraries loaded at the beginning of the file.
                   </t-b>
                   <hr />
                   <t-b>
                     This example uses some of the facilities of std::C++20, but does not use
                     modules.  I was unable to get CMake to sucessfully build the program with
                     module imports instead of #includes.
                   </t-b>
                   <t-b>
                     This appears to be an issue with
                     CMake, or my CMakeLists.txt file, not the Visual Studio compiler that CMake loads.
                     I will be looking into that evenutally and will update this example at that time.
                   </t-b>
                   <hr />
                   <t-b>
                     The demonstrations are entirely contained in the function <c-s>main()</c-s>, but
                     use the <c-s>Point4D</c-s> type from PointsObj.h and several functions from
                     AnalysisObj.h.
                   </t-b>
                   <t-b>
                     First, a <c-s>std::string</c-s> and <c-s>std::vector&lt;double&gt;</c-s> are used
                     to create instances initialized with specific values.
                   </t-b>
                   <t-b>
                     Then values of the instances are displayed. That uses a standard overload of the
                     stream insertion operator <c-s>operator&lt;&lt;</c-s> for <c-s>std::string</c-s>
                     and an overload of the same operator for <c-s>std::vector&lt;T&gt;</c-s> provided
                     at the beginning of AnalysisObj.h.
                   </t-b>
                   <t-b>
                     Then the inferred type name and type size are shown for each with
                     <c-s>showType&lt;T&gt;(T&nbsp;t,&nbsp;...)</c-s>.
                   </t-b>
                   <hr />
                   <t-b>
                     The <c-s>std::vector&lt;double&gt;</c-s> is modified and displayed, then copied with
                     the vector copy constructor via the expression <c-s>auto vec2 = vec</c-s>. This
                     expression implicitly invokes the <c-s>vector&lt;double&gt;</c-s> copy constructor to
                     create the instance <c-s>vec2</c-s>.
                   </t-b>
                   <t-b>
                     Note that no assignment or void construction is
                     called. You may wish to verify this by walking through the code from the
                     <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects">
                       Bits Repository
                     </a> using VS Code.
                   </t-b>
                   <div style="height:0em;"></div>
                 </div>
  -->
          <div style="height:1em;"></div>
          <h3 id="analysis">1.6 AnalysisObj.h - Analysis and Display Functions</h3>
          <t-b style="margin-bottom:1em;">
            This block presents code for analysis and display of C++ objects. The source code
            is available
            <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
            Download the entire Bits repository
            <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
          </t-b>
          <div class="blockSingle">
            <div class="codewrap" style="width:max-content; float:left;">
              <pre><code class="language-cpp">/*---------------------------------------------------------
  AnalysisObj.h
  - Provides functions that analyze types, display results
    and other program defined information.
  - Some of this code requires complex template operations.
    Those will be discussed in the generics bit.
  - You can skip the hard parts until then, without loss
    of understanding.
*/

#include &lt;typeinfo&gt;     // typeid
#include &lt;utility&gt;      // move()
#include &lt;sstream&gt;      // stringstream
#include &lt;type_traits&gt;  // is_scalar, if constexpr
#include &lt;iostream&gt;     // cout
#include &lt;vector&gt;       // vector

/*---------------------------------------------------------
  Display and Analysis function and globals definitions
-----------------------------------------------------------
*/
const std::string nl = &quot;&#92;n&quot;;
/*---------------------------------------------------------
  Mutable globals are a common source of bugs.  We try not
  to use them, but will use DisplayParams here to control
  how insertion operator sends instances to std output.

  Only the trunc variable is used in this demo. The others
  will be used in the Bits_GenericCpp demo.
*/
struct displayParams {
  size_t left = 2;    // number of spaces to indent
  size_t width = 7;   // width of display row
  size_t trunc = 40;  // replace text after trunc with ...
} DisplayParams;      // global object

/*-----------------------------------------------
  Display text after newline and indentation
*/
inline void print(const std::string& txt = &quot;&quot;) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt;
}
/*-----------------------------------------------
  Display text after newline and indentation
  - provides trailing newline
*/
inline void println(const std::string& txt = &quot;&quot;) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt &lt;&lt; &quot;&#92;n&quot;;
}
/*-----------------------------------------------
  Overload operator&lt;&lt; required for
  showType(std::vector&lt;T&gt; v, const std::vector&lt;T&gt;& nm)
*/
template&lt;typename T&gt;
std::ostream& operator&lt;&lt; (
  std::ostream& out, const std::vector&lt;T&gt;& vec
) {
    out &lt;&lt; &quot;[&quot;;
    for (auto it = vec.begin(); it != vec.end(); ++it)
    {
        out &lt;&lt; *it;
        if (it != vec.end() - 1)
            out &lt;&lt; &quot;, &quot;;
    }
    out &lt;&lt; &quot;]&quot;;
    return out;
}
/*-----------------------------------------------
  Display emphasized text
*/
inline void showNote(
  const std::string& txt, const std::string& suffix = &quot;&quot;
) {
  print(&quot;--------------------------------------------------&quot;);
  print(&quot;  &quot; + txt);
  print(&quot;--------------------------------------------------&quot;);
  std::cout &lt;&lt; suffix;
}
/*-----------------------------------------------
  Display emphasized line
*/
inline void showOp(
  const std::string& opstr, const std::string& suffix = &quot;&quot;
) {
  std::cout &lt;&lt; &quot;&#92;n  --- &quot; &lt;&lt; opstr &lt;&lt; &quot; ---&quot; &lt;&lt; suffix;
}
/*-----------------------------------------------
  Helper function for formatting output
  - truncates line to N chars and adds ellipsis
*/
inline std::string truncate(size_t N, const char* pStr) {
  std::string temp(pStr);
  if(temp.length() &gt; N) {
    temp.resize(N);
    return temp + &quot;...&quot;;
  }
  return temp;
}
/*-----------------------------------------------
  Helper function for formatting output
  - generates string of n blanks to offset text
*/
inline std::string indent(size_t n) {
  return std::string(n, ' ');
}
/*-----------------------------------------------
  Display calling name, static class, and size
*/
template&lt;typename T&gt;
void showType(
  T t, const std::string &callname,
  const std::string& suffix = &quot;&quot;
) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; callname;  // show name at call site
  std::cout &lt;&lt; &quot; type: &quot;
            &lt;&lt; truncate(DisplayParams.trunc,typeid(t).name());
  std::cout &lt;&lt; &quot;&#92;n  size:  &quot; &lt;&lt; sizeof(t);  // show size on stack
  std::cout &lt;&lt; suffix;
}
/*-----------------------------------------------
  Format output for scalar types like primitives
*/
template&lt;typename T&gt;
std::string formatScalar(
  const T& t, const std::string& nm,
  const std::string& suffix = &quot;&quot;,
  size_t left = 2
) {
  std::stringstream out;
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: &quot; &lt;&lt; t &lt;&lt; suffix;
  return out.str();
}
/*-----------------------------------------------
  Format output for strings
  - indent and embed in quotation marks
*/
template&lt;typename T&gt;
std::string formatString(
  const T& t, const std::string& nm,
  const std::string& suffix = &quot;&quot;,
  size_t left = 2
) {
  std::stringstream out;
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm
      &lt;&lt; &quot;: &#92;&quot;&quot; &lt;&lt; t &lt;&lt; &quot;&#92;&quot;&quot; &lt;&lt; suffix;
  return out.str();
}
</code></pre>
            </div>
            <div class="textwrap">
              <h4>Analysis and Display</h4>
              <t-b>
                This code block contains definitions of ten functions, four of which
                are templates.  If this seems too complex for you right now, you don&apos;t
                have to understand them completely to understand this Bits demo.
              </t-b>
              <t-b>
                You are invited to skim over the definitions to try to understand what they
                do, not so much how they do it. You can come back later to pick up any missing
                details.
              </t-b>
              <t-b>
                The next <a target="_blank" href="Bits_GenericCpp.html">Bit</a>
                will explore generics and will help you understand how these functions
                work.
              </t-b>
              <h4>Template functions:</h4>
              <t-b>
                <t-b>
                  Template functions are code generators that create code for specific template argument
                  types using the template pattern.
                </t-b>
                <t-b>
                  In the code blocks above you have seen <c-s>showType(T t, ...)</c-s> used
                  where <c-s>std::String</c-s>s, <c-s>std::Vector</c-s>s, and instances of <c-s>Point4D</c-s> are substitued
                  for the template argument <c-s>T</c-s>.
                </t-b>
                <t-b>
                  That creates function overloads for each T argument, e.g., three distinct
                  functions generated from a single template function definition.
                </t-b>
              </t-b>
              <t-b>
                <c-s>showType(T t, ...)</c-s> is the only analysis function in this file. The
                next <a target="_blank" href="Bits_GenericCpp.html">Bit</a> will add several more.
              </t-b>
              <t-b>
                The other functions simply format and display their instance arguments, or provide helper
                activities for display.
              </t-b>
              <!--<h4>Template Functions supporting display of collections:</h4>
              <t-b>
                <c-s>formatColl&lt;T&gt;(const T&t, ...)</c-s> displays enumerable collections like
                <c-s>std::Vector&lt;T&gt;</c-s> for any of the types usually contained in a vector.
              </t-b>
              <t-b>
                Functions <c-s>indent</c-s> and <c-s>fold</c-s> are helpers for displaying
                collections.
              </t-b>
              <t-b>
                Unlike Rust and C#, you don&apos;t have to provide constraints on
                template parameters.  C++ uses lazy type checking on templates so code
                using a compilable template library may fail when the template is supplied
                with a specific type.
              </t-b>
              <t-b>
                Second-stage compile errors often create long and hard to interpret error
                messages.  C++20 introduced concepts to improve error messaging. For
                simplicity this code does not use C++ concepts.
              </t-b>
              <h4>Template MetaProgramming</h4>
              <t-b>
                Template MetaProgramming is an advanced template technique that uses
                functional programming to evaluate constexpr expressions at compile-time.
                That makes it relatively easy to build template functions as a collection
                of template function parts.
              </t-b>
              <t-b>
                That sounds complicated, but if you scan <c-s>format&lt;T&gt;</c-s> you
                will see a quite general function being constructed from more specific
                parts.
              </t-b>
              <h4>Other Functions</h4>
              <t-b>
                Most of the remaining functions are simple display operations like
                <c-s>showNote</c-s>, <c-s>showOp</c-s>, and <c-s>showType</c-s>.
              </t-b>-->
            </div>
            <div>
            <table style="width:40%; float:right;">
              <tr>
                <th>function</th>
                <th>operation</th>
              </tr>
              <tr>
                <td>
                  print
                </td>
                <td>
                  display string argument after newline and indent
                </td>
              </tr>
              <tr>
                <td>
                  println
                </td>
                <td>
                  print with a trailing newline
                </td>
              </tr>
              <tr>
                <td>
                  operator&lt;&lt;
                </td>
                <td>
                  insert text repr of object into stream
                </td>
              </tr>
              <tr>
                <td>
                  showNote
                </td>
                <td>
                  display block of text encased in horizontal lines
                </td>
              </tr>
              <tr>
                <td>
                  showOp
                </td>
                <td>
                  display --- short text ---
                </td>
              </tr>
              <tr>
                <td>
                  truncate
                </td>
                <td>
                  clip string to n chars followed by ellipsis
                </td>
              </tr>
              <tr>
                <td>
                  indent
                </td>
                <td>
                  create string of n spaces
                </td>
              </tr>
              <tr>
                <td>
                  showType
                </td>
                <td>
                  display compiler&apos;s repr of type of T
                </td>
              </tr>
              <tr>
                <td>
                  formatScalar
                </td>
                <td>
                  return string with name : value
                </td>
              </tr>
              <tr>
                <td>
                  formatString
                </td>
                <td>
                  return string with name : &quot;value&quot;
                </td>
              </tr>
            </table>
            </div>
            <!--           <div id="fcode1" class="txt">
                <t-b>
                  C++ requires functions and classes to be declared before use in compile scan order.
                  In order to define analysis functions that may use other analysis functions, without
                  maintaining a strict definition order, we provide declarations for all here.
                </t-b>
                <t-b>
                  Several of the functions are templates, which we have not covered yet. It is sufficient
                  to have a rough idea of how they work for this demo.  We will cover template details
                  in the next Bit.
                </t-b>
              </div>
              <div id="fcode2" class="txt">
                <t-b>
                  The insertion operator <c-s>std::ostream& operator&lt;&lt;(std::ostream& out, T&amp; t)</c-s>
                  sends a text representation of t to the std::ostream.
                </t-b>
                <t-b>
                  Here we are overloading this
                  std global function to accept an argument of type <c-s>std::vector&lt;T&gt;&amp;</c-s>.  It parses that into parts that
                  the <c-s>std::operator&lt;&lt;</c-s> knows how to handle.
                </t-b>
                <t-b>
                  This definition uses function <c-s>std::string format(const T&amp; t, ...)</c-s>, to
                  represent the vector as rows of its internal data, and is defined
                  below.  <c-s>format</c-s> uses some advanced template processing so we defer discussing its
                  implementation to the next Bit.
                </t-b>
              </div>
              <div id="fcode3" class="txt">
                <t-b>
                  <c-s>showType(T t, ...)</c-s> uses C++ <c-s>typeid(t)</c-s>, a weak form of reflection,
                  to retrieve the class name and <c-s>sizeof(t)</c-s> to measure the size of t in
                  the stack.  Any part of t that lies in the heap is not measured by this invocation.
                </t-b>
                <t-b>
                  Type names are often long for template types, so we truncate the name string to
                  the value of <c-s>DisplayParams.trunc</c-s> which is 40 bytes by default. That is
                  usually long enough to get most of the information delivered in the type name.
                </t-b>
              </div>
              <div id="fcode31" class="txt">
                <t-b>
                  <c-s>std::stringstream</c-s> is a wrapper around an in-memory std::string.
                  Its contents are managed just like a <c-s>std::stream</c-s> with insertions,
                  &quot;&lt;&lt;&quot;.  The internal string is retrieved by invoking the member
                  function <c-s>str()</c-s>.
                </t-b>
                <t-b>
                  The <c-s>std::stringstream</c-s> objects make it simple to assemble a string
                  from parts, as we do in this <c-s>fold</c-s> function.
                </t-b>
              </div>
              <div id="fcode4" class="txt">
                <t-b>
                  <c-s>formatColl(const Coll&amp; c, ...)</c-s> works for any collection that provides
                  <c-s>std::Iterator begin()</c-s> and <c-s>std::Iterator end()</c-s> functions. All of
                  the std template library containers do that.
                </t-b>
                <t-b>
                  So this function works for
                  sequential containers like <c-s>std::vector&lt;T&gt;</c-s> and associative containers
                  like <c-s>std::unordered_map&lt;K,V&gt;</c-s>.
                </t-b>
              </div>
              <div id="fcode5" class="txt">
                <t-b>
                  This template struct uses template-meta-programming to decide, at compile time,
                  if a template time is iterable, e.g., it provides <c-s>std::Iterator begin()</c-s> and
                  <c-s>std::Iterator end()</c-s> functions.
                </t-b>
                <t-b>
                  It is used to decide, at compile-time, which format function to call in the function
                  <c-s>std::string format(Const T&amp; t, ...)</c-s>. So <c-s>format</c-s> works for
                  many different kinds of collections. That generality makes the code simpler and
                  easier to maintain.
                </t-b>
              </div>
     -->
          </div>
          <div style="height:1em;"></div>
          <div class="clear"></div>
          <details id="build">
            <summary class="darkItem">Build&nbsp;&nbsp;</summary>
            <div class="blockSingle">
              <pre class="codeSnap">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build
&gt; cmake ..
-- Building for: Visual Studio 17 2022
-- Selecting Windows SDK version 10.0.22000.0 to target Windows 10.0.22621.
-- The C compiler identification is MSVC 19.34.31942.0
-- The CXX compiler identification is MSVC 19.34.31942.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933/bin/Hostx64/x64/cl.exe - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933/bin/Hostx64/x64/cl.exe - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: C:/github/JimFawcett/Bits/Cpp/Cpp_Objects/build
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build
&gt; cmake --build .
MSBuild version 17.4.1+9a89d02ff for .NET Framework
  Checking Build System
  Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Obje
  cts/CMakeLists.txt
  Bits_Objects.cpp
  Cpp_Objects.vcxproj -&gt; C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Ob
  jects&#92;build&#92;Debug&#92;Cpp_Objects.exe
  Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Obje
  cts/CMakeLists.txt
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build
&gt;
</pre>
            </div>
          </details>
        </div>
        <h3 id="ide">2.0 Visual Studio Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Cpp\Cpp_Objects.
        </t-b>
        <photosizer-block src="pictures/VS_Code_Cpp_Objects.JPG" width="800" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE</span>
        </photosizer-block>
        <photosizer-block src="pictures/LaunchJSON_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 2. Launch.JSON</span>
        </photosizer-block>
        <photosizer-block src="pictures/VS_Code_Debugging_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 3. Debugging Objects</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
          <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
        </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../CppStoryRepo.html">C++ Story</a>
            </td>
            <td>
              E-book with thirteen chapters covering most of intermediate C++
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../CppBites/CppBites_Intro.html">C++ Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank " href="../../StrCode.Html">STRCode</a>
            </td>
            <td>
              User-defined string type with all standard methods and functions
              documented with: purpose, declaration, definition, invocation, and notes.
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://www.w3schools.com/cpp/default.asp">w3schools&nbsp;tutorial</a>
            </td>
            <td>
              Slow and easy walk throught basics.
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://en.cppreference.com/w/">cppreference.com</a>
            </td>
            <td>
              Very complete reference with lots of details and examples.
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <!-- <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ide">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">bld</a></menu-elem>
        <menu-elem class="secElem"><a href="#out">out</a></menu-elem>
        <menu-elem class="secElem"><a href="#analysis">anal</a></menu-elem>
        <menu-elem class="secElem"><a href="#points">pts</a></menu-elem>
        <menu-elem class="secElem"><a href="#source">src</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">codeSnaps</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections -->
      >
    </main>
    <!-- <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer> -->
  </page-frame>
  <!--<script>
      //let loc = document.getElementById("loc");
      //let fn = window.location.href.split(/\/|\\/).pop();
      //loc.innerHTML = fn;
      for (let x of cars) {
        text += x + " ";
  }
    </script>-->
  <script>
    var scrollables = document.querySelectorAll('.scrollable');
    for (let scrollable of scrollables) {
      //alert('adding listener');
      scrollable.addEventListener('wheel', function (event) {
        var deltaY = event.deltaY;
        var contentHeight = scrollable.scrollHeight;
        var visibleHeight = scrollable.offsetHeight;
        var scrollTop = scrollable.scrollTop;

        if (scrollTop === 0 && deltaY < 0)
          event.preventDefault();
        else if (visibleHeight + scrollTop === contentHeight && deltaY > 0)
          event.preventDefault();
      });
    }
    // https://stackoverflow.com/questions/7600454/how-to-prevent-page-scrolling-when-scrolling-a-div-element
  </script>
  <script>
    onLoadSplitter("fig2");
    onLoadSplitter("fig3");
    onLoadSplitter("fig4");
    onLoadSplitter("fig5");
    onLoadSplitter("fig6");
  </script>
</body>
</html>