<!DOCTYPE html>
<html>
<!--
  Bits_ObjectsCpp.html
-->
<head>
  <title>Bits_Objects C++</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeCpp.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesSplitterBar.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsSplitterBar.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBits.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding: 0.75em 1.5em;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width: 50em;
    }

    #github h2 {
      margin-top: 0.75em;
    }

    #github #pagetitle {
      border: 2px double var(--dark);
      /* line-height:1.5em; */
    }

    #github .hide {
      display: none;
    }

    body {
      position: relative;
      line-height: 1.25em;
    }

    #github .remotebutton {
      padding: 0.25em 0.5em;
    }

    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }

    #github hr.spread {
      margin: 0.75em 0em;
    }

    #github {
      user-select: none;
    }

    .focus {
      padding: 0.5em 1.0em 0.5em 1.0em;
      /*border:1px solid red;*/
    }

    *.focus ul {
      padding-top: -0.5em;
      /*background-color:green;*/
    }

    .cat {
      text-align: left;
      background-color: var(--menu);
    }

    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 1em 1.5em;
      margin-right: 0.5em;
    }

    #github pre {
      overflow-x: auto;
      /* user-select: all; */
    }

    code-style {
      white-space: pre;
      font-family: Consolas;
      font-size: 0.95em;
      font-weight: bold;
    }

    .blockDouble {
      position: relative;
      display: grid;
      grid-template-columns: 1fr 1fr;
      border: 1px solid green;
      overflow-x: auto;
      overflow-y: hidden;
      margin-right: 0.75em;
      padding: 0.75em;
      padding-right: 0em;
    }

    .blockSingle {
      position: relative;
      border: 1px solid green;
      overflow-x: auto;
      overflow-y: hidden;
      margin-right: 0.75em;
      padding: 0.75em;
      padding-right: 0em;
    }

    .codewrap {
      padding: 0.5em;
      padding-right: 0em;
      overflow-y: auto;
      border: 1px dashed blue;
    }

    #github div.block t-b {
      max-width: 100%;
      padding-left: 0.5em;
    }

    .textwrap {
      position: relative;
      padding-right: 1em;
      margin-right: 0.5em;
      overflow-y: scroll;
      border: 1px dashed red;
    }

    table {
      margin-right: 0.75em;
    }

    #github .scrollable {
      overflow: auto;
    }
  </style>
  <style>
    #github .info {
      position: relative;
      top: 0em;
      float: right;
      font-size: large;
      font-weight: bold;
      text-align: center;
      background-color: var(--dark);
      border-radius: 8px;
      color: var(--light);
      width: 1.25em;
      cursor: pointer;
      user-select: none;
    }

    #github .infoKill {
      position: relative;
      top: 0.05em;
      float: right;
      font-size: large;
      font-weight: bold;
      text-align: center;
      background-color: var(--light);
      border-radius: 8px;
      color: var(--dark);
      width: 1.25em;
      cursor: pointer;
      user-select: none;
      margin: 0.25em;
    }

    #github .txt {
      display: none;
      position: absolute;
      right: 4.5em;
      width: 25em;
      z-index: 10;
      color: var(--dark);
      font-size: small;
      background-color: var(--light);
      border: 2px solid var(--dark);
      padding: 0em 0.5em;
      overflow-y:visible;
    }
  </style>
  <script>
    function closeInfos() {
      var elems = document.querySelectorAll('.txt');
      for (let i = 0; i < elems.length; ++i) {
        if (elems[i].style.display === "block") {
          elems[i].style.display = "none";
        }
      }
    }
    function toggleInfo(dst) {
      var elem = document.getElementById(dst);
      if (elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = "block";
      }
      else {
        elem.style.display = "none";
      }
    }
    function toggleInfoRel(src, dst, adj = 0) {
      var txtcont = document.getElementById(dst);
      var elemtop = src.offsetTop;
      txtcont.style.top = parseInt(elemtop - 25 - adj) + 'px';
      var top = txtcont.style.top;
      if (txtcont.style.display === "none" || txtcont.style.display === "") {
        txtcont.style.display = "block";
      }
      else {
        txtcont.style.display = "none";
      }
    }
  </script>
  <script>
    function setScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = main.scrollTop;
      localStorage.setItem('scrollPositionHelloRust', scrollPosition);
      let scroller = document.getElementById("scrollY")
      scroller.innerHTML = Math.trunc(scrollPosition);
    }
    function gotoLastScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = localStorage.getItem('scrollPositionHelloRust');
      if (scrollPosition) {
        main.scrollTo(0, scrollPosition);
      }
      main.addEventListener('scroll', setScroll);
    }
    function load() {
      //initialize();
      gotoLastScroll();
    }
  </script>

  <script>
    function remote() {
      window.open('https://godbolt.org/z/vrn4cP8Yn', '_blank');
    }
  </script>
</head>
<body id="github" onload="load()">

  <a id="Next" href="Bits_GenericCpp.html">Next</a>
  <a id="Prev" href="Bits_DataCpp.html">Prev</a>

  <page-frame>
    <!-- <frame-header>
      <nav id="navbar"></nav>
    </frame-header> -->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits Objects C++</div>
      <div id="modified">11/12/2023</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.750em; width:max-content; height:1.5em;
             text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits: C++ Objects</h1>
            <h3 id="subtitle" class="indent">
              classes and objects for C++ on Windows, macOS, and Linux
            </h3>
          </hgroup>
        </header>
        <t-b id="syn" style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          This page demonstrates uses of C++ User-Defined types and their objects.
          The purpose is to quickly acquire some familiarity with user-defined types
          and their implementations.
          <hr class="spread" />
          <ul>
            <li>
              C++ defines special class methods: copy and move constructors, copy and move
              assignment operators, and other operators for indexing and comparison etc.
            </li>
            <li>
              The compiler will generate constructors and assignment operators if needed and
              not provided by the class.  Those are correct if, and only if, the class&apos;s
              members and bases have correct semantics for those operations.
              For other cases, like pointer members, developers must either implement them or
              prohibit them. We will show how in this example.
            </li>
            <li>
              Also, this is the first set of examples to partition code into several files.
              That supports readability, may improve translation times, and makes maintenance
              significantly easier.
            </li>
          </ul>
          <div style="height:0.5em;"></div>
        </t-b>
        <details id="notes">
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <div style="border:1px solid var(--dark); padding:0em 1em 0.5em; max-width:fit-content;">
            <t-b>
              All of the languages covered in this demonstration support classes<sup>1</sup>.  Each class provides
              a pattern for laying out a memory footprint and defines how data within are accessed.
            </t-b>
            <t-b>
              Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
              is a pattern for defining functions and classes of a specific type.  Thus a generic is a
              pattern for making patterns.
            </t-b>
            <t-b>
              The other two, Python and JavaScript, are dynamically typed and already support defining
              functions and classes that work for multiple types, e.g., no need for generics.
            </t-b>
            <t-b>
              This demonstration illustrates use of classes and objects, which for C++, Rust, and C#,
              are defined in a stackframe or in the heap or both. <strongs>All</strongs> data for Python and JavaScript are
              stored in managed heaps.
            </t-b>
            <t-b>
              A few functions in this code are generic, e.g., have type(s) to be specified by the caller
              at compile time. The next bit explores generics in greater detail with more discussion.
            </t-b>
            <div style="margin:0.25em 1em; font-size:0.85em; max-width:75%;">
              <hr />
              <ol>
                <li>
                  Rust uses structs to implement objects in the same way that the other languages
                  use classes.  Here we will just use the term class for all of them.
                </li>
              </ol>
            </div>
          </div>
        </details>
        <div style="height:0.25em;"></div>
        <t-b>
          The examples below show how to use library and user defined types with emphasis on
          illustrating syntax and basic operations.
        </t-b>
        <div style="height:0.15em;"></div>
        <h3 id="code">1.0 Source Code</h3>
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote()" />
        <t-b>
          Code was presented in the previous Bits using simulated or actual screenshots, including
          syntax highlighting.
        </t-b>
        <t-b>
          This Bit, about objects, needs to cover more code in a single block for continuity. The
          points illustrated are all parts of this larger code body.  For that, syntax highlighting is
          too &quot;noisy&quot; so we use a simpler presentation here.
        </t-b>
        <t-b>
          The source code is available
          <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
          Download the entire Bits repository
          <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
        </t-b>
        <div>
          <div style="height:0.25em;"></div>
          <h4 id="points">1.1 Source Code - PointsObj.h</h4>
          <t-b style="margin-bottom:1em;">
            This block presents code for creation of user-defined C++ objects.
          </t-b>
          <div class="blockSingle">
            <!-- <div class="codewrap scrollable" style="height:35em; overflow-y:auto;"> -->
            <pre class="codeSnap">
/*---------------------------------------------------------
  Points.h defines a space-time point class:
  - Point4D represents points with three double spatial <span class="info" style="float:right;" onclick="toggleInfoRel(this, 'txt0', 20)">?</span>
    coordinates and std::time_t time coordinate.
*/
#pragma warning(disable:4996) // warning about ctime use
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
/*---------------------------------------------------------
  Point4D class represents a point in a 4-Dimensional 
  space-time lattice. Simple enough for illustration, 
  but still useful.

  It declares all of the special class methods, most with
  default qualifiers to indicate that the compiler will
  generate them as needed.

  The word ctor is an abbreviation of constructor and dtor
  an abbreviation for destructor.
*/
class Point4D {  <span class="info" style="float:right;" onclick="toggleInfoRel(this, 'txt1')">?</span>
public:
  Point4D();                              // void ctor
  Point4D(const Point4D& pt) = default;   // copy ctor
  Point4D(Point4D&& pt) = default;        // move ctor
  Point4D& operator=(const Point4D& pt) = default;
                                          // copy assignment
  Point4D& operator=(Point4D&& pt) = default;
                                          // move assignment
  ~Point4D() = default;                   // dtor
  std::string timeToString();
  void updateTime();
  void show();  <span class="info" style="float:right;" onclick="toggleInfoRel(this,'txt2')">?</span>
  double& xCoor() { return x; }
  double& yCoor() { return y; }
  double& zCoor() { return z; }
  std::time_t& tCoor() { return t; }
private:
  double x;
  double y;
  double z;
  std::time_t t;
};

Point4D::Point4D() { <span class="info" style="float:right;" onclick="toggleInfoRel(this, 'txt3')">?</span>
  x = y = z = 0.0;
  t = std::time(0);
}
std::string Point4D::timeToString() {
  return ctime(&t);
  /*
    ctime is depricated due to a thread-safety issue.
    That's not a problem here. Compiler warning
    recommends converting to ctime_s, which, unfortunately
    has a different and awkward interface.
  */
}
void Point4D::updateTime() {
  t = std::time(0);
}

void Point4D::show() {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; &quot;Point4D {&quot;;
  std::cout &lt;&lt; &quot;&#92;n    &quot; 
            &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; &quot;, &quot;;
  std::cout &lt;&lt; &quot;&#92;n    &quot; &lt;&lt; timeToString();
  std::cout &lt;&lt; &quot;  }&quot;;
}

/* required for showType(T t, const std::string& nm) */

std::ostream& operator&lt;&lt;( <span class="info" style="float:right;" onclick="toggleInfoRel(this, 'txt4', 350)">?</span>
  std::ostream& out, Point4D& t1
) {
  out &lt;&lt; &quot;Point4D {&quot;;
  out &lt;&lt; &quot;    &quot; &lt;&lt; t1.xCoor() &lt;&lt; &quot;, &quot; &lt;&lt; t1.yCoor() &lt;&lt; &quot;, &quot;
                &lt;&lt; t1.zCoor() &lt;&lt; std::endl
                &lt;&lt; &quot;    &quot; &lt;&lt; t1.timeToString() &lt;&lt; std::endl
                &lt;&lt; &quot;  }&quot; &lt;&lt; std::endl;
  return out;
}

              </pre>
            <!-- </div> -->
            <!-- <div class="textwrap scrollable" style="height:35em; position:relative; background-color:var(--dark);">
  <span class="infoKill" style="float:left;" onclick="closeInfos()">X</span>
  <h3>Information Canvas</h3> -->
            <div id="txt0" class="txt">
              <t-b>
                This file is a header only library that defines a type, <c-s>Point4D</c-s>, representing
                a point in 3 dimensional space with a forth time dimension.
              </t-b>
              <t-b>
                A sequence of these instances could be used
                to capture flight trajectories for commercial aircraft, for example.
              </t-b>
              <t-b>
                User-defined C++ types are described by classes. A class is a pattern for laying out
                an instance&apos;s data in the stack or heap, and methods that access and modify the data.
              </t-b>
              <t-b>
                Code that implements class methods resides in static memory, and has lifetime essentially
                equal to program lifetime.
              </t-b>
              <t-b>
                Instances, i.e. objects, are created by invoking a constructor method, and are accessed
                and modified by other methods.
              </t-b>
            </div>
            <div id="txt1" class="txt">
              <t-b>
                <c-s>Point4D</c-s> declares all of the C++ special methods: void, copy,
                and move constructors, copy and move assignment, and a destructor.
                All but the void constructor are declared default.
              </t-b>
              <t-b>
                That
                means that the compiler implements them by doing member-wise operations, e.g.,
                the default copy constructor copies each of the class data members and any base
                class instances, using their copy constructors.
              </t-b>
              <t-b>
                Compiler generation works correctly only if all members have correct copy and assignment
                semantics. That is true for all primitive data types and all of the Standard Template
                Library containers, but not true for pointers or handles.
              </t-b>
              <t-b style="color:maroon;">
                All the special methods are described in detail in
                <a target="_blank" href="../../Resources/CppBites/CppBites_STR.html">STR</a>, code for a user-defined
                string class.
              </t-b>
            </div>
            <div id="txt2" class="txt">
              <t-b>
                Methods may be defined inline, like <c-s>xCoor</c-s> and <c-s>tCoor</c-s>.
                Class data, like <c-s>x</c-s> and <c-s>t</c-s>, are declared private so
                they can only be mutated by methods of the class.
              </t-b>
              <t-b>
                Methods like <c-s>xCoor</c-s> that return references allow a class designer
                to selectively expose class data to user modification.
              </t-b>
            </div>
            <div id="txt3" class="txt">
              <t-b>
                Class methods may also be defined outside the bounds of the class declaration,
                as shown for <c-s>Point4D()</c-s>, <c-s>timeToString()</c-s>, et al. Moving all
                complex method definitions below the class declaration makes the class
                interface easier to understand.
              </t-b>
              <t-b>
                Note that doesn&apos;t work for languages like C# and Java.
              </t-b>
            </div>
            <div id="txt4" class="txt">
              <t-b>
                The function:
  <code-style>
  std::operator&lt;&lt;(
    std::ostream&amp; out,
    const T&amp; t
  )
  </code-style>
              sends a text representation of its argument t to the std output stream.  It is
              defined in the std library.
            </t-b>
            <t-b>
              The second argument must
              be one of a common set of types known to the library.
            </t-b>
            <t-b>
              C++ provides a very nice operator syntax that makes the two statements:<code-style>
  --------------------------
  std::operator&lt;&lt;(
    std::cout, x
  );
  --------------------------
  std::cout << x;
  --------------------------
</code-style>
                equivalent.
              </t-b>
              <t-b>
                The function <c-s>operator&lt;&lt;</c-s> is overloaded here to accept a
                <c-s>Point4D</c-s> instance.  It breaks down the instance into parts that
                the <c-s>std::operator&lt;&lt;</c-s> can accept.
              </t-b>
              <t-b>
                This supports statements like <c-s>std::cout &lt;&lt; apoint;</c-s>.
              </t-b>
            </div>
          </div>
          <!--  </div> -->
          <div style="height:1em;"></div>
          <h4 id="source">1.2 Source Code - Bits_Objects.cpp</h4>
          <t-b style="margin-bottom:1em;">
            This block presents code for creating and using C++ objects. The source code
            is available
            <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
            Download the entire Bits repository
            <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
          </t-b>
          <div class="blockSingle">
            <splitter-container id="container">
              <first-item id="fig1-first" style="width:55%;">
                <div class="codewrap">
                  <pre class="codeSnap">/*------------------------------------------------
  Cpp_Objects.cpp
  - depends on user-defined point class in Points.h
  - depends on several display and analysis functions
    in Analysis.h
*/
#include &lt;iostream&gt;     // std::cout
#include &lt;memory&gt;       // std::unique_ptr
#include &lt;vector&gt;       // vector&lt;T&gt; class
#include &lt;array&gt;        // array&lt;T&gt; class
#include &lt;map&gt;          // map&lt;K,V&gt; class
#include &lt;set&gt;          // set&lt;T&gt; class
#include &quot;Analysis.h&quot;   // Analysis functions
#include &quot;Points.h&quot;     // Point4D class declaration
/*
  This demo uses the std::string and std::vector&lt;T&gt; 
  classes and a user defined class, Point4D, to 
  illustrate how objects are defined and instantiated.

  Operations:
    All the classes discussed here provide operations:
      T t2 = t1          // copy construction
      T t3 = temporary   // move construction
      t1 = t2            // copy assignment
      t3 = temporary     // move assignment

    All instances return their resources when they
    go out of scope by implicitly calling their 
    destructor.
    
    Primitive types can all be copied.

    Most library and user-defined types can be copied, 
    moved, and deleted by providing member constructors 
    and destructor.
    
    Often compiler generation of these methods works
    well, but for classes with pointer members devs
    must provide them.

  Processing:
    All types are static, operations run as native code, 
    and no garbage collection is needed. Resources are 
    returned at end of their declaration scope.
*/
#pragma warning(disable: 4984)
  // warns about C++17 extension

/*-----------------------------------------------
  alias type name
  - pU&lt;T&gt; is the same type as std::unique_ptr&lt;T&gt;
  - this just provides a shorter name
*/
template&lt;typename T&gt;
using pU = std::unique_ptr&lt;T&gt;;

/*-----------------------------------------------
  Demonstration starts here
*/
int main() {

    print(&quot;Demonstrate C++ Objects&#92;n&quot;);

    showNote(&quot;std library types string and vector&lt;T&gt;&quot;);

    /* create and display std::string object */
    auto str = std::string(&quot;&#92;&quot;Wile E. Coyote&#92;&quot;&quot;);
    auto out = std::string(&quot;contents of str = &quot;) + str;
    print(out);
    print(&quot;--- showType(str, &#92;&quot;str&#92;&quot;); ---&quot;);
    showType(str, &quot;str&quot;, nl);

    /* create and display std::vector&lt;double&gt; */
    auto vec = std::vector&lt;double&gt;{ 3.5, 3, 2.5, 2 };
    std::cout &lt;&lt; vec;
    showOp(&quot;showType(vec, &#92;&quot;vec&#92;&quot;);&quot;);
    showType(vec, &quot;vec&quot;, nl);

    showOp(&quot;vec[2] = -2.5;&quot;);
    vec[2] = -2.5;
    std::cout &lt;&lt; &quot;&#92;n  vec:&quot; &lt;&lt; vec;

    showOp(&quot;auto vec2 = vec : copy construction&quot;);
    /* copy construction */
    auto vec2 = vec;
    std::cout &lt;&lt; &quot;&#92;n  vec2:&quot; &lt;&lt; vec2;

    showOp(&quot;vec2[0] = 42;&quot;);
    vec2[0] = 42;
    std::cout &lt;&lt; &quot;&#92;n  vec2: &quot; &lt;&lt; vec2;
    std::cout &lt;&lt; &quot;&#92;n  vec: &quot; &lt;&lt; vec;

    showNote(
      &quot;Copy construction, auto vec2 = vec, creates&#92;n&quot;
      &quot;independent instance. So changing target vec2&#92;n&quot;
      &quot;has no affect on source vec.&quot;, nl
    );

    showNote(&quot;user-defined type Point4D&quot;);
    Point4D p1;
    p1.show();
    p1.xCoor() = 42;
    p1.zCoor() = -3.5;
    /*- t contains time of construction -*/
    p1.show();
    print();

    print(&quot;--- showType(p1, &#92;&quot;p1&#92;&quot;, nl) ---&quot;);
    showType(p1, &quot;p1&quot;, nl);
    std::cout &lt;&lt; &quot;  p1.xCoor() returns value &quot;
              &lt;&lt; p1.xCoor() &lt;&lt; &quot;&#92;n&quot;;

    showNote(&quot;heap-based string instance&quot;);

    /* standard library type std::string */
    /* uses alias pU for std::unique_ptr */
    showOp(
      &quot;pU&lt;std::string&gt; &quot;
      &quot;pStr(new std::string(&#92;&quot;&#92;&#92;&#92;&quot;Road Runner&#92;&#92;&#92;&quot;&#92;&quot;)&quot;
    );
    pU&lt;std::string&gt; pStr(
      new std::string(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;)
    );
    std::cout &lt;&lt; &quot;&#92;n  pStr contents = 
      &quot; &lt;&lt; *pStr &lt;&lt; &quot;&#92;n&quot;;

    showOp(&quot;showType(*pStr, &#92;&quot;*pStr&#92;&quot;)&quot;);
    showType(*pStr, &quot;*pStr&quot;, nl);

    /* std::unique_ptr&lt;T&gt; cannot be copied 
       but can be moved */
    showOp(&quot;showType(move(pStr), &#92;&quot;pStr&#92;&quot;)&quot;);
    showType(move(pStr), &quot;pStr&quot;, nl);

    /* standard library type std::vector&lt;T&gt; */
    showNote(&quot;heap-based vector instance&quot;);
    showOp(
      &quot;pU&lt;std::vector&lt;double&gt;&gt;&#92;n &quot;
      &quot;     pVec(
              new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }
            );&quot;
    );
    pU&lt;std::vector&lt;double&gt;&gt; pVec(
      new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }
    );
    std::cout &lt;&lt; &quot;&#92;n  *pVec = &quot; &lt;&lt; *pVec;
    showType(*pVec, &quot;*pVec&quot;, nl);
    std::cout &lt;&lt; &quot;&#92;n  pVec = &quot; &lt;&lt; pVec;
    showType(move(pVec), &quot;move(pVec)&quot;, nl);

    /* custom point types */
    showNote(&quot;heap-based Point4D instance&quot;);
    showOp(&quot;pU&lt;Point4D&gt; pPoint4D(new Point4D())&quot;);
    pU&lt;Point4D&gt; pPoint4D(new Point4D());
    pPoint4D-&gt;show();
    pPoint4D-&gt;xCoor() = 1;
    pPoint4D-&gt;yCoor() = 2;
    pPoint4D-&gt;zCoor() = -3;
    pPoint4D-&gt;updateTime();
    pPoint4D-&gt;show();

    std::cout &lt;&lt; &quot;&#92;n  pPoint4D-&gt;zCoor() = &quot; 
              &lt;&lt; pPoint4D-&gt;zCoor();
    showOp(&quot;showType(*pPoint4D, &#92;&quot;*pPoint4D&#92;&quot;);&quot;);
    showType(*pPoint4D, &quot;*pPoint4D&quot;);
    showOp(
      &quot;showType(std::move(pPoint4D), &#92;&quot;pPoint4D&#92;&quot;);&quot;
    );
    showType(std::move(pPoint4D), &quot;pPoint4D&quot;, nl);
    /* pPoint4D moved, so now invalid */

    print(&quot;&#92;n  That's all Folks!&#92;n&#92;n&quot;);
}
</pre>
                </div>
              </first-item>
              <splitter-bar id="fig1-seperator"></splitter-bar>
              <second-item id="fig1-second" style="width:45%; display:block;">
                <div style="white-space:nowrap; font-size:1.2em; margin:2em 5em;">
                  Output starts below:
                </div>
                <div style="height:69.5em;">&nbsp;</div>
                <pre class="codeSnap">

Demonstrate C++ Objects

--------------------------------------------------
  std library types string and vector&lt;T&gt;
--------------------------------------------------
contents of str = &quot;Wile E. Coyote&quot;
--- showType(str, &quot;str&quot;); ---
str type: class std::basic_string&lt;char,struct std:...
size:  40

vector&lt;T&gt;: {
  3.5, 3, 2.5, 2
}
--- showType(vec, &quot;vec&quot;); ---
vec type: class std::vector&lt;double,class std::allo...
size:  32

--- vec[2] = -2.5; ---
vec:
vector&lt;T&gt;: {
  3.5, 3, -2.5, 2
}
--- auto vec2 = vec : copy construction ---
vec2:
vector&lt;T&gt;: {
  3.5, 3, -2.5, 2
}
--- vec2[0] = 42; ---
vec2:
vector&lt;T&gt;: {
  42, 3, -2.5, 2
}
vec:
vector&lt;T&gt;: {
  3.5, 3, -2.5, 2
}
--------------------------------------------------
  Copy construction, auto vec2 = vec, creates
  independent instance. So changing target vec2
  has no affect on source vec.
--------------------------------------------------

--------------------------------------------------
  user-defined type Point4D
--------------------------------------------------
Point4D {
  0, 0, 0,
  Mon May  1 16:04:27 2023
}
Point4D {
  42, 0, -3.5,
  Mon May  1 16:04:27 2023
}

--- showType(p1, &quot;p1&quot;, nl) ---
p1 type: class Point4D
size:  32
p1.xCoor() returns value 42

--------------------------------------------------
  heap-based string instance
--------------------------------------------------
--- pU&lt;std::string&gt; pStr(new std::string(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;) ---
pStr contents = &quot;Road Runner&quot;

--- showType(*pStr, &quot;*pStr&quot;) ---
*pStr type: class std::basic_string&lt;char,struct std:...
size:  40

--- showType(move(pStr), &quot;pStr&quot;) ---
pStr type: class std::unique_ptr&lt;class std::basic_s...
size:  8

--------------------------------------------------
  heap-based vector instance
--------------------------------------------------
--- pU&lt;std::vector&lt;double&gt;&gt;
    pVec(new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }); ---
*pVec =
vector&lt;T&gt;: {
  1.5, 2.5, 3.5
}
*pVec type: class std::vector&lt;double,class std::allo...
size:  32

pVec = 000002897B682AC0
move(pVec) type: class std::unique_ptr&lt;class std::vector&lt;...
size:  8

--------------------------------------------------
  heap-based Point4D instance
--------------------------------------------------
--- pU&lt;Point4D&gt; pPoint4D(new Point4D()) ---
Point4D {
  0, 0, 0,
  Mon May  1 16:04:27 2023
}
Point4D {
  1, 2, -3,
  Mon May  1 16:04:27 2023
}
pPoint4D-&gt;zCoor() = -3
--- showType(*pPoint4D, &quot;*pPoint4D&quot;); ---
*pPoint4D type: class Point4D
size:  32
--- showType(std::move(pPoint4D), &quot;pPoint4D&quot;); ---
pPoint4D type: class std::unique_ptr&lt;class Point4D,stru...
size:  8


That's all Folks!

C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build
&gt;
          </pre>
                <!--                 <div class="textwrap" style="overflow-y:auto;">
                         <t-b>
                           Cpp_Objects.cpp is the code executive, loading PointsObj.h and AnalysisObj.h,
                           and using standard libraries loaded at the beginning of the file.
                         </t-b>
                         <hr />
                         <t-b>
                           This example uses some of the facilities of std::C++20, but does not use
                           modules.  I was unable to get CMake to sucessfully build the program with
                           module imports instead of #includes.
                         </t-b>
                         <t-b>
                           This appears to be an issue with
                           CMake, or my CMakeLists.txt file, not the Visual Studio compiler that CMake loads.
                           I will be looking into that evenutally and will update this example at that time.
                         </t-b>
                         <hr />
                         <t-b>
                           The demonstrations are entirely contained in the function <c-s>main()</c-s>, but
                           use the <c-s>Point4D</c-s> type from PointsObj.h and several functions from
                           AnalysisObj.h.
                         </t-b>
                         <t-b>
                           First, a <c-s>std::string</c-s> and <c-s>std::vector&lt;double&gt;</c-s> are used
                           to create instances initialized with specific values.
                         </t-b>
                         <t-b>
                           Then values of the instances are displayed. That uses a standard overload of the
                           stream insertion operator <c-s>operator&lt;&lt;</c-s> for <c-s>std::string</c-s>
                           and an overload of the same operator for <c-s>std::vector&lt;T&gt;</c-s> provided
                           at the beginning of AnalysisObj.h.
                         </t-b>
                         <t-b>
                           Then the inferred type name and type size are shown for each with
                           <c-s>showType&lt;T&gt;(T&nbsp;t,&nbsp;...)</c-s>.
                         </t-b>
                         <hr />
                         <t-b>
                           The <c-s>std::vector&lt;double&gt;</c-s> is modified and displayed, then copied with
                           the vector copy constructor via the expression <c-s>auto vec2 = vec</c-s>. This
                           expression implicitly invokes the <c-s>vector&lt;double&gt;</c-s> copy constructor to
                           create the instance <c-s>vec2</c-s>.
                         </t-b>
                         <t-b>
                           Note that no assignment or void construction is
                           called. You may wish to verify this by walking through the code from the
                           <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects">
                             Bits Repository
                           </a> using VS Code.
                         </t-b>
                         <div style="height:0em;"></div>
                       </div>
        -->
              </second-item>
            </splitter-container>
          </div>
          <div style="height:1em;"></div>
          <h4 id="analysis">1.3 Source Code - AnalysisObj.h</h4>
          <t-b style="margin-bottom:1em;">
            This block presents code for analysis and display of C++ objects. The source code
            is available
            <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Objects/src">here</a>.
            Download the entire Bits repository
            <a target="_blank" href="https://github.com/JimFawcett/Bits">here</a>.
          </t-b>
          <div class="blockSingle">
            <pre class="codeSnap">
/*-------------------------------------------------------------------
  Analysis.h
  - Provides functions that analyze types, display results
    and other program defined information.
  - Some of this code requires complex template operations.
    Those will be discussed in the generics bit.
  - You can skip the hard parts until then, without loss
    of understanding.
*/

#include &lt;typeinfo&gt;     // typeid
#include &lt;utility&gt;      // move()
#include &lt;sstream&gt;      // stringstream
#include &lt;type_traits&gt;  // is_scalar, if constexpr
#include &lt;iostream&gt;     // cout
#include &lt;vector&gt;       // vector

/*-------------------------------------------------------------------
  Analysis function declarations are provided here so that
  definitions below may be placed in any order. That's
  needed because C++ requires declaration before use.
*/
template&lt;typename T&gt;  <span class="info" style="float:right;" onclick="toggleInfoRel(this, 'fcode1')">?</span>
void showType(T t, const std::string &nm, const std::string& suffix = &quot;&quot;);
void showNote(const std::string& txt, const std::string& suffix = &quot;&quot;);
void showOp(const std::string& opstr, const std::string& suffix = &quot;&quot;);
void print(const std::string& txt = &quot;&quot;);
void println(const std::string& txt = &quot;&quot;);
std::string truncate(size_t N, const char* pStr);
std::string indent(size_t n);
template&lt;typename T&gt;
std::string fold(std::vector&lt;T&gt;& v, size_t left, size_t width);
template&lt;typename T&gt;
std::string formatColl(
  const T& t, const std::string& nm,
  const std::string& suffix = &quot;&quot;, size_t left = 2, size_t width = 7
);
template&lt;typename T&gt;
std::string formatScalar(
  const T& t, const std::string& nm,
  const std::string& suffix = &quot;&quot;, size_t left = 2
);
template&lt;typename T&gt;
std::string formatString(
  const T& t, const std::string& nm, const std::string& suffix,
  size_t left = 2
);
template&lt;typename T&gt;
std::string format(
  const T& t, const std::string& nm, const std::string& suffix = &quot;&quot;,
  size_t left = 2, size_t width = 7
);
/*-------------------------------------------------------------------
  Display and Analysis function and globals definitions
---------------------------------------------------------------------
*/
const std::string nl = &quot;&#92;n&quot;;
/*-------------------------------------------------------------------
  Mutable globals are a common source of bugs.  We try not
  to use them, but will use DisplayParams here to control how
  the insertion operator sends instances to standard output.
*/
struct displayParams {
  size_t left = 2;    // number of spaces to indent
  size_t width = 7;   // width of display row
  size_t trunc = 40;  // replace text after trunc with ...
} DisplayParams;      // global object
            <span class="info" style="float:right;" onclick="toggleInfoRel(this, 'fcode2')">?</span>
/*-----------------------------------------------
  Overload operator&lt;&lt; required for
  showType(std::vector&lt;T&gt; v, const std::vector&lt;T&gt;& nm)
*/
template&lt;typename T&gt;
std::ostream& operator&lt;&lt;(std::ostream& out, std::vector&lt;T&gt;& v) {
  out &lt;&lt; format(v, &quot;vector&lt;T&gt;&quot;, &quot;&quot;, DisplayParams.left, DisplayParams.width);
  return out;
}
/*-----------------------------------------------
  Display calling name, static class, and size
*/
template&lt;typename T&gt; <span class="info" style="float:right;" onclick="toggleInfoRel(this, 'fcode3')">?</span>
void showType(T t, const std::string &callname, const std::string& suffix) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; callname;          // show name at call site
  std::cout &lt;&lt; &quot; type: &quot;
            &lt;&lt; truncate(DisplayParams.trunc,typeid(t).name());  // show type
  std::cout &lt;&lt; &quot;&#92;n  size:  &quot; &lt;&lt; sizeof(t);  // show size on stack
  std::cout &lt;&lt; suffix;
}
/*-----------------------------------------------
  Display emphasized text
*/
inline void showNote(const std::string& txt, const std::string& suffix) {
  print(&quot;--------------------------------------------------&quot;);
  print(&quot;  &quot; + txt);
  print(&quot;--------------------------------------------------&quot;);
  std::cout &lt;&lt; suffix;
}
/*-----------------------------------------------
  Display emphasized line
*/
inline void showOp(const std::string& opstr, const std::string& suffix) {
  std::cout &lt;&lt; &quot;&#92;n  --- &quot; &lt;&lt; opstr &lt;&lt; &quot; ---&quot; &lt;&lt; suffix;
}
/*-----------------------------------------------
  Helper function for formatting output
  - truncates line to N chars and adds ellipsis
*/
inline std::string truncate(size_t N, const char* pStr) {
  std::string temp(pStr);
  if(temp.length() &gt; N) {
    temp.resize(N);
    return temp + &quot;...&quot;;
  }
  return temp;
}
/*-----------------------------------------------
  Helper function for formatting output
  - generates string of n blanks to offset text
*/
inline std::string indent(size_t n) {
  return std::string(n, ' ');
}
/*-----------------------------------------------
  Helper function for formatting output
  - folds lines after width elements
*/
template&lt;typename T&gt;
std::string fold(std::vector&lt;T&gt;& v, size_t left, size_t width) { <span class="info" style="float:right;" onclick="toggleInfoRel(this, 'fcode31')">?</span>
  std::stringstream out(&quot;&#92;n&quot;);
  out &lt;&lt; indent(left);
  for(int i=0; i&lt;v.size(); ++i) {
    if((i % width) == 0 && i != 0 && i != width - 1) {
      out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left);
    }
    if(i &lt; v.size() - 1) {
      out &lt;&lt; v[i] &lt;&lt; &quot;, &quot;;
    }
    else {
      out &lt;&lt; v[i] &lt;&lt; &quot;&#92;n&quot;;
      break;
    }
  }
  return out.str();
}
/*-----------------------------------------------
  Helper function for formatColl
  - defines out &lt;&lt; std::pair&lt;K,V&gt;
  - used in formatColl for associative containers
*/
template&lt;typename K, typename V&gt;
std::stringstream& operator&lt;&lt;(
  std::stringstream& out, const std::pair&lt;K,V&gt;& p
) {
  out &lt;&lt; &quot;{&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot;}&quot;;
  return out;
}
/*-----------------------------------------------
  Format output for Collection types <span class="info" style="float:right;" onclick="toggleInfoRel(this, 'fcode4')">?</span>
  - any type with begin() and end() like
    all the STL containers.
*/
template&lt;typename Coll&gt;
std::string formatColl(
  const Coll& c, const std::string& nm, const std::string& suffix,
  size_t left, size_t width
) {
  std::stringstream out;
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: {&#92;n&quot; &lt;&lt; indent(left + 2);
  /*-- fold rows of comma separated elements with width elements in each row --*/
  size_t i = 0;
  for(const Coll::value_type& elem : c) {
    if((i % width) == 0 && i != 0 && i != width - 1) {
      out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left + 2);
    }
    if(i &lt; c.size() - 1) {
      out &lt;&lt; elem &lt;&lt; &quot;, &quot;;
    }
    else {
      out &lt;&lt; elem &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; &quot;}&quot; &lt;&lt; suffix;
      break;
    }
    ++i;
  }
  return out.str();
}
/*-----------------------------------------------
  Format output for scalar types like primitives
*/
template&lt;typename T&gt;
std::string formatScalar(
  const T& t, const std::string& nm, const std::string& suffix,
  size_t left
) {
  std::stringstream out;
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: &quot; &lt;&lt; t &lt;&lt; suffix;
  return out.str();
}
/*-----------------------------------------------
  Format output for strings
  - indent and embed in quotation marks
*/
template&lt;typename T&gt;
std::string formatString(
  const T& t, const std::string& nm, const std::string& suffix,
  size_t left
) {
  std::stringstream out;
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: &#92;&quot;&quot; &lt;&lt; t &lt;&lt; &quot;&#92;&quot;&quot; &lt;&lt; suffix;
  return out.str();
}
/*----------------------------------------------- <span class="info" style="float:right;" onclick="toggleInfoRel(this, 'fcode5')">?</span>
  Defines is_iterable trait
  - detects STL containers and user-defined types
    that provide iteration
https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable
*/
template &lt;typename T, typename = void&gt;
struct is_iterable : std::false_type {};

// this gets used only when we can call
// std::begin() and std::end() on that type
template &lt;typename T&gt;
struct is_iterable&lt;
  T,
  std::void_t
    &lt;decltype(std::begin(std::declval&lt;T&gt;())),
     decltype(std::end(std::declval&lt;T&gt;()))&gt;
&gt; : std::true_type {};

template &lt;typename T&gt;
constexpr bool is_iterable_v = is_iterable&lt;T&gt;::value;

/*-----------------------------------------------
  Displays almost everything.
  - strings work better with formatString(...)
  https://www.cppstories.com/2018/03/ifconstexpr/
*/
template&lt;typename T&gt;
std::string format(
  const T& t, const std::string& nm, const std::string& suffix,
  size_t left, size_t width
) {
  if constexpr(is_iterable_v&lt;T&gt;) {  // decision at compile-time
    return formatColl(t, nm, suffix, left, width);
  }
  else {
    return formatScalar(t, nm, suffix, left);
  }
}
/*-----------------------------------------------
  Display text after newline and indentation
*/
inline void print(const std::string& txt) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt;
}
/*-----------------------------------------------
  Display text after newline and indentation
  - provides trailing newline
*/
inline void println(const std::string& txt) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt &lt;&lt; &quot;&#92;n&quot;;
}
            </pre>
            <div id="fcode1" class="txt">
              <t-b>
                C++ requires functions and classes to be declared before use in compile scan order.
                In order to define analysis functions that may use other analysis functions, without
                maintaining a strict definition order, we provide declarations for all here.
              </t-b>
              <t-b>
                Several of the functions are templates, which we have not covered yet. It is sufficient
                to have a rough idea of how they work for this demo.  We will cover template details
                in the next Bit.
              </t-b>
            </div>
            <div id="fcode2" class="txt">
              <t-b>
                The insertion operator <c-s>std::ostream& operator&lt;&lt;(std::ostream& out, T&amp; t)</c-s>
                sends a text representation of t to the std::ostream.
              </t-b>
              <t-b>
                Here we are overloading this
                std global function to accept an argument of type <c-s>std::vector&lt;T&gt;&amp;</c-s>.  It parses that into parts that
                the <c-s>std::operator&lt;&lt;</c-s> knows how to handle.
              </t-b>
              <t-b>
                This definition uses function <c-s>std::string format(const T&amp; t, ...)</c-s>, to
                represent the vector as rows of its internal data, and is defined
                below.  <c-s>format</c-s> uses some advanced template processing so we defer discussing its
                implementation to the next Bit.
              </t-b>
            </div>
            <div id="fcode3" class="txt">
              <t-b>
                <c-s>showType(T t, ...)</c-s> uses C++ <c-s>typeid(t)</c-s>, a weak form of reflection,
                to retrieve the class name and <c-s>sizeof(t)</c-s> to measure the size of t in
                the stack.  Any part of t that lies in the heap is not measured by this invocation.
              </t-b>
              <t-b>
                Type names are often long for template types, so we truncate the name string to
                the value of <c-s>DisplayParams.trunc</c-s> which is 40 bytes by default. That is
                usually long enough to get most of the information delivered in the type name.
              </t-b>
            </div>
            <div id="fcode31" class="txt">
              <t-b>
                <c-s>std::stringstream</c-s> is a wrapper around an in-memory std::string.
                Its contents are managed just like a <c-s>std::stream</c-s> with insertions,
                &quot;&lt;&lt;&quot;.  The internal string is retrieved by invoking the member
                function <c-s>str()</c-s>.
              </t-b>
              <t-b>
                The <c-s>std::stringstream</c-s> objects make it simple to assemble a string
                from parts, as we do in this <c-s>fold</c-s> function.
              </t-b>
            </div>
            <div id="fcode4" class="txt">
              <t-b>
                <c-s>formatColl(const Coll&amp; c, ...)</c-s> works for any collection that provides
                <c-s>std::Iterator begin()</c-s> and <c-s>std::Iterator end()</c-s> functions. All of
                the std template library containers do that.
              </t-b>
              <t-b>
                So this function works for
                sequential containers like <c-s>std::vector&lt;T&gt;</c-s> and associative containers
                like <c-s>std::unordered_map&lt;K,V&gt;</c-s>.
              </t-b>
            </div>
            <div id="fcode5" class="txt">
              <t-b>
                This template struct uses template-meta-programming to decide, at compile time,
                if a template time is iterable, e.g., it provides <c-s>std::Iterator begin()</c-s> and
                <c-s>std::Iterator end()</c-s> functions.
              </t-b>
              <t-b>
                It is used to decide, at compile-time, which format function to call in the function
                <c-s>std::string format(Const T&amp; t, ...)</c-s>. So <c-s>format</c-s> works for
                many different kinds of collections. That generality makes the code simpler and
                easier to maintain.
              </t-b>
            </div>
          </div>
          <div style="height:1em;"></div>
          <div class="clear"></div>
          <details id="build">
            <summary class="darkItem">Build&nbsp;&nbsp;</summary>
            <div class="blockSingle">
              <pre class="codeSnap">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build
&gt; cmake ..
-- Building for: Visual Studio 17 2022
-- Selecting Windows SDK version 10.0.22000.0 to target Windows 10.0.22621.
-- The C compiler identification is MSVC 19.34.31942.0
-- The CXX compiler identification is MSVC 19.34.31942.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933/bin/Hostx64/x64/cl.exe - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933/bin/Hostx64/x64/cl.exe - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: C:/github/JimFawcett/Bits/Cpp/Cpp_Objects/build
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build
&gt; cmake --build .
MSBuild version 17.4.1+9a89d02ff for .NET Framework
  Checking Build System
  Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Obje
  cts/CMakeLists.txt
  Bits_Objects.cpp
  Cpp_Objects.vcxproj -&gt; C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Ob
  jects&#92;build&#92;Debug&#92;Cpp_Objects.exe
  Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Obje
  cts/CMakeLists.txt
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build
&gt;
</pre>
            </div>
          </details>
        </div>
        <h3 id="ide">2.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Cpp\Cpp_Objects.
        </t-b>
        <photosizer-block src="pictures/VS_Code_Cpp_Objects.JPG" width="800" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE</span>
        </photosizer-block>
        <photosizer-block src="pictures/LaunchJSON_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 2. Launch.JSON</span>
        </photosizer-block>
        <photosizer-block src="pictures/VS_Code_Debugging_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 3. Debugging Objects</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
  </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../CppStoryRepo.html">C++ Story</a>
            </td>
            <td>
              E-book with thirteen chapters covering most of intermediate C++
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../CppBites/CppBites_Intro.html">C++ Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <!-- <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ide">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">bld</a></menu-elem>
        <menu-elem class="secElem"><a href="#out">out</a></menu-elem>
        <menu-elem class="secElem"><a href="#analysis">anal</a></menu-elem>
        <menu-elem class="secElem"><a href="#points">pts</a></menu-elem>
        <menu-elem class="secElem"><a href="#source">src</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">codeSnaps</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections -->>
    </main>
    <!-- <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer> -->
  </page-frame>
  <!--<script>
    //let loc = document.getElementById("loc");
    //let fn = window.location.href.split(/\/|\\/).pop();
    //loc.innerHTML = fn;
    for (let x of cars) {
      text += x + " ";
}
  </script>-->
  <script>
    var scrollables = document.querySelectorAll('.scrollable');
    for (let scrollable of scrollables) {
      //alert('adding listener');
      scrollable.addEventListener('wheel', function (event) {
	      var deltaY = event.deltaY;
	      var contentHeight = scrollable.scrollHeight;
	      var visibleHeight = scrollable.offsetHeight;
	      var scrollTop = scrollable.scrollTop;

	      if (scrollTop === 0 && deltaY < 0)
		      event.preventDefault();
	      else if (visibleHeight + scrollTop === contentHeight && deltaY > 0)
		      event.preventDefault();
      });
    }
  // https://stackoverflow.com/questions/7600454/how-to-prevent-page-scrolling-when-scrolling-a-div-element
</script>
  <script>
    onLoadSplitter("fig1");
  </script>
</body>
</html>