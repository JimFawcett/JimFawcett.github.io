<!DOCTYPE html>
<html>
<!--
  Bits_IterRust.html
-->
<head>
  <title>Bits_Iter Rust</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeDefault.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBitsRust.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding:0.75em 1.5em;
      margin-top:1.25em;
      margin-bottom:1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width:50em;
    }
    #github h2 {
      margin-top: 0.75em;
    }
    #github #pagetitle {
      border:2px double var(--dark);
    }
    #github form {
      border:none;
      padding:0.5em 1em;
    }
    #github form span {
      padding:0em 0.5em;
    }
    #github code-container {
      display: flex;
      position:relative;
      width:calc(100%);
      flex-direction: row;
      justify-content: space-between;
      /*border-top: 1px solid var(--dark);*/
    }
    #github code-banner {
      display: block;
      border: 2px solid var(--dark);
      border-top:none;
      border-bottom:none;
      padding: 0.25em 1em;
      font-family: 'Comic Sans MS', Tahoma;
      width: calc(100% + 0.5em);
      background-color: var(--atten);
    }
    #github code-display {
      display: block;
      border: 2px solid var(--dark);
      white-space: pre;
      padding: 0.75em 1em;
      font-family: Consolas, monospace;
      font-size:0.9em;
      width: calc(50% - 0.5em);
      overflow-x: auto;
      /*height:20em;*/
    }
    #github label {
      margin-right:1em;
    }
    #github fieldset {
      border:none;
    }
    #github #exeRight, #exeLeft {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github #hideLeft, #hideRight {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github .hide {
      display:none;
    }
    body {
      position:relative;
    }
    #github table.showcode {
      table-layout:fixed;
      width:calc(100% + 4em);
      margin-left:-2em;
    }
    #github th.leftblock {
      border: 2px solid var(--dark);
      /*border: 1px solid red;*/
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.rightblock {
      border: 2px solid var(--dark);
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.centerblock {
      border: none;
      padding: 0em;
      width:1em;
    }
    #github td.leftblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em);
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.leftblock summary {
      border:1px solid #ffffbb;
    }

    #github td.rightblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em) !important;
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.rightblock summary {
      border: 1px solid #ffffbb;
    }

    #github td.centerblock {
      border: none;
      padding: 0em;
    }
    #github pre {
      overflow-x: auto !important;
    }
    #github #left1 {
      /*height:45em;*/
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }

    #github #right1 {
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }
    #github #left2 {
      /*height:45em;*/
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right2 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github #left3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github .mover {
      width:2em;
      padding: 0.05em;
      position:relative;
      right:-1.5em;
      top:0.6em;
    }
    #github #ruler {

      width:calc(50% - 1.5em);
      height:0.001em;
      margin:-0.45em 0em;
    }
    #github .btns {
      width:3em;
      border:none;
    }
    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 10px;
    }
    #github .remotebutton {
      padding:0.25em 0.5em;
    }
    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }
    #github hr.spread {
      margin:0.75em 0em;
    }
  </style>
  <script>
    function saveScroll() {
      let main = document.querySelector("main");
      localStorage.setItem("ObjectsRust", main.scrollTop);
    //  let debug = scrollTop;
    //  console.log(debug);
    }
    function getScroll() {
      let scroll = localStorage.getItem("ObjectsRust");
      if (scroll) {
        scrollTop = parseInt(scroll, 10);
        let main = document.querySelector("main");
        main.scrollTop = scrollTop;
        //  let debug = scrollTop;
        //  console.log(debug);
      }
      else {
        let main = document.querySelector("main");
        localStorage.setItem("ObjectsRust", main.scrollTop);
        main.scrollTop = 0;
      }
    }
  </script>

  <script>
    function remote() {
      window.open('https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1004755496fd8f49782f95ad631664eb', '_blank');
    }
  </script>
</head>
<body id="github" onload="initialize()" onunload="saveScroll()">

  <a id="Next" href="Bits_IterRust.html">Next</a>
  <a id="Prev" href="Bits_GenericRust.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="page">Bits_Iter Rust</div>
      <div id="modified">06/03/2023</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <div class="rightPanelLinks">
          <a href="Bits_IterCpp.html">C++</a>
          <a class="darkItem" href="Bits_IterRust.html">Rust</a>
          <a class="undefined" href="# Bits_IterCSharp.html">C#</a>
          <a class="undefined" href="# Bits_IterPython.html">Python</a>
          <a class="undefined" href="# Bits_IterJs.html">JvScrpt</a>
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits_Iter Rust</h1>
            <h3 id="subtitle" class="indent">
              code, output, and build for Rust on Windows, macOS, and Linux
            </h3>
          </hgroup>
        </header>
        <t-b>
          These pages support comparison of fragments of code in several different
          languages, much as you might compare a sentence of English with one in Spanish to help you learn
          Spanish.
          </t-b>
          <t-b style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
            <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
            This bit demonstrates uses of Rust iterators to walk through enumerable collections.
            The purpose is to quickly acquire some familiarity with Rust iteration.
            <hr class="spread" />
            <ul>
              <li>
                Rust iterable containers support two functions that return iterators: <c-s>iter()</c-s> 
                for non-modifying traversals and <c-s>iter_mut()</c-s> for modifying traversals. 
              </li>
              <li>
                Iterator <c-s>iter()</c-s> supports the function <c-s>fn next(&self) -> Option&lt;Self::Item&gt;</c-s>.
              </li>
              <li>
                Iterator <c-s>iter_mut()</c-s> supports <c-s>fn next(&mut self) -> Option&lt;Self::Item&gt;</c-s>.
              </li>
              <li>
                While walking the collection <c-s>next()</c-s> returns <c-s>Some(item)</c-s>.
                When the end of its collection is reached, <c-s>next()</c-s> returns <c-s>None</c-s>.
              </li>
              <li>
                Collections may also support the IntoIterator trait with function <c-s>into_iter(self)</c-s> which consumes 
                the collection and returns an iterator over its elements.
              </li>
              <li>
                Rust Strings are a special case.  Unlike <c-s>vec</c-s> and <c-s>slice &T[]</c-s>, string items 
                are not all the same size.
                strings hold utf-8 characters which vary in size from 1 to 4 bytes. So strings support two iterators:
                <c-s>chars(&self)</c-s>, for moving from character to character, and <c-s>bytes(&self)</c-s> for 
                stepping through each of the string&apos;s bytes.
              </li>
              <li>
                Rust for-loops are simplifying syntax wrappers around iterators. 
              </li>
            </ul>
            <div style="height:0.5em;"></div>
          </t-b>
        <details>
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <t-b><hr /></t-b>
          <t-b>
            All of the languages covered in this demonstrtion support iteration using iterators.  
          </t-b>
          <t-b>
            Rust iterators are provided by enumerable containers and have public interface with the method
            <c-s>fn next(&self) -> Option&lt;Self::Item&gt;</c-s>.
          </t-b>
          <t-b>
            This demonstration illustrates use of iterators with a series of functions that provide code,
            in several forms, for iterating through containers. It includes demos for library types and
            for a user-defined point class.
          </t-b>
          <t-b><hr /></t-b>
        </details>
        <!--<t-b>
          The examples below show how to use library and user defined types with emphasis on
          illustrating syntax and basic operations.
        </t-b>-->
        <div style="height:0.25em;"></div>
        <h3 id="code">1.0 CodeSnaps</h3>
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote()" />
        <div style="display:flex; flex-direction:column;">
          <h4 id="source">Source Code - main.rs</h4>
          <pre class="codeSnap">
/*-----------------------------------------------
  Bits::rust_iter::main.rs
  - demonstrates iteration over collections with
    Rust iterators
  - Most collections implement the Rust trait
    IntoIterator which consumes the collection
    to generate an iterator.
  - Demonstrates iteration over arrays, slices,
    Vecs, VecDeques, and custom PointN&lt;T&gt; type.
-----------------------------------------------*/

#![allow(dead_code)]
#![allow(unused_variables)]

use std::collections::*;
mod analysis_iter;
// use analysis_iter::*;
mod points_iter;
use points_iter::*;

/*---------------------------------------------------------
  Use of Rust iterators is encapsulated in a sequence of
  functions defined below and used in main.  This file
  builds collections and applies the various functions
  to illustrate how iterators are used.

  It starts with a few quick iteration examples before
  applying the analysis functions.
---------------------------------------------------------*/
/*
- vec_indexer&lt;T:Debug&gt;(v:&Vec&lt;T&gt;)
- slice_indexer&lt;T:Debug&gt;(s:&[T])
- sub_range_indexer&lt;T:Debug&gt;(
    s:&[T],
    mut lower:usize, mut upper:usize
  )
- slice_looper&lt;T:Debug&gt;(s:&[T])
- collection_looper&lt;C: Debug, I: Debug&gt;(c:&C)
    where C: IntoIterator&lt;Item = I&gt; + Clone
- for_looper&lt;C: Debug, I: Debug&gt;(c:&C)
    where C: IntoIterator&lt;Item = I&gt; + Clone
- ranger&lt;T&gt;(iter: &mut T)
    where T: Iterator, T::Item: Debug
*/
use std::fmt::*;
use std::cmp::*;

/*-----------------------------------------------
  vec_indexer&lt;T: Debug&gt;(v:&Vec&lt;T&gt;)
-------------------------------------------------
Simplest case - displays Vector with generic
Item type.
- uses naive indexing
- works only for Vec's
*/
pub fn vec_indexer&lt;T: Debug&gt;(v:&Vec&lt;T&gt;) {
  let mut i = 0;
  while i &lt; v.len() {
    print!(&quot;{:?} &quot;, v[i]);
    i += 1;
  }
  println!();
}
/*-----------------------------------------------
  slice_indexer&lt;T:Debug&gt;(s:&[T])
-------------------------------------------------
Illustrates indexing in slices
- Not idiomatic, but safe and correct.
- Works with any collection with contiguous
  fixed size elements.
- Won't work with String or str inputs; they
  are collections of utf8 chars which vary
  in size from 1 to 4 bytes.
- It is rare for idomatic Rust code to use
  indexing.
- &[T] is slice type
- Demo's in main show how to use for various
  types.
*/
#[allow(clippy::needless_range_loop)]
pub fn slice_indexer&lt;T:Debug&gt;(s:&[T]) {
  let max = s.len();
  /* 0..max is range iterator */
  for i in 0..max {
      print!(&quot;{:?} &quot;, s[i]);
  }
  println!();
  /*---------------------------
    clippy prefers no indexing:
    for item in s.iter().take(max) {
      print!(&quot;{item} &quot;);
    }
  */
}
/*-----------------------------------------------
  sub_range_indexer&lt;T:Debug&gt;(
    s:&[T], mut lower:usize, mut upper:usize
  )
Iterates over a sub-range of the slice s
- works with any collection with contiguous
  fixed size elements.
*/
#[allow(clippy::needless_range_loop)]
pub fn sub_range_indexer&lt;T:Debug&gt;(
  s:&[T], mut lower:usize, mut upper:usize
) {
  lower = max(0, lower);
  upper = min(s.len(), upper);
  if lower &lt;= upper {
    for i in lower..upper {
      print!(&quot;{:?} &quot;, s[i]);
    }
  }
  println!();
}
/*-----------------------------------------------
  slice_looper&lt;T:Debug&gt;(s:&[T])
-------------------------------------------------
Iterates over slice s without indexing
- Works with any collection with contiguous
  fixed size elements,
  e.g., array, Vector, PointN, ...
- Uses slice iterator.
*/
pub fn slice_looper&lt;T:Debug&gt;(s:&[T]) {
  let mut iter = s.iter();
  loop {
      let item = iter.next();
      match item {
          Some(val) =&gt; print!(&quot;{val:?} &quot;),
          None =&gt; break
      }
  }
  println!();
}
/*-----------------------------------------------
  collection_looper&lt;C:Debug, I:Debug&gt;(c:&C)
-------------------------------------------------
- prints comma separated list of Collection&lt;I&gt;'s
  items.
- where clause requires C to implement
  IntoIterator trait.
- C is type of collection, I is type of C's items
- Accepts any collection type that implements
  IntoIterator trait, e.g., array, slice, Vector, ...
- collection_looper can't accept String or &str
  because String does not implement IntoIterator
- That's because String provides two iterators,
  chars() to iterate multibyte chars and bytes()
  to iterate over bytes.
- Not very efficient - uses three order N operations,
  clone, collect, and loop.
  https://stackoverflow.com/questions/49962611/why-does-str-not-implement-intoiterator
*/
pub fn collection_looper&lt;C: Debug, I: Debug&gt;(c:&C)
where C: IntoIterator&lt;Item = I&gt; + Clone
{
  let cc = c.clone();
  let iter = cc.into_iter();
  /* convert c into Vec to get len() method */
  let v:Vec&lt;_&gt; = iter.collect();
  let mut iter = v.iter();  // shadowing
  let mut count = 0;
  loop {
      let item = iter.next();
      match item {
          Some(val) =&gt; print!(&quot;{val:?}&quot;),
          None =&gt; { println!(); break; }
      }
      if count &lt; v.len() - 1 {
          print!(&quot;, &quot;);
      }
      count += 1;
  }
}
/*-----------------------------------------------
  for_looper&lt;C: Debug, I: Debug&gt;(c:&C)
-------------------------------------------------
- prints comma separated list of Collection&lt;I&gt;'s
  items.
- similar to collection_looper but erases last comma
  so no need for collection or clone
- uses idiomatic forloop with no indexing
*/
pub fn for_looper&lt;C: Debug, I: Debug&gt;(c:&C)
  where C: IntoIterator&lt;Item = I&gt; + Clone
{
  /* build string of comma separated values */
  let mut accum = String::new();
  let cc = c.clone();
  for item in cc {  // converts cc into iterator
      accum += &format!(&quot;{item:?}, &quot;);
  }
  /* remove last comma */
  let opt = find_last_utf8(&accum, ',');
  if let Some(index) = opt {
      accum.truncate(index);
  }
  println!(&quot;{accum}&quot;);
}
/*-- find last char in str --*/
pub fn find_last_utf8(s:&str, chr: char) -&gt; Option&lt;usize&gt; {
  s.chars().rev().position(|c| c == chr)
   .map(|rev_pos| s.chars().count() - rev_pos -1)
}
/*-----------------------------------------------
  ranger&lt;T&gt;(iter: &mut T)
-------------------------------------------------
- Displays contents of iterator, often passed in
  as range.
- another idiomatic iteration.
*/
pub fn ranger&lt;T&gt;(iter: &mut T)
  where T: Iterator, T::Item: Debug
{
  for item in iter {
      print!(&quot;{item:?} &quot;)
  }
  println!();
}
/*-----------------------------------------------
  demo_adapters&lt;C, I&gt;(c: C, i: I) -&gt; Vec&lt;I&gt;
-------------------------------------------------
- iterates over collection C,
  removes non-positive items, adds second
  argument i and collects into vector.
-------------------------------------------------
- adapters accept an iterator and return a
  revised iterator, as discussed below.
- adapter filter builds iterator over elements
  that satisfy a predicate defined by closure
- map builds iterator that modifies elements
  according to a closure.
- Adapter collect runs iterator and collects
  into Vec&lt;I&gt;.
*/
pub fn demo_adapters&lt;C, I&gt;(c: C, i: I) -&gt; Vec&lt;I&gt;
where
  C: IntoIterator&lt;Item = I&gt; + Debug + Clone,
  I: std::ops::Add&lt;Output = I&gt; + std::ops::Mul&lt;Output = I&gt;
      + PartialOrd + PartialEq + Debug + Default + Copy,
{
  let def = I::default();  // expect value is zero
  c.into_iter()
      .filter(|item| item &gt; &def)
      .map(|item| item + i)
      .collect()
}

/*-- Begin demonstrations ---------------------*/

fn main() {
  analysis_iter::show_label(&quot;Demonstrate Rust Iteration&quot;,30);

  let s = &mut [1usize, 2, 3, 4, 3, 2, 1];
  println!(&quot;slice s = {s:?}&quot;);
  println!(&quot;s[2] = {:?}&quot;, s[2usize]);

  /*-- PointN&lt;T&gt;.into_iter() -----------------*/
  let mut p = PointN::&lt;i32&gt;::new(5);
  p[1] = 1;
  p[3] = -1;
  println!(&quot;&#92;n{p:?}&quot;);
  println!(&quot;using PointN&lt;i32&gt;.iter&quot;);
  for item in p.iter() {
      print!(&quot;{item:?} &quot;);
  }
  println!(&quot;&#92;nusing PointN&lt;i32&gt;.into_iter&quot;);
  let iter = p.clone().into_iter(); // consumes clone
  analysis_iter::show_op(&quot;displaying iter type&quot;);
  analysis_iter::show_type(&iter, &quot;iter&quot;);
  for item in iter {
      print!(&quot;{item} &quot;);
  }
  println!();
  println!(&quot;using PointN&lt;i32&gt;.into_iter iter() with auto deref&quot;);
  let pc = p.clone();
  for item in pc {  // auto deref of pc into pc.iter()
      print!(&quot;{item} &quot; ) // consumes pc
  }
  println!();
  println!(&quot;using PointN&lt;i32&gt;.iter()&quot;);
  for item in p.iter() { // does not consume p
      print!(&quot;{item} &quot; )
  }
  println!();
  println!(&quot;using PointN&lt;i32&gt;.iter_mut()&quot;);
  for item in p.iter_mut() { // does not consume p
      *item *= 2;
      print!(&quot;{item} &quot; )
  }
  println!(&quot;&#92;n{p:?}&quot;);

  /*-- vec_indexer -------------------------------*/
  println!(&quot;&#92;nvec_indexer displays Vec&lt;T&gt;&quot;);
  let v = vec![1, 6, 2, 5, 3, 4];
  vec_indexer(&v);  // can only display vecs
  println!();

  /*-- slice_indexer -----------------------*/
  println!(&quot;slice_indexer displays slice&quot;);
  slice_indexer(s);
  println!(&quot;slice_indexer displays vector&quot;);
  let v = vec![5, 4, 3, 2, 1, 0];
  slice_indexer(&v);
  println!(&quot;slice_indexer displays string bytes&quot;);
  let str1:&str = &quot;a string&quot;;
  slice_indexer(str1.as_bytes());
  println!();

  /*-- sub_range_indexer --------------------*/
  println!(&quot;sub_range_indexer displays slice&quot;);
  sub_range_indexer(s, 2, 5);
  println!();

  /*-- slice_looper ------------------------*/
  println!(&quot;slice_looper displays slice&quot;);
  slice_looper(s);
  println!(&quot;slice_looper displays vector&quot;);
  slice_looper(&v);
  println!(&quot;slice_looper displays PointN&quot;);
  let mut point = PointN::&lt;i32&gt;::new(5);
  point[1] = 2;
  point[3] = -3;
  let ps = &point[0..];  // take slice
  slice_looper(ps);
  println!();

  /*-- collection_looper -------------------------------*/
  println!(&quot;collection_looper displays slice:&quot;);
  collection_looper(s);
  println!(&quot;collection_looper displays array&quot;);
  let a = [1, 2, 3];
  collection_looper(&a);
  println!(&quot;collection_looper displays VecDeque&quot;);
  let vecdeq = VecDeque::from([4, 3, 2, 0, -1]);
  collection_looper(&vecdeq);
  println!(&quot;collection_looper displays PointN&quot;);
  let pc = point.clone();
  collection_looper(&pc);
  println!(&quot;{pc:?}&quot;);
  println!();

  /*-- for_looper ---------------------------*/
  println!(&quot;for_looper displays slice:&quot;);
  for_looper(s);
  println!(&quot;for_looper displays vector:&quot;);
  let vec = s.to_vec();
  for_looper(&vec);
  println!(&quot;for_looper displays VecDeque&quot;);
  for_looper(&vecdeq);
  println!(&quot;for_looper displays PointN&lt;T&gt;&quot;);
  let pc = point.clone();
  for_looper(&pc);
  println!();
  /*-------------------------------------------
    for_looper can't accept String or &str
    because they do not implement IntoIterator
    https://stackoverflow.com/questions/49962611/why-does-str-not-implement-intoiterator
  */

  /*-- ranger -------------------------------*/
  println!(&quot;ranger displays string:&quot;);
  let str = &quot;a literal string&quot;.to_string();
  ranger(&mut str.chars());
  println!(&quot;ranger displays values in range&quot;);
  ranger(&mut (0..10));
  println!(&quot;ranger accepts Vector iterator&quot;);
  ranger(&mut vec.iter());
  println!(&quot;ranger accepts VecDeque iterator&quot;);
  ranger(&mut vecdeq.iter());
  println!(&quot;ranger accepts PointN&lt;T&gt; iterator&quot;);
  ranger(&mut point.iter());
  println!();

  /*-- demo_adapters ------------------------*/
  println!(&quot;demo_adapters&lt;T, i32&gt;(coll, 2) accepts array:&quot;);
  let a = [1, -1, 0, 2, 3, 4];
  println!(&quot;{:?} &quot;, &a);
  let vo = demo_adapters(a, 2);
  println!(&quot;{:?} &quot;, &vo);

  println!(&quot;demo_adapters&lt;T, f64&gt;(coll, 1.5) accepts PointN&lt;f64&gt;:&quot;);
  let mut pad = PointN::&lt;f64&gt;::new(5);
  pad[0] = 1.5;
  pad[1] = -2.0;
  pad[2] = 0.0;
  pad[3] = 1.1;
  pad[4] = 2.2;
  // this assignment works only in local module
  // pad.items = vec![1.5, -2.0, 0.0, 1.1, 2.2];
  println!(&quot;{:?} &quot;, &pad);
  let vo = demo_adapters(&pad, 1.5);
  println!(&quot;{:?} &quot;, &vo);

  println!(&quot;&#92;nThat's all folks!&#92;n&quot;);
}
          </pre>
          <h4 id="points">Source Code - points_iter.rs</h4>
          <pre class="codeSnap">
/*-- PointN&lt;T&gt; -----------------------------------
  PointN&lt;T&gt; declares a PointN type holding a
  Vec&lt;T&gt; of coordinate values.
  It implements:
  - new(n)  constructor
  - iter()  returns iterator over items
  - trait IntoIterator for PointN&lt;T&gt;
  - trait IntoIterator for &PointN&lt;T&gt;
  - immutable and mutable indexing
  Note:
  ---------------------------------------------
  This is a nice example of building a custom
  collection type. It implements methods and
  traits necessary to make a collection behave
  like standard library collections.
  ---------------------------------------------
*/
use std::fmt::*;

#[derive(Debug, Clone)]
pub struct PointN&lt;T&gt;
    where T:Debug + Default + Clone
{
  items: Vec&lt;T&gt;
}
impl&lt;T&gt; PointN&lt;T&gt;
    where T:Debug + Default + Clone
{
  pub fn new(n:usize) -&gt; PointN&lt;T&gt; {
    PointN::&lt;T&gt; {
      items: vec![T::default(); n],
    }
  }
  pub fn is_empty(&self) -&gt; bool {
    self.items.is_empty()
  }
  pub fn len(&self) -&gt; usize {
    self.items.len()
  }
  pub fn push(&mut self, item:T) {
    self.items.push(item);
  }
  pub fn pop(&mut self) -&gt; Option&lt;T&gt; {
    self.items.pop()
  }
  pub fn iter(&self) -&gt; impl Iterator&lt;Item = &T&gt; {
      self.items.iter()
  }
  pub fn iter_mut(&mut self) -&gt; impl Iterator&lt;Item = &mut T&gt; {
      self.items.iter_mut()
  }
}
/*-- implements const indexer -----------------*/
impl&lt;T:Debug, Idx&gt; std::ops::Index&lt;Idx&gt; for PointN&lt;T&gt;
    where
      T:Debug + Default + Clone,
      Idx: std::slice::SliceIndex&lt;[T]&gt;
{
  type Output = Idx::Output;

  fn index(&self, index:Idx) -&gt; &Self::Output {
    &self.items[index]
  }
}
/*-- implements mutable indexer ---------------*/
impl&lt;T, Idx&gt; std::ops::IndexMut&lt;Idx&gt; for PointN&lt;T&gt;
    where
      T:Debug + Default + Clone,
      Idx: std::slice::SliceIndex&lt;[T]&gt;
{
  fn index_mut(&mut self, index:Idx) -&gt; &mut Self::Output {
    &mut self.items[index]
  }
}
/*-- IntoIterator trait for &PointN&lt;T&gt; ---------*/
impl&lt;'a, T&gt; IntoIterator for &'a PointN&lt;T&gt;
    where T:Debug + Default + Clone
{
  type Item = T;
  type IntoIter = std::vec::IntoIter&lt;Self::Item&gt;;
  fn into_iter(self) -&gt; Self::IntoIter {
    let ccln = self.items.clone();
    ccln.into_iter()
  }
}
/*-- IntoIterator trait for PointN&lt;T&gt; ----------*/
impl&lt;T&gt; IntoIterator for PointN&lt;T&gt;
    where T:Debug + Default + Clone
{
  type Item = T;
  type IntoIter = std::vec::IntoIter&lt;Self::Item&gt;;
  fn into_iter(self) -&gt; Self::IntoIter {
    self.items.into_iter()
  }
}
          </pre>
          <h4 id="analysis">Source Code - analysis_iter.rs</h4>
          <pre class="codeSnap">
/*-----------------------------------------------
  analysis_iter.cs:
    Test functions with increasing functionality
    and increasing generality of inputs:
-----------------------------------------------*/

use std::fmt::*;

/*---------------------------------------------------------
  Show input's call name and type
  - doesn't consume input
  - show_type is generic function with Debug bound.
    Using format &quot;{:?}&quot; requires Debug.
*/
pub fn show_type&lt;T:Debug&gt;(_t: &T, nm: &str) {
  let typename = std::any::type_name::&lt;T&gt;();
  println!(&quot;{nm:?}, type: {typename:?}&quot;);
}
/*---------------------------------------------------------
  Show enumerable input's values
  - 'a is an annotation saying that T's lifetime
    is as long as the function's lifetime.
  - I is the type of T's elements, that is coll:T&lt;I&gt;.
  - T can be any iterable type and both T and I must
    satisfy Debug trait.
  - Does not consume input t since passed by reference.
*/
pub fn show_value_enum&lt;T:Debug, I:Debug&gt;(
  t: &T, nm: &str, left:usize, width:usize
)
  where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;
{
  println!(&quot;{nm:?} {{&quot;);
  show_fold(t, left, width);
  print!(&quot;}}&quot;);
  println!(&quot;&#92;nsize: {}&quot;, std::mem::size_of::&lt;T&gt;());
}
/*---------------------------------------------------------
  Show facts about a type's elements, e.g., name, type,
  value, and size.
  - show_type is generic function with Debug bound.
    Using format &quot;{:?} requires Debug.&quot;
  - works with small enumerable collections too because
    {:?} knows how to format them, but won't fold long
    sequences of elements. Use show_value_enum for that.
*/
pub fn show_type_scalar&lt;T:Debug&gt;(t: &T, nm: &str) {
  show_type(t, nm);
  println!(
    &quot;value: {t:?}, size: {}&quot;, std::mem::size_of::&lt;T&gt;()
  );
}
/*---------------------------------------------------------
Show facts about an enumerable type's elements, e.g.,
name, type, values, and size.
- show_type is generic function with Debug bound.
  Using format &quot;{:?} requires Debug.&quot;
*/
pub fn show_type_enum&lt;T:Debug, I:Debug&gt;(t: &T, nm: &str, left:usize, width:usize)
  where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;
{
  show_type(t, nm);
  show_value_enum(t, nm, left, width);
}
/*---------------------------------------------------------
  build indent string with &quot;left&quot; spaces
*/
pub fn offset(left: usize) -&gt; String {
  let mut accum = String::new();
  for _i in 0..left {
    accum += &quot; &quot;;
  }
  accum
}
/*---------------------------------------------------------
  find index of last occurance of chr in s
  - returns option in case chr is not found
  https://stackoverflow.com/questions/50101842/how-to-find-the-last-occurrence-of-a-char-in-a-string
*/
fn find_last_utf8(s: &str, chr: char) -&gt; Option&lt;usize&gt; {
  s.chars().rev().position(|c| c== chr)
    .map(|rev_pos| s.chars().count() - rev_pos - 1)
  /*-- alternate implementation --*/
  // if let Some(rev_pos) =
  //   s.chars().rev().position(|c| c == chr) {
  //     Some(s.chars().count() - rev_pos - 1)
  // } else {
  //     None
  // }
}
/*---------------------------------------------------------
  fold an enumerable's elements into rows of w elements
  - indent by left spaces
  - does not consume t since passed as reference
  - returns string
  https://users.rust-lang.org/t/generic-code-over-iterators/10907/3
*/
pub fn fold&lt;T, I:Debug&gt;(
  t: &T, left: usize, width: usize
) -&gt; String
    where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;, T:Debug
{
  let mut accum = String::new();
  accum += &offset(left);

  for (i, item) in t.into_iter().enumerate() {
    accum += &format!(&quot;{item:?}, &quot;);
    if ((i + 1) % width) == 0 && i != 0 {
        accum += &quot;&#92;n&quot;;
        accum += &offset(left);
    }
  }
  let opt = find_last_utf8(&accum, ',');
  if let Some(index) = opt {
    accum.truncate(index);
  }
  accum
  /*-- Alternate direct implementation --*/
  //let mut i = 0usize;
  // for item in t {
  //   accum += &format!(&quot;{item:?}, &quot;);
  //   if ((i + 1) % width) == 0 && i != 0 {
  //       accum += &quot;&#92;n&quot;;
  //       accum += &offset(left);
  //   }
  //   i += 1;
  // }
}
/*---------------------------------------------------------
  show enumerables's elements as folded rows
  - width is number of elements in each row
  - left is indent from terminal left
*/
pub fn show_fold&lt;T:Debug, I:Debug&gt;(t:&T, left:usize, width:usize)
  where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;
{
  println!(&quot;{}&quot;,fold(t, left, width));
}
/*---------------------------------------------------------
  show string wrapped with long dotted lines above and below
*/
pub fn show_label(note: &str, n:usize) {
  let mut line = String::new();
  for _i in 0..n {
    line.push('-');
  }
  print!(&quot;&#92;n{line}&#92;n&quot;);
  print!(&quot;  {note}&quot;);
  print!(&quot;&#92;n{line}&#92;n&quot;);
}
pub fn show_label_def(note:&str) {
  show_label(note, 50);
}
/*---------------------------------------------------------
  show string wrapped with dotted lines above and below
*/
pub fn show_note(note: &str) {
  print!(&quot;&#92;n-------------------------&#92;n&quot;);
  print!(&quot; {note}&quot;);
  print!(&quot;&#92;n-------------------------&#92;n&quot;);
}
/*---------------------------------------------------------
  show string wrapped in short lines
*/
pub fn show_op(opt: &str) {
  println!(&quot;--- {opt} ---&quot;);
}
/*---------------------------------------------------------
  print newline
*/
pub fn nl() {
  println!();
}
          </pre>
          <h4 id="out">Output</h4>
          <pre class="codeSnap">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_iter
&gt; cargo run -q

------------------------------
  Demonstrate Rust Iteration
------------------------------
slice s = [1, 2, 3, 4, 3, 2, 1]
s[2] = 3

PointN { items: [0, 1, 0, -1, 0] }
using PointN&lt;i32&gt;.iter
0 1 0 -1 0
using PointN&lt;i32&gt;.into_iter
--- displaying iter type ---
&quot;iter&quot;, type: &quot;alloc::vec::into_iter::IntoIter&lt;i32&gt;&quot;
0 1 0 -1 0
using PointN&lt;i32&gt;.into_iter iter() with auto deref
0 1 0 -1 0
using PointN&lt;i32&gt;.iter()
0 1 0 -1 0
using PointN&lt;i32&gt;.iter_mut()
0 2 0 -2 0
PointN { items: [0, 2, 0, -2, 0] }

vec_indexer displays Vec&lt;T&gt;
1 6 2 5 3 4

slice_indexer displays slice
1 2 3 4 3 2 1
slice_indexer displays vector
5 4 3 2 1 0
slice_indexer displays string bytes
97 32 115 116 114 105 110 103

sub_range_indexer displays slice
3 4 3

slice_looper displays slice
1 2 3 4 3 2 1
slice_looper displays vector
5 4 3 2 1 0
slice_looper displays PointN
0 2 0 -3 0

collection_looper displays slice:
1, 2, 3, 4, 3, 2, 1
collection_looper displays array
1, 2, 3
collection_looper displays VecDeque
4, 3, 2, 0, -1
collection_looper displays PointN
0, 2, 0, -3, 0
PointN { items: [0, 2, 0, -3, 0] }

for_looper displays slice:
1, 2, 3, 4, 3, 2, 1
for_looper displays vector:
1, 2, 3, 4, 3, 2, 1
for_looper displays VecDeque
4, 3, 2, 0, -1
for_looper displays PointN&lt;T&gt;
0, 2, 0, -3, 0

ranger displays string:
'a' ' ' 'l' 'i' 't' 'e' 'r' 'a' 'l' ' ' 's' 't' 'r' 'i' 'n' 'g'
ranger displays values in range
0 1 2 3 4 5 6 7 8 9
ranger accepts Vector iterator
1 2 3 4 3 2 1
ranger accepts VecDeque iterator
4 3 2 0 -1
ranger accepts PointN&lt;T&gt; iterator
0 2 0 -3 0

demo_adapters&lt;T, i32&gt;(coll, 2) accepts array:
[1, -1, 0, 2, 3, 4]
[3, 4, 5, 6]
demo_adapters&lt;T, f64&gt;(coll, 1.5) accepts PointN&lt;f64&gt;:
PointN { items: [1.5, -2.0, 0.0, 1.1, 2.2] }
[3.0, 2.6, 3.7]

That's all folks!

C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_iter
&gt;          </pre>
          <h4 id="build">Build</h4>
          <pre class="codeSnap">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_iter
&gt; cargo run
   Compiling rust_iter v0.1.0 (C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_iter)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_iter
&gt;
          </pre>
        </div>
        <h3 id="ide">2.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in 
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Rust\rust_iter.
        </t-b>
        <photosizer-block src="pictures/Debug_RustIter.JPG" width="800" class="photoSizerBlock left"
          style="overflow-x:auto;"
        >
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE - Debug Rust Iter</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/LaunchJSON_Rust_Objects.JPG" width="700" class="photoSizerBlock left"
          style="overflow-x:auto;"
        >
          <span style="font-family:'Comic Sans MS';">Figure 2. Rust Launch.JSON</span>
        </photosizer-block>
        <photosizer-block src="pictures/VS_Code_Debugging_Rust_Objects.JPG" width="700" class="photoSizerBlock left"
          style="overflow-x:auto;"
        >
          <span style="font-family:'Comic Sans MS';">Figure 3. Debugging Rust Objects</span>
        </photosizer-block>-->
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
          <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
        </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th><th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../RustBites/RustBites_Iterator.html">RustBite_Iterators</a>
            </td>
            <td>
              RustBite on Iterators and Adapters
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../RustStoryRepo.html">Rust Story</a>
            </td>
            <td>
              E-book with seven chapters covering most of intermediate Rust
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../RustBites/RustBites_Intro.html">Rust Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ide">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">bld</a></menu-elem>
        <menu-elem class="secElem"><a href="#out">out</a></menu-elem>
        <menu-elem class="secElem"><a href="#analysis">anal</a></menu-elem>
        <menu-elem class="secElem"><a href="#points">pts</a></menu-elem>
        <menu-elem class="secElem"><a href="#source">src</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">codeSnaps</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
  <script>
    getScroll();
  </script>
</body>
</html>