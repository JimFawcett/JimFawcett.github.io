<!DOCTYPE html>
<html>
<!--
  Bits_DataCSharp.html
-->
<head>
  <title>Bits_Data C#</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeCSharp.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBits.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding: 0.75em 1.5em;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width: 50em;
    }

    #github h2 {
      margin-top: 0.75em;
    }

    #github #pagetitle {
      border: 2px double var(--dark);
    }

    #github .hide {
      display: none;
    }

    body {
      position: relative;
    }

    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 10px;
    }

    #github .remotebutton {
      padding: 0.25em 0.5em;
    }

    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }

    #github hr.spread {
      margin: 0.75em 0em;
    }

    body {
      overflow-y: auto;
    }

    #github pre {
      min-width: 20em;
      max-width: 60em;
      user-select: all;
    }

    #github {
      user-select: none;
    }

    .focus {
      padding: 0.5em 1.0em 0.5em 1.0em;
      /*border:1px solid red;*/
    }

    *.focus ul {
      padding-top: -0.5em;
      /*background-color:green;*/
    }

    .cat {
      text-align: left;
      background-color: var(--menu);
    }

    #github pre {
      overflow-x: auto !important;
    }

    .block {
      border: 1px solid var(--dark);
      overflow: hidden;
      clear: both;
      max-width: 50em;
      margin-right: 0.75em;
    }

    .codewrap {
      float: left;
      padding-left: 0.5em;
      padding-right: 0.75em;
    }

    .textwrap {
      padding: 0.0em 0.75em 0.5em 0.5em;
      padding-left: 0.5em;
      padding-right: 0.75em;
    }

    table {
      margin-right: 0.75em;
    }
  </style>
  <script>
    function setScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = main.scrollTop;
      localStorage.setItem('scrollPositionHelloRust', scrollPosition);
      let scroller = document.getElementById("scrollY")
      scroller.innerHTML = Math.trunc(scrollPosition);
    }
    function gotoLastScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = localStorage.getItem('scrollPositionHelloRust');
      if (scrollPosition) {
        main.scrollTo(0, scrollPosition);
      }
      main.addEventListener('scroll', setScroll);
    }
    function load() {
      //initialize();
      gotoLastScroll();
    }
  </script>

  <script>
    function remote() {
      window.open('https://godbolt.org/z/19YYo3a68', '_blank');
    }
  </script>
</head>
<body id="github" onload="load()">

  <a id="Next" href="Bits_ObjectsCSharp.html">Next</a>
  <a id="Prev" href="Bits_HelloCSharp.html">Prev</a>

  <page-frame>
    <!-- <frame-header>
      <nav id="navbar"></nav>
    </frame-header> -->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits Data C#</div>
      <div id="modified">08/05/2023</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content id="content">
        <div class="rightPanelLinks">
          <a target="_parent" href="Bits_DataCpp.html">C++</a>
          <a target="_parent" href="Bits_DataRust.html">Rust</a>
          <a target="_parent" class="darkItem" href="Bits_DataCSharp.html">C#</a>
          <a target="_parent" href="Bits_DataPython.html">Python</a>
          <a target="_parent" href="Bits_DataJs.html">JvScrpt</a>
        </div>
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.50em; width:max-content; height:1.5em;
           text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits_Data C#</h1>
            <h3 id="subtitle" class="indent">
              types, initialization, construction, assignment
            </h3>
          </hgroup>
        </header>
        <div style="border:1px solid red; padding:0.5em 1em; width:max-content;">
          This page is under construction. 
        </div>
        <t-b id="syn" style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          Most of a language&apos;s syntax and semantics derives directly from its type
          system design. This is true of all of the languages discussed in these Bits:
          C++, Rust, C#, Python, and JavaScript.
          <div style=height:0.5em;></div>
          C# has a rich complex type system, divided into two fundamentally different parts:
          value types and reference types. Its value types are similar to the primitive
          types defined by C++ and Rust. Reference types each consist of a handle in stack
          memory referring to a value stored in the dotnet managed heap. Execution is controlled
          by a virtual machine called the Common Language Runtime (CLR).
          <div style=height:0.5em;></div>
          This page demonstrates simple uses of the most important C# types.
          The purpose is to quickly acquire some familiarity with types and their uses.
          <hr class="spread" />
          <ul>
            <li>
              Value types and aggregates of value types are copyable.  Assignment and
              pass-by-value copies the source&apos;s value to the destination.
            </li>
            <li>
              Value types have a nullable variant declared by adding a &quot;?&quot; suffix, 
              e.g., <c-s>bool? b;</c-s>.
              Nullable value types hold <c-s>null</c-s> by default and may be assigned
              a null value as well as non-null values. The value can be tested with
              <c-s>Nullable&lt;T&gt;.HasValue</c-s> property which holds a boolean, 
              true if t&epsilon;T is non-null, otherwise false.
            </li>
            <li>
              Reference types are not copyable. Assignment and pass-by-value copies the reference,
              not the referenced instance.  That results in two handles referring to the same
              heap-based instance.
            </li>
            <li>
              C# does not support move operations since the CLR owns all reference type instances.
              There is no need to use moves to avoid the expense of possibly large copies, since
              the language does not directly support making copies of reference types.
            </li>
            <li>
              Value types may be stored in stack or static memory. Reference types may only be stored
              in the program&apos;s managed heap.
            </li>
            <li>
              C# is memory safe because all memory management operations are executed by the CLR, not
              by a user&apos;s code. That comes with performance - throughput and latency - that are 
              significantly worse than that of native code languages like C++ and Rust.
            </li>
            <li>
              Here we begin to see significant differences between the languages, especially
              when comparing statically typed languages like C++, Rust, and C#, with dynamically typed
              languages like Python and JavaScript.
            </li>
          </ul>
          <div style="height:0.25em;"></div>
        </t-b>
        <div style="height:0.75em;"></div>
        <details id="types">
          <summary class="darkItem">C++&nbsp;Types&nbsp;Details&nbsp;</summary>
          <h3>Table 1.0 C# Types</h3>
          <table style="font-size: 0.9em; max-width: 71em;">
            <tr>
              <th style="width:15em;">Type</th>
              <th>Comments</th>
              <th>Example</th>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Integral types ----</th>
            </tr>
            <tr>
              <td><c-s>bool</c-s></td>
              <td>values true and false</td>
              <td><c-s>bool b = true;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>int<br />with signed, unsigned, short, long qualifiers</c-s>
              </td>
              <td>1 == sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)</td>
              <td><c-s>short int i = 42;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>size_t</c-s>
              </td>
              <td><c-s>2 ≤ sizeof(size_t)</c-s>,<br /><c-s>size_t</c-s> is used for indexing</td>
              <td><c-s>size_t i = 0;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>char<br />with signed and unsigned qualifiers</c-s>
              </td>
              <td>signedness of <c-s>char</c-s> depends on platform</td>
              <td><c-s>char c = 'a';</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>wchar_t, char16_t, char32_t</c-s>
              </td>
              <td>
                wchar_t is 16 bits and holds UTF-16 code units on Windows,
                32 bits and holds UTF-32 on Linux
              </td>
              <td><c-s>wchar_t c = L'\U263A';</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Floating point types ----</th>
            </tr>
            <tr>
              <td><c-s>float, double, long double</c-s></td>
              <td>values have finite precision, and may have approximate values</td>
              <td><c-s>double d = 3.14159;</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- literal string types --</th>
            </tr>
            <tr>
              <td><c-s>const&nbsp;char[], const&nbsp;wchar_t[]</c-s></td>
              <td>
                literal string, resides in static memory and is always null terminated.
                "Hello" is a const char[6] containing the chars: 'H', 'e', 'l', 'l', 'o', '\0'.
              </td>
              <td>
                <c-s>char* lst = "a literal string"</c-s>
              </td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Aggregate types ----</th>
            </tr>
            <tr>
              <td><c-s>T[N]</c-s></td>
              <td>Native array of N elements all of type <c-s>T</c-s></td>
              <td>
                <c-s>int arr[] = [1, 2, 3, 2, 1];<br />let first = arr[0];</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::tuple&lt;T1, T2, ...&gt;</c-s></td>
              <td>collection of heterogeneous types accessed by position</td>
              <td>
                <c-s>
                  std::tuple&lt;int, float, char&gt; tu&nbsp;=&nbsp;(42,&nbsp;3.14159,&nbsp;'z');<br />char third = get&lt;2&gt;(tu);
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::optional&lt;T&gt;</c-s></td>
              <td>std::optional holds optional value <c-s>t&epsi;T</c-s> or <c-s>std::nullopt</c-s></td>
              <td><c-s>fn doOp(..args) -> Optional&lt;T&gt;</c-s></td>
            </tr>
            <tr><th colspan="3" class="cat">-- Std::library types ----</th></tr>
            <tr>
              <td><c-s>std::string</c-s></td>
              <td>Expandable collection of ASCII characters allocated in the heap</td>
              <td><c-s>std::string strg = "a string";</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::wstring</c-s></td>
              <td>Expandable collection of Unicode characters allocated in the heap</td>
              <td><c-s>std::wstring strg = L"a wstring";</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::array&lt;T, N&gt;</c-s></td>
              <td>Fixed size generic array of items of type <c-s>T</c-s></td>
              <td><c-s>std::array&lt;int,3&gt; v { 1, 2, 3 };</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::vector&lt;T&gt;</c-s></td>
              <td>Expandable generic collection of items of type <c-s>T</c-s></td>
              <td><c-s>std::vector&lt;double&gt;&nbsp;v&nbsp;{&nbsp;1.0,&nbsp;1.5,&nbsp;2.0 }; v.push(2.5);</c-s></td>
            </tr>
            <tr>
              <td><c-s>std::deque&lt;T&gt;</c-s></td>
              <td>
                Expandable double-ended generic collection of items of type <c-s>T</c-s>.
                Uses circular buffer internally.
              </td>
              <td>
                <c-s>
                  std::deque&lt;int&gt; vd { 1, 2, 3 }<br />
                  v.push_front(-1); ...
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::unordered_map&lt;K,V&gt;</c-s></td>
              <td>Unordered associative container of Key-Value pairs, held in a table of bucket lists.</td>
              <td>
                <c-s>
                  std::unordered_map&lt;std::string, int&gt; m {&nbsp;{"one",1},&nbsp;{"two",2}&nbsp;}<br />
                  map.insert("zero", 0); ...
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>std::map&lt;K,V&gt;</c-s></td>
              <td>Ordered associative container of Key-Value pairs, held in binary tree.</td>
              <td>
                <c-s>
                  std::map&lt;std::string, int&gt; m {&nbsp;{"one",1},&nbsp;{"two",2}&nbsp;}<br />
                  map.insert("zero", 0); ...
                </c-s>
              </td>
            </tr>
            <tr>
              <td>
                forward_list, list, unordered_map, unordered_set, unordered_multimap, unordered_multiset,
                set, multiset, and several adapters like stack and queue
              </td>
              <td>
                The C++ std::library also defines types for threading and synchronization,
                reading and writing to streams, anonymous functions, and many more.
              </td>
              <td><a href="https://en.cppreference.com/w/cpp/container">Containers library</a></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- User-defined Types --</th>
            </tr>
            <tr>
              <td>User-defined types</td>
              <td colspan="2">
                Based on classes and structs, these will be discussed in the <a href="Bits_ObjectsCpp.html">next Bit</a>.

              </td>
            </tr>
          </table>
          <div style="height:0.5em;"></div>
        </details>
        <div style="height:0.25em;"></div>
        <details id="typesys">
          <summary class="darkItem">C++&nbsp;Type&nbsp;System&nbsp;Details&nbsp;</summary>
          <h3>Table 2. C++ Copy and Move Operations</h3>
          <table style="font-size:0.9em; max-width:65em;">
            <colgroup>
              <col span="1" style="width:12%;" />
              <col span="1" style="width:16%;" />
              <col span="1" style="width:36%;" />
              <col span="1" style="width:36%;" />
            </colgroup>
            <tr>
              <th>Operation</th>
              <th>Example</th>
              <th>Primitive or Aggregate of Primitives</th>
              <th>Library or User-defined Type</th>
            </tr>
            <tr style="background-color:var(--menu);">
              <th colspan="4">If u&epsilon;T is a named variable</th>
            </tr>
            <tr>
              <td>Construction</td>
              <td><c-s>T t = u; u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>T</c-s>&apos;s copy constructor copies <c-s>u</c-s></td>
            </tr>
            <tr>
              <td>Assignment</td>
              <td><c-s>t = u, t&epsilon;T, u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>T</c-s>&apos;s assignment operator copies value of <c-s>u</c-s></td>
            </tr>
            <tr>
              <td>Pass-by-value</td>
              <td><c-s>fn doOp(T t)</c-s></td>
              <td><c-s>t</c-s>&apos;s value is mem-copy&apos;ed to doOp stack frame</td>
              <td><c-s>t</c-s>&apos;s value is copied to doOp stack frame,<br />using <c-s>T</c-s>&apos;s copy constructor</td>
            </tr>
            <tr style="background-color:var(--menu);">
              <th colspan="4">If u&epsilon;T is a temporary or u = std::move(v), v&epsilon;T</th>
            </tr>
            <tr>
              <td>Construction</td>
              <td><c-s>T t = u; u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>u</c-s>&apos;s value is moved to <c-s>t</c-s> using <c-s>T</c-s>&apos;s move constructor<br /><c-s>u</c-s>&apos;s value becomes undefined</td>
            </tr>
            <tr>
              <td>Assignment</td>
              <td><c-s>t = u, t&epsilon;T, u&epsilon;T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is mem-copy&apos;ed to <c-s>t</c-s></td>
              <td><c-s>u</c-s>&apos;s value is moved to <c-s>t</c-s> using <c-s>T</c-s>&apos;s move assignment operator<br /><c-s>u</c-s>&apos;s value becomes undefined</td>
            </tr>
            <tr>
              <td>Pass-by-value</td>
              <td><c-s>fn doOp(T t)</c-s></td>
              <td><c-s>t</c-s>&apos;s value is mem-copy&apos;ed to doOp stack frame</td>
              <td><c-s>T</c-s>&apos;s move constructor copies <c-s>t</c-s> to doOp stack frame<br /><c-s>t</c-s>&apos;s value becomes undefined</td>
            </tr>
          </table>
          <t-b>
            <h3>Table 3. C++ Type System Attributes</h3>
          </t-b>
          <table style="font-size:0.9em; max-width:65em;">
            <tr>
              <td>Static&nbsp;typing</td>
              <td>
                All types are known at compile time and are fixed throughout program execution.
              </td>
            </tr>
            <tr>
              <td>Inference</td>
              <td>
                Compiler infers types in expressions if not explicitly annotated or if declared <c-s>auto</c-s>.
                Occasionally inference fails and explicit annotation is required.
              </td>
            </tr>
            <tr>
              <td>Intermediate&nbsp;strength typing</td>
              <td>
                Types are exhaustively checked but there are many implicit conversions.
                <ul class="tight">
                  <li>Numeric and boolean literals coerce to their correspoinding type, e.g., 42 to int.</li>
                  <li>Variables with auto type declarations are coerced to the type of their RHS&apos;s</li>
                  <li>Values can be coerced using user-defined conversion constructors.</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Generics</td>
              <td>
                Generics provide types and functions with unspecified parameters,
                supporting code reuse and abstraction
                over types. Generic parameters are specified at the call site, e.g., <c-s>doOp&lt;T, U&gt;(T t, U u)</c-s>
                The function <c-s>doOp</c-s> is checked for syntax before instantiating with specific type(s). Any
                use of <c-s>t</c-s> or <c-s>u</c-s> in the <c-s>doOp</c-s> body are not checked until the types
                of <c-s>t</c-s> and <c-s>u</c-s> are known.
                <div style="height:0.75em;"></div>
                Unlike all the other languages examined in these Bits, C++ generics use an internal meta language
                at compile time to implement generic facilities. That can be used to move some processing from
                run-time to compile-time using &quot;template metaprogramming&quot;.
              </td>
            </tr>
            <tr>
              <td>Concepts</td>
              <td>
                Concepts are similar to Rust traits and Java and C# interfaces.
                They define shared behavior that types can
                implement, supporting abstraction over behavior. Concepts define behavior by declaring concept
                specific functions. A template type can use a Requires clause with concept arguments to bound
                types that are valid for a class or function.
              </td>
            </tr>
          </table>
        </details>
        <!--<details>
    <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
    <t-b><hr /></t-b>
    <t-b>
      All of the languages covered in this demonstration support classes.  Each class provides
      a pattern for laying out a memory footprint and defines how data within are accessed.
    </t-b>
    <t-b>
      Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
      is a pattern for defining functions and classes of a specific type.  Thus a generic is a
      pattern for making patterns.
    </t-b>
    <t-b>
      The other two, Python and JavaScript, are dynamically typed and already support defining
      functions and classes for multiple types, e.g., no need for generics.
    </t-b>
    <t-b>
      This demonstration illustrates use of classes and objects, which for C++, Rust, and C#,
      are defined in a stackframe or in the heap or both. <strongs>All</strongs> data for Python and JavaScript are
      stored in managed heaps.
    </t-b>
    <t-b><hr /></t-b>
  </details>
  <t-b>
    The examples below show how to use library and user defined types with emphasis on
    illustrating syntax and basic operations.
  </t-b>-->
        <div style="height:0.25em;"></div>
        <h3 id="code">1.0 CodeSnaps</h3>
        <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote()" />
        <div style="display:flex; flex-direction:column;">
          <h4 id="source">Source Code: Program.cs</h4>
          <pre class="codeSnaps"><code class="language-csharp">using System;
using System.Reflection;
using System.Reflection.Emit;
using Analysis;

/* Cs_Data::Program.cs */
/*
  Static Data Types:
    value types =&gt; assignment copies value
    --------------------------------------
      sbyte, byte, short, int, long, ushort, uint, ulong
      float, double
      decimal, char, bool
      struct
    Reference types =&gt; assignment copies reference
    ----------------------------------------------
      object, string, class
*/
//#pragma warning disable CS8602  // possibly null reference warning
// https://stackoverflow.com/questions/8173239/c-getting-size-of-a-value-type-variable-at-runtime/8173293#8173293
//
namespace HelloData
{
//  using AnalysisData
  /*--
    Svt is a value type used for type demo example.
    It consists of three public properties.
  --*/
  public struct Svt   // value type with value type members
  {
    public Svt() {}
    public int I { get; set; } = 0;
    public double D { get; set; } = 1.0;
    public char C { get; set; }  = 'a';
    public readonly void PrintSelf(string name) {
      Console.Write(&quot;{0}  {{ I:{1}, D:{2}, C:{3} }}&#92;n&quot;, name, I, D, C);
    }
  }
  /*--
    Crt is a reference type used for type demo example.
    It consists of three public properties.
  --*/
  public class Crt   // reference type with a reference type member
  {
    public Crt() {}
    public int I { get; set; } = 0;
    public double D { get; set; } = 1.0;
    public string S { get; set; }  = &quot;a string&quot;;
    public void PrintSelf(string name) {
      Console.Write(&quot;{0}  {{ I:{1}, D:{2}, S:{3} }}&#92;n&quot;, name, I, D, S);
    }
  }
  /*-- type demonstration --*/

  class Program
  {
    /*-- demonstration begins here --*/

    const string nl = &quot;&#92;n&quot;;

    static void Main(string[] args)
    {
      Display.Print(&quot; Demonstrate C# types&quot;);

      Display.ShowNote(&quot;int - value type&quot;);

      Display.ShowOp(&quot;int t1 = 42&quot;);
      int t1 = 42;
      Display.ShowType(t1, &quot;t1&quot;, nl);

      Display.ShowOp(&quot;interate over val type members using reflection&quot;);
      Display.Iterate(t1);
      Display.Print();

      Display.ShowOp(&quot;int t1a = t1 : copy of value type&quot;);
      int t1a = t1;
      Display.IsSameObj(t1a, &quot;t1a&quot;, t1, &quot;t1&quot;, nl);

      // reference behavior - copy on write
      Display.ShowNote(&quot;string - reference type&quot;);

      Display.ShowOp(&quot;string t2 = &#92;&quot;a string&#92;&quot;&quot;);
      string t2 = &quot;a string&quot;;
      Display.ShowType(t2, &quot;t2&quot;);

      Display.ShowNote(&quot;string has many methods - uncomment next line to see them&quot;, &quot;&quot;, 60);
      //Display.Iterate(t2);

      Display.ShowOp(&quot;string t3 = t2 : copy handle of ref type&quot;);
      string t3 = t2;
      Display.ShowType(t3, &quot;t3&quot;);
      Display.IsSameObj(t3,&quot;t3&quot;,t2,&quot;t2&quot;);

      Display.ShowOp(&quot;t3 += &#92;&quot; is here&#92;&quot; : copy on write&quot;);
      t3 += &quot; is here&quot;;
      Display.ShowType(t2, &quot;t2&quot;);
      Display.ShowType(t3, &quot;t3&quot;);
      Display.IsSameObj(t3,&quot;t3&quot;,t2,&quot;t2&quot;);
      Display.ShowNote(&quot;t2 not modified by change in t3 due to copy on write&quot;, nl, 55);
      Console.WriteLine();

      Display.ShowNote(&quot;Object - base reference type&quot;);

      Display.ShowOp(&quot;Object obj1 - new Object()&quot;);
      Object obj1 = new Object();
      Display.ShowType(obj1, &quot;obj&quot;);

      Display.ShowOp(&quot;interate over ref type members using reflection&quot;);
      Display.Iterate(obj1);
      Display.Print();

      Display.ShowOp(&quot;Object obj2 = obj1&quot;);
      Object obj2 = obj1;
      Display.IsSameObj(obj2, &quot;obj2&quot;, obj1, &quot;obj1&quot;, nl);

      Display.ShowNote(&quot;Svt Struct value type&quot;);

      Display.ShowOp(&quot;Svt t4 = new Svt()&quot;);
      Svt t4 = new() { I=3, D=3.1415927, C='z' };
      t4.PrintSelf(&quot;t4&quot;);
      Display.ShowType(t4, &quot;t4&quot;);
      Display.ShowNote(&quot;value type: size of object in stackframe&quot;, nl, 45);

      /* Iterate over val type members using reflection */
      Display.ShowOp(&quot;Iterate over val type members using reflection&quot;);
      Display.Iterate(t4);
      Display.Print();

      /* copy of value type */
      Display.ShowOp(&quot;Svt t4a = t4 : copy of val type&quot;);
      Svt t4a = t4;
      t4a.PrintSelf(&quot;t4a&quot;);
      t4.PrintSelf(&quot;t4&quot;);
      Display.IsSameObj(t4a,&quot;t4a&quot;,t4,&quot;t4&quot;);
      Display.ShowType(t4a, &quot;t4a&quot;);

      Display.ShowOp(&quot;t4a.C = 'q'&quot;);
      t4a.C = 'q';
      t4a.PrintSelf(&quot;t4a&quot;);
      t4.PrintSelf(&quot;t4&quot;);
      Display.IsSameObj(t4, &quot;t4&quot;, t4a, &quot;t4a&quot;, nl);

      Display.ShowNote(&quot;Crt - ref type with ref member&quot;);

      Display.ShowOp(&quot;Crt t5 = new Crt()&quot;);
      Crt t5 = new() { S = &quot;SomeString&quot; };
      // using default values for I and D
      t5.PrintSelf(&quot;t5&quot;);
      Display.ShowType(t5, &quot;t5&quot;);
      Display.ShowNote(&quot;ref type: size of handle to object in heap&quot;, nl, 45);

      /* copy handle of reference type */
      Display.ShowOp(&quot;Crt t5a = t5 : copy handle of ref type&quot;);
      Crt t5a = t5;
      t5a.PrintSelf(&quot;t5a&quot;);
      Display.IsSameObj(t5a, &quot;t5a&quot;, t5, &quot;t5&quot;);
      Display.IsSameObj(t5a.S, &quot;t5a.S&quot;, t5.S, &quot;t5.S&quot;);

      /* literal strings are not immutable */
      Display.ShowOp(&quot;t5a.S = &#92;&quot;new literal string&#92;&quot; : no copy on write&quot;);
      t5a.S = &quot;new string&quot;;
      t5a.PrintSelf(&quot;t5a&quot;);
      t5a.PrintSelf(&quot;t5&quot;);
      Display.IsSameObj(t5a, &quot;t5a&quot;, t5, &quot;t5&quot;);
      Display.IsSameObj(t5a.S, &quot;t5a.S&quot;, t5.S, &quot;t5.S&quot;);
      Display.ShowNote(&quot;source t5 was altered!&quot;);

      Console.WriteLine(&quot;&#92;nThat's all Folks!&#92;n&quot;);
    }
  }
}</code></pre>
          <h4 id="anal">Source Code: AnalysisData.cs</h4>
          <pre><code class="language-csharp">using System;
using System.Reflection;
using System.Reflection.Emit;

/* Cs_Data::AnalysisData.cs */

namespace Analysis
{
  class Display
  {
    /*-- simple reflection --*/
    public static void ShowType&lt;T&gt;(T t, String nm, String suffix = &quot;&quot;)
    {
      #pragma warning disable CS8602  // possibly null reference warning
      Type tt = t.GetType();
      Console.WriteLine(&quot;{0}, {1}&quot;, nm, tt.Name);
      int size = Utils.GetManagedSize(tt);
      Console.WriteLine(&quot;value: {0}, size: {1}{2}&quot;, t, size, suffix);
    }
    /*-- beware, two distinct objects may have same hashcode --*/
    public static void showIdent&lt;T&gt;(T t, String n, string suffix = &quot;&quot;) {
      int id = t.GetHashCode();
      Console.WriteLine(&quot;{0}, {1}{2}&quot;, n, id, suffix);
    }
    public static void IsSameObj&lt;T&gt;(
      T t1, String n1, T t2, String n2, string suffix = &quot;&quot;
    ) {
      if(ReferenceEquals(t1, t2)) {
        Console.WriteLine(
          &quot;{0} is same object as {1}{2}&quot;, n1, n2, suffix
        );
      }
      else {
        Console.WriteLine(
          &quot;{0} is not same object as {1}{2}&quot;, n1, n2, suffix);
      }
    }
    public static void ShowOp(String op, String suffix = &quot;&quot;) {
      Console.WriteLine(&quot;--- {0} ---{1}&quot;, op, suffix);
    }
    // https://stackoverflow.com/questions/7613782/iterating-through-struct-members
    public static void Iterate&lt;T&gt;(T t) /*where T:new()*/ {
      Console.WriteLine(&quot;fields:&quot;);
      foreach(
        var field in typeof(T).GetFields(
          BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public
        )
      ) {
        Console.WriteLine(
          &quot;  {0} = {1}&quot;, field.Name, field.GetValue(t)
        );
      }
      Console.WriteLine(&quot;methods:&quot;);
      foreach(
        var method in typeof(T).GetMethods(
          BindingFlags.Instance | BindingFlags.Public
        )
      ) {
        Console.WriteLine(
          &quot;  {0}&quot;, method.Name
        );
      }
    }
    public static void Print(String s = &quot;&quot;) {
      Console.WriteLine(s);
    }
    public static void ShowNote(string s, string suffix = &quot;&quot;, int length = 35) {
      string line = new string('-', length);
      Console.WriteLine(line);
      Console.WriteLine(&quot;  {0}&quot;, s);
      Console.WriteLine(line);
    }
  }
  /*--
    Utils uses advanced relection
    - GetMangedSize(Type type) is function that returns the size of
      value types and handles.
      It is used to help discover how things work.
      It is placed here because it uses advanced techniques that
      will eventually be covered elsewhere in this site.  Knowing
      how it works is not essential for the things we are examining
      in this demo.
  --*/
  // https://stackoverflow.com/questions/8173239/c-getting-size-of-a-value-type-variable-at-runtime/8173293#8173293
  public static class Utils {
    /*-- more advanced reflection --*/
    // https://stackoverflow.com/questions/7613782/iterating-through-struct-members
    public static int GetManagedSize(Type type)
    {
      // all this just to invoke one opcode with no arguments!
      var method = new DynamicMethod(
        &quot;GetManagedSizeImpl&quot;, typeof(uint), new Type[0],
        typeof(TypeExtensions), false
      );

      ILGenerator gen = method.GetILGenerator();
      gen.Emit(OpCodes.Sizeof, type);
      gen.Emit(OpCodes.Ret);

      var func = (Func&lt;uint&gt;)method.CreateDelegate(typeof(Func&lt;uint&gt;));
      return checked((int)func());
    }
  }
}</code></pre>
          <h4 id="out">Output</h4>
          <pre><code class="language-shell">C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Data
&gt; dotnet run
 Demonstrate C# types
-----------------------------------
  int - value type
-----------------------------------
--- int t1 = 42 ---
t1, Int32
value: 42, size: 4

--- interate over val type members using reflection ---
fields:
  m_value = 42
methods:
  CompareTo
  CompareTo
  Equals
  Equals
  GetHashCode
  ToString
  ToString
  ToString
  ToString
  TryFormat
  GetTypeCode
  GetType

--- int t1a = t1 : copy of value type ---
t1a is not same object as t1

-----------------------------------
  string - reference type
-----------------------------------
--- string t2 = &quot;a string&quot; ---
t2, String
value: a string, size: 8
------------------------------------------------------------
  string has many methods - uncomment next line to see them
------------------------------------------------------------
--- string t3 = t2 : copy handle of ref type ---
t3, String
value: a string, size: 8
t3 is same object as t2
--- t3 += &quot; is here&quot; : copy on write ---
t2, String
value: a string, size: 8
t3, String
value: a string is here, size: 8
t3 is not same object as t2
-------------------------------------------------------
  t2 not modified by change in t3 due to copy on write
-------------------------------------------------------

-----------------------------------
  Object - base reference type
-----------------------------------
--- Object obj1 - new Object() ---
obj, Object
value: System.Object, size: 8
--- interate over ref type members using reflection ---
fields:
methods:
  GetType
  ToString
  Equals
  GetHashCode

--- Object obj2 = obj1 ---
obj2 is same object as obj1

-----------------------------------
  Svt Struct value type
-----------------------------------
--- Svt t4 = new Svt() ---
t4  { I:3, D:3.1415927, C:z }
t4, Svt
value: HelloData.Svt, size: 24
---------------------------------------------
  value type: size of object in stackframe
---------------------------------------------
--- Iterate over val type members using reflection ---
fields:
  &lt;I&gt;k__BackingField = 3
  &lt;D&gt;k__BackingField = 3.1415927
  &lt;C&gt;k__BackingField = z
methods:
  get_I
  set_I
  get_D
  set_D
  get_C
  set_C
  PrintSelf
  Equals
  GetHashCode
  ToString
  GetType

--- Svt t4a = t4 : copy of val type ---
t4a  { I:3, D:3.1415927, C:z }
t4  { I:3, D:3.1415927, C:z }
t4a is not same object as t4
t4a, Svt
value: HelloData.Svt, size: 24
--- t4a.C = 'q' ---
t4a  { I:3, D:3.1415927, C:q }
t4  { I:3, D:3.1415927, C:z }
t4 is not same object as t4a

-----------------------------------
  Crt - ref type with ref member
-----------------------------------
--- Crt t5 = new Crt() ---
t5  { I:0, D:1, S:SomeString }
t5, Crt
value: HelloData.Crt, size: 8
---------------------------------------------
  ref type: size of handle to object in heap
---------------------------------------------
--- Crt t5a = t5 : copy handle of ref type ---
t5a  { I:0, D:1, S:SomeString }
t5a is same object as t5
t5a.S is same object as t5.S
--- t5a.S = &quot;new literal string&quot; : no copy on write ---
t5a  { I:0, D:1, S:new string }
t5  { I:0, D:1, S:new string }
t5a is same object as t5
t5a.S is same object as t5.S
-----------------------------------
  source t5 was altered!
-----------------------------------

That's all Folks!

C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Data
&gt;
</code></pre>
          <h4 id="build">Build</h4>
          <pre class="codeSnaps"><code class="language-csharp">
C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Data
&gt; dotnet build
MSBuild version 17.4.1+fedecea9d for .NET
  Determining projects to restore...
  All projects are up-to-date for restore.
  Cs_Hello -&gt; C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Data&#92;bin
  &#92;Debug&#92;net7.0&#92;Cs_Hello.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:00.79
C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Data
&gt;
</code></pre>
        </div>

        <h3 id="ide">2.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for CSharp\CSharp_Data.
        </t-b>
        <photosizer-block src="pictures/VS_Code_CSharp_Data.JPG" width="700" class="photoSizerBlock left">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE - C# Data</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/VS_Code_Debugging_CSharp_Hello.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 2. Debugging C#</span>
  </photosizer-block>-->
        <photosizer-block src="pictures/LaunchJSON_CSharp_Data.JPG" width="700" class="photoSizerBlock left">
          <span style="font-family:'Comic Sans MS';">Figure 2. C# Data Launch.JSON</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/VS_Code_CSharp_Plugins.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 3. C# Plugins</span>
  </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/">
                C# Type System - Microsoft
              </a>
            </td>
            <td>
              Discussion with examples
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types">
                C# Type Reference - Microsoft
              </a>
            </td>
            <td>
              Semi-formal description of C# Types
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
    </main>
  </page-frame>
  <script>
  </script>
  <script>
 </script>
</body>
</html>