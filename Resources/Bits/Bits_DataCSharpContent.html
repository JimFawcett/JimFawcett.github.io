<!DOCTYPE html>
<html>
<!--
  Bits_DataCSharp.html
-->
<head>
  <title>Bits_Data C#</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeCSharp.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBits.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding: 0.75em 1.5em;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width: 50em;
    }

    #github h2 {
      margin-top: 0.75em;
    }

    #github #pagetitle {
      border: 2px double var(--dark);
    }

    #github .hide {
      display: none;
    }

    body {
      position: relative;
    }

    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 10px;
    }

    #github .remotebutton {
      padding: 0.25em 0.5em;
    }

    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }

    #github hr.spread {
      margin: 0.75em 0em;
    }

    body {
      overflow-y: auto;
    }

    #github pre {
      min-width: 20em;
      max-width: 60em;
      user-select: all;
    }

    #github {
      user-select: none;
    }

    .focus {
      padding: 0.5em 1.0em 0.5em 0.5em;
      /*border:1px solid red;*/
    }

    *.focus ul {
      padding-top: -0.5em;
      /*background-color:green;*/
    }

    .cat {
      text-align: left;
      background-color: var(--menu);
    }

    #github pre {
      overflow-x: auto !important;
    }

    .block {
      border: 1px solid var(--dark);
      overflow: hidden;
      clear: both;
      max-width: 50em;
      margin-right: 0.75em;
    }

    .codewrap {
      float: left;
      padding-left: 0.5em;
      padding-right: 0.75em;
    }

    .textwrap {
      padding: 0.0em 0.75em 0.5em 0.5em;
      padding-left: 0.5em;
      padding-right: 0.75em;
    }

    table {
      margin-right: 0.75em;
    }
  </style>
  <script>
    function setScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = main.scrollTop;
      localStorage.setItem('scrollPositionHelloRust', scrollPosition);
      let scroller = document.getElementById("scrollY")
      scroller.innerHTML = Math.trunc(scrollPosition);
    }
    function gotoLastScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = localStorage.getItem('scrollPositionHelloRust');
      if (scrollPosition) {
        main.scrollTo(0, scrollPosition);
      }
      main.addEventListener('scroll', setScroll);
    }
    function load() {
      //initialize();
      gotoLastScroll();
    }
  </script>

  <script>
    function remote() {
      window.open('https://godbolt.org/z/19YYo3a68', '_blank');
    }
    function toggleTypes() {
      typesdetails = document.getElementById("types");
      typesdetails.open = !typesdetails.open;
      return true;
    }
  </script>
</head>
<body id="github" onload="load()">

  <a id="Next" href="Bits_ObjectsCSharp.html">Next</a>
  <a id="Prev" href="Bits_HelloCSharp.html">Prev</a>

  <page-frame>
    <!-- <frame-header>
      <nav id="navbar"></nav>
    </frame-header> -->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits: C# Data</div>
      <div id="modified">10/08/2023</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content id="content">
        <!-- <div class="rightPanelLinks">
          <a target="_parent" href="Bits_DataCpp.html">C++</a>
          <a target="_parent" href="Bits_DataRust.html">Rust</a>
          <a target="_parent" class="darkItem" href="Bits_DataCSharp.html">C#</a>
          <a target="_parent" href="Bits_DataPython.html">Python</a>
          <a target="_parent" href="Bits_DataJs.html">JvScrpt</a>
        </div> -->
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.50em; width:max-content; height:1.5em;
           text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits: C# Data</h1>
            <h3 id="subtitle" class="indent">
              types, initialization, construction, assignment
            </h3>
          </hgroup>
        </header>
<!--         <div style="border:1px solid red; padding:0.5em 1em; width:max-content;">
          This page is under construction.
        </div>
 -->        <!-- <a id="typesanchor" href="#types" onclick="toggleTypes()">types</a> -->

        <t-b id="syn" style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          Most of a language&apos;s syntax and semantics derives directly from its type
          system design. This is true of all of the languages discussed in these Bits:
          C++, Rust, C#, Python, and JavaScript.
          <div style=height:0.5em;></div>
          C# has a rich complex type system, divided into two fundamentally different parts:
          value types and reference types. Its value types are similar to the primitive
          types defined by C++ and Rust. Reference types each consist of a handle in stack
          memory referring to a value stored in the dotnet managed heap. Execution is controlled
          by a virtual machine called the Common Language Runtime
          (<a target="_blank" href="https://learn.microsoft.com/en-us/dotnet/standard/clr">CLR</a>).
          <div style=height:0.5em;></div>
          C# was created starting from Microsoft&apos;s Java definition, with 
          This page demonstrates simple uses of the most important C# types.
          The purpose is to quickly acquire some familiarity with types and their uses.
          <hr class="spread" />
          <ul>
            <li>
              Value types and aggregates of value types are copyable.  Assignment and
              pass-by-value copies the source&apos;s value to the destination.
            </li>
            <li>
              Reference types are not copyable. Assignment and pass-by-value copies the reference,
              not the referenced instance.  That results in two handles referring to the same
              heap-based instance.
            </li>
            <li>
              Value types have a nullable variant declared by adding a &quot;?&quot; suffix,
              e.g., <c-s>bool? b;</c-s>.
              Nullable value types hold <c-s>null</c-s> by default and may be assigned
              a null value as well as non-null values. The value can be tested with
              <c-s>Nullable&lt;T&gt;.HasValue</c-s> property which holds a boolean,
              true if t&epsilon;T is non-null, otherwise false.
            </li>
            <li>
              Reference types may be decorated with a &quot;?&quot; to indicate that it is a
              nullable type. They may also be decorated with the &quot;!&quot; suffix to assert that
              they are not null. That is done when the compiler&apos;s static analysis yields a
              &quot;maybe null&quot; state for the variable but the designer knows that
              it is not null.
            </li>
            <li>
              C# does not support move operations since the CLR owns all reference type instances.
              There is no need to use moves to avoid the expense of possibly large copies, since
              the language does not directly support making copies of reference types.
            </li>
            <li>
              Value types may be stored in stack or static memory. Reference types may only be stored
              in the program&apos;s managed heap.
            </li>
            <li>
              C# is memory safe because all memory management operations are executed by the CLR, not
              by user&apos;s code. That comes with performance penalties for throughput and latency that are
              significantly worse than that of native code languages like C++ and Rust.
            </li>
            <li>
              Here we begin to see significant differences between the languages, especially
              when comparing statically typed languages like C++, Rust, and C#, with dynamically typed
              languages like Python and JavaScript.
            </li>
          </ul>
          <div style="height:0.25em;"></div>
        </t-b>
        <div style="height:0.75em;"></div>
        <details id="types">
          <summary class="darkItem">C#&nbsp;Types&nbsp;Details&nbsp;</summary>
          <t-b>
            Types are defined by the size of their memory allocations, the encodings used to place values
            in memory, and rules that define how the values can be accessed, modified, and combined.
          </t-b>
          <t-b>
            The name of an instance of a Value type binds to a single contiguous block of stack memory. Each name
            is an identifier to a unique block of memory.
          </t-b>
          <t-b>
            The name of an instance of a Reference type binds to a unique handle that refers to a heap allocation
            that may have other handles referring to it.
          </t-b>
          <h3>Table 1.0 C# Types</h3>
          <table style="font-size: 0.9em; max-width: 71em;">
            <tr>
              <th style="width:15em;">Type</th>
              <th>Comments</th>
              <th>Example</th>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Integral value types ----</th>
            </tr>
            <tr>
              <td><c-s>bool</c-s></td>
              <td>values true and false</td>
              <td><c-s>bool b = true;</c-s></td>
            </tr>
            <tr>
              <td><c-s>byte</c-s></td>
              <td>unsigned 8-bit integer</td>
              <td><c-s>byte bt = 0x2A;</c-s></td>
            </tr>
            <tr>
              <td><c-s>sbyte</c-s></td>
              <td>signed 8-bit integer</td>
              <td><c-s>byte sb = 0xffD6;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>int<br />with short, ushort, uint, long, ulong qualifiers</c-s>
              </td>
              <td>
                <c-s>int</c-s> is a signed 32 bit integer
              </td>
              <td><c-s>int i = 42;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>nint, unint</c-s>
              </td>
              <td>
                nint and unint are signed and unsigned native size integers.
                Size is platform dependent.
              </td>
              <td><c-s>nint i = 42;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>char</c-s>
              </td>
              <td>16 bit unsigned value</td>
              <td><c-s>char c = 'a';</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Floating point value types ----</th>
            </tr>
            <tr>
              <td><c-s>float</c-s></td>
              <td>size = 4 bytes, values have finite precision, and may have approximate values</td>
              <td><c-s>float f = 3.1415927;</c-s></td>
            </tr>
            <tr>
              <td><c-s>double</c-s></td>
              <td>size = 8 bytes, values have finite precision, and may have approximate values</td>
              <td><c-s>double d = 3.14159265359;</c-s></td>
            </tr>
            <tr>
              <td><c-s>decimal</c-s></td>
              <td>size = 16 bytes, values are exact, has no exponent</td>
              <td><c-s>decimal dc = 100000000.00;</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Aggregate types ----</th>
            </tr>
            <tr>
              <td><c-s>T[]</c-s></td>
              <td>Reference type, array of N elements, all of type <c-s>T</c-s></td>
              <td>
                <c-s>int[]arr = { 1, 2, 3, 2, 1 };<br />int first = arr[0];</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>(T1, T2, ...)</c-s></td>
              <td>Tuple value type, collection of heterogeneous types accessed by position</td>
              <td>
                <c-s>
                  (int, float, char)tup&nbsp;=&nbsp;(42,&nbsp;3.14159,&nbsp;'z');<br />char third = tup.Item3;
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>struct</c-s></td>
              <td>Value type, collection of heterogeneous types accessed by name</td>
              <td>
                <c-s>
                  struct S { public int I; public double D; }<br />
                  S s; s.I = 42; s.D = 3.14159;<br />
                  int first = s.I;
                </c-s>
              </td>
            </tr>
            <tr><th colspan="3" class="cat">-- Reference types defined by C# language ----</th></tr>
            <tr>
              <td><c-s>object</c-s></td>
              <td>
                Base for all value and reference types<br />
                with methods <c-s>GetType, ToString, Equals, ...</c-s>
              </td>
              <td>
                <c-s>
                  object o = new object();<br />
                  string type = o.GetType().ToString();
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>string</c-s></td>
              <td>Expandable collection of Unicode characters allocated in the managed heap</td>
              <td>
                <c-s>
                  string str = new("a string");
                  Console.WriteLine("str: {0}", str);
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>delegate</c-s></td>
              <td>Reference type that encapsulates a method</td>
              <td><c-s>delegate string methodDelegate(int&nbsp;i,&nbsp;string&nbsp;s,&nbsp;...);</c-s></td>
            </tr>
            <tr>
              <td><c-s>dynamic</c-s></td>
              <td>
                An instance of dynamic type can be bound to any type of data.
                Use of a dynamic instance is checked at run-time, not compile-time.
              </td>
              <td>
                <c-s>
                  dynamic dyn = 42;<br />
                  Console.WriteLine("dyn: {0}", dyn);<br />
                  dyn = 3.1415927;<br />
                  Console.WriteLine("dyn: {0}", dyn);
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>class</c-s></td>
              <td>
                <c-s>class</c-s> is a meta-type, used to define library and user reference types.
              </td>
              <td>
                <c-s>
                  public class X {<br />
                  &nbsp;&nbsp;public X(int ia, double da) {<br />
                  &nbsp;&nbsp;&nbsp;&nbsp;i = ia;<br />
                  &nbsp;&nbsp;&nbsp;&nbsp;d = da;<br />
                  &nbsp;&nbsp;}<br />
                  &nbsp;&nbsp;public int i {get;set;} = 0;<br />
                  &nbsp;&nbsp;public double d {get;set;} = 0.0;<br />
                  }<br />
                  X x = new X(42, 3.1415927);
                  Console.WriteLine("X.d: {0}", x.d);
                </c-s>
              </td>
            </tr>
            <tr><th colspan="3" class="cat">-- Reference types defined by .net library ----</th></tr>
            <tr>
              <td><c-s>List&lt;T&gt;</c-s></td>
              <td>Expandable list of elements of type <c-s>T</c-s></td>
              <td>
                <c-s>
                  List&lt;int&gt; li = <br />&nbsp;&nbsp;new List&lt;int&gt; { 1, 2, 3, 2, 1 };<br />
                  int lfirst = li[0];
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>Dictionary&lt;K, V&gt;</c-s></td>
              <td>Unordered associative container of Key-Value pairs, held in table of buckets.</td>
              <td>
                <c-s>
                  Dictionary&lt;string, int&gt; dict =<br />
                  &nbsp;&nbsp;new Dictionary&lt;string, int&gt;()<br />
                  dict["zero"] = 0;
                </c-s>
              </td>
            </tr>
            <tr>
              <td>Many additional types defined by library</td>
              <td colspan="2">Types for reading and writing, parallel and concurrent operations, synchronization, ...</td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- User-defined Types --</th>
            </tr>
            <tr>
              <td>User-defined types</td>
              <td colspan="2">
                Based on classes and structs, these will be discussed in the <a href="Bits_ObjectsCpp.html">next Bit</a>.

              </td>
            </tr>
          </table>
          <div style="height:0.5em;"></div>
        </details>
        <div style="height:0.25em;"></div>
        <details id="typesys">
          <summary class="darkItem">C#&nbsp;Type&nbsp;System&nbsp;Details&nbsp;</summary>
          <t-b>
            <h3>Table 2. C# Type System Attributes</h3>
          </t-b>
          <table style="font-size:0.9em; max-width:65em;">
            <tr>
              <td>Static&nbsp;typing</td>
              <td>
                All non-dynamic types are known at compile-time and are fixed throughout program execution.
              </td>
            </tr>
            <tr>
              <td>Dynamic&nbsp;typing</td>
              <td>
                Dynamic types are evaluated at run-time and may be bound to any type of data.
              </td>
            </tr>
            <tr>
              <td>Type inference</td>
              <td>
                Compiler infers types in expressions if not explicitly annotated or if declared <c-s>var</c-s>.
                Occasionally inference fails and explicit annotation is required.
              </td>
            </tr>
            <tr>
              <td>Intermediate strength typing</td>
              <td>
                Types are exhaustively checked but allow both implicit and explicit conversions.
                <ul class="tight">
                  <li>Numeric and boolean literals coerce to their correspoinding type, e.g., 42 to int.</li>
                  <li>Variables with var type declarations are coerced to the type of their RHS&apos;s</li>
                  <li>Values can be coerced using user-defined explicit and implicit conversion methods.</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Generics</td>
              <td>
                Generics provide types and functions with unspecified parameters,
                supporting code reuse and abstraction
                over types. Generic parameters are specified at the call site, e.g., <c-s>doOp&lt;T, U&gt;(T t, U u)</c-s>.
                The function <c-s>doOp</c-s> is checked for syntax before instantiating with specific type(s). Calling
                methods on <c-s>t</c-s> or <c-s>u</c-s> in the <c-s>doOp</c-s> body require type constraints to interfaces
                that declare those methods.
                That will be demonstrated in the
                <a target="_blank" href="Bits_GenericCSharp.html">Bit on Generics</a>.
              </td>
            </tr>
          </table>
        </details>
        <!--<details>
    <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
    <t-b><hr /></t-b>
    <t-b>
      All of the languages covered in this demonstration support classes.  Each class provides
      a pattern for laying out a memory footprint and defines how data within are accessed.
    </t-b>
    <t-b>
      Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
      is a pattern for defining functions and classes of a specific type.  Thus a generic is a
      pattern for making patterns.
    </t-b>
    <t-b>
      The other two, Python and JavaScript, are dynamically typed and already support defining
      functions and classes for multiple types, e.g., no need for generics.
    </t-b>
    <t-b>
      This demonstration illustrates use of classes and objects, which for C++, Rust, and C#,
      are defined in a stackframe or in the heap or both. <strongs>All</strongs> data for Python and JavaScript are
      stored in managed heaps.
    </t-b>
    <t-b><hr /></t-b>
  </details>
  <t-b>
    The examples below show how to use library and user defined types with emphasis on
    illustrating syntax and basic operations.
  </t-b>-->
        <div style="height:0.5em;"></div>
        <h3 id="init">1.0 Initialization</h3>
        <t-b>
          Several of the code blocks shown below have formatting and output code elided.  You can find
          complete code in the <a target="_blank" href="https://github.com/JimFawcett/Bits">Bits Repository</a>:&nbsp;&nbsp;
          <a target="_blank" href="https://github.com/JimFawcett/Bits/blob/master/CSharp/Cs_Data/Program.cs">Program.cs</a>,
          <a target="_blank" href="https://github.com/JimFawcett/Bits/blob/master/CSharp/Cs_Data/AnalysisData.cs">AnalysisData.cs</a>,
        </t-b>
        <h3 id="values">1.1 Value Types</h3>
        <t-b>
          Initialization is the process of endowing a newly created type instance with a specified value.
          Uninitialized local value type instances have undefined values. All other uninitialized variables
          are compiler-initialized to null for reference types, zero for numeric types, and false for bools.
        </t-b>
        <t-b>
          To insure well defined behavior initialize all varibles where they are declared, as shown below.
        </t-b>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-cpp">  /*---------------------------------
    All code used for output has 
    been elided
  */
  /*-- bool --*/
  bool b = true;

  /*-- int --*/
  int i = 42;

  /*-- char --*/
  char c = 'z';

  /*-- double --*/
  double d = 3.1415927;

  /*-- decimal --*/
  decimal dec = 100_000_000.00m;
</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              Instances of value types each occupy one block of contiguous memory.
            </t-b>
            <t-b>
              These scalars, types with a single value, are initialized by assigning a value.
            </t-b>
            <t-b>
              The int type can be qualified with keywords short, ushort, uint, long, and ulong. Floating
              point types are float, double, and decimal.
            </t-b>
            <t-b>
              A&nbsp;complete list of types and their qualifiers are given in
              the &quot;C# Types Details&quot; dropdown list, above.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre><code class="language-cpp">  -------------------------
  Value Types
  -------------------------

  --- bool b = true; ---
  b: Type: Boolean
  value: True
  size: 1

  --- int i = 42 ---
  i: Type: Int32
  value: 42
  size: 4

  --- char c = 'z' ---
  c: Type: Char
  value: z
  size: 2

  --- double d = 3.1415927; ---
  d: Type: Double
  value: 3.1415927
  size: 8

  --- decimal dc = 100_000_000.00m; ---
  dec: Type: Decimal
  value: 100000000.00
  size: 16

</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                Each type in the code block on the left is characterized by its value,
                its type evaluated using reflection with
                <div class="focus"><c-s>&nbsp;&nbsp;&nbsp;Type tt = t.GetType()</c-s></div>
                and its size retrieved using reflection in the function
                <div class="focus"><c-s>&nbsp;&nbsp;&nbsp;int GetManagedSize(Type type)</c-s></div>
                That is defined in the AnalysisData.cs file, and shown in Section 3.0, below.
              </t-b>
              <t-b>
                Value types are held in a single block of contiguous memory.  Value copies are byte-by-byte
                copies of value from source location to the destination.
              </t-b>
              <t-b>
                The <c-s>char</c-s> type has size of two bytes, e.g., 16 bits. That holds a
                Unicode UTF-16 character. The <c-s>string</c-s> type holds an array of these <c-s>char</c-s>s
                in the managed heap.
              </t-b>
              <t-b>
                The <c-s>decimal</c-s> type is larger than <c-s>double</c-s>. Decimals are intended to hold large
                numbers with no exponent.
              </t-b>
              <t-b>
                The <c-s>double</c-s> type has lower precision, but can
                approximate very large numbers using an exponent. Its contiguous memory allocation is partitioned
                into a value part and exponent part.
              </t-b>
            </div>
          </div>
        </details>
        <div style="height:0.25em;"></div>
        <h3 id="aggr">1.2 Language-defined Aggregate Types</h3>
        <t-b>
          Aggregates are types composed of a collection of zero or more instances of item type(s).
          The language-defined aggregates are arrays, <c-s>T[]</c-s>, tuples, <c-s>(T1, T2, ...)</c-s>,
          and structs, <c-s>struct { T1, T2, ... }</c-s>.
        </t-b>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-cpp">  /*-- array --*/
  int[] array = { 1, 2, 3, 2, 1 };
  int first = array[0];

  /*-- tuple --*/
  (int, double, char)tup = (42, 3.14159, 'z');
  double second = tup.Item2;

  /*-- struct --*/
  S s = new S(42, 3.1415927);
  int sfirst = s.I;

</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              Arrays, <c-s>T[]</c-s>, consist of a sequence of elements all of the same type.
              They are initialized with a braced list of values, and each
              element is accessed with array indexes.
            </t-b>
            <t-b>
              Tuples, <c-s>(T1, T2, ...)</c-s>, are a heterogeneous collection of instances of arbitrary
              types. Their elements are initialized with assignment and accessed by position.
            </t-b>
            <t-b>
              Structs, <c-s>struct { T1, T2, ... }</c-s> are also a collection of heterogeneous types, but
              individual elements are accessed by name. They are initialized with a constructor, e.g., an
              initializing function with the name of the struct.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre><code class="language-cpp">  --- int[]array = { 1, 2, 3, 2, 1} ---
  array: Type: Int32[]
  value: System.Int32[]
  size: 8
  { 1, 2, 3, 2, 1 }

  --- (int, double, char)tup = (42, 3.14159, 'z'); ---
  tup: Type: ValueTuple`3
  value: (42, 3.14159, z)
  size: 16

  --- S s = new S(42, 3.1415927); ---
  s: Type: S
  value: CSharpData.Program+S
  size: 16
  S { 42, 3.1415927 }

</code></pre>
            </div>
            <div class="textwrap">
              <t-b>
                Arrays are reference types, so the size shown here is the size of a handle to
                the array in the .net managed heap.
              </t-b>
              <t-b>
                Tuples are value types. The size shown is for storage of all the values, e.g., 4 bytes for
                the integer, 8 bytes for the double, and 2 bytes for the char, with an additional
                2 bytes for padding, used to optimize read/write times.
              </t-b>
              <t-b>
                Structs are also value types. The size shown is for storage of all the values, e.g.,
                4 bytes for the integer and 8 bytes for the double, with 4 bytes of padding.
              </t-b>
            </div>
          </div>
        </details>
        <div style="height:0.25em;"></div>
        <h3 id="refs">1.3 Language-defined Reference Types</h3>
        <t-b>
          There are many types associated with C# defined by the language and by its libraries.
          The types presented in this block are defined directly by the language, e.g.,
          <c-s>object, string, dynamic, and class</c-s>.
        </t-b>
        <div class="block">
          <div class="codewrap">
            <pre>
<code class="language-cpp">  /*-- object --*/
  object o = new object();

  /*-- string --*/
  string str = &quot;a string&quot;;
  string str_alt = new(&quot;another string&quot;);

  /*-- dynamic --*/
  dynamic dyn = 42;
  dyn = 3.1415927;

  /*-- class --*/
  X x = new X(42, 3.1415927);
  int xFirst = x.i;</code>
            </pre>
          </div>
          <div class="textwrap">
            <t-b>
              Object is the base type for the C# reference types, providing reflection capabilities and
              a few other base facilities, i.e., non-generic collections are defined to hold objects,
              allowing instances of other types to be bound, as elements, to a collection instance.
            </t-b>
            <t-b>
              All other reference types derive directly, or indirectly, from the object class.
            </t-b>
            <t-b>
              String represents a constant sequence of characters. C# strings have no null terminator, unlike
              C and C++.
              Strings cannot be directly modified,
              but changes result in a new string instance with copies of the original charcter sequence
              with the new modification.
            </t-b>
            <t-b>
              The type dynamic is a third type category, e.g., values, references, and dynamic types.
              Instances of dynamic types can be bound to new values of any type at run-time, like
              Python and JavaScript types. All validity checking happens at run-time.
            </t-b>
            <t-b>
              Class is a meta-type, used to create user-defined types.
              Most C# programs use both user-defined types and library types specified by classes.
              This example uses a demonstration type X defined as:
              <div class="focus" style="white-space:nowrap; overflow-x:auto;">
                &nbsp;&nbsp;&nbsp;<c-s>class X { int i { get; set; } = 0; double d { get; set; } = 0.0; }</c-s>.
              </div>
              The <c-s>{ get; set; }</c-s> syntax represents a property endowed with getter and setter functions.
              Properties have the same use syntax as public data, but provide encapsulation of their values.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre>
<code class="language-cpp">  --- object o = new object(); ---
  o: Type: Object
  value: System.Object
  size: 8

  --- string str = "a string" ---
  str: Type: String
  value: a string
  size: 8

  --- dynamic dyn = 42; ---
  dyn: Type: Int32
  value: 42
  size: 4
  dyn: Type: Double
  value: 3.1415927
  size: 8

  --- X x = new X(42, 3.1415927); ---
  x: Type: X
  value: CSharpData.Program+X
  size: 8
  X { 42, 3.1415927 }</code>
            </pre>
            </div>
            <div class="textwrap">
              <t-b>
                Note that all sizes are the same, i.e., 8 bytes. That&apos;s because the specified
                types are really handles to instances of those types stored in the managed heap.
              </t-b>
              <t-b>
                Copies of these are copies of the handles, not copies of the underlying type instances.
                Consequently, the result of a copy is two handles pointing to the same instance in
                the managed heap.
              </t-b>
              <t-b>
                The string type represents a constant sequence of unicode (16 bit) characters. Modification
                creates a new string with specified modification to the original characters. This is referred
                to as &quot;copy on write&quot;.
              </t-b>
              <t-b>
                Instances of the dynamic type are frequently used to interoperate with foreign code, especially
                native C++ used to define Microsoft Component Object Model (COM) facilities. In that case,
                dynamic typing greatly simplifies boilerplate code needed to use COM objects.
              </t-b>
              <t-b>
                Class defines a code structure that binds together functions and associated data, all focused on
                one particular concept or transformation, e.g., data records, events, messages, ...
              </t-b>
              <t-b>
                The .net libraries define many more types; and user programs define application specific types,
                that frequently use these language defined types as bases or aggregated instances.
              </t-b>
            </div>
          </div>
        </details>

        <div style="height:0.25em;"></div>
        <h3 id="librefs">1.4 Library-defined Reference Types</h3>
        <t-b>
          Many types are defined in <c-s>System.Collections</c-s> and <c-s>System.Collections.Generic</c-s>.
          Typical examples are the sequential collections:
          <c-s>Array, ArrayList, List&lt;T&gt;, Queue, Stack</c-s>, which
          all implement the <c-s>IList</c-s> inteface.
        </t-b>
        <t-b>
          The associative collections:
          <c-s>Hashtable, SortedList, SortedList&lt;Tkey, TValue&gt;, Dictionaryt&lt;Tkey, TValue&gt;</c-s>
          all derive from the <c-s>IDictionary</c-s> interface.
        </t-b>
        <t-b>
          We focus here on the
          <a target="_blank"
             href="https://learn.microsoft.com/en-us/dotnet/standard/collections/commonly-used-collection-types">
            Commonly Used Collections
          </a>
          <c-s>List&lt;T&gt;</c-s> and <c-s>Dictionary&lt;TKey, TValue&gt;</c-s> types.
        </t-b>
        <div class="block">
          <div class="codewrap">
            <pre>
<code class="language-cpp">  /*-- List&lt;int&gt; --*/
  List&lt;int&gt; li = new List&lt;int&gt; { 1, 2, 3, 2, 1 };
  int lfirst = li[0];
  li.Insert(5, 0);

  /*----------------------------------------------
    Alias declaration, shown here, must immediately
    follow a namespace declaration (see top of file)
    - using Dict = Dictionary&lt;string,int&gt;;
    This alias is used to simplify Dictionary 
    declarations below.
  */
  Dict dict = new Dict();
  dict.Add(&quot;three&quot;, 3);
  dict[&quot;zero&quot;] = 0;
  dict[&quot;one&quot;] = 1;
  dict[&quot;two&quot;] = 22;
  dict[&quot;two&quot;] = 2;  // overwrites previous value
  int oneval = dict[&quot;one&quot;];
  /*-----------------------------------------
    Find first key and value
    - this is here just to show how to retrieve
      an element from an associative collection
  */
  IDictionaryEnumerator enumr = 
    dict.GetEnumerator();
  if(enumr.MoveNext()) { // returns false at end
    string key = (string)enumr.Key;
    int? value = null;
    if(enumr.Value != null) {
      value = (int)enumr.Value;
    }
    // do something with key and value
  }
  /*-- alternate evaluation --*/
  List&lt;string&gt; keys = dict.Keys.ToList();
  if(keys.Count &gt; 0) {
    string keyfirst = keys[0];
    int valfirst = dict[keyfirst];
    // do something with key and value
  }
</code>
            </pre>
          </div>
          <div class="textwrap">
            <t-b>
              <c-s>List&lt;T&gt;</c-s> is sequential container with an expandable number of elements
              all of type t&epsilon;T.
            </t-b>
            <t-b>
              New lists are initialized with a braced list of elements of the specified type. Element values are
              accessed via indexing, and new values can be added, inserted, and removed.
            </t-b>
            <t-b>
              <c-s>Dictionary&lt;K, V&gt;</c-s> is an associative container of values accessed with keys.
              The associative containers use a table of buckets, where each bucket is a linked list of
              <c-s>KeyValuePair</c-s>s.  An item is accessed with a hashed address followed by a walk up
              the bucket list looking for the specified key to find its value.
            </t-b>
            <t-b>
              The table size is adjusted at run-time to keep the bucket lists short, e.g., one or two items.
              That means that value access via a key is nearly constant time, e.g., the time to compute
              the hashed address.
            </t-b>
            <t-b>
              <c-s>KeyValuePair</c-s>s are added using <c-s>Add(Key,Value)</c-s> or by &quot;indexing&quot
              with <c-s>Dict[key] = value</c-s>.
            </t-b>
            <t-b>
              All of the keys and values can be accessed sequentially using an enumerator since
              <c-s>Dictionary&lt;K, V&gt;</c-s>
              implements the <c-s>IEnumerable&lt;T&gt;</c-s> interface.
            </t-b>
            <t-b>
              Individual key-value pairs can be accessed from the dictionary&apos;s key collection, e.g.,
              <c-s>dict.keys.ToList()</c-s>.
            </t-b>
            <t-b>
              Collection elements can also be accessed using C#&apos;s <c-s>LINQ</c-s> facility.  That provides
              an <c-s>SQL</c-s> like programming interface:<br />
              <a target="_blank" href="https://learn.microsoft.com/en-us/dotnet/csharp/linq/query-a-collection-of-objects">
                Query a collection of objects
              </a>
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre>
<code class="language-cpp">  /*-- List&lt;int&gt; li = new List&lt;intgt; { 1, 2, 3, 2, 1 }; --*/
  li: Type: List`1
  value: System.Collections.Generic.List`1[System.Int32]
  size: 8
  /*-- li.Insert(5, 0) --*/
  List&lt;int&gt; { 1, 2, 3, 2, 1, 0 }

  /*-- Dict dict = new Dict(); --*/
  dict: Type: Dictionary`2
  value: System.Collections.Generic.Dictionary`2[ ...
  size: 8
  dict: { [three, 3], [zero, 0], [one, 1], [two, 2] }
</code>
            </pre>
            </div>
            <div class="textwrap">
              <t-b>
                Initialization and display of <c-s>List&lt;int&gt;</c-s> and <c-s>Dictionary&lt;string, int&gt;</c-s>
                are shown here.
              </t-b>
              <t-b>
                The output functionalities of <c-s>Console.Write</c-s> and <c-s>String.Format</c-s> do not enumerate
                through collection types.  Instead they display the compiler&apos;s version of the collection type name.
              </t-b>
              <t-b>
                Enumerated values shown here were generated from generic functions defined in
                <a target="_blank" href="https://github.com/JimFawcett/Bits/blob/master/CSharp/Cs_Data/AnalysisData.cs">
                  AnalysisData.cs
                </a>, found in the <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master">
                  Bits&nbsp;Repository
                </a>.
                These functions use C# syntax we won&apos;t cover until the
                <a target="_blank" href="Bits_GenericCSharp.html">C# Generics</a> bit.  We will discuss them in
                some detail in that Bit.  You don&apos;t need to
                understand how they work for now.
                <ul>
                  <li>
                    <c-s>ToStringRepIEnumerable&lt;List&lt;int&gt;, int&gt;(li)</c-s>
                  </li>
                  <li>
                    <c-s>ToStringRepAssocCont&lt;Dict,string,int&gt;(dict)</c-s>
                  </li>
                </ul>
                shown in <a target="_blank" href="#funcs">Section 3.0</a>, below.
              </t-b>
            </div>
          </div>
        </details>

        <div style="height:0.25em;"></div>
        <h3 id="copies">2.0 Copy Operations</h3>
        <t-b>
          This section presents basic type operations, e.g., copy construction and copy assignment. We will see
          that for value types these operations do bit-wise copy of values from source to destination.
        </t-b>
        <t-b>
          For reference types only references are copied, not the values they refer to. The purpose of this section
          is to explore the consequences of that behavior.
        </t-b>
        <div class="block">
          <div class="codewrap">
            <pre>
<code class="language-cpp">  /*--- copy value type ---*/

  int i = 42;
  string addri = ToStringAddress&lt;int&gt;(&i);

  int j = i;  // copy of value
  string addrj = ToStringAddress&lt;int&gt;(&j);

  /*--- copy reference ---*/

  List&lt;int&gt; li = new List&lt;int&gt; { 1, 2, 3, 2, 1 };
  string addrli = ToStringAddress&lt;List&lt;int&gt;&gt;(&li);

  List&lt;int&gt; lj = li;  // copy of ref
  string addrlj = ToStringAddress&lt;List&lt;int&gt;&gt;(&lj);</code>
            </pre>
          </div>
          <div class="textwrap">
            <t-b>
              Since i and j are value types, e.g., integers, the
              copy construction operation shown is a bit-wise copy of the value
              of the source i into the newly created destination j.
            </t-b>
            <t-b>
              The lists li and lj are reference types. That is, li is not an instance of a list,
              it is a handle to an instance of a list in the managed heap.
            </t-b>
            <t-b>
              The copy construction
              operation shown creates a new location to store a handle for lj and copies the
              li&apos;s reference into that location. The result is two handles pointing to
              the same underlying instance of a list in the managed heap.
            </t-b>
            <t-b>
              It is unfortunate that the same syntax results in very different semantics for value types
              and reference types.
            </t-b>
            <t-b>
              The <c-s>ToStringAddress&lt;T&gt;(T* ptr)</c-s> function creates a string representation
              of the specified addresses &amp;i, &amp;j, &amp;li, and &amp;lj. Its definition is shown
              in <a target="_blank" href="#funcs">Section 3.0</a>.
            </t-b>
            <t-b>
              Note that pointers can only be used in <c-s>unsafe</c-s> C# code blocks. We use the
              pointers to investigate consequences of copying.  They are not dereferenced in any part
              of this code.
            </t-b>
            <t-b>
              If you examine the output provided below, you will see that the address data verifies claims
              made in this text.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre>
<code class="language-shell">  -----------------------------------
  Demonstrate Copy Operations
  -----------------------------------

  --- int i = 42; ---
  i: address: 0xb2f397e958
  --- int j = i; // copy of value ---
  j: address: 0xb2f397e948
  --------------------------------------------------
  Addresses of i and j are unique, demonstrating
  value of i was copied to new j location.
  --------------------------------------------------

  --- List&lt;int&gt; li = new List&lt;int&gt; { 1, 2, 3, 2, 1 } ---
  li: address: 0xb2f397e938
  --- List&lt;int&gt; lj = li  // copy of reference ---
  lj: address: 0xb2f397e928
  -------------------------------------------------------
  Addresses of li and lj are adjacent, and adjacent to
  addresses of i and j in the stack frame.

  That demonstrates that lj is a copy of the handle li
  both of which point to the managed heap-based list
  instance.
  -------------------------------------------------------

  --- lj.Add(-1) ---
  lj: { 1, 2, 3, 2, 1, -1 }
  li: { 1, 2, 3, 2, 1, -1 }
  -------------------------------------------------------
  Note: changing lj results in the same change to li.
  This demonstrates that both variables refer to the
  same List&lt;int&gt; instance in the managed heap.
  -------------------------------------------------------

  Using ReferenceEquals(li, lj) we find:

    li is same object as lj</code>
            </pre>
            </div>
            <div class="textwrap">
              <t-b>
                The first few lines illustrate a copy of the integer value type <c-s>i</c-s> into a newly created
                integer <c-s>j</c-s>. This is a byte-wise copy of one location in the stack frame to another.
              </t-b>
              <t-b>
                The next lines demonstrate a copy of the reference type handle <c-s>li</c-s> to a new location
                in the stack frame for <c-s>lj</c-s>. this is a byte-wise copy of the <strong>handle</strong>,
                not the heap-based <c-s>List&lt;int&gt;</c-s> it points to.
                Both handles refer to the same managed instance.
              </t-b>
              <t-b>
                Those semantics are demonstrated by adding an element using the new handle <c-s>lj</c-s>, i.e.
                <c-s>lj.Add(-1)</c-s>, and observing
                that the original <c-s>li</c-s> now points to the modified list.
              </t-b>
              <t-b>
                Finally, we confirm those results using C#&apos;s <c-s>ReferenceEquals</c-s> method from the
                Object class.
              </t-b>
            </div>
          </div>
        </details>
        <div style="height:0.25em;"></div>
        <h3 id="funcs">3.0 Analysis and Display Functions</h3>
        <t-b style="margin-top:0em;">
          When you look at any of the &quot;Output&quot; details, you will see
          some output with detailed formatting, but you won&apos;t see code providing
          that output in corresponding code sections.
        </t-b>
        <t-b>
          Code responsible for formatting and supplying low-level details,
          like type information, has been elided from the examples shown above.
          The elided code consists of calls to functions shown in the dropdown below.
        </t-b>
        <t-b>
          These functions use language features, like generics, that will be covered
          in later Bits. You can find the complete code, including all the elisions,
          in the <a target="_blank" href="https://github.com/JimFawcett/Bits">Bits Repository</a>.
        </t-b>
        <details>
          <summary class="darkItem">Functions&nbsp;</summary>
        <div class="block">
          <div class="codewrap">
            <pre>
<code class="language-cpp">  class Anal {

    /*--------------------------------------------- 
      display the type of t using reflection 
    ---------------------------------------------*/
    public static void ShowType&lt;T&gt;(
      T t, String nm, String suffix = &quot;&quot;
    )
    {
      #pragma warning disable CS8602 // possible null ref
      Type tt = t.GetType();
      Console.WriteLine(&quot;{0}: Type: {1}&quot;, nm, tt.Name);
      int size = Anal.GetManagedSize(tt);
      Console.WriteLine(
        &quot;value: {0}&#92;nsize: {1}{2}&quot;, t, size, suffix
      );
      #pragma warning restore CS8602
    }
    /*---------------------------------------------
      return a string with type information 
    ---------------------------------------------*/
    public static string GetTypeString&lt;T&gt;(
      T t, String nm, String suffix = &quot;&quot;
    ) {
      #pragma warning disable CS8602 // possible null ref
      Type tt = t.GetType();
      string typeInfo = 
        String.Format(&quot;{0}: Type: {1}&#92;n&quot;, nm, tt.Name);
      int size = Anal.GetManagedSize(tt);
      string instanceInfo = 
        String.Format(
          &quot;value: {0}&#92;nsize: {1}{2}&quot;, t, size, suffix
        );
      return typeInfo + instanceInfo;
      #pragma warning restore CS8602
    }
    /*--------------------------------------------- 
      do t1 and t2 refer to same object? 
    ---------------------------------------------*/
    public static void IsSameObj&lt;T&gt;(
      T t1, String n1, T t2, String n2, 
      string suffix = &quot;&quot;
    ) {
      if(ReferenceEquals(t1, t2)) {
        Console.WriteLine(
          &quot;{0} is same object as {1}{2}&quot;,
          n1, n2, suffix
        );
      }
      else {
      Console.WriteLine(
        &quot;{0} is not same object as {1}{2}&quot;, 
        n1, n2, suffix
      );
      }
    }
    /*---------------------------------------------
      - GetMangedSize(Type type) is function that
        returns size of value types and handles.
      - It uses advanced techniques that will 
        eventually be covered elsewhere in this
        site. Knowing how it works is not essential 
        for things we are examining in this demo.
      - uses advanced relection
    ---------------------------------------------*/
    // https://stackoverflow.com/questions/8173239/...
    public static int GetManagedSize(Type type)
    {
      var method = new DynamicMethod(
        &quot;GetManagedSizeImpl&quot;, 
        typeof(uint), new Type[0],
        typeof(TypeExtensions), false
      );

      ILGenerator gen = method.GetILGenerator();
      gen.Emit(OpCodes.Sizeof, type);
      gen.Emit(OpCodes.Ret);

      var func = 
        (Func&lt;uint&gt;)method.CreateDelegate(
          typeof(Func&lt;uint&gt;)
        );
      return checked((int)func());
    }
    /*--------------------------------------------- 
      return string rep of argument&apos;s address 
    ---------------------------------------------*/
    #pragma warning disable 8500
    /*
      Suppress warning about taking address of 
      managed type. Pointer is used only to show 
      address of ptr as part of analysis of copy 
      operations.
    */
    public static unsafe string 
      ToStringAddress&lt;T&gt;(T* ptr) {
      if(ptr == null) {
        return &quot;&quot;;
      }
      IntPtr addr = (IntPtr)ptr;
      string addrstr = 
        string.Format(
          &quot;address: 0x&quot; + addr.ToString(&quot;x&quot;)
        );
      return addrstr;
    }
    #pragma warning restore 8500
  }
  class Display
  {
    /*---------------------------------------------
      show string description of operation 
    ---------------------------------------------*/
    public static void ShowOp(
      String op, String suffix = &quot;&quot;
    ) {
      Console.WriteLine(
        &quot;--- {0} ---{1}&quot;, op, suffix
      );
    }
    /*--------------------------------------------- 
      Display all elements of object&apos;s tree
      - uses advanced reflection
    ---------------------------------------------*/
    // https://stackoverflow.com/questions/7613782/...
    public static void Iterate&lt;T&gt;(T t) {
      Console.WriteLine(&quot;fields:&quot;);
      foreach(
        var field in typeof(T).GetFields(
          BindingFlags.Instance | 
          BindingFlags.NonPublic | 
          BindingFlags.Public
        )
      ) {
        Console.WriteLine(
          &quot;{0} = {1}&quot;, field.Name, field.GetValue(t)
        );
      }
      Console.WriteLine(&quot;methods:&quot;);
      foreach(
        var method in typeof(T).GetMethods(
          BindingFlags.Instance | BindingFlags.Public
        )
      ) {
        Console.WriteLine(
          &quot;{0}&quot;, method.Name
        );
      }
    }
    /*---------------------------------------------
      shorthand for console write command 
    ----------------------------------------------*/
    public static void Print(String s = &quot;&quot;) {
      Console.WriteLine(s);
    }
    /*---------------------------------------------
      Show text wrapped in horizontal lines
    ---------------------------------------------*/
    public static void ShowNote(
      string s, string suffix = &quot;&quot;, int length = 35
    ) {
      string line = new string('-', length);
      Console.WriteLine(line);
      Console.WriteLine(&quot;  {0}&quot;, s);
      Console.WriteLine(line + suffix);
    }
    /*---------------------------------------------
      Build string rep of array of type T
    ---------------------------------------------*/
    public static string ToStringRepArray&lt;T&gt;(T[] arr) {
      StringBuilder sb = new StringBuilder();
      sb.Append(&quot;{ &quot;);
      bool first = true;
      foreach(T item in arr) {
        if(item == null) {
          break;
        }
        if(first) {
          sb.Append(item.ToString());
          first = false;
        }
        else {
          sb.AppendFormat(&quot;, {0}&quot;, item);
        }
      }
      sb.Append(&quot; }&#92;n&quot;);
      return sb.ToString();
    }
    /*---------------------------------------------
      Build string rep of IEnumerable collection
      T&lt;U&gt;. Works for array too.
    ---------------------------------------------*/
    public static string 
      ToStringRepIEnumerable&lt;T,U&gt;(T enu)
      where T:IEnumerable&lt;U&gt;
    {
      StringBuilder sb = new StringBuilder();
      sb.Append(&quot;{ &quot;);
      bool first = true;
      foreach(U item in enu) {
        if(item == null) {
          break;
        }
        if(first) {
          sb.Append(item.ToString());
          first = false;
        }
        else {
          sb.AppendFormat(&quot;, {0}&quot;, item);
        }
      }
      sb.Append(&quot; }&#92;n&quot;);
      return sb.ToString();
    }
  }
  /*-----------------------------------------------------
    Direct implementation of enumerating associative
    collection.  This can also be done with 
    ToStringRepIEnumerable&lt;Dict,KVPair&gt;(dict).
  -----------------------------------------------------*/
  public static string 
    ToStringRepAssocCont&lt;Dict,Key,Value&gt;(Dict assoc)
    where Dict:IDictionary&lt;Key,Value&gt;
  {
    StringBuilder sb = new StringBuilder();
    sb.Append(&quot;{ &quot;);
    bool first = true;
    foreach(var item in assoc) {
      if(first) {
        var sf = String.Format(
          &quot;{{ {0}, {1} }}&quot;, item.Key, item.Value
        );
        sb.Append(sf);
        first = false;
      }
      else {
        sb.AppendFormat(
          &quot;, {{ {0}, {1} }}&quot;, item.Key, item.Value
        );
      }
    }
    sb.Append(&quot; }&#92;n&quot;);
    return sb.ToString();
  }
}</code>
            </pre>
          </div>
          <div class="textwrap">
            <t-b>
              These functions are all static member functions of one of two classes.  Class <c-s>Anal</c-s> holds functions that
              analyze types and their operations. Class <c-s>Display</c-s> holds functions that supply text information to
              the output.
            </t-b>
            <t-b>
              Many of these use reflection, which we have not covered yet.  It is not critical that you understand
              all the details.  Just knowing what they do is sufficient for this Bit.
            </t-b>
            <t-b>
              We will cover some of them in detail in the <a target="_blank" href="Bits_GenericCSharp.html">Generics Bit</a>.
            </t-b>
          </div>
        </div>
        </details>
        <div style="height:0.75em;"></div>
        <h3 id="ide">4.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for CSharp\CSharp_Data.
        </t-b>
        <photosizer-block src="pictures/VS_Code_CSharp_Data.JPG" width="700" class="photoSizerBlock left">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE - C# Data</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/VS_Code_Debugging_CSharp_Hello.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 2. Debugging C#</span>
  </photosizer-block>-->
        <photosizer-block src="pictures/LaunchJSON_CSharp_Data.JPG" width="700" class="photoSizerBlock left">
          <span style="font-family:'Comic Sans MS';">Figure 2. C# Data Launch.JSON</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/VS_Code_CSharp_Plugins.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 3. C# Plugins</span>
  </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refers">5.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/">
                C# Type System - Microsoft
              </a>
            </td>
            <td>
              Discussion with examples
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types">
                C# Type Reference - Microsoft
              </a>
            </td>
            <td>
              Semi-formal description of C# Types
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
    </main>
  </page-frame>
  <script>
  </script>
  <script>
 </script>
</body>
</html>