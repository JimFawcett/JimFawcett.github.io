<!DOCTYPE html>
<html>
<!--
  Bits_IterCppContent.html
-->
<head>
  <title>Bits_Iter C++</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeCpp.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBitsRust.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <link rel="stylesheet" href="css/Styles_BitsContent.css" />
  <script src="js/Scripts_BitsContent.js"></script>
  <link rel="stylesheet" href="css/StylesSplitterBar.css" />
  <script src="js/ScriptsSplitterBar.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <script>
    function remote() {
      window.open('https://godbolt.org/z/xWqqT1457', '_blank');
    }
  </script>
</head>
<body id="github" onload="load()">

  <a id="Next" href="Bits_Intro.html">Next</a>
  <a id="Prev" href="Bits_GenericCpp.html">Prev</a>

  <page-frame>
    <!-- <frame-header>
      <nav id="navbar"></nav>
    </frame-header> -->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits Iter C++</div>
      <div id="modified">06/16/2024</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.50em; width:max-content; height:1.5em;
           text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits_Iter C++</h1>
            <h3 id="subtitle" class="indent">
              code, output, and build for C++ on Windows, macOS, and Linux
            </h3>
          </hgroup>
        </header>
        <t-b style="border:2px solid red; padding:0.5em 1.5em;">
          This page is a prototype used to decide which language features to emphasize. It will
          be replaced with a final version soon.
        </t-b>
        <t-b style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          This Bit demonstrates uses of C++ iterators to walk through enumerable collections.
          The purpose is to quickly acquire some familiarity with C++ iteration.
          <hr class="spread" />
          <ul>
            <li>
              C++ Iterators are smart pointers that are provided by, and have special knowledge about the
              structure of, C++ iterable containers.
            </li>
            <li>
              An iterable C++ container provides <c-s>begin()</c-s> and <c-s>end()</c-s> methods which return
              iterators pointing to the first and one past the last element of the container.
            </li>
          </ul>
          <div style="height:0.5em;"></div>
        </t-b>
        <details id="notes">
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <t-b><hr /></t-b>
          <t-b>
            All of the languages covered in this demonstration support iteration using iterators.
          </t-b>
          <t-b>
            C++ iterators are provided by enumerable containers and have a public interface similar
            to, but smaller than native pointers. Any operation that moves data under an iterator,
            like insertion, causes invalidation and any subsequent dereference operation will
            throw an exception.
          </t-b>
          <t-b>
            User-defined types can also provide iterators, as shown in the example code below.
          </t-b>
          <!--<t-b>
      Rust iterators satisfy the Iterator Trait with a <c-s>next() -> Option&lt;T&gt;</c-s>.
      Each call to <c-s>next()</c-s> returns the next item, if any, else None.
    </t-b>
    <t-b>
      C# iterators satisfy the IEnumerable&lt;T&gt; interface with a <c-s>bool MoveNext()</c-s>
      and <c-s>Current</c-s> property.
    </t-b>
    <t-b>
      Python iterators .
    </t-b>-->
          <t-b><hr /></t-b>
        </details>
        <t-b>
          The examples below show how to use library and user defined types with emphasis on
          illustrating iteration through container elements.
        </t-b>
        <div style="height:0.25em;"></div>
        <h3 id="iterators">1.0 Iterators</h3>
        <t-b>
          C++ iterators have the size and interface of native C++ pointers. Each standard iterable container,
          like <c-s>std::vector&lt;T&gt;</c-s> and <c-s>std::unordered_map&lt;K, V&gt;</c-s> provide
          iterators that are designed to step through the container&apos;s data structure.
        </t-b>
        <h4>Table 1. - Basic Iterator Operations</h4>
        <table>
          <tr>
            <td>
              <c-s>c.begin()</c-s>
            </td>
            <td>
              returns iterator pointing to the first element of <c-s>c&nbsp;&epsilon;&nbsp;C</c-s>
            </td>
          <tr>
            <td>
              <c-s>c.end()</c-s>
            </td>
            <td>
              returns iterator pointing to one past the last element of <c-s>c&nbsp;&epsilon;&nbsp;C</c-s>
            </td>
          </tr>
          <tr>
            <td>
              <c-s>auto iter = c.begin();<br />iter++;<br />val = *iter;</c-s>
            </td>
            <td>
              After executing this code
              iter points to the second element of <c-s>c&nbsp;&epsilon;&nbsp;C</c-s>.<br />
              <c-s>val</c-s> is the value of the second element of <c-s>c</c-s>.
            </td>
          </tr>
          <tr>
            <td>
              <c-s>
                for(auto item : c) {<br />
                &nbsp;&nbsp;&nbsp;/*&nbsp;do&nbsp;something&nbsp;with&nbsp;item&nbsp;*/<br />
                }
              </c-s>
            </td>
            <td>
              range-for extracts iterator from <c-s>c</c-s> and does the equivalent of:<br />
              <c-s>
                for(auto itr = c.begin(); itr != c.end(); ++itr)<br />
                {&nbsp;/*&nbsp;do&nbsp;some&nbsp;thing with *iter&nbsp;*/&nbsp;}
              </c-s>.
            </td>
          </tr>
        </table>
        <h3 id="code">2.0 Source Code</h3>
        <t-b>
          The code block below uses operations from Table 1. in executable code.
        </t-b>
        <t-b>
          This block contains two panels seperated by a splitter-bar. You can expand the width
          of either panel by dragging the splitter bar or by clicking in either panel.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="basics-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('basics-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------
  Basic iterator operations
  - uses std::vector&lt;int&gt;
  - could be any other iterable container
*/
void iteratorBasics() {
  showOp(&quot;iterator basics&quot;);
  std::cout &lt;&lt; std::endl;

  auto v = std::vector&lt;int&gt; { 1, 2, 3, 4, 5 };

  /* basic loop showing iterator usage */
  for(auto itr = v.begin(); itr != v.end(); ++itr) {
    std::cout &lt;&lt; *itr &lt;&lt; &quot; &quot;;
  }
  std::cout &lt;&lt; &quot; - using basic for loop&quot; &lt;&lt; std::endl;

  /* range-for uses iterator internally */
  for(auto item : v) {
    std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;
  }
  std::cout &lt;&lt; &quot; - using range-for&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; std::endl;
}</code></pre>
              </div>
            </first-item>
            <splitter-bar id="basics-seperator"></splitter-bar>
            <second-item id="basics-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('basics-first')">
                <pre style="width:200em;"><code class="language-shell">





  --- iterator basics ---
1 2 3 4 5  - using basic for loop
1 2 3 4 5  - using range-for
</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="speccoll">2.1 Iteration for Specified Collections</h3>
        <t-b>
          The demos in this code block use iterators explicitly or range-for loops which use
          iterators internally.
        </t-b>
        <t-b>
          All of the demos show different ways of displaying an iterable container&apos;s elements,
          using for loops, range-for loops, and do-while loops.
        </t-b>
        <t-b>
          All the demos uses either a <c-s>std::vector&lt;T&gt;</c-s> or a custom <c-s>Point&lt;T,&nbsp;N&gt;</c-s>
          type that provides the expected iterable operations:
          <div class="inset">
            <c-s>begin()</c-s>, <c-s>end()</c-s>,
            and index operators <c-s>T&&nbsp;operator[](size_t&nbsp;i)</c-s> and
            <c-s>const&nbsp;T&nbsp;operator[](size_t&nbsp;i)</c-s>
          </div>
        </t-b>
        <t-b>
          Implementation of <c-s>Point&lt;T,&nbsp;N&gt;</c-s> will be discussed in detail in the next section.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="speccoll-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('speccoll-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------
  demoIndexer(const std::vector&lt;T&gt;& v)
  - accepts std::vector&lt;T&gt;
  - creates comma separated list
  - uses indexing, not using iterator
*/
template&lt;typename T&gt;
void indexerVec(const std::vector&lt;T&gt;& v) {
  if(v.size() &lt; 1)
    return;
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; v[0];
  for(size_t i = 1; i&lt;v.size(); ++i) {
    std::cout &lt;&lt; &quot;, &quot;  &lt;&lt; v[i];
  }
}
void executeIndexerVec() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoIndexerVec(v)&quot;;
  auto v = std::vector&lt;int&gt; { 1, 2, 3, 2, 1 };
  indexerVec(v);
}
/*-----------------------------------------------
  demoIteratorVec
  - accepts std::vector&lt;T&gt; instances
  - uses iterator
*/
template&lt;typename T&gt;
void iteratorVec(const std::vector&lt;T&gt;& v) {
  auto itr = v.begin();
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; *itr;
  while(++itr != v.end()) {
    std::cout &lt;&lt; &quot;, &quot; &lt;&lt; *itr;
  }
}
void executeIteratorVec() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoIteratorVec(v)&quot;;
  auto v = std::vector&lt;int&gt; { 1, 2, 3, 2, 1 };
  iteratorVec(v);
}
/*-----------------------------------------------
  demoForLoopVec
  - accepts std::vector&lt;T&gt; instances
  - uses range-for to display elements
  - that uses iterator implicitly
*/
template&lt;typename T&gt;
void forLoopVec(const std::vector&lt;T&gt;& v) {
  std::cout &lt;&lt; &quot;&#92;n  &quot;;
  for(auto const &item : v) {
    std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;
  }
}
void executeForLoopVec() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoForLoopVec(v)&quot;;
  auto v = std::vector&lt;int&gt; { 1, 2, 3, 2, 1 };
  forLoopVec(v);
}
/*-----------------------------------------------
  forLoopPoint
  - accepts Point&lt;T, N&gt; instances by constant reference.
  - uses range-for to display Point coordinates
  - creates comma separated list
*/
template&lt;typename T, const size_t N&gt;
void forLoopPoint(const Point&lt;T, N&gt;& p) {
  auto s = std::stringstream();
  s &lt;&lt; &quot;&#92;n  &quot;;
  for(auto const &item : p) {
    s &lt;&lt; item &lt;&lt; &quot;, &quot;;
  }
  auto str = s.str();
  /* remove last &quot;, &quot; */
  str.pop_back();
  str.pop_back();
  std::cout &lt;&lt; str;
}
void executeForLoopPoint() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoForLoopPoint(v)&quot;;
  /* using initialization list */
  auto p = Point&lt;int, 5&gt; { 1, 2, 3, 2, 1 };
  forLoopPoint(p);
}
/*-----------------------------------------------
  whilerPoint
  - accepts Point&lt;T, N&gt; instances by constant reference.
  - explicit use of iterator to display PointN coordinates
  - creates comma separated list
*/
template&lt;typename T, const size_t N&gt;
void whilerPoint(const Point&lt;T, N&gt;& p) {
  auto itr = p.begin();
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; *itr++;
  while (itr &lt; p.end()) {
    std::cout &lt;&lt; &quot;, &quot; &lt;&lt; *itr++;
  }
}
void executeWhilerPoint() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhilerPoint(v)&quot;;
  auto p = Point&lt;int, 5&gt;();
  /* using indexer */
  p[0] = 1;
  p[1] = 2;
  p[2] = 3;
  p[3] = 2;
  p[4] = 1;
  whilerPoint(p);
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="speccoll-seperator"></splitter-bar>
            <second-item id="speccoll-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('speccoll-first')">
                <pre style="width:200em;"><code class="language-shell">
  --- collection specific iterations ---





execute indexerVec(v)
1, 2, 3, 2, 1

















execute iteratorVec(v)
1, 2, 3, 2, 1

















execute forLoopVec(v)
1 2 3 2 1
















execute forLoopPoint(v)
1, 2, 3, 2, 1























execute whilerPoint(v)
1, 2, 3, 2, 1

</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="gencoll">2.2 Iteration for Generic Collections</h3>
        <t-b>
          It only requires a little more effort to make functions that iterate over generic collections, 
          e.g., collections that support:
          <div class="inset">
            <c-s>begin()</c-s>, <c-s>end()</c-s>,
            and index operators <c-s>T&&nbsp;operator[](size_t&nbsp;i)</c-s> and
            <c-s>const&nbsp;T&nbsp;operator[](size_t&nbsp;i)</c-s>
          </div>
          How to do that is what this section illustrates.
        </t-b>
        <t-b>
          It is a bit harder to handle errors by returning an error message if a collection is not
          iterable instead of simply failing to compile with often obscure error messages. That takes
          a small amount of template metaprogramming. The last example does that.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="gencoll-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('gencoll-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------
  demoWhiler
  - is flexible function that accepts any
    iterable container
  - uses iterator on C.
  - creates comma separated list
*/
template&lt;typename C&gt;
void demoWhiler(const C& c) {
  auto itr = c.begin();  // uses const overload
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; *itr++;
  while (itr != c.end()) {
    std::cout &lt;&lt; &quot;, &quot; &lt;&lt; *itr++;
  }
}
void executeDemoWhiler() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhiler(c) with string&quot;;
  auto s = std::string(&quot;a string&quot;);
  demoWhiler(s);
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhiler(c) with vector&quot;;
  auto v = std::vector&lt;double&gt; { 1.0, 1.5, -1.5, -1.0, 0 };
  demoWhiler(v);
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhiler(c) with Point&quot;;
  auto p = Point&lt;double, 5&gt; { 1.0, 2.0, 3.0, 2.0, 1.0 };
  demoWhiler(p);
}
/*-----------------------------------------------
  whiler_guarded is flexible function that accepts
  any container
  - if C is iterable will use iterator on C.
  - If non-iterable input is detected,
    will display error msg and return.
  - decision is made at compile time.
  - is_iterable_v is defined in Analysis.h
  - max is the maximum number of items
    to show on one line
*/
template&lt;typename C&gt;
void whilerGuarded(
  const C& c, const std::string& name,
  size_t indent = 2, size_t max = 8
  ) {
  if constexpr(!is_iterable_v&lt;C&gt;) {  // decision at compile-time
    std::cout &lt;&lt; &quot;&#92;n  whiler input type is not iterable&quot;;
    return;
  }
  else {
    std::cout &lt;&lt; formatColl(c, name, &quot;&quot;, indent, max);
    /*
      Analysis::formatColl uses range-based for loop to iterate
      over collection, folding output into rows of max items.

      Could have used the same iteration as in demoWhiler
      but wanted to show nicer formatting.
    */
  }
}
void executeWhilerGuarded() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhilerGuarded(c) with vector&quot;;
  auto v = std::vector&lt;int&gt; { 1, 2, 3, 2, 1, 0, -1, -2, -3, -4 };
  whilerGuarded(v, &quot;vector&quot;);
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhiler(c) with double&quot;;
  whilerGuarded(3.5, &quot;double&quot;);
  auto v2 = std::vector&lt;int&gt; { 1, 2, 3, 4, 5 };
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="gencoll-seperator"></splitter-bar>
            <second-item id="gencoll-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('gencoll-first')">
                <pre style="width:200em;"><code class="language-shell">
  --- accepts any iterable collection ---














execute demoWhiler(c) with string
  a,  , s, t, r, i, n, g

execute demoWhiler(c) with vector
  1.0, 1.5, -1.5, -1.0, 0.0

execute demoWhiler(c) with Point
  1.0, 2.0, 3.0, 2.0, 1.0



  --- detects non-iterable input at compile-time ---




























execute demoWhilerGuarded(c) with vector
  vector : {
    1, 2, 3, 2, 1, 0, -1, -2,
    -3, -4
  }

execute demoWhiler(c) with double
  whiler input type is not iterable

</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>


        <h4 id="build">3.0 Build</h4>
        <div style="border:2px solid var(--dark); padding:0.25em; width:max-content;">
          <pre style="width:100%; margin:0em;"><code class="language-term">C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Iter
&gt; cd build
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Iter&#92;build
&gt; cmake ..
-- Selecting Windows SDK version 10.0.22000.0 to target Windows 10.0.22621.
-- Configuring done
-- Generating done
-- Build files have been written to: C:/github/JimFawcett/Bits/Cpp/Cpp_Iter/build
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Iter&#92;build
&gt; cmake --build .
MSBuild version 17.5.1+f6fdcf537 for .NET Framework

  Checking Build System
  Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Iter/CMakeLists.txt
  Cpp_Iter.vcxproj -&gt; C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Iter&#92;build&#92;Debug&#92;Cpp_Iter.ex
  e
  Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Iter/CMakeLists.txt
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Iter&#92;build
&gt;
</code></pre>
        </div>
        <h3 id="ide">4.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Cpp\Cpp_Iter.
        </t-b>
        <photosizer-block src="pictures/Debug_CppIter.JPG" width="800" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE - Debug Cpp_Iter</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/LaunchJSON_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
    style="overflow-x:auto;"
  >
    <span style="font-family:'Comic Sans MS';">Figure 2. Launch.JSON</span>
  </photosizer-block>
  <photosizer-block src="pictures/VS_Code_Debugging_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
    style="overflow-x:auto;"
  >
    <span style="font-family:'Comic Sans MS';">Figure 3. Debugging Objects</span>
  </photosizer-block>-->
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
  </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../CppStory_LibrarySTL.html">C++ Story: Standard Template Library</a>
            </td>
            <td>
              Covers containers, iterators, and STL algorithms
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../CppStoryRepo.html">C++ Story</a>
            </td>
            <td>
              E-book with thirteen chapters covering most of intermediate C++
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../CppBites/CppBites_Intro.html">C++ Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <!-- <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ide">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">bld</a></menu-elem>
        <menu-elem class="secElem"><a href="#out">out</a></menu-elem>
        <menu-elem class="secElem"><a href="#analysis">anal</a></menu-elem>
        <menu-elem class="secElem"><a href="#points">pts</a></menu-elem>
        <menu-elem class="secElem"><a href="#source">src</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">codeSnaps</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections> -->
    </main>
    <!-- <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer> -->
  </page-frame>
  <!-- <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn + ":";
  </script>
  <script>
    getScroll();
  </script> -->
  <script>
    onLoadSplitter("basics");
    onLoadSplitter("speccoll");
    onLoadSplitter("gencoll");
    onLoadSplitter("pointdef");
    onLoadSplitter("pointdemo");
    onLoadSplitter("structure");
    onLoadSplitter("methods");
    onLoadSplitter("fig4");
    onLoadSplitter("fig5");
    onLoadSplitter("fig6");
    onLoadSplitter("fig7");
    onLoadSplitter("fig8");
    onLoadSplitter("fig9");
    onLoadSplitter("fig10");
  </script>
</body>
</html>