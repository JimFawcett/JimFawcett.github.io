<!DOCTYPE html>
<html>
<!--
  Bits_IterCppContent.html
-->
<head>
  <title>Bits_Iter C++</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeCpp.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrameBitsCpp.js"></script>
  <script src="js/ScriptsPageFramePagesBitsRust.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <link rel="stylesheet" href="css/Styles_BitsContent.css" />
  <script src="js/Scripts_BitsContent.js"></script>
  <link rel="stylesheet" href="css/StylesSplitterBar.css" />
  <script src="js/ScriptsSplitterBar.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <script>
    function remote() {
      window.open('https://godbolt.org/z/xWqqT1457', '_blank');
    }
  </script>
  <script>
    function loadifbits() {
      console.log(window.location);
      console.log(window.parent.location);
      console.log(window.top.location);
      var loc = window.location.href;
      if (window.parent === window.top) {
        window.top.location.href = '../../TOCBits.html?src=' + 'Resources/Bits/Bits_IterCpp.html';
      }
      else {
        window.top.location.href = 'Bits_IterCpp.html';
      }
    }
    function logme() {
      console.log(window.location.href);
      console.log(window.parent.location);
      console.log(window.top.location);
    }
  </script>
</head>
<body id="github" onload="load()">

  <a id="Next" href="Bits_Intro.html">Next</a>
  <a id="Prev" href="Bits_GenericCpp.html">Prev</a>

  <page-frame>
    <!-- <frame-header>
      <nav id="navbar"></nav>
    </frame-header> -->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits Iter C++</div>
      <div id="modified">06/16/2024</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.50em; width:max-content; height:1.5em;
           text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle" onclick="loadifbits()" style="cursor:pointer;" title="toggle Bits Explorer">
            <h1 id="title">Bits: C++ Iteration</h1>
            <h3 id="subtitle" class="indent">
              indexing into and iteration through std and user-defined collections
            </h3>
          </hgroup>
        </header>
        <!-- <t-b style="border:2px solid red; padding:0.5em 1.5em;">
    This page is a prototype used to decide which language features to emphasize. It will
    be replaced with a final version soon.
  </t-b> -->
        <t-b style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          This Bit demonstrates uses of C++ iterators to walk through enumerable collections.
          The purpose is to quickly acquire some familiarity with C++ iteration.
          <hr class="spread" />
          <ul>
            <li>
              C++ Iterators are smart pointers that are provided by, and have special knowledge about the
              structure of, C++ iterable containers.
            </li>
            <li>
              An iterable C++ container provides <c-s>begin()</c-s> and <c-s>end()</c-s> methods which return
              iterators pointing to the first and one past the last element of the container.
            </li>
          </ul>
          <div style="height:0.5em;"></div>
        </t-b>
        <details id="notes">
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <t-b><hr /></t-b>
          <t-b>
            All of the languages covered in this demonstration support iteration using iterators.
          </t-b>
          <t-b>
            C++ iterators are provided by enumerable containers and have a public interface similar
            to, but smaller than native pointers. Any operation that moves data under an iterator,
            like insertion, causes invalidation and any subsequent dereference operation will
            throw an exception.
          </t-b>
          <t-b>
            User-defined types can also provide iterators, as shown in the example code below.
          </t-b>
          <!--<t-b>
      Rust iterators satisfy the Iterator Trait with a <c-s>next() -> Option&lt;T&gt;</c-s>.
      Each call to <c-s>next()</c-s> returns the next item, if any, else None.
    </t-b>
    <t-b>
      C# iterators satisfy the IEnumerable&lt;T&gt; interface with a <c-s>bool MoveNext()</c-s>
      and <c-s>Current</c-s> property.
    </t-b>
    <t-b>
      Python iterators .
    </t-b>-->
          <t-b><hr /></t-b>
        </details>
        <t-b>
          The examples below show how to use library and user defined types with emphasis on
          illustrating iteration through container elements.
        </t-b>
        <div style="height:0.25em;"></div>
        <h3 id="iterators">1.0 Iterators</h3>
        <t-b>
          C++ iterators have the size and interface of native C++ pointers. Each standard iterable container,
          like <c-s>std::vector&lt;T&gt;</c-s> and <c-s>std::unordered_map&lt;K, V&gt;</c-s> provide
          iterators that are designed to step through the container&apos;s data structure. That is accomplished
          by defining operator overloads like <c-s>C::operator++()</c-s> where C is an iterable container.
        </t-b>
        <h4>Table 1. - Basic Iterator Operations</h4>
        <table>
          <tr>
            <td>
              <c-s>c.begin()</c-s>
            </td>
            <td>
              returns iterator pointing to the first element of <c-s>c&nbsp;&epsilon;&nbsp;C</c-s>
            </td>
          <tr>
            <td>
              <c-s>c.end()</c-s>
            </td>
            <td>
              returns iterator pointing to one past the last element of <c-s>c&nbsp;&epsilon;&nbsp;C</c-s>
            </td>
          </tr>
          <tr>
            <td>
              <c-s>auto iter = c.begin();<br />iter++;<br />val = *iter;</c-s>
            </td>
            <td>
              After executing this code
              iter points to the second element of <c-s>c&nbsp;&epsilon;&nbsp;C</c-s>.<br />
              <c-s>val</c-s> is the value of the second element of <c-s>c</c-s>.
            </td>
          </tr>
          <tr>
            <td>
              <c-s>
                for(auto item : c) {<br />
                &nbsp;&nbsp;&nbsp;/*&nbsp;do&nbsp;something&nbsp;with&nbsp;item&nbsp;*/<br />
                }
              </c-s>
            </td>
            <td>
              range-for extracts iterator from <c-s>c</c-s> and does the equivalent of:<br />
              <c-s>
                for(auto itr = c.begin(); itr != c.end(); ++itr)<br />
                {&nbsp;/*&nbsp;do&nbsp;some&nbsp;thing with *iter&nbsp;*/&nbsp;}
              </c-s>.
            </td>
          </tr>
        </table>
        <h3 id="code">2.0 Source Code</h3>
        <t-b>
          Code for this &quot;Iteration Bit&quot; is partitioned into Basics, iteration over concretely
          specified containers, iteration over generic containers, and over custom iterable types.
        </t-b>
        <t-b style="width:max-content; padding:0.0em 1em;">
          <table>
            <tr>
              <td>
                Source code for this bit can be found here:
              </td>
              <td>
                <a target="_blank" href="https://github.com/JimFawcett/Bits/tree/master/Cpp/Cpp_Iter/src">Bits Iter C++ code</a>
              </td>
            </tr>
            <tr>
              <td>
                All of the bits code is here:<br />
                You can clone this repository and run all the examples locally.
              </td>
              <td>
                <a target="_blank" href="https://github.com/JimFawcett/Bits">Bits code</a>
              </td>
            </tr>
          </table>
        </t-b>
        <h3 id="basics">2.1 Basic Iteration</h3>
        <t-b>
          The code block below uses operations from Table 1. in executable code using
          <c-s>std::vector&lt;int&gt;</c-s> and <c-s>int [N]</c-s> collections. Note that native
          arrays don&apos;t have methods, so the std::library provides <c-s>std::begin(arrayName)</c-s>
          and <c-s>std::end(arrayName)</c-s> functions. Native pointers are used as iterators for
          native arrays.
        </t-b>
        <t-b>
          This block contains two panels seperated by a splitter-bar. You can expand the width
          of either panel by dragging the splitter bar or by clicking in either panel.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="basics-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('basics-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------
  Basic iterator operations
  - uses std::vector&lt;int&gt;
  - could be any other iterable container
*/
void iteratorBasics() {
  showOp(&quot;iterator basics&quot;);
  std::cout &lt;&lt; std::endl;

  auto v = std::vector&lt;int&gt; { 1, 2, 3, 4, 5 };

  /* basic loop showing iterator usage */
  for(auto itr = v.begin(); itr != v.end(); ++itr) {
    std::cout &lt;&lt; *itr &lt;&lt; &quot; &quot;;
  }
  std::cout &lt;&lt; &quot; - using basic for loop&quot; &lt;&lt; std::endl;

  /* range-for uses iterator internally */
  for(auto item : v) {
    std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;
  }
  std::cout &lt;&lt; &quot; - using range-for&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; std::endl;

  int arr[5] { 1, 2, 3, 2, 1 };

  /* basic loop showing iterator usage */
  for(auto itr = std::begin(arr); itr != std::end(arr); ++itr) {
    std::cout &lt;&lt; *itr &lt;&lt; &quot; &quot;;
  }
  std::cout &lt;&lt; &quot; - using basic for loop with native array&quot; &lt;&lt; std::endl;

  /* range-for uses iterator internally */
  for(auto item : arr) {
    std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;
  }
  std::cout &lt;&lt; &quot; - using range-for with native array&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; std::endl;
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="basics-seperator"></splitter-bar>
            <second-item id="basics-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('basics-first')">
                <pre style="width:200em;"><code class="language-shell">





  --- iterator basics ---




1 2 3 4 5  - using basic for loop





1 2 3 4 5  - using range-for








1 2 3 2 1  - using basic for loop with native array





1 2 3 2 1  - using range-for with native array
</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="speccoll">2.2 Iteration for Specified Collections</h3>
        <t-b>
          The demos in this code block use iterators explicitly or range-for loops which use
          iterators internally.
        </t-b>
        <t-b>
          All of the demos show different ways of displaying an iterable container&apos;s elements,
          using for loops, range-for loops, and do-while loops.
        </t-b>
        <t-b>
          All the demos uses either a <c-s>std::vector&lt;T&gt;</c-s> or a custom <c-s>Point&lt;T,&nbsp;N&gt;</c-s>
          type that provides the expected iterable operations:
          <div class="inset">
            <c-s>begin()</c-s>, <c-s>end()</c-s>,
            and index operators <c-s>T&&nbsp;operator[](size_t&nbsp;i)</c-s> and
            <c-s>const&nbsp;T&nbsp;operator[](size_t&nbsp;i)</c-s>
          </div>
        </t-b>
        <t-b>
          Implementation of <c-s>Point&lt;T,&nbsp;N&gt;</c-s> will be discussed in detail in  section.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="speccoll-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('speccoll-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------
  demoIndexer(const std::vector&lt;T&gt;& v)
  - accepts std::vector&lt;T&gt;
  - creates comma separated list
  - uses indexing, not using iterator
*/
template&lt;typename T&gt;
void indexerVec(const std::vector&lt;T&gt;& v) {
  if(v.size() &lt; 1)
    return;
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; v[0];
  for(size_t i = 1; i&lt;v.size(); ++i) {
    std::cout &lt;&lt; &quot;, &quot;  &lt;&lt; v[i];
  }
}
void executeIndexerVec() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoIndexerVec(v)&quot;;
  auto v = std::vector&lt;int&gt; { 1, 2, 3, 2, 1 };
  indexerVec(v);
}
/*-----------------------------------------------
  demoIteratorVec
  - accepts std::vector&lt;T&gt; instances
  - uses iterator
*/
template&lt;typename T&gt;
void iteratorVec(const std::vector&lt;T&gt;& v) {
  auto itr = v.begin();
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; *itr;
  while(++itr != v.end()) {
    std::cout &lt;&lt; &quot;, &quot; &lt;&lt; *itr;
  }
}
void executeIteratorVec() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoIteratorVec(v)&quot;;
  auto v = std::vector&lt;int&gt; { 1, 2, 3, 2, 1 };
  iteratorVec(v);
}
/*-----------------------------------------------
  demoForLoopVec
  - accepts std::vector&lt;T&gt; instances
  - uses range-for to display elements
  - that uses iterator implicitly
*/
template&lt;typename T&gt;
void forLoopVec(const std::vector&lt;T&gt;& v) {
  std::cout &lt;&lt; &quot;&#92;n  &quot;;
  for(auto const &item : v) {
    std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;
  }
}
void executeForLoopVec() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoForLoopVec(v)&quot;;
  auto v = std::vector&lt;int&gt; { 1, 2, 3, 2, 1 };
  forLoopVec(v);
}
/*-----------------------------------------------
  forLoopPoint
  - accepts Point&lt;T, N&gt; instances by constant reference.
  - uses range-for to display Point coordinates
  - creates comma separated list
*/
template&lt;typename T, const size_t N&gt;
void forLoopPoint(const Point&lt;T, N&gt;& p) {
  auto s = std::stringstream();
  s &lt;&lt; &quot;&#92;n  &quot;;
  for(auto const &item : p) {
    s &lt;&lt; item &lt;&lt; &quot;, &quot;;
  }
  auto str = s.str();
  /* remove last &quot;, &quot; */
  str.pop_back();
  str.pop_back();
  std::cout &lt;&lt; str;
}
void executeForLoopPoint() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoForLoopPoint(v)&quot;;
  /* using initialization list */
  auto p = Point&lt;int, 5&gt; { 1, 2, 3, 2, 1 };
  forLoopPoint(p);
}
/*-----------------------------------------------
  whilerPoint
  - accepts Point&lt;T, N&gt; instances by constant reference.
  - explicit use of iterator to display PointN coordinates
  - creates comma separated list
*/
template&lt;typename T, const size_t N&gt;
void whilerPoint(const Point&lt;T, N&gt;& p) {
  auto itr = p.begin();
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; *itr++;
  while (itr &lt; p.end()) {
    std::cout &lt;&lt; &quot;, &quot; &lt;&lt; *itr++;
  }
}
void executeWhilerPoint() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhilerPoint(v)&quot;;
  auto p = Point&lt;int, 5&gt;();
  /* using indexer */
  p[0] = 1;
  p[1] = 2;
  p[2] = 3;
  p[3] = 2;
  p[4] = 1;
  whilerPoint(p);
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="speccoll-seperator"></splitter-bar>
            <second-item id="speccoll-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('speccoll-first')">
                <pre style="width:200em;"><code class="language-shell">
  --- collection specific iterations ---





execute indexerVec(v)
1, 2, 3, 2, 1

















execute iteratorVec(v)
1, 2, 3, 2, 1

















execute forLoopVec(v)
1 2 3 2 1
















execute forLoopPoint(v)
1, 2, 3, 2, 1























execute whilerPoint(v)
1, 2, 3, 2, 1

</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="gencoll">2.3 Iteration for Generic Collections</h3>
        <t-b>
          It only requires a little more effort to make functions that iterate over generic collections,
          e.g., collections that support:
          <div class="inset">
            <c-s>begin()</c-s>, <c-s>end()</c-s>,
            and index operators <c-s>T&&nbsp;operator[](size_t&nbsp;i)</c-s> and
            <c-s>const&nbsp;T&nbsp;operator[](size_t&nbsp;i)</c-s>
          </div>
          How to do that is what this section illustrates.
        </t-b>
        <t-b>
          It is a bit harder to handle errors by returning an error message if a collection is not
          iterable instead of simply failing to compile with often obscure error messages. That takes
          a small amount of template metaprogramming. The last example does that.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="gencoll-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('gencoll-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-----------------------------------------------
  demoWhiler
  - is flexible function that accepts any
    iterable container
  - uses iterator on C.
  - creates comma separated list
*/
template&lt;typename C&gt;
void demoWhiler(const C& c) {
  auto itr = c.begin();  // uses const overload
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; *itr++;
  while (itr != c.end()) {
    std::cout &lt;&lt; &quot;, &quot; &lt;&lt; *itr++;
  }
}
void executeDemoWhiler() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhiler(c) with string&quot;;
  auto s = std::string(&quot;a string&quot;);
  demoWhiler(s);
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhiler(c) with vector&quot;;
  auto v = std::vector&lt;double&gt; { 1.0, 1.5, -1.5, -1.0, 0 };
  demoWhiler(v);
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhiler(c) with Point&quot;;
  auto p = Point&lt;double, 5&gt; { 1.0, 2.0, 3.0, 2.0, 1.0 };
  demoWhiler(p);
}
/*-----------------------------------------------
  whiler_guarded is flexible function that accepts
  any container
  - if C is iterable will use iterator on C.
  - If non-iterable input is detected,
    will display error msg and return.
  - decision is made at compile time.
  - is_iterable_v is defined in Analysis.h
  - max is the maximum number of items
    to show on one line
*/
template&lt;typename C&gt;
void whilerGuarded(
  const C& c, const std::string& name,
  size_t indent = 2, size_t max = 8
  ) {
  if constexpr(!is_iterable_v&lt;C&gt;) {  // decision at compile-time
    std::cout &lt;&lt; &quot;&#92;n  whiler input type is not iterable&quot;;
    return;
  }
  else {
    std::cout &lt;&lt; formatColl(c, name, &quot;&quot;, indent, max);
    /*
      Analysis::formatColl uses range-based for loop to iterate
      over collection, folding output into rows of max items.

      Could have used the same iteration as in demoWhiler
      but wanted to show nicer formatting.
    */
  }
}
void executeWhilerGuarded() {
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhilerGuarded(c) with vector&quot;;
  auto v = std::vector&lt;int&gt; { 1, 2, 3, 2, 1, 0, -1, -2, -3, -4 };
  whilerGuarded(v, &quot;vector&quot;);
  std::cout &lt;&lt; &quot;&#92;nexecute demoWhiler(c) with double&quot;;
  whilerGuarded(3.5, &quot;double&quot;);
  auto v2 = std::vector&lt;int&gt; { 1, 2, 3, 4, 5 };
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="gencoll-seperator"></splitter-bar>
            <second-item id="gencoll-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('gencoll-first')">
                <pre style="width:200em;"><code class="language-shell">
  --- accepts any iterable collection ---














execute demoWhiler(c) with string
  a,  , s, t, r, i, n, g

execute demoWhiler(c) with vector
  1.0, 1.5, -1.5, -1.0, 0.0

execute demoWhiler(c) with Point
  1.0, 2.0, 3.0, 2.0, 1.0



  --- detects non-iterable input at compile-time ---




























execute demoWhilerGuarded(c) with vector
  vector : {
    1, 2, 3, 2, 1, 0, -1, -2,
    -3, -4
  }

execute demoWhiler(c) with double
  whiler input type is not iterable

</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="pointdefn">2.4 Point&lt;T, N&gt; Definition</h3>
        <t-b>
          The <c-s>Point&lt;T, N&gt;</c-s> type was defined and discussed in the previous
          &quot;<a target="_blank" href="Bits_GenericCpp.html">Bits C++ Generics</a>&quot;.
          Here, we extend that type by building in support for iteration. That is fairly simple: add declarations:
          <div class="inset">
            <c-s>iterator</c-s>, <c-s>const_iterator</c-s>, and <c-s>value_type</c-s>
          </div>
          and add methods:
          <div class="inset">
            <c-s>iterator begin()</c-s>, <c-s>iterator end()</c-s>,<br />
            <c-s>const_iterator begin() const</c-s>, and <c-s>const_iterator end() const</c-s>
          </div>
          These methods simply delegate delivery of the iterators to the underlying
          <c-s>std::vector&lt;T&gt;</c-s> coord methods.
        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="pointdef-first" style="width:65%;">
              <div class="codewrap" onclick="cbubbleup('pointdef-first')">
                <pre style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------
  Point&lt;T, N&gt; class represents a point in an N-Dimensional hyperspace.
  It uses a template parameter to support a variety of coordinate
  types, and uses a vector to hold any finite number of
  coordinates, specified by N.

  It also carries a Time t instance which conceptually is the time
  at which something was at that point in space. Time is a class
  defined for this demonstration in Time.h.

  All its special members, ctors, assignment, ... with the exception
  of constructor Point(), are declared default to indicate to a maintainer
  that compiler generated methods are correct and should not be provided.

  It does not provide an iterator nor begin() and end() members.
  Those will added in the iteration bit.
*/
template&lt;typename T, const size_t N&gt;
class Point {
public:
  using iterator = typename std::vector&lt;T&gt;::iterator;
  using const_iterator = typename std::vector&lt;T&gt;::const_iterator;
  using value_type = T;

  Point();                                      // default ctor
  Point(std::initializer_list&lt;T&gt; il);           // construct from list
  Point(const Point& pt) = default;             // copy ctor
  Point(Point&& pt) = default;                  // move ctor
  Point& operator=(const Point& pt) = default;  // copy assignment
  Point& operator=(Point&& pt) = default;       // move assignemnt
  ~Point() = default;                           // dtor

  void init(const std::vector&lt;T&gt;& v);

  std::string timeToString();
  void updateTime();
  Time& time();
  const size_t size() const;

  iterator begin();
  iterator end();
  const_iterator begin() const;
  const_iterator end() const;

  T& operator[](size_t index);                  // index oper
  const T operator[](size_t index) const;       // const index oper

  std::vector&lt;T&gt;& coords() { return coord; }    // accessor

  void show(const std::string& name);           // display contents
  size_t& left() { return _left; }              // display indent
  size_t& width() { return _width; }            // display width
private:
  std::vector&lt;T&gt; coord;
  Time tm;
  size_t _left = 2;   // default display indent
  size_t _width = 7;  // default display row width
};
/*-----------------------------------------------
  Point&lt;T, N&gt; constructor with size Template
  parameter
*/
template&lt;typename T, size_t N&gt;
Point&lt;T, N&gt;::Point()
  : tm(Time()) {
  for(size_t i=0; i&lt;N; i++) {
    coord.push_back(T{0});
  }
}
/*-----------------------------------------------
  Fill coor with elements from initializer list li
  - if li is smaller than N then fill remainder with
    default values of T
  - if li is larger use first N elements of li
*/
template&lt;typename T, size_t N&gt;
Point&lt;T, N&gt;::Point(std::initializer_list&lt;T&gt; il)
  : tm(Time()) {
  size_t sz = std::min(N, il.size());
  size_t i = 0;
  for(auto item : il) {
    coord.push_back(item);
    if(++i == sz) {
      break;
    }
  }
  for(size_t i = il.size(); i&lt;N; i++) {
    coord.push_back(T{0});
  }
}
/*---------------------------------------------
  Always returns N
*/
template&lt;typename T, size_t N&gt;
const size_t Point&lt;T, N&gt;::size() const {
  return coord.size();
}
/*---------------------------------------------
  index returns mutable value
*/
template&lt;typename T, size_t N&gt;
T& Point&lt;T, N&gt;::operator[](size_t index) {
  if (index &lt; 0 || coord.size() &lt;= index) {
    throw &quot;Point&lt;T, N&gt; indexing error&quot;;
  }
  return coord[index];
}
/*---------------------------------------------
  index returns immutable value
*/
template&lt;typename T, size_t N&gt;
const T Point&lt;T, N&gt;::operator[](size_t index) const {
  if (index &lt; 0 || coord.len() &lt;= index) {
    throw &quot;Point&lt;T, N&gt; indexing error&quot;;
  }
  return coord[index];
}

template&lt;typename T, const size_t N&gt;
typename Point&lt;T, N&gt;::iterator Point&lt;T, N&gt;::begin() {
  return coord.begin();
}
template&lt;typename T, const size_t N&gt;
typename Point&lt;T, N&gt;::iterator Point&lt;T, N&gt;::end() {
  return coord.end();
}
template&lt;typename T, const size_t N&gt;
typename Point&lt;T, N&gt;::const_iterator Point&lt;T, N&gt;::begin() const {
  return coord.begin();
}
template&lt;typename T, const size_t N&gt;
typename Point&lt;T, N&gt;::const_iterator Point&lt;T, N&gt;::end() const {
  return coord.end();
}

/*-----------------------------------------------
  Fill coor with elements from vector v
  - if v is smaller fill remainder with default
    values of T
  - if v is larger use first N elements of v
*/
template&lt;typename T, size_t N&gt;
void Point&lt;T, N&gt;::init(const std::vector&lt;T&gt;& v) {
  size_t sz = std::min(N, v.size());
  for(size_t i=0; i&lt;sz; i++) {
    coord[i] = v[i];
  }
  for(size_t i = v.size(); i&lt;N; i++) {
    coord[i] = T{0};
  }
}
/*---------------------------------------------
  returns string datetime
*/
template&lt;typename T, size_t N&gt;
std::string Point&lt;T, N&gt;::timeToString() {
  std::string ts = tm.toString();
  return ts;
}
/*---------------------------------------------
  set time to current time
*/
template&lt;typename T, size_t N&gt;
void Point&lt;T, N&gt;::updateTime() {
  tm = std::time(0);
}
/*---------------------------------------------
  returns current number of seconds in clock's
  epoch
*/
template&lt;typename T, size_t N&gt;
Time& Point&lt;T, N&gt;::time() {
  return tm;
}
/*-----------------------------------------------
  PointtN&lt;T&gt; display function
*/
template&lt;typename T, size_t N&gt;
void Point&lt;T, N&gt;::show(const std::string& name) {
  std::cout &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(_left) &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; &quot;Point&lt;T, N&gt;&quot;;
  std::cout &lt;&lt; &quot; {&#92;n&quot;;
  std::cout &lt;&lt; fold(coord, _left + 2, _width);
  std::cout &lt;&lt; indent(_left) &lt;&lt; &quot;}&quot;;
  std::cout &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(_left) &lt;&lt; tm.toString() &lt;&lt; std::endl;
}
/*-----------------------------------------------
  Overload operator&lt;&lt; required for
  showType(Point&lt;T, N&gt; t, const std::string& nm)
*/
template&lt;typename T, size_t N&gt;
std::ostream& operator&lt;&lt;(std::ostream& out, Point&lt;T, N&gt;& t2) {
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(t2.left()) &lt;&lt; &quot;Point&lt;T, N&gt;&quot;;
  out &lt;&lt; &quot; {&#92;n&quot;;
  out &lt;&lt; fold(t2.coords(), t2.left() + 2, t2.width());
  out &lt;&lt; indent(t2.left()) &lt;&lt; &quot;}&quot;;
  return out;
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="pointdef-seperator"></splitter-bar>
            <second-item id="pointdef-second" style="width:40em; background-color:var(--light);" onclick="obubbleup('pointdef-first')">
              <div class="textwrap noflow commentary">
                <h4>Point&lt;T, N&gt; Support for Iteration:</h4>
                <pre class="light">

















<span style="font-size:1.0em; font-weight:bold;">&lArr; Point Declaration</span>


<span style="font-size:1.0em; font-weight:bold;">&lArr; Iterator Declarations</span>



















<span style="font-size:1.0em; font-weight:bold;">&lArr; Iterator method declarations</span>





















































































<span style="font-size:1.0em; font-weight:bold;">&lArr; Iterator method definitions</span>

                </pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:0.75em;"></div>
        <h3 id="pointdemo">2.5 Point&lt;T, N&gt; Demonstration</h3>
        <t-b>

        </t-b>
        <div class="blockSingle" style="padding:0em;">
          <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
          <splitter-container id="container">
            <first-item id="pointdemo-first" style="width:52%;">
              <div class="codewrap" onclick="cbubbleup('pointdemo-first')">
                <pre style="width:200em;"><code class="language-cpp">void demo_custom_type_Point_iteration() {
  using namespace Analysis;
  using namespace Points;

  showNote(&quot;iteration over user-defined Point&lt;T, N&gt;&quot;, 45, &quot;&#92;n&quot;);

  /*-- demonstrate Point&lt;double 3&gt; initialization lists --*/
  showOp(&quot;Point&lt;double, 3&gt; p1 {1.0, 1.5, 2.0, 1.5, 1.0 }&quot;);  // equal to N
  Point&lt;double, 5&gt; p1 {1.0, 1.5, 2.0, 1.5, 1.0};
  p1.left() = 0;
  p1.show(&quot;p1&quot;);
  std::cout &lt;&lt; &quot;&#92;np1[1] = &quot; &lt;&lt; p1[1];           // indexing
  std::cout &lt;&lt; &quot;&#92;np1.time().day() = &quot;
            &lt;&lt; p1.time().day();
  std::cout &lt;&lt; &quot;&#92;np1.time().seconds() = &quot;
            &lt;&lt; p1.time().seconds() &lt;&lt; &quot;&#92;n&quot;;

  showOp(&quot;iteration using basic loop&quot;, &quot;&#92;n&quot;);
  auto itr = p1.begin();
  while(true) {
    std::cout &lt;&lt; *itr++ &lt;&lt; &quot; &quot;;
    if(itr == p1.end()) {
      break;
    }
  }
  std::cout &lt;&lt; std::endl;

  showOp(&quot;iteration using range-for&quot;, &quot;&#92;n&quot;);
  for(auto item : p1) {
    std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;
  }
  std::cout &lt;&lt; std::endl;

  showOp(&quot;Point&lt;int, 10&gt; p2 { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }&quot;);
  Point&lt;int, 10&gt; p2 { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  p2.left() = 0;
  p2.show(&quot;p2&quot;);
}
</code></pre>
              </div>
            </first-item>
            <splitter-bar id="pointdemo-seperator"></splitter-bar>
            <second-item id="pointdemo-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('pointdemo-first')">
                <pre style="width:200em;"><code class="language-shell">  ---------------------------------------------
    iteration over user-defined Point<T, N>
  ---------------------------------------------

--- Point<double, 3> p1 {1.0, 1.5, 2.0, 1.5, 1.0 } ---        
p1: Point<T, N> {
  1, 1.5, 2, 1.5, 1
}
Tue Jun 18 09:25:11 2024 local time zone

p1[1] = 1.5
p1.time().day() = 18
p1.time().seconds() = 11

--- iteration using basic loop ---
1.0 1.5 2.0 1.5 1.0

--- iteration using range-for ---
1.0 1.5 2.0 1.5 1.0 

--- Point<int, 10> p2 { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } ---   
p2: Point<T, N> {
  1, 2, 3, 4, 5, 6, 7,
  8, 9, 10
}
Tue Jun 18 09:25:11 2024 local time zone
</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>
        <h3 id="analysis">2.6 Analysis Functions</h3>
        <t-b>
          This code is very similar to that discussed in
          &quot;<a target="_blank" href="Bits_GenericCpp.html">Bits: Generic C++</a>&quot;.
        </t-b>
        <details>
          <summary class="darkItem">2.6 Analysis and Display Functions&nbsp;</summary>
          <div class="blockSingle" style="padding:0em;">
            <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
            <splitter-container id="container">
              <first-item id="analysis-first" style="width:70%;">
                <div class="codewrap" onclick="cbubbleup('analysis-first')" style="max-width:100%;">
                  <pre style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------
  Display and Analysis function and globals definitions
---------------------------------------------------------------------
*/
const std::string nl = &quot;&#92;n&quot;;
/*-------------------------------------------------------------------
  Mutable globals are a common source of bugs.  We try not
  to use them, but will use DisplayParams here to control how
  the insertion operator sends instances to standard output.
*/
struct displayParams {
  size_t left = 2;    // number of spaces to indent
  size_t width = 7;   // width of display row
  size_t trunc = 40;  // replace text after trunc with ...
} DisplayParams;      // global object

/*-----------------------------------------------
  Overload operator&lt;&lt; required for
  showType(std::vector&lt;T&gt; v, const std::vector&lt;T&gt;& nm)
*/
template&lt;typename T&gt;
std::ostream& operator&lt;&lt;(std::ostream& out, std::vector&lt;T&gt;& v) {
  out &lt;&lt; format(v, &quot;vector&lt;T&gt;&quot;, &quot;&quot;, DisplayParams.left, DisplayParams.width);
  return out;
}
/*-----------------------------------------------
  Display calling name, static class, and size
*/
template&lt;typename T&gt;
void showType(T t, const std::string &callname, const std::string& suffix) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; callname;          // show name at call site
  std::cout &lt;&lt; &quot; type: &quot;
            &lt;&lt; truncate(DisplayParams.trunc,typeid(t).name());  // show type
  std::cout &lt;&lt; &quot;&#92;n  size:  &quot; &lt;&lt; sizeof(t);  // show size on stack
  std::cout &lt;&lt; suffix;
}
/*-----------------------------------------------
  Display emphasized text
*/
inline void showNote(
  const std::string& txt,
  const size_t width,
  const std::string& suffix
) {
  auto fill = std::string(width, '-');
  print(fill);
  print(&quot;  &quot; + txt);
  print(fill);
  std::cout &lt;&lt; suffix;
}
/*-----------------------------------------------
  Display emphasized line
*/
inline void showOp(const std::string& opstr, const std::string& suffix) {
  std::cout &lt;&lt; &quot;&#92;n--- &quot; &lt;&lt; opstr &lt;&lt; &quot; ---&quot; &lt;&lt; suffix;
}
/*-----------------------------------------------
  Helper function for formatting output
  - truncates line to N chars and adds ellipsis
*/
inline std::string truncate(size_t N, const char* pStr) {
  std::string temp(pStr);
  if(temp.length() &gt; N) {
    temp.resize(N);
    return temp + &quot;...&quot;;
  }
  return temp;
}
/*-----------------------------------------------
  Helper function for formatting output
  - generates string of n blanks to offset text
*/
inline std::string indent(size_t n) {
  return std::string(n, ' ');
}
/*-----------------------------------------------
  Helper function for formatting output
  - folds lines after width elements
*/
template&lt;typename T&gt;
std::string fold(std::vector&lt;T&gt;& v, size_t left, size_t width) {
  std::stringstream out(&quot;&#92;n&quot;);
  out &lt;&lt; indent(left);
  for(size_t i=0; i&lt;v.size(); ++i) {
    if((i % width) == 0 && i != 0 && i != width - 1) {
      out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left);
    }
    if(i &lt; v.size() - 1) {
      out &lt;&lt; v[i] &lt;&lt; &quot;, &quot;;
    }
    else {
      out &lt;&lt; v[i] &lt;&lt; &quot;&#92;n&quot;;
      break;
    }
  }
  return out.str();
}
/*-----------------------------------------------
  Helper function for formatColl
  - defines out &lt;&lt; std::pair&lt;K,V&gt;
  - used in formatColl for associative containers
*/
template&lt;typename K, typename V&gt;
std::stringstream& operator&lt;&lt;(
  std::stringstream& out, const std::pair&lt;K,V&gt;& p
) {
  out &lt;&lt; &quot;{&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot;}&quot;;
  return out;
}
/*-----------------------------------------------
  Format output for Collection types
  - any type with begin() and end() like
    all the STL containers.
  - if nm is larger than empty str displays nm : { + ...
  - if nm is empty str displays { + ...
  - if c.size() &lt;= width displays on one line
  - if c.size() &gt; width displays on folded stack of lines
*/
template&lt;typename Coll&gt;
std::string formatColl(
  const Coll& c, const std::string& nm = &quot;&quot;, const std::string& suffix = &quot;&quot;,
  size_t left = 2, size_t width = 7
) {
  std::string nameStr;
  std::string prologue;
  std::string epilogue;
  if(nm.size() == 0) {
    nameStr = &quot;{ &quot;;
  }
  else {
    nameStr = nm + &quot; : { &quot;;
  }
  if(c.size() &lt;= width) {
    prologue = indent(left) + nameStr;
    epilogue = &quot; }&quot;;
  }
  else {
    prologue = indent(left) + nameStr + &quot;&#92;n&quot; + indent(left + 2);
    epilogue = &quot;&#92;n&quot; + indent(left) + &quot;}&#92;n&quot;;
  }
  std::stringstream out;
  out &lt;&lt; &quot;&#92;n&quot; + prologue;
  size_t i = 0;
  for(const Coll::value_type& elem : c) {
    if((i % width) == 0 && i != 0 && i != width - 1) {
      out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left + 2);
    }
    if(i &lt; c.size() - 1) {
      out &lt;&lt; elem &lt;&lt; &quot;, &quot;;
    }
    else {
      out &lt;&lt; elem &lt;&lt; epilogue &lt;&lt; suffix;
      break;
    }
    ++i;
  }
  return out.str();
}
/*-----------------------------------------------
  Format output for scalar types like primitives
*/
template&lt;typename T&gt;
std::string formatScalar(
  const T& t, const std::string& nm, const std::string& suffix,
  size_t left
) {
  std::stringstream out;
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: &quot; &lt;&lt; t &lt;&lt; suffix;
  return out.str();
}
/*-----------------------------------------------
  Format output for strings
  - indent and embed in quotation marks
*/
template&lt;typename T&gt;
std::string formatString(
  const T& t, const std::string& nm, const std::string& suffix,
  size_t left
) {
  std::stringstream out;
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: &#92;&quot;&quot; &lt;&lt; t &lt;&lt; &quot;&#92;&quot;&quot; &lt;&lt; suffix;
  return out.str();
}
/*-----------------------------------------------
  Defines is_iterable trait
  - detects STL containers and user-defined types
    that provide iteration
  - uses template metaprogramming, e.g., user code
    that runs at compile-time
https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable
*/
template &lt;typename T, typename = void&gt;
struct is_iterable : std::false_type {};

// this gets used only when we can call
// std::begin() and std::end() on that type
template &lt;typename T&gt;
struct is_iterable&lt;
  T,
  std::void_t
    &lt;decltype(std::begin(std::declval&lt;T&gt;())),
    decltype(std::end(std::declval&lt;T&gt;()))&gt;
&gt; : std::true_type {};

template &lt;typename T&gt;
constexpr bool is_iterable_v = is_iterable&lt;T&gt;::value;

/*-----------------------------------------------
  Displays almost everything.
  - strings work better with formatString(...)
  https://www.cppstories.com/2018/03/ifconstexpr/
  Iteration is discussed in Bit Cpp_iter
*/
template&lt;typename T&gt;
std::string format(
  const T& t, const std::string& nm, const std::string& suffix,
  size_t left, size_t width
) {
  if constexpr(is_iterable_v&lt;T&gt;) {  // decision at compile-time
    return formatColl(t, nm, suffix, left, width);
  }
  else {
    return formatScalar(t, nm, suffix, left);
  }
}
/*-----------------------------------------------
  Display text after newline and indentation
*/
inline void print(const std::string& txt) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt;
}
/*-----------------------------------------------
  Display text after newline and indentation
  - provides trailing newline
*/
inline void println(const std::string& txt) {
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt &lt;&lt; &quot;&#92;n&quot;;
}
</code></pre>
                </div>
              </first-item>
              <splitter-bar id="analysis-seperator"></splitter-bar>
              <second-item id="analysis-second" style="width:40em; background-color:var(--light);" onclick="obubbleup('analysis-first')">
                <div class="textwrap noflow commentary">
                  <h3>Analysis and Display:</h3>
                  <pre class="light">





















<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>std::vector&lt;T&gt; operator&lt;&lt;</c-s>







<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>showType</c-s>










<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>showNote</c-s>














<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>showOp</c-s>






<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>truncate</c-s>












<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>indent</c-s>








<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>fold</c-s>























<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>std::pair&lt;K,V&gt; operator&lt;&lt;</c-s>
















<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>formatColl</c-s>













































<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>formatScalar</c-s>













<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>formatString</c-s>


















<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>is_iterable</c-s>






















<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>format</c-s>














<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>print</c-s>







<span style="font-size:1.25em; font-weight:bold;">&lArr;</span> <c-s>println</c-s>
                  </pre>
                </div>
              </second-item>
            </splitter-container>
          </div>
        </details>
        <div style="height:0.75em;"></div>
        <h3 id="structure">2.7 Program Structure</h3>
        <t-b>
          The structure of this demonstration program is quite similar to that used
          in earlier bits, so is not shown by default.
        </t-b>
        <details>
          <summary class="darkItem">Code Structure&nbsp;</summary>
          <div class="blockSingle" style="padding:0em;">
            <input type="button" value="RemoteExecute" class="remotebutton" onclick="remote1()" />
            <splitter-container id="container">
              <first-item id="structure-first" style="width:60%;">
                <div class="codewrap" onclick="cbubbleup('structure-first')">
                  <pre style="width:200em;"><code class="language-cpp">/*-------------------------------------------------------------------
  Bits_Iter.cpp
  - defines functions to iterate over collections
  - depends on Points.h to provide user-defined point class
  - depends on Analysis.h for several display and analysis functions
*/
#include &lt;iostream&gt;         // std::cout
#include &lt;iomanip&gt;          // std::fixed, std::setprecision
#include &lt;sstream&gt;          // std::stringstream
#include &lt;memory&gt;           // std::unique_ptr
#include &lt;vector&gt;           // vector&lt;T&gt; class
#include &lt;array&gt;            // array&lt;T&gt; class
#include &lt;map&gt;              // map&lt;K,V&gt; class
#include &lt;set&gt;              // set&lt;T&gt; class
#include &lt;concepts&gt;         // supports C++20 concepts
#include &lt;algorithm&gt;        // STL algorithms
#include &quot;AnalysisIter.h&quot;   // Analysis functions
#include &quot;PointsIter.h&quot;     // PointN&lt;T&gt; class declaration

using namespace Points;
/*-----------------------------------------------
  Note:
  Find all Bits code, including this in
  https://github.com/JimFawcett/Bits
  You can clone the repo from this link.
-----------------------------------------------*/
/*
  This demo uses the std::string and std::vector&lt;T&gt; classes
  and a user-defined class, Point&lt;T, N&gt;, to illustrate how
  types support indexing and iteration.
  - Each standard container, C, provides C::iterator,
    C::const_iterator, C::reverse_iterator, and
    begin() and end() methods that return iterators to
    the first and one past the last element of the
    collection, respectively.
*/
void iteratorBasics() {
  /* code elided */
}
template&lt;typename T&gt;
void indexerVec(const std::vector&lt;T&gt;& v) {
  /* code elided */
}
void executeIndexerVec() {
  /* code elided */
}
template&lt;typename T&gt;
void iteratorVec(const std::vector&lt;T&gt;& v) {
  /* code elided */
}
void executeIteratorVec() {
  /* code elided */
}
template&lt;typename T&gt;
void forLoopVec(const std::vector&lt;T&gt;& v) {
  /* code elided */
}
void executeForLoopVec() {
  /* code elided */
}
template&lt;typename T, const size_t N&gt;
void forLoopPoint(const Point&lt;T, N&gt;& p) {
  /* code elided */
}
void executeForLoopPoint() {
  /* code elided */
}
template&lt;typename T, const size_t N&gt;
void whilerPoint(const Point&lt;T, N&gt;& p) {
  /* code elided */
}
void executeWhilerPoint() {
  /* code elided */
}
template&lt;typename C&gt;
void demoWhiler(const C& c) {
  /* code elided */
}
void executeDemoWhiler() {
  /* code elided */
}
template&lt;typename C&gt;
void whilerGuarded(
  const C& c, const std::string& name,
  size_t indent = 2, size_t max = 8
  ) {
  /* code elided */
}
void executeWhilerGuarded() {
  /* code elided */
}
template&lt;typename C, typename F&gt;
void forEachOp(C& c, F f) {
  /* code elided */
}
void executeForEachOp() {
  /* code elided */
}
template&lt;typename C&gt;
inline void showCSL(const C& c, const std::string& nm, size_t max, size_t indent) {
  /* code elided */
}
void executeForEachAlgorithm() {
  /* code elided */
}
/*-------------------------------------------------------------------
  Demonstration starts here
*/
void testFormat();

int main() {

    showNote(&quot;Demonstrate C++ Iteration&quot;, 30, &quot;&#92;n&quot;);

    iteratorBasics();

    showOp(&quot;collection specific iterations&quot;, nl);
    std::cout &lt;&lt; std::fixed;
    std::cout &lt;&lt; std::setprecision(1);
    executeIndexerVec();
    executeIteratorVec();
    executeForLoopVec();
    executeForLoopPoint();
    executeWhilerPoint();
    print();

    showOp(&quot;accepts any iterable collection&quot;, nl);
    executeDemoWhiler();
    print();

    showOp(&quot;detects non-iterable input at compile-time&quot;, nl);
    executeWhilerGuarded();
    print();

    showOp(&quot;using lambda to operate on items&quot;, nl);
    executeForEachOp();
    std::cout &lt;&lt; &quot;&#92;n&quot;;

    showOp(&quot;using std::for_each algorithm to modify items&quot;, nl);
    executeForEachAlgorithm();

    demo_custom_type_Point_iteration();

    // #define TEST
    #ifdef TEST
    testFormat();
    #endif

    print(&quot;&#92;n  That's all Folks!&#92;n&#92;n&quot;);
}
void testFormat() {
  /* code elided */
}
</code></pre>
                </div>
              </first-item>
              <splitter-bar id="structure-seperator"></splitter-bar>
              <second-item id="structure-second" style="width:40em; background-color:var(--light);" onclick="obubbleup('structure-first')">
                <div class="textwrap noflow">
                  <h4>Code Structure:</h4>
                  <pre class="light">
This program is partitioned into 3 header-only 
libraries and a demonstration file that uses
them.
</pre>
                  <div style="height:0.75em;"></div>
<pre class="light">
The libraries are:
  - PointsIter.h
  - Time.h, included in Points.Iter.h
  - AnalysisIter.h
and the demonstration file is:
  - Bits_Iter.cpp
</pre>
                  <div style="height:0.75em;"></div>
<pre class="light">
PointsIter.h:
  - defines <c-s>Point&lt;N, T&gt;</c-s>
  - includes Time.h
Time.h
  - defines <c-s>Time</c-s> and <c-s>Timer</c-s> types.
AnalysisIter.h:
  - defines several functions used to analyze
    type instances and display them.
Bits_IterCpp.cpp
  - includes the libraries
  - defines several demonstration functions,
    each of which demonstrates iteration
    techniques for types in std, std::library,
    and user-defined type <c-s>Point&lt;T, N&gt;</c-s>
</pre>
                  <div style="height:0.75em;"></div>
<pre class="light">
Each library declares at the beginning: 
  #ifndef [libname]
  #define [libname]
and at the end:
  #endif
</pre>
                  <div style="height:0.75em;"></div>
<pre class="light">
That ensures that each header is only compiled once,
avoiding multiple definitions and skipping unnec-
essary compiles.
                </pre>
                </div>
              </second-item>
            </splitter-container>
          </div>
        </details>

        <div style="height:0.75em;"></div>


        <div style="height:0.75em;"></div>
        <h4 id="build">3.0 Build</h4>
        <div style="border:2px solid var(--dark); padding:0.25em; width:max-content;">
          <pre style="width:100%; margin:0em;"><code class="language-term">C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Iter
&gt; cd build
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Iter&#92;build
&gt; cmake ..
-- Selecting Windows SDK version 10.0.22000.0 to target Windows 10.0.22621.
-- Configuring done
-- Generating done
-- Build files have been written to: C:/github/JimFawcett/Bits/Cpp/Cpp_Iter/build
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Iter&#92;build
&gt; cmake --build .
MSBuild version 17.5.1+f6fdcf537 for .NET Framework

  Checking Build System
  Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Iter/CMakeLists.txt
  Cpp_Iter.vcxproj -&gt; C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Iter&#92;build&#92;Debug&#92;Cpp_Iter.ex
  e
  Building Custom Rule C:/github/JimFawcett/Bits/Cpp/Cpp_Iter/CMakeLists.txt
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Iter&#92;build
&gt;
</code></pre>
        </div>
        <h3 id="ide">4.0 VS Code View</h3>
        <t-b>
          The code for this demo is available in
          <a target="_blank" href="https://github.com/JimFawcett/Bits">github.com/JimFawcett/Bits</a>. If you click on
          the Code dropdown you can clone the repository of all code for these demos to your local drive.
          Then, it is easy to bring up any example, in any of the languages, in VS Code.
        </t-b>
        <t-b>
          Here, we do that for Cpp\Cpp_Iter.
        </t-b>
        <photosizer-block src="pictures/Debug_CppIter.JPG" width="800" class="photoSizerBlock left"
                          style="overflow-x:auto;">
          <span style="font-family:'Comic Sans MS';">Figure 1. VS Code IDE - Debug Cpp_Iter</span>
        </photosizer-block>
        <!--<photosizer-block src="pictures/LaunchJSON_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
    style="overflow-x:auto;"
  >
    <span style="font-family:'Comic Sans MS';">Figure 2. Launch.JSON</span>
  </photosizer-block>
  <photosizer-block src="pictures/VS_Code_Debugging_Cpp_Objects.JPG" width="700" class="photoSizerBlock left"
    style="overflow-x:auto;"
  >
    <span style="font-family:'Comic Sans MS';">Figure 3. Debugging Objects</span>
  </photosizer-block>-->
        <!--<photosizer-block src="pictures/VS_Code_Cpp_Plugins.jpg" width="700" class="photoSizerBlock left">
    <span style="font-family:'Comic Sans MS';">Figure 3. C++ Plugins</span>
  </photosizer-block>-->

        <div style="height:0.75em;" class="clear"></div>
        <h3 id="refs">3.0 References</h3>
        <table class="indent">
          <tr>
            <th class="darkItem">Reference</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../CppStory_LibrarySTL.html">C++ Story: Standard Template Library</a>
            </td>
            <td>
              Covers containers, iterators, and STL algorithms
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../../CppStoryRepo.html">C++ Story</a>
            </td>
            <td>
              E-book with thirteen chapters covering most of intermediate C++
            </td>
          </tr>
          <tr>
            <td>
              <a target="_blank" href="../CppBites/CppBites_Intro.html">C++ Bites</a>
            </td>
            <td>
              Relatively short feature discussions
            </td>
          </tr>
        </table>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <!-- <page-sections id="sections" style="display:flex;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ide">VS Code</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">bld</a></menu-elem>
        <menu-elem class="secElem"><a href="#out">out</a></menu-elem>
        <menu-elem class="secElem"><a href="#analysis">anal</a></menu-elem>
        <menu-elem class="secElem"><a href="#points">pts</a></menu-elem>
        <menu-elem class="secElem"><a href="#source">src</a></menu-elem>
        <menu-elem class="secElem"><a href="#code">codeSnaps</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections> -->
    </main>
    <!-- <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer> -->
  </page-frame>
  <!-- <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn + ":";
  </script>
  <script>
    getScroll();
  </script> -->
  <script>
    onLoadSplitter("basics");
    onLoadSplitter("speccoll");
    onLoadSplitter("gencoll");
    onLoadSplitter("pointdef");
    onLoadSplitter("pointdemo");
    onLoadSplitter("analysis");
    onLoadSplitter("structure");
    onLoadSplitter("fig4");
    onLoadSplitter("fig5");
    onLoadSplitter("fig6");
    onLoadSplitter("fig7");
    onLoadSplitter("fig8");
    onLoadSplitter("fig9");
    onLoadSplitter("fig10");
  </script>
</body>
</html>