<!DOCTYPE html>
<html>
<!--
  Bits_Objects.html
-->
<head>
  <title>Bits_Objects</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeDefault.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBits.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <script src="js/ScriptsPageFrameRadioButtons.js"></script>
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding:0.75em 1.5em;
      margin-top:1.25em;
      margin-bottom:1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width:50em;
    }
    #github h2 {
      margin-top: 0.75em;
    }
    #github #pagetitle {
      border:2px double var(--dark);
    }
    #github form {
      border:none;
      padding:0.5em 1em;
    }
    #github form span {
      padding:0em 0.5em;
    }
    #github code-container {
      display: flex;
      position:relative;
      width:calc(100%);
      flex-direction: row;
      justify-content: space-between;
      /*border-top: 1px solid var(--dark);*/
    }
    #github code-banner {
      display: block;
      border: 2px solid var(--dark);
      border-top:none;
      border-bottom:none;
      padding: 0.25em 1em;
      font-family: 'Comic Sans MS', Tahoma;
      width: calc(100% + 0.5em);
      background-color: var(--atten);
    }
    #github code-display {
      display: block;
      border: 2px solid var(--dark);
      white-space: pre;
      padding: 0.75em 1em;
      font-family: Consolas, monospace;
      font-size:0.9em;
      width: calc(50% - 0.5em);
      overflow-x: auto;
      /*height:20em;*/
    }
    #github label {
      margin-right:1em;
    }
    #github fieldset {
      border:none;
    }
    #github #exeRight, #exeLeft {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github #hideLeft, #hideRight {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github .hide {
      display:none;
    }
    body {
      position:relative;
    }
    #github table.showcode {
      table-layout:fixed;
      width:calc(100% + 4em);
      margin-left:-2em;
    }
    #github th.leftblock {
      border: 2px solid var(--dark);
      /*border: 1px solid red;*/
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.rightblock {
      border: 2px solid var(--dark);
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.centerblock {
      border: none;
      padding: 0em;
      width:1em;
    }
    #github td.leftblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github td.rightblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em) !important;
      overflow-x:auto;
    }

    #github td.centerblock {
      border: none;
      padding: 0em;
    }
    #github pre {
      overflow-x: auto !important;
    }
    #github #left1 {
      /*height:45em;*/
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }

    #github #right1 {
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }
    #github #left2 {
      /*height:45em;*/
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right2 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github #left3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github .mover {
      width:2em;
      padding: 0.05em;
      position:relative;
      right:-1.5em;
      top:0.6em;
    }
    #github #ruler {

      width:calc(50% - 1.5em);
      height:0.001em;
      margin:-0.45em 0em;
    }
    #github .btns {
      width:3em;
      border:none;
    }
  </style>
  <script>
    /*-- Load Cpp Code, Output, Build --*/
    function loadCppCode(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div style='white-space:normal; margin-left:2em;'>\
<details>\
  <summary class='darkItem' style='margin-left:-2em;'>Code Notes&nbsp;&nbsp;</summary>\
  <ol class='tight' style='margin-left:0em;'>\
    <li>\
      This code is a relatively simple demonstration of classes and objects. It uses classes\n\
      std::string, std::vector<T>, Point1, and Point2&lt;T&gt; to show class anatomy and uses.\
    </li>\
    <li>\
      It illustrates stack and heap based storage.\
    </li>\
    <li>\
      show function is designed to display type and calling name of its\
      first argument and its value and size.\
    </li>\
    <li>\
      <c-s>template&lt;typename T&gt;</c-s>\n\
      <c-s>void show(T t, const std::string &ts)</c-s> is generic on the type T\
    </li>\
  </ol >\
  <div style=&quot;height: 3em;&quot;>&nbsp;</div>\
</details >\
</div >\
<pre><div class=&quot;code&quot;>\
// Cpp_Objects.cpp\n\
\n\
#include &lt;iostream&gt;  // std::cout\n\
#include &lt;typeinfo&gt;  // typeid\n\
#include &lt;memory&gt;    // std::unique_ptr\n\
#include &lt;utility&gt;   // move()\n\
#include &lt;vector&gt;    // vector class\n\
\n\
/*\n\
  This demo uses the std::string and std::vector&lt;T&gt; classes\n\
  and two user defined classes, Point1 and Point2&lt;T&gt;, to \n\
  illustrate how objects are defined and instantiated.\n\
\n\
  Operations:\n\
    All the classes discussed here provide:\n\
      T t2 = t1        // copy construction\n\
      T t3 = move(t1)  // move construction\n\
      t1 = t2          // copy assignment\n\
      t3 = move(t2)    // move assignment\n\
\n\
    All instances return their resources when they go out of\n\
    scope by implicitly calling their destructor.\n\
    Primitive types can all be copied.\n\
\n\
    Most library and user-defined types can be copied, moved, \n\
    and deleted by providing member constructors and destructor.\n\
    Often compiler generation works well, but for classes with \n\
    pointer members developers must provide them.\n\
\n\
  Processing:\n\
    All types are static, operations run as native code, and no \n\
    garbage collection is needed. Resources are returned at end \n\
    of their declaration scope.\n\
*/\n\
\n\
const std::string nl = &quot;&#92;n&quot;;\n\
\n\
/* Display and analysis functions are defined at the end */\n\
/* but C++ requires declaration before use.              */\n\
template&lt;typename T&gt;\n\
void showType(T t, const std::string &nm, const std::string& suffix = &quot;&quot;);\n\
void showNote(const std::string& txt, const std::string& suffix = &quot;&quot;);\n\
void print(const std::string& txt = &quot;&quot;);\n\
void println(const std::string& txt = &quot;&quot;);\n\
std::string truncate(size_t N, const char* pStr);\n\
\n\
/* alias type name - pU&lt;T&gt; is the same type as std::unique_ptr&lt;T&gt; */\n\
template&lt;typename T&gt;\n\
using pU = std::unique_ptr&lt;T&gt;;\n\
\n\
/*\n\
  Point1 class represents a point in an integral 3-Dimensional\n\
  lattice. Simple enough for illustration, but still useful.\n\
\n\
  It declares all of the special class methods, most with\n\
  default qualifiers to indicate that the compiler will\n\
  generate them as needed.\n\
\n\
  The word ctor is an abbreviation of constructor and dtor\n\
  an abbreviation for destructor.\n\
*/\n\
class Point1 {\n\
public:\n\
  Point1();                                       // default ctor\n\
  Point1(const Point1& pt) = default;             // copy ctor\n\
  Point1(Point1&& pt) = default;                  // move ctor\n\
  Point1& operator=(const Point1& pt) = default;  // copy assignment\n\
  Point1& operator=(Point1&& pt) = default;       // move assignment\n\
  ~Point1() = default;                            // dtor\n\
  void show();\n\
  int& xCoor() { return x; }\n\
  int& yCoor() { return y; }\n\
  int& zCoor() { return z; }\n\
private:\n\
  int x;\n\
  int y;\n\
  int z;\n\
};\n\
\n\
Point1::Point1() {\n\
  x = y = z = 0;\n\
}\n\
void Point1::show() {\n\
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; &quot;Point1&quot;;\n\
  std::cout &lt;&lt; &quot; { &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; &quot; }&quot;;\n\
}\n\
/* required for showType(T t, const std::string& nm) */\n\
std::ostream& operator&lt;&lt;(std::ostream& out, Point1& t1) {\n\
  out &lt;&lt; &quot;Point1&quot;;\n\
  out &lt;&lt; &quot; { &quot; &lt;&lt; t1.xCoor() &lt;&lt; &quot;, &quot; &lt;&lt; t1.yCoor() &lt;&lt; &quot;, &quot; \n\
               &lt;&lt; t1.zCoor() &lt;&lt; &quot; }&quot;;\n\
  return out;\n\
}\n\
\n\
/*\n\
  Point2<T> class represents a point in an n-Dimensional hyperspace.\n\
  It is more flexible than Point1 by using a template to support\n\
  a variety of coordinate types, and by using a vector to hold\n\
  any finite number of coordinates.\n\
\n\
  Its default constructor Point2() is declared delete so it won't\n\
  be provided here nor generated by the compiler.\n\
*/\n\
template&lt;typename T&gt;\n\
class Point2 {\n\
public:\n\
  Point2() = delete;                              // default ctor\n\
  Point2(size_t N);\n\
  Point2(const Point2& pt) = default;             // copy ctor\n\
  Point2(Point2&& pt) = default;                  // move ctor\n\
  Point2& operator=(const Point2& pt) = default;  // copy assignment\n\
  Point2& operator=(Point2&& pt) = default;       // move assignemnt\n\
  ~Point2() = default;                            // dtor\n\
  void show();\n\
  std::vector&lt;T&gt;& coords() { return coord; }\n\
private:\n\
  std::vector&lt;T&gt; coord;\n\
};\n\
\n\
template&lt;typename T&gt;\n\
Point2&lt;T&gt;::Point2(size_t N) {\n\
  for(size_t i=0; i&lt;N; i++) {\n\
    coord.push_back(T{0});\n\
  }\n\
}\n\
template&lt;typename T&gt;\n\
void Point2&lt;T&gt;::show() {\n\
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; &quot;Point2&quot;;\n\
  std::cout &lt;&lt; &quot; { &quot;;\n\
  for(size_t i=0; i&lt;coord.size(); ++i) {\n\
    std::cout &lt;&lt; coord[i];\n\
    if(i &lt; coord.size() - 1) {\n\
      std::cout &lt;&lt; &quot;, &quot;;\n\
    }\n\
  }\n\
  std::cout &lt;&lt; &quot; }&quot;;\n\
}\n\
/* required for showType(T t, const std::string& nm) */\n\
template&lt;typename T&gt;\n\
std::ostream& operator&lt;&lt;(std::ostream& out, Point2&lt;T&gt;& t2) {\n\
  out &lt;&lt; &quot;Point2&quot;;\n\
  out &lt;&lt; &quot; { &quot;;\n\
  for(size_t i=0; i &lt; t2.coords().size(); ++i) {\n\
    std::cout &lt;&lt; t2.coords()[i];\n\
    if(i &lt; t2.coords().size() - 1) {\n\
      std::cout &lt;&lt; &quot;, &quot;;\n\
    }\n\
  }\n\
  std::cout &lt;&lt; &quot; }&quot;;  \n\
  return out;\n\
}\n\
/* required for showType(T t, const std::vector&lt;T&gt;& nm) */\n\
template&lt;typename T&gt;\n\
std::ostream& operator&lt;&lt;(std::ostream& out, std::vector&lt;T&gt;& v) {\n\
  out &lt;&lt; &quot;vector&quot;;\n\
  out &lt;&lt; &quot; { &quot;;\n\
  for(size_t i=0; i &lt; v.size(); ++i) {\n\
    std::cout &lt;&lt; v[i];\n\
    if(i &lt; v.size() - 1) {\n\
      std::cout &lt;&lt; &quot;, &quot;;\n\
    }\n\
  }\n\
  std::cout &lt;&lt; &quot; }&quot;;  \n\
  return out;\n\
}\n\
/* Demonstration starts here */\n\
\n\
int main() {\n\
    print(&quot;Demonstrate C++ Objects&#92;n&quot;);\n\
\n\
    showNote(&quot;stack based instances&quot;);\n\
\n\
    showNote(&quot;std library types string and vector&lt;T&gt;&quot;);\n\
\n\
    /* standard type std::string */\n\
    print(&quot;--- auto str = std::string(&#92;&quot;&#92;&#92;&#92;&quot;Wile E. Coyote&#92;&#92;&#92;&quot;&#92;&quot;); ---&quot;);\n\
    auto str = std::string(&quot;&#92;&quot;Wile E. Coyote&#92;&quot;&quot;);\n\
    auto out = std::string(&quot;contents of str = &quot;) + str;\n\
    print(out);\n\
    print(&quot;--- showType(str, &#92;&quot;str&#92;&quot;); ---&quot;);\n\
    showType(str, &quot;str&quot;);\n\
\n\
    print(&quot;&#92;n  --- auto vec = std::vector&lt;double&gt;{ 3.5, 3, 2.5, 2 }; ---&quot;);\n\
    auto vec = std::vector&lt;double&gt;{ 3.5, 3, 2.5, 2 };\n\
    print(&quot;--- showType(vec, &#92;&quot;vec&#92;&quot;); ---&quot;);\n\
    showType(vec, &quot;vec&quot;);\n\
    print(&quot;--- vec[2] = -2.5; ---&quot;);\n\
    vec[2] = -2.5;\n\
    print(&quot;--- showType(vec, &#92;&quot;vec&#92;&quot;); ---&quot;);\n\
    showType(vec, &quot;vec&quot;, nl);    \n\
\n\
    showNote(&quot;user-defined types Point1 and Point2&lt;T&gt;&quot;);\n\
    print(&quot;--- Point1 p1; ---&quot;);\n\
    Point1 p1;\n\
    print(&quot;--- p1.show() ---&quot;);\n\
    p1.show();\n\
    p1.xCoor() = 42;\n\
    p1.zCoor() = -3;\n\
    p1.show();\n\
    print(&quot;--- showType(p1, &#92;&quot;p1&#92;&quot;, nl) ---&quot;);\n\
    showType(p1, &quot;p1&quot;, nl);\n\
    std::cout &lt;&lt; &quot;  --- p1.xCoor() returns value &quot; &lt;&lt; p1.xCoor() &lt;&lt; &quot; ---&#92;n&quot;;\n\
\n\
    print(&quot;--- Point2&lt;double&gt; p2(5) ---&quot;);\n\
    Point2&lt;double&gt; p2(5);\n\
    p2.show();\n\
    print(&quot;--- p2.coords() = std::vector&lt;double&gt;{ 1.0, -2.0, 3.0, 4.5, -42.0 } ---&quot;);\n\
    p2.coords() = std::vector&lt;double&gt;{1.0, -2.0, 3.0, 4.5, -42.0 };\n\
    p2.show();\n\
    print(&quot;--- showType(p2, &#92;&quot;p2&#92;&quot;, nl); ---&quot;);\n\
    showType(p2, &quot;p2&quot;, nl);\n\
    std::cout &lt;&lt; &quot;  p2.coords()[2] = &quot; &lt;&lt; p2.coords()[2] &lt;&lt; &quot;&#92;n&quot;;\n\
    \n\
    showNote(&quot;heap-based instances&quot;);\n\
\n\
    /* standard library type std::string */\n\
    /* uses alias pU for std::unique_ptr, defined above */\n\
    print(&quot;&#92;n  --- pU&lt;std::string&gt; pStr(new std::string(&#92;&quot;&#92;&#92;&#92;&quot;Road Runner&#92;&#92;&#92;&quot;&#92;&quot;) ---&quot;);\n\
    pU&lt;std::string&gt; pStr(new std::string(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;));\n\
    std::cout &lt;&lt; &quot;&#92;n  pStr contents = &quot; &lt;&lt; *pStr;\n\
    print(&quot;--- showType(*pStr, &#92;&quot;*pStr&#92;&quot;) ---&quot;);\n\
    showType(*pStr, &quot;*pStr&quot;);\n\
    /* std::unique_ptr&lt;T&gt; cannot be copied but can be moved */\n\
    print(&quot;--- showType(move(pStr), &#92;&quot;pStr&#92;&quot;) ---&quot;);\n\
    showType(move(pStr), &quot;pStr&quot;, nl);\n\
\n\
    /* standard library type std::vector&lt;T&gt; */\n\
    print(&quot;--- pU&lt;std::vector&lt;double&gt;&gt; pVec(new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 });&quot;);\n\
    pU&lt;std::vector&lt;double&gt;&gt; pVec(new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 });\n\
    showType(*pVec, &quot;*pVec&quot;);\n\
\n\
    /* custom types */\n\
    print(&quot;&#92;n  --- pU&lt;Point1&gt; pPoint1(new Point1()) ---&quot;);\n\
    pU&lt;Point1&gt; pPoint1(new Point1());\n\
    print(&quot;--- pPoint1-&gt;show() ---&quot;);\n\
    pPoint1-&gt;show();\n\
    pPoint1-&gt;xCoor() = 1;\n\
    pPoint1-&gt;yCoor() = 2;\n\
    pPoint1-&gt;zCoor() = -3;\n\
    pPoint1-&gt;show();\n\
    std::cout &lt;&lt; &quot;&#92;n  pPoint1-&gt;zCoor() = &quot; &lt;&lt; pPoint1-&gt;zCoor();\n\
    print(&quot;--- showType(*pPoint1, &#92;&quot;*pPoint1&#92;&quot;); ---&quot;);\n\
    showType(*pPoint1, &quot;*pPoint1&quot;);\n\
    print(&quot;--- showType(std::move(pPoint1), &#92;&quot;pPoint1&#92;&quot;); ---&quot;);\n\
    showType(std::move(pPoint1), &quot;pPoint1&quot;);\n\
    /* pPoint1 moved, so invalid */\n\
\n\
    print(&quot;&#92;n  --- pU&lt;Point2&lt;double&gt;&gt; pPoint2(new Point2&lt;double&gt;(4)) ---&quot;);\n\
    pU&lt;Point2&lt;double&gt;&gt; pPoint2(new Point2&lt;double&gt;(4));\n\
    print(&quot;--- pPoint2-&gt;show() ---&quot;);\n\
    pPoint2-&gt;show();\n\
    print(&quot;--- pPoint2-&gt;coords() = std::vector&lt;double&gt;{ 1.0, 3.5, -2.0, 42.0 }; ---&quot;);\n\
    pPoint2-&gt;coords() = std::vector&lt;double&gt;{ 1.0, 3.5, -2.0, 42.0 };\n\
    pPoint2-&gt;show();\n\
    std::cout &lt;&lt; &quot;&#92;n  value of pPoint2-&gt;coords()[1] is &quot; &lt;&lt; pPoint2-&gt;coords()[1];\n\
    print(&quot;--- showType(*pPoint2, &#92;&quot;*pPoint2&#92;&quot;); ---&quot;);\n\
    showType(*pPoint2, &quot;*pPoint2&quot;);\n\
    print(&quot;--- showType(std::move(pPoint2), &#92;&quot;pPoint2&#92;&quot;); ---&quot;);\n\
    showType(std::move(pPoint2), &quot;pPoint2&quot;);\n\
    /* pPoint2 moved, so invalid */\n\
\n\
    print(&quot;&#92;n&#92;n  That's all Folks!&#92;n&#92;n&quot;);\n\
}\n\
\n\
template&lt;typename T&gt;\n\
void showType(T t, const std::string &nm, const std::string& suffix) {\n\
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; nm;                // show name at call site\n\
  std::cout &lt;&lt; &quot; type: &quot; &lt;&lt; truncate(60,typeid(t).name());  // show type\n\
  std::cout &lt;&lt; &quot;&#92;n  value: &quot; &lt;&lt; t;          // show value\n\
  std::cout &lt;&lt; &quot;,  size:  &quot; &lt;&lt; sizeof(t);   // show size on stack\n\
  std::cout &lt;&lt; suffix;\n\
}\n\
void showNote(const std::string& txt, const std::string& suffix) {\n\
  print(&quot;-------------------------&quot;);\n\
  print(txt);\n\
  print(&quot;-------------------------&quot;);\n\
  std::cout &lt;&lt; suffix;\n\
}\n\
std::string truncate(size_t N, const char* pStr) {\n\
  std::string temp(pStr);\n\
  if(temp.length() &gt; N) {\n\
    temp.resize(N);\n\
    return temp + &quot;...&quot;;\n\
  }\n\
  return temp;\n\
}\n\
void print(const std::string& txt) {\n\
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt;\n\
}\n\
void println(const std::string& txt) {\n\
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt &lt;&lt; &quot;&#92;n&quot;;\n\
}\n\</div></pre>\
";
    }

    function loadCppOut(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\
  Demonstrate C++ Objects\n\
\n\
  -------------------------\n\
  stack based instances\n\
  -------------------------\n\
  -------------------------\n\
  std library types string and vector&lt;T&gt;\n\
  -------------------------\n\
  --- auto str = std::string(&quot;&#92;&quot;Wile E. Coyote&#92;&quot;&quot;); ---\n\
  contents of str = &quot;Wile E. Coyote&quot;\n\
  --- showType(str, &quot;str&quot;); ---\n\
  str type: class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,c...\n\
  value: &quot;Wile E. Coyote&quot;,  size:  40\n\
\n\
  --- auto vec = std::vector&lt;double&gt;{ 3.5, 3, 2.5, 2 }; ---\n\
  --- showType(vec, &quot;vec&quot;); ---\n\
  vec type: class std::vector&lt;double,class std::allocator&lt;double&gt; &gt;\n\
  value: vector { 3.5, 3, 2.5, 2 },  size:  32\n\
  --- vec[2] = -2.5; ---\n\
  --- showType(vec, &quot;vec&quot;); ---\n\
  vec type: class std::vector&lt;double,class std::allocator&lt;double&gt; &gt;\n\
  value: vector { 3.5, 3, -2.5, 2 },  size:  32\n\
\n\
  -------------------------\n\
  user-defined types Point1 and Point2&lt;T&gt;\n\
  -------------------------\n\
  --- Point1 p1; ---\n\
  --- p1.show() ---\n\
  Point1 { 0, 0, 0 }\n\
  Point1 { 42, 0, -3 }\n\
  --- showType(p1, &quot;p1&quot;, nl) ---\n\
  p1 type: class Point1\n\
  value: Point1 { 42, 0, -3 },  size:  12\n\
  --- p1.xCoor() returns value 42 ---\n\
\n\
  --- Point2&lt;double&gt; p2(5) ---\n\
  Point2 { 0, 0, 0, 0, 0 }\n\
  --- p2.coords() = std::vector&lt;double&gt;{ 1.0, -2.0, 3.0, 4.5, -42.0 } ---\n\
  Point2 { 1, -2, 3, 4.5, -42 }\n\
  --- showType(p2, &quot;p2&quot;, nl); ---\n\
  p2 type: class Point2&lt;double&gt;\n\
  value: Point2 { 1, -2, 3, 4.5, -42 },  size:  32\n\
  p2.coords()[2] = 3\n\
\n\
  -------------------------\n\
  heap-based instances\n\
  -------------------------\n\
\n\
  --- pU&lt;std::string&gt; pStr(new std::string(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;) ---\n\
  pStr contents = &quot;Road Runner&quot;\n\
  --- showType(*pStr, &quot;*pStr&quot;) ---\n\
  *pStr type: class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,c...\n\
  value: &quot;Road Runner&quot;,  size:  40\n\
  --- showType(move(pStr), &quot;pStr&quot;) ---\n\
  pStr type: class std::unique_ptr&lt;class std::basic_string&lt;char,struct st...\n\
  value: 00000184A447E920,  size:  8\n\
\n\
  --- pU&lt;std::vector&lt;double&gt;&gt; pVec(new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 });\n\
  *pVec type: class std::vector&lt;double,class std::allocator&lt;double&gt; &gt;\n\
  value: vector { 1.5, 2.5, 3.5 },  size:  32\n\
\n\
  --- pU&lt;Point1&gt; pPoint1(new Point1()) ---\n\
  --- pPoint1-&gt;show() ---\n\
  Point1 { 0, 0, 0 }\n\
  Point1 { 1, 2, -3 }\n\
  pPoint1-&gt;zCoor() = -3\n\
  --- showType(*pPoint1, &quot;*pPoint1&quot;); ---\n\
  *pPoint1 type: class Point1\n\
  value: Point1 { 1, 2, -3 },  size:  12\n\
  --- showType(std::move(pPoint1), &quot;pPoint1&quot;); ---\n\
  pPoint1 type: class std::unique_ptr&lt;class Point1,struct std::default_delet...\n\
  value: 00000184A4479BA0,  size:  8\n\
\n\
  --- pU&lt;Point2&lt;double&gt;&gt; pPoint2(new Point2&lt;double&gt;(4)) ---\n\
  --- pPoint2-&gt;show() ---\n\
  Point2 { 0, 0, 0, 0 }\n\
  --- pPoint2-&gt;coords() = std::vector&lt;double&gt;{ 1.0, 3.5, -2.0, 42.0 }; ---\n\
  Point2 { 1, 3.5, -2, 42 }\n\
  value of pPoint2-&gt;coords()[1] is 3.5\n\
  --- showType(*pPoint2, &quot;*pPoint2&quot;); ---\n\
  *pPoint2 type: class Point2&lt;double&gt;\n\
  value: Point2 { 1, 3.5, -2, 42 },  size:  32\n\
  --- showType(std::move(pPoint2), &quot;pPoint2&quot;); ---\n\
  pPoint2 type: class std::unique_ptr&lt;class Point2&lt;double&gt;,struct std::defau...\n\
  value: 00000184A4474A00,  size:  8\n\
\n\
\n\
  That's all Folks!\n\
\n\
></pre>";
    }

    function loadCppBld(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div class='code'>\
<pre style='overflow-x:auto;'>\n\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build\n\
&gt; cmake ..\n\
-- Building for: Visual Studio 17 2022\n\
-- Selecting Windows SDK version 10.0.22000.0 to target Windows 10.0.22621.    \n\
-- The C compiler identification is MSVC 19.34.31935.0\n\
-- The CXX compiler identification is MSVC 19.34.31935.0\n\
-- Detecting C compiler ABI info\n\
-- Detecting C compiler ABI info - done\n\
-- Check for working C compiler: C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933/bin/Hostx64/x64/cl.exe - skipped\n\
-- Detecting C compile features\n\
-- Detecting C compile features - done\n\
-- Detecting CXX compiler ABI info\n\
-- Detecting CXX compiler ABI info - done\n\
-- Check for working CXX compiler: C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933/bin/Hostx64/x64/cl.exe - skipped\n\
-- Detecting CXX compile features\n\
-- Detecting CXX compile features - done\n\
-- Configuring done\n\
-- Generating done\n\
-- Build files have been written to: C:/github/JimFawcett/Bits/Cpp/Cpp_Objects/build\n\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build\n\
&gt; cmake build .\n\
-- Selecting Windows SDK version 10.0.22000.0 to target Windows 10.0.22621.\n\
-- Configuring done\n\
-- Generating done\n\
-- Build files have been written to: C:/github/JimFawcett/Bits/Cpp/Cpp_Objects/build\n\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Cpp&#92;Cpp_Objects&#92;build\n\
&gt;</pre>\
</div>\
";
    }
    /*-- Load C# Code, Output, Build --*/
    function loadCsCode(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div>\
<div style='white-space:normal; margin-left:2em;'>\
<details>\
  <summary class='darkItem' style='margin-left:-2em;'>Code Notes&nbsp;&nbsp;</summary>\
  <ol class='tight' style='margin-left:0em;'>\
    <li>\
      This code is a demonstration of the creation and use of instances of C# Value\n\
      and Reference types.\
    </li>\
    <li>\
      All implementation code is required to be placed inline within the class method\
      declarations.\
    </li>\
    <li>\
      This code explores instance sharing and copy on write.\
    </li>\
    <li>\
      show function is designed to display type and calling name of its\
      first argument and its value and size.\
    </li>\
    <li>\
      Some of the analysis methods require reflection. The method\
      int GetManagedSize(Type type), at the bottom of the code listing, requires\
      advanced reflection techniques.\
    </li>\
  </ol >\
  <div style=&quot;height: 3em;&quot;>&nbsp;</div>\
</details >\
</div >\
</div>\
<pre>\n\
using System;\n\
using System.Reflection;\n\
using System.Reflection.Emit;\n\
using System.Collections;\n\
using System.Collections.Generic;   // IEnumerable&lt;T&gt;, List&lt;T&gt;\n\
using System.Linq;                  // IEnumerable&lt;T&gt;.ToArray\n\
using System.Text;                  // StringBuilder\n\
\n\
/*\n\
  Cs_Objects::Cs_Objects.cs\n\
  ----------------------\n\
  Demonstrates creation and assignment of objects as well as a few\n\
  peeks at other operations on objects.\n\
*/\n\
/*\n\
  Static Data Types:\n\
    value types =&gt; assignment copies value\n\
    --------------------------------------\n\
      sbyte, byte, short, int, long, ushort, uint, ulong\n\
      float, double\n\
      decimal, char, bool\n\
      struct\n\
    Reference types =&gt; assignment copies reference\n\
    ----------------------------------------------\n\
      object, string, array, class\n\
    ----------------------------------------------\n\
      strings are immutable, so any change requires copy on write.\n\
      That simulates value behavior.\n\
*/\n\
namespace CSharpObjects\n\
{\n\
  /*----------------------------------------------------------------------\n\
    IShow allows analysis functions to operate on instances of any class \n\
    that implements it. See ShowTypeShowable&lt;T&gt;(T t, ...), below.\n\
  */\n\
  interface IShow {\n\
    void Show(string name);   // show instance state as rows of elements\n\
    int Length { get; }       // total number of elements\n\
    int Width { get; set; }   // number of elements per row\n\
    int Left { get; set; }    // offset from terminal Left\n\
  }\n\
  /*-----------------------------------------------------------------------\n\
    Point1 is a basic point class with three integer coordinates.\n\
    - It is a reference type because it's instances are created\n\
      from a class\n\
    - That affects the way assignments work - see demo near the\n\
      end of main.\n\
  */\n\
  public class Point1 : IShow  // reference type with value type members\n\
  { \n\
    public Point1() {\n\
      /* \n\
        doesn't need to do anything because its properties have\n\
        default values\n\
      */\n\
    }\n\
    public int x { get; set; } = 0;\n\
    public int y { get; set; } = 0;\n\
    public int z { get; set; } = 0;\n\
    public int Length { get; } = 3;\n\
    public int Width { get; set; } = 3;\n\
    public int Left { get; set; } = 2;\n\
    /* translates IShow::show to needs of class */\n\
    public void Show(string name) {\n\
      PrintSelf(name);\n\
    }\n\
    /* Display Point1 structure and state */\n\
    public void PrintSelf(string name) {\n\
      string ofstr = Program.Indent(Left);\n\
      Console.WriteLine(\n\
        &quot;{4}{0}  {{ x:{1}, y:{2}, z:{3} }}&quot;, name, x, y, z, ofstr\n\
      );\n\
    }\n\
  }\n\
  /*----------------------------------------------------------------------\n\
    Point2&lt;T&gt; is a generalization of Point1 \n\
     - holds any finite number of generic coordinates\n\
     - coordinates are held in a List&lt;T&gt;\n\
     - implements IEnumerable&lt;T&gt; so it can be indexed and iterated\n\
     - it is a reference type because it is implemented with a class.\n\
       its List&lt;T&gt; is also a reference type\n\
  */\n\
  public class Point2&lt;T&gt; : IEnumerable&lt;T&gt; , IShow {\n\
    /*--------------------------------------------------------------------\n\
      Constructs a point with N coordinates each with default value\n\
    */\n\
    public Point2(int N) {\n\
      coor = new List&lt;T&gt;();\n\
      for(int i = 0; i&lt;N; ++i) {\n\
        T? test = default(T);\n\
        if(test != null) {\n\
          coor.Add(test);\n\
        }\n\
      }\n\
    }\n\
    /* translates IShow::show() for needs of Point2 class */\n\
    public void Show(string name) {\n\
      PrintSelf(name);\n\
    }\n\
    /*\n\
      Displays structure and state of N-dimensional point.\n\
      - state is a set of rows of coordinate data\n\
      - property Width specifies number of elements in each row\n\
      - property Left specifies offset of row from terminal Left edge\n\
    */\n\
    public void PrintSelf(string name) {\n\
      Console.Write(Program.Indent(Left));\n\
      Console.Write(&quot;{0} {{&#92;n{1}&quot;, name, Program.Indent(Left + 2));\n\
      for(int i=0; i&lt;coor.Count; ++i) {\n\
        Console.Write(&quot;{0}&quot;, coor[i]);\n\
        if(i &lt; coor.Count - 1) {\n\
          Program.print(&quot;, &quot;);\n\
        }\n\
        if((i+1) % Width == 0 && i != coor.Count - 1) {\n\
          Console.Write(&quot;&#92;n&quot;);\n\
          Console.Write(Program.Indent(Left + 2));\n\
        }\n\
      }\n\
      Console.Write(&quot;&#92;n{0}&quot;, Program.Indent(Left));\n\
      Console.WriteLine(&quot;}&quot;);\n\
    }\n\
    /* The three functions below support indexing and iterating */\n\
    public T this[int index] {\n\
      get { return coor[index]; }\n\
      set { coor.Insert(index, value); }\n\
    }\n\
    public IEnumerator&lt;T&gt; GetEnumerator() {\n\
      return coor.GetEnumerator();\n\
    }\n\
    IEnumerator IEnumerable.GetEnumerator() {\n\
      return this.GetEnumerator();\n\
    }\n\
    public List&lt;T&gt; coor { get; set; }\n\
    public int Length { get { return coor.Count; } }\n\
    public int Width { get; set; } = 5;   // default row size\n\
    public int Left { get; set; } = 2;    // default offset\n\
    /* initializers */\n\
    public Point2&lt;T&gt; width(int w) {\n\
      this.Width = w;\n\
      return this;\n\
    } \n\
    public Point2&lt;T&gt; left(int l) {\n\
      this.Left = l;\n\
      return this;\n\
    } \n\
  }\n\
  /* \n\
    Demonstration composite value type.\n\
    - St is a value type because it is implemented with\n\
      a struct and all its data members are value types. \n\
  */\n\
  public struct St { \n\
    public St(int ai, double bi, char ci) {\n\
      a=ai; b=bi; c=ci;\n\
    }\n\
    public void Show(string name) {\n\
      Console.WriteLine(\n\
        &quot;  {0} {{ a:{1}, b:{2}, c:{3} }}&quot;, name, a, b, c \n\
      );\n\
    }\n\
    /*\n\
     These data members are public instead of public properties.\n\
     - we don't need that ceremony because St is simply a data\n\
       aggregator. It doesn't have any significant behavior.\n\
    */\n\
    public int a; \n\
    public double b; \n\
    public char c; \n\
  }\n\
\n\
  /*-- Object demonstration begins here --*/\n\
\n\
  class Program\n\
  {\n\
    const string nl = &quot;&#92;n&quot;;\n\
\n\
    static void Main(string[] args)\n\
    {\n\
      ShowLabel(&quot; Demonstrate C# objects&quot;);\n\
\n\
      ShowNote(\n\
        &quot;Examples of creation and display of Primitive Types&quot;\n\
      );\n\
      short s = 123;\n\
      ShowTypeScalar(s, &quot;s&quot;, nl);\n\
      long l = 12345;\n\
      ShowTypeScalar(l, &quot;l&quot;, nl);\n\
      float f = 3.1415927f;\n\
      ShowTypeScalar(f, &quot;f&quot;, nl);\n\
      double d = 3.1415927;\n\
      ShowTypeScalar(d, &quot;d&quot;, nl);\n\
      int[] arr = new int[]{ 4, 3, 2, 1, 0, -1};\n\
      ShowTypeEnum(arr, &quot;arr&quot;, 10, nl);\n\
\n\
      ShowNote(\n\
        &quot;Examples of creation and display of Library Types&#92;n&quot; + \n\
        &quot;- size is the size of reference, not instance&quot;\n\
      );\n\
      string aString = &quot;a string&quot;;  // hides construction\n\
      ShowTypeScalar(aString, &quot;aString&quot;, nl);\n\
\n\
      string another = new string(&quot;another string&quot;);\n\
      ShowTypeScalar(another, &quot;another&quot;, nl);\n\
\n\
      List&lt;double&gt; aList = \n\
        new List&lt;double&gt;{ 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0 };\n\
    \n\
      ShowTypeEnum(aList, &quot;aList&quot;, 5, nl);\n\
\n\
      var d1 = new Dictionary&lt;int, string&gt;\n\
      {\n\
        { 0, &quot;zero&quot;}, {1, &quot;one&quot;}, {2, &quot;two&quot;}\n\
      };\n\
      ShowTypeEnum(d1, &quot;d1&quot;, 5, nl);\n\
  \n\
      ShowNote(\n\
        &quot;Examples of user-defined types:&#92;n&quot; + \n\
        &quot;- Point1, a point with x,y,z coordinates&#92;n&quot; +\n\
        &quot;- Point2, a point with N generic coordinates&quot;\n\
      );\n\
      Point1 p1 = new Point1();\n\
      p1.x = 3;\n\
      p1.y = -42;\n\
      p1.z = 1;\n\
      ShowOp(&quot;ShowTypeShowable(p1, &#92;&quot;p1&#92;&quot;)&quot;);\n\
      ShowTypeShowable(p1, &quot;p1&quot;, nl);\n\
\n\
      ShowNote(\n\
        &quot;Point2&lt;T&gt; is both Enumerable and Showable. That is,&#92;n&quot; +\n\
        &quot;it implements both IEnumerable&lt;T&gt; and IShow.&#92;n&quot; +\n\
        &quot;- so both ShowTypeEnum and ShowTypeShowable work&quot;\n\
      );\n\
      Point2&lt;double&gt; p2 = new Point2&lt;double&gt;(7);\n\
      p2.coor = new List&lt;double&gt; {\n\
        1.5, 2.0, 3.5, 4.0, 5.5, 6.0, 7.5\n\
      };\n\
      ShowOp(&quot;ShowTypeShowable(p2, &#92;&quot;p2&#92;&quot;)&quot;);\n\
      p2.Width = 6;\n\
      ShowTypeShowable(p2, &quot;p2&quot;, nl);\n\
\n\
      ShowOp(&quot;ShowTypeEnum(p2, &#92;&quot;p2&#92;&quot;)&quot;);\n\
      ShowTypeEnum&lt;double&gt;(p2, &quot;p2&quot;, p2.Width, nl);\n\
\n\
      ShowOp(&quot;ShowTypeShowable(p3, &#92;&quot;p3&#92;&quot;)&quot;);\n\
      Point2&lt;int&gt; p3 = new Point2&lt;int&gt;(7);\n\
      p3.left(4).width(7);\n\
      ShowOp(&quot;set left(4) and width(7)&quot;);\n\
      p3.coor = new List&lt;int&gt;{1, 2, 3, 4, 5, 6, 7};\n\
      ShowTypeShowable(p3, &quot;p3&quot;, nl);\n\
\n\
      ShowLabel(\n\
        &quot;Differences between value and reference types&quot;\n\
      );\n\
      ShowNote(\n\
        &quot;Assignment of reference types assigns their references,&#92;n&quot; +\n\
        &quot;creating two references to the same instance in managed&#92;n&quot; +\n\
        &quot;heap, so variables are coupled through single instance.&quot;\n\
      );\n\
      ShowOp(&quot;Point1 val1 = new Point1(), then initialize&quot;);\n\
      Point1 val1 = new Point1();\n\
      val1.x = 1;\n\
      val1.y = 2;\n\
      val1.y = 3;\n\
      ShowLabeledObject(val1, &quot;val1&quot;);\n\
      ShowOp(&quot;Point1 val2 = val1&quot;);\n\
      Point1 val2 = val1;\n\
      ShowLabeledObject(val2, &quot;val2&quot;);\n\
      IsSameObj(val2, &quot;val2&quot;, val1, &quot;val1&quot;);\n\
      ShowOp(&quot;val2.z = 42;&quot;);\n\
      val2.z = 42;\n\
      IsSameObj(val2, &quot;val2&quot;, val1, &quot;val1&quot;);\n\
      ShowLabeledObject(val2, &quot;val2&quot;);\n\
      ShowLabeledObject(val1, &quot;val1&quot;);\n\
      ShowNote(\n\
        &quot;Note! Source of assignment, val1, changed when val2 changed.&#92;n&quot; +\n\
        &quot;Point1 is ref type, so assignment just assigns references.&quot;\n\
      );\n\
      println();\n\
\n\
      ShowNote(\n\
        &quot;Value types can be independently assigned and copied.&quot;\n\
      );\n\
      ShowOp(&quot;var s1 = new St(1, -0.5, 'z');&quot;);\n\
      var s1 = new St(1, -0.5, 'z');\n\
      ShowOp(&quot;var s2 = s1&quot;);\n\
      var s2 = s1;\n\
      IsSameObj(s2, &quot;s2&quot;, s1, &quot;s1&quot;);\n\
      s2.Show(&quot;s2&quot;);\n\
      s1.Show(&quot;s1&quot;);\n\
      ShowOp(&quot;s2.c = 'q'&quot;);\n\
      s2.c = 'q';\n\
      s2.Show(&quot;s2&quot;);\n\
      s1.Show(&quot;s1&quot;);\n\
      ShowNote(\n\
        &quot;Change in destination, s2, did not alter source, s1.&#92;n&quot; +\n\
        &quot;Assignment of value types creates independent objects.&quot;\n\
      );\n\
      ShowLabel(\n\
        &quot;Instances of string are reference types, but simulate&#92;n&quot; +\n\
        &quot;some value behaviors.  String objects are immutable.&#92;n&quot; +\n\
        &quot;To modify an instance, a new string is created with&#92;n&quot; +\n\
        &quot;copies of the source string characters inclucing any&#92;n&quot; +\n\
        &quot;modifications.  This is called copy on write.&quot;\n\
      );\n\
      var str1 = &quot;An immutable string&quot;;\n\
      var str2 = str1;\n\
      IsSameObj(str2, &quot;str2&quot;, str1, &quot;str1&quot;);\n\
      DisplayLabeledObject&lt;string&gt;(str1, &quot;str1&quot;);\n\
      DisplayLabeledObject(str2, &quot;str2&quot;);\n\
      str2 = str2.Remove(0,3);\n\
      IsSameObj(str2, &quot;str2&quot;, str1, &quot;str1&quot;);\n\
      DisplayLabeledObject(str1, &quot;str1&quot;);\n\
      DisplayLabeledObject(str2, &quot;str2&quot;);\n\
      ShowNote(\n\
        &quot;There is no way for change in str2 to affect str1.&quot;\n\
      );\n\
\n\
      // ShowLabel(&quot;Test code for functions used above&quot;);\n\
      // print(&quot;--- double[] to folded CSV ---&quot;);\n\
      // int[] arr2 = { 0,1,2,3,4,5,6,7,8 };\n\
      // string tmp = FoldArray(arr2, 3, 2);\n\
      // Console.WriteLine(&quot;&#92;n{0}&quot;,tmp);\n\
\n\
      // ShowLabel(&quot;Alternate function for generating CSVs&quot;);\n\
      // print(&quot;--- coor to folded CSV ---&quot;);\n\
      // double[] arr3 = p2.coor.ToArray();\n\
      // tmp = FoldArray(arr3, 4, 2);\n\
      // Console.WriteLine(&quot;&#92;n{0}&quot;,tmp);\n\
\n\
      // string tmp1 = ToCSV&lt;double&gt;(p2.coor);\n\
      // string tmp2 = ToCSV(p2.coor);  // demo that type inference works here\n\
      // ShowTypeScalar(tmp2, &quot;tmp2&quot;);\n\
\n\
      Console.WriteLine(&quot;&#92;nThat's all Folks!&#92;n&quot;);\n\
    }\n\
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\
        cut here\n\
\n\
        The functions below are used for analysis and display. They\n\
        have varying complexities. It is not essential to understand \n\
        them in order to follow the demonstrations above.  We will \n\
        look at them in some detail in Bits_Functions. \n\
    */\n\
    public static void ShowType&lt;T&gt;(T t, string nm) {\n\
      Type tt = t!.GetType();\n\
      string tnm = tt.Name;\n\
      if(tt.IsGenericType) {\n\
        if(tnm.Length &gt; 1) {\n\
          tnm = tnm.Remove(tnm.Length - 2) + &quot;&lt;T&gt;&quot;;\n\
        }\n\
      }\n\
      Console.Write(&quot;{0}: {1}, &quot;, nm, tnm);\n\
      int size = Utils.GetManagedSize(tt);\n\
      Console.Write(&quot;size: {0}, &quot;, size);\n\
      if (tt.IsValueType) {\n\
        Console.WriteLine(&quot;value type&quot;);\n\
      }\n\
      else {\n\
        Console.WriteLine(&quot;reference type&quot;);\n\
      }\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Display information about the type of any scalar type.\n\
      - scalar types are those with a single value like:\n\
        int, double, string, ...\n\
      - This function directly uses only simple reflection\n\
    */\n\
    public static void ShowTypeScalar&lt;T&gt;(T t, string nm, string suffix = &quot;&quot;)\n\
    {\n\
      // Type? tt = t!.GetType();\n\
      // int size = 0;\n\
      // if(tt != null) {\n\
      //   Console.WriteLine(&quot;{0}, {1}&quot;, nm, tt.Name);\n\
      //   size = Utils.GetManagedSize(tt);\n\
      // }\n\
      ShowType(t, nm);\n\
      Console.WriteLine(&quot;value: &#92;&quot;{0}&#92;&quot;{1}&quot;, t, suffix);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Show type information about any type that implements the IShow\n\
      interface\n\
    */\n\
    public static void ShowTypeShowable&lt;T&gt;(T t, string nm, string suffix=&quot;&quot;)\n\
      where T:IShow\n\
    {\n\
      ShowType(t, nm);\n\
      // Type tt = t.GetType();\n\
      // Console.WriteLine(&quot;{0}, {1}&quot;, nm, tt.Name);\n\
      // int size = Utils.GetManagedSize(tt);\n\
      Console.WriteLine(&quot;value:&quot;);\n\
      t.Show(nm);  // guaranteed availability by IShow implementation\n\
      // Console.WriteLine(&quot;size: {0}{1}&quot;, size, suffix);\n\
      Console.Write(suffix);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Provides name of caller, nm, as label for IShow() information.\n\
      - works for all Showable instances\n\
    */\n\
    public static void ShowLabeledObject&lt;T&gt;(T t, string nm) where T:IShow {\n\
      Console.Write(nm);\n\
      t.Show(nm);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Provides name of caller, nm, as label for value.\n\
      - works for all T with ToString.\n\
    */\n\
    public static void DisplayLabeledObject&lt;T&gt;(T t, string nm) {\n\
      Console.WriteLine(&quot;{0}: {1}&quot;, nm, t!.ToString());\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Show type information for any type that implements IEnumerable&lt;T&gt; \n\
      interface.\n\
    */\n\
    public static void ShowTypeEnum&lt;T&gt; (\n\
      IEnumerable&lt;T&gt; t, string nm, int w = 5, string suffix = &quot;&quot;\n\
    )\n\
    {\n\
      ShowType(t, nm);\n\
      Console.WriteLine(&quot;value:&#92;n{0}{1} {{&quot;, &quot;  &quot;, nm);\n\
      /* \n\
        beautify value list into rows of w elements \n\
        indented by 4 spaces\n\
      */\n\
      string tmp = FoldArray(t.ToArray(), w, 4);\n\
      Console.Write(tmp);\n\
      Console.WriteLine(&quot;&#92;n  }&quot;);\n\
      Console.Write(suffix);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      create string of count spaces, used to offset output \n\
    */\n\
    public static string Indent(int count) {\n\
      StringBuilder sb = new StringBuilder();\n\
      sb.Append(' ', count);\n\
      return sb.ToString();\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Truncate string to length of N, but only\n\
      if its length is greater than N\n\
    */\n\
    string truncate(int N, string bigStr) {\n\
      if(bigStr.Length &lt;= N) {\n\
        return bigStr;\n\
      }\n\
      StringBuilder sb =  new StringBuilder();\n\
      sb.Append(bigStr);\n\
      sb.Length = N;  // move back pointer to desired length\n\
      return sb.ToString();\n\
    }\n\
    /*-------------------------------------------------------------------- \n\
      fold array elements into rows of w elements \n\
    */\n\
    public static string FoldArray&lt;T&gt;(T[] arr, int w, int Left) {\n\
      StringBuilder tmp = new StringBuilder();\n\
      tmp.Append(Indent(Left));\n\
      for(int i=0; i&lt; arr.Length; ++i) {\n\
        tmp.Append(arr[i]!.ToString());\n\
        tmp.Append(&quot;, &quot;);\n\
        if((i+1) % w == 0 && i != arr.Length - 1) {\n\
          tmp.Append(&quot;&#92;n&quot;);\n\
          tmp.Append(Indent(Left));\n\
        }\n\
      }\n\
      if(tmp.Length &gt; 1) {\n\
        tmp.Length -= 2;  // don't return last comma and space\n\
      }\n\
      return tmp.ToString();\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      do t1 and t2 share the same address?\n\
    */\n\
    public static void IsSameObj&lt;T&gt;(\n\
      T t1, String n1, T t2, String n2, string suffix = &quot;&quot;\n\
    ) {\n\
      if(ReferenceEquals(t1, t2)) {\n\
        Console.WriteLine(\n\
          &quot;{0} is same object as {1}{2}&quot;, n1, n2, suffix\n\
        );\n\
      }\n\
      else {\n\
        Console.WriteLine(\n\
          &quot;{0} is not same object as {1}{2}&quot;, n1, n2, suffix);\n\
      }\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Beware, two distinct objects may have same hashcode.\n\
      Not used in this demo for that reason.\n\
    */\n\
    public static void showIdent&lt;T&gt;(T t, String n, string suffix = &quot;&quot;) {\n\
      int id = t!.GetHashCode();\n\
      Console.WriteLine(&quot;{0}, {1}{2}&quot;, n, id, suffix);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Display function call or operation to help turn output data \n\
      into information \n\
    */\n\
    public static void ShowOp(string op, string suffix = &quot;&quot;) {\n\
      Console.WriteLine(&quot;--- {0} ---{1}&quot;, op, suffix);\n\
    }\n\
    public static void print(String s = &quot;&quot;) {\n\
      Console.Write(s);\n\
    }\n\
    public static void println(String s = &quot;&quot;) {\n\
      Console.WriteLine(s);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Emphasize text with borders\n\
    */\n\
    public static void ShowNote(string s, string suffix = &quot;&quot;) {\n\
      Console.WriteLine(\n\
        &quot;--------------------------------------------------&quot;\n\
      );\n\
      Console.WriteLine(&quot;{0}&quot;, s);  \n\
      Console.WriteLine(\n\
        &quot;--------------------------------------------------{0}&quot;, suffix\n\
      );\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Surround note with empty lines\n\
    */\n\
    public static void ShowLabel(string s) {\n\
      Console.WriteLine();\n\
      ShowNote(s);\n\
      Console.WriteLine();\n\
    }\n\
    /*\n\
      Show fields and methods for either reference or value types using reflection\n\
    */\n\
    // https://stackoverflow.com/questions/7613782/iterating-through-struct-members\n\
    public static void iterate&lt;T&gt;(T t) /*where T:new()*/ {\n\
      Console.WriteLine(&quot;fields:&quot;);\n\
      foreach(\n\
        var field in typeof(T).GetFields(\n\
          BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public\n\
        )\n\
      ) {\n\
        Console.WriteLine(\n\
          &quot;  {0} = {1}&quot;, field.Name, field.GetValue(t)\n\
        );\n\
      }\n\
      Console.WriteLine(&quot;methods:&quot;);\n\
      foreach(\n\
        var method in typeof(T).GetMethods(\n\
          BindingFlags.Instance | BindingFlags.Public\n\
        )\n\
      ) {\n\
        Console.WriteLine(\n\
          &quot;  {0}&quot;, method.Name\n\
        );\n\
      }\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Build string of comma separated values from Enumerable collection\n\
      - no longer used here, but will be useful so kept\n\
    */\n\
    // https://stackoverflow.com/questions/330493/join-collection-of-objects-into-comma-separated-string\n\
    public static string ToCSV&lt;T&gt;(IEnumerable&lt;T&gt; coll) {\n\
      StringBuilder sb = new StringBuilder();\n\
      foreach(T elem in coll) {\n\
        sb.Append(elem!.ToString()).Append(&quot;, &quot;);\n\
      }\n\
      return sb.ToString(0, sb.Length - 2);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Returns value of T for IEnumerable&lt;T&gt; at runtime.  Needed for some functions\n\
      that operate on generic collections.\n\
      - at this time, not used in this demo\n\
    */\n\
    // https://www.codeproject.com/Tips/5267157/How-To-Get-A-Collection-Element-Type-Using-Reflect\n\
    public static Type? GetTypeOfCollection(Object coll) {\n\
      Type type = (coll).GetType();\n\
      var etype = typeof(IEnumerable&lt;&gt;);\n\
      foreach (var bt in type.GetInterfaces()) {\n\
        if (bt.IsGenericType && bt.GetGenericTypeDefinition() == etype) {\n\
          return (bt.GetGenericArguments()[0]);\n\
        }\n\
      }\n\
      return null;\n\
    }\n\
  }\n\
  /*\n\
    Utils uses advanced relection \n\
    - GetMangedSize(Type type) is function that returns the size of \n\
      value types and handles, used to help discover how things work.\n\
      It is placed here because it uses advanced techniques that\n\
      will eventually be covered elsewhere in this site.  Knowing\n\
      how it works is not essential for the things we are examining\n\
      in this demo.\n\
  */\n\
  // https://stackoverflow.com/questions/8173239/c-getting-size-of-a-value-type-variable-at-runtime/8173293#8173293\n\
  public static class Utils {\n\
    /*-- more advanced reflection --*/\n\
    // https://stackoverflow.com/questions/7613782/iterating-through-struct-members\n\
    public static int GetManagedSize(Type type)\n\
    {\n\
      // all this just to invoke one opcode with no arguments!\n\
      var method = new DynamicMethod(\n\
        &quot;GetManagedSizeImpl&quot;, typeof(uint), new Type[0], \n\
        typeof(TypeExtensions), false\n\
      );\n\
\n\
      ILGenerator gen = method.GetILGenerator();\n\
      gen.Emit(OpCodes.Sizeof, type);\n\
      gen.Emit(OpCodes.Ret);\n\
\n\
      var func = (Func&lt;uint&gt;)method.CreateDelegate(typeof(Func&lt;uint&gt;));\n\
      return checked((int)func());\n\
    }\n\
  }\n\
}\n\\n\</pre>\n\
"
    }
    function loadCsOut(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\n\
 --------------------------------------------------\n\
 Demonstrate C# objects\n\
--------------------------------------------------\n\
\n\
--------------------------------------------------\n\
Examples of creation and display of Primitive Types\n\
--------------------------------------------------\n\
s: Int16, size: 2, value type\n\
value: &quot;123&quot;\n\
\n\
l: Int64, size: 8, value type\n\
value: &quot;12345&quot;\n\
\n\
f: Single, size: 4, value type\n\
value: &quot;3.1415927&quot;\n\
\n\
d: Double, size: 8, value type\n\
value: &quot;3.1415927&quot;\n\
\n\
arr: Int32[], size: 8, reference type\n\
value:\n\
  arr {\n\
    4, 3, 2, 1, 0, -1\n\
  }\n\
\n\
--------------------------------------------------\n\
Examples of creation and display of Library Types\n\
- size is the size of reference, not instance\n\
--------------------------------------------------\n\
aString: String, size: 8, reference type\n\
value: &quot;a string&quot;\n\
\n\
another: String, size: 8, reference type\n\
value: &quot;another string&quot;\n\
\n\
aList: List&lt;T&gt;, size: 8, reference type\n\
value:\n\
  aList {\n\
    1, 1.5, 2, 2.5, 3,\n\
    3.5, 4\n\
  }\n\
\n\
d1: Dictionary&lt;T&gt;, size: 8, reference type\n\
value:\n\
  d1 {\n\
    [0, zero], [1, one], [2, two]\n\
  }\n\
\n\
--------------------------------------------------\n\
Examples of user-defined types:\n\
- Point1, a point with x,y,z coordinates\n\
- Point2, a point with N generic coordinates\n\
--------------------------------------------------\n\
--- ShowTypeShowable(p1, &quot;p1&quot;) ---\n\
p1: Point1, size: 8, reference type\n\
value:\n\
  p1  { x:3, y:-42, z:1 }\n\
\n\
--------------------------------------------------\n\
Point2&lt;T&gt; is both Enumerable and Showable. That is,\n\
it implements both IEnumerable&lt;T&gt; and IShow.\n\
- so both ShowTypeEnum and ShowTypeShowable work\n\
--------------------------------------------------\n\
--- ShowTypeShowable(p2, &quot;p2&quot;) ---\n\
p2: Point2&lt;T&gt;, size: 8, reference type\n\
value:\n\
  p2 {\n\
    1.5, 2, 3.5, 4, 5.5, 6,\n\
    7.5\n\
  }\n\
\n\
--- ShowTypeEnum(p2, &quot;p2&quot;) ---\n\
p2: Point2&lt;T&gt;, size: 8, reference type\n\
value:\n\
  p2 {\n\
    1.5, 2, 3.5, 4, 5.5, 6,\n\
    7.5\n\
  }\n\
\n\
--- ShowTypeShowable(p3, &quot;p3&quot;) ---\n\
--- set left(4) and width(7) ---\n\
p3: Point2&lt;T&gt;, size: 8, reference type\n\
value:\n\
    p3 {\n\
      1, 2, 3, 4, 5, 6, 7\n\
    }\n\
\n\
\n\
--------------------------------------------------\n\
Differences between value and reference types\n\
--------------------------------------------------\n\
\n\
--------------------------------------------------\n\
Assignment of reference types assigns their references,\n\
creating two references to the same instance in managed\n\
heap, so variables are coupled through single instance.\n\
--------------------------------------------------\n\
--- Point1 val1 = new Point1(), then initialize ---\n\
val1  val1  { x:1, y:3, z:0 }\n\
--- Point1 val2 = val1 ---\n\
val2  val2  { x:1, y:3, z:0 }\n\
val2 is same object as val1\n\
--- val2.z = 42; ---\n\
val2 is same object as val1\n\
val2  val2  { x:1, y:3, z:42 }\n\
val1  val1  { x:1, y:3, z:42 }\n\
--------------------------------------------------\n\
Note! Source of assignment, val1, changed when val2 changed.\n\
Point1 is ref type, so assignment just assigns references.\n\
--------------------------------------------------\n\
\n\
--------------------------------------------------\n\
Value types can be independently assigned and copied.\n\
--------------------------------------------------\n\
--- var s1 = new St(1, -0.5, 'z'); ---\n\
--- var s2 = s1 ---\n\
s2 is not same object as s1\n\
  s2 { a:1, b:-0.5, c:z }\n\
  s1 { a:1, b:-0.5, c:z }\n\
--- s2.c = 'q' ---\n\
  s2 { a:1, b:-0.5, c:q }\n\
  s1 { a:1, b:-0.5, c:z }\n\
--------------------------------------------------\n\
Change in destination, s2, did not alter source, s1.\n\
Assignment of value types creates independent objects.\n\
--------------------------------------------------\n\
\n\
--------------------------------------------------\n\
Instances of string are reference types, but simulate\n\
some value behaviors.  String objects are immutable.\n\
To modify an instance, a new string is created with\n\
copies of the source string characters inclucing any\n\
modifications.  This is called copy on write.\n\
--------------------------------------------------\n\
\n\
str2 is same object as str1\n\
str1: An immutable string\n\
str2: An immutable string\n\
str2 is not same object as str1\n\
str1: An immutable string\n\
str2: immutable string\n\
--------------------------------------------------\n\
There is no way for change in str2 to affect str1.\n\
--------------------------------------------------\n\
\n\
That's all Folks!\n\
\n\
\n\</pre>\n\
"
    }
    function loadCsBld(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre style='overflow-x:auto;'>\n\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Objects\n\
&gt; dotnet build\n\
MSBuild version 17.4.0+18d5aef85 for .NET\n\
  Determining projects to restore...\n\
  All projects are up-to-date for restore.\n\
  Cs_Objects -&gt; C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Objects&#92;bin&#92;Debug&#92;net7.0\n\
  &#92;Cs_Objects.dll\n\
\n\
Build succeeded.\n\
    0 Warning(s)\n\
    0 Error(s)\n\
\n\
Time Elapsed 00:00:00.63\n\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Objects\n\
\n\
</pre>"
    }

    /*-- Load Rust Code, Output, Build --*/
    function loadRsCode(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div class='code'>\
      <div style='white-space:normal; margin-left:2em; margin-top:0em;'>\
        <details>\
          <summary class='darkItem' style='margin-left:-2em;'>Code Notes&nbsp;&nbsp;</summary>\
          <ol class='tight' style='margin-left:0em;'>\
            <li>\
              This Bit illustrates use of std::String, std::Vector, and two user-defined\n\
              types Point1 and Point2<T>.\
            </li>\
            <li>\
              It illustrates use of move, and clone operations, as well as stack\n\
              and heap memory.\
            </li>\
            <li>\
              show function is designed to display type and calling name of its\
              first argument and its value and size.\
            </li>\
            <li>\
              <c-s>show&lt;T: Debug&gt;(T:t, n:&str)</c-s> is generic on the type T\
              with the bound that T must satisfy the Debug trait.\
            </li>\
            <li>\
              The Debug trait provides a simple formatting using {:?} in print macro.\
            </li>\
            <li>\
              Macros end with &quot;!&quot; character.  The macro println! is an example.\
              <div style='height:0.75em;'></div>\
            </li>\
          </ol >\
        </details >\n\
      </div >\
<pre>\
use std::fmt::*;\n\
use std::default::*;\n\
\n\
// CreateObject::main.rs\n\
\n\
/*-------------------------------------\n\
  - Declare Point1 struct, like a C++ class\n\
  - Request compiler implement traits Debug & Clone\n\
*/\n\
#[derive(Debug, Clone)]\n\
pub struct Point1 {\n\
    x:i32,\n\
    y:i32,\n\
    z:i32\n\
}\n\
/*-- implement functions new and name --*/\n\
impl Point1 {\n\
  pub fn new() \n\
        -&gt; Point1 {\n\
      Point1 {\n\
          x:0, y:0, z:0\n\
      }\n\
  }\n\
  /* \n\
    For simple types like this it would be reasonable to \n\
    make x, y, z public and remove the getter and setter\n\
    functions. \n\
  */\n\
  pub fn get_x(&self) -&gt; &i32 {\n\
    &self.x\n\
  }\n\
  pub fn get_y(&self) -&gt; &i32 {\n\
    &self.y\n\
  }\n\
  pub fn get_z(&self) -&gt; &i32 {\n\
    &self.z\n\
  }\n\
  pub fn set_x(&mut self, x:i32) {\n\
    self.x = x\n\
  }\n\
  pub fn set_y(&mut self, y:i32) {\n\
    self.y = y\n\
  }\n\
  pub fn set_z(&mut self, z:i32) {\n\
    self.z = z\n\
  }\n\
  pub fn show(&self) {\n\
    print!(&quot;Point1 {{ &quot;);\n\
    print!(&quot;{0}, &quot;, self.x);\n\
    print!(&quot;{0}, &quot;, self.y);\n\
    print!(&quot;{0} }}&quot;, self.z);\n\
  }\n\
}\n\
\n\
/*-------------------------------------\n\
  - Declare Point2&lt;T&gt; struct, like a C++ template class\n\
  - Request compiler implement traits Debug & Clone\n\
*/\n\
#[derive(Debug, Clone)]\n\
pub struct Point2&lt;T&gt; where T:Debug, T:Default, T:Clone {\n\
  coor: Vec&lt;T&gt;,\n\
}\n\
impl&lt;T&gt; Point2&lt;T&gt; where T:Debug, T:Default, T:Clone {\n\
  pub fn new(n:usize) \n\
        -&gt; Point2&lt;T&gt; {\n\
      Point2::&lt;T&gt; {\n\
          coor : vec![T::default(); n],\n\
      }\n\
  }\n\
  pub fn init(mut self, coord: Vec&lt;T&gt;) -&gt; Point2&lt;T&gt; {\n\
    self.coor = coord;\n\
    self\n\
  }\n\
  pub fn len(&self) -&gt; usize {\n\
    self.coor.len()\n\
  }\n\
  /* acts as both get_coor() and set_coor(vec![1, 2, 3]) */\n\
  pub fn coors(&mut self) -&gt; &mut Vec&lt;T&gt; {\n\
    return &mut self.coor;\n\
  }\n\
  pub fn show(&self, width:usize, left:usize) {\n\
    print!(&quot;Point2&lt;T&gt; {{ &quot;);\n\
    show_fold(&self.coor, width, left);\n\
    print!(&quot;}}&quot;)\n\
  }\n\
}\n\
/*-- Demo object instances in action --*/\n\
fn main() {\n\
    print!(\n\
      &quot;&#92;n -- demonstrate object creation --&#92;n&quot;\n\
    );\n\
    show_note(&quot;std::library objects&quot;);\n\
\n\
    print!(&quot;&#92;n--- let mut s1 = {}.to_string() ---&quot;, &quot;&#92;&quot;a string&#92;&quot;&quot;);\n\
    let mut s1 = &quot;a string&quot;.to_string();\n\
    print!(&quot;&#92;n--- {} ---&quot;, &quot;show_type(&s1, &#92;&quot;&s1&#92;&quot;)&quot;);\n\
    show_type(&s1, &quot;&s1&quot;);\n\
    print!(&quot;&#92;n--- {} ---&quot;, &quot;s1.push_str(&#92;&quot; and more&#92;&quot;);&quot;);\n\
    s1.push_str(&quot; and more&quot;);\n\
    show_type(&s1, &quot;&s1&quot;);\n\
\n\
    print!(&quot;&#92;n--- let mut v:Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1]; ---&quot;);\n\
    let mut v:Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1];\n\
    show_type(&v, &quot;&v&quot;);\n\
    print!(&quot;&#92;n--- v.push(42); ---&quot;);\n\
    v.push(42);\n\
    show_type(&v, &quot;&v&quot;);    \n\
\n\
    show_note(&quot;instances of user-defined types&quot;);\n\
    \n\
    print!(&quot;&#92;n--- let mut p1 = Point1::new() ---&#92;n&quot;);\n\
    let mut p1 = Point1::new();\n\
    p1.show();\n\
    println!();\n\
    p1.set_x(42);\n\
    p1.set_y(-3);\n\
    p1.set_z(2);\n\
    p1.show();\n\
    show_type(p1.clone(), &quot;p1&quot;);\n\
    print!(&quot;&#92;n--- let p1a = p1.clone() ---&#92;n&quot;);\n\
    let p1a = p1.clone();\n\
    p1a.show();\n\
\n\
    let mut p2 = Point2::&lt;f64&gt;::new(10);\n\
    print!(&quot;&#92;n&#92;n--- show_type(p2a.clone(), &#92;&quot;p2a&#92;&quot;) ---&quot;);\n\
    show_type(p2.clone(), &quot;p2&quot;);\n\
    p2.coors()[2] = 3.1415;\n\
    show_type(p2.clone(), &quot;p2&quot;);\n\
\n\
    let p2a = Point2::&lt;i32&gt;::new(1).init(vec![0,1,2,3,4,4,3,2,1,0]);\n\
    print!(&quot;&#92;n--- show_type(p2a.clone(), &#92;&quot;p2a&#92;&quot;) ---&quot;);\n\
    show_type(p2a.clone(), &quot;p2a&quot;);\n\
    print!(&quot;&#92;n{}&quot;, &quot;&#92;&quot;--- p2a.len() ---&#92;&quot;&quot;);\n\
    print!(&quot;&#92;nsize of p2a = {:?}&quot;, p2a.len());\n\
    print!(&quot;&#92;n&#92;n--- p2a.show(8,2) ---&#92;n&quot;);\n\
    p2a.show(8,2);\n\
    println!();\n\
\n\
    let v = vec![\n\
      0i32, -1, 2, -3, 4, -5, 6, -7, 8, -9, 10, -11, 12, -13, 14\n\
    ];\n\
    \n\
    print!(&quot;{}&quot;, &quot;&#92;n--- show_type(&v, &#92;&quot;&v&#92;&quot;) ---&quot;);\n\
    show_type(&v, &quot;&v&quot;);\n\
    print!(&quot;&#92;n--- show_fold(&v, 5, 2) ---&quot;);\n\
    show_fold(&v, 5, 2);\n\
\n\
    print!(&quot;&#92;n&#92;n  That's all Folks!&#92;n&#92;n&quot;);\n\
}\n\
/*\n\
  Show facts about a type's elements, e.g., name, type, \n\
  value, and size.\n\
  show_type is generic function with Debug bound.\n\
  Using format &quot;{:?} requires Debug.&quot;\n\
*/\n\
fn show_type&lt;T: std::fmt::Debug&gt;(t: T, nm: &str) {\n\
  let typename = std::any::type_name::&lt;T&gt;();\n\
  println!(&quot;&#92;ncall name: {:?}, type: {:?}&quot;, nm, typename);\n\
  println!(&quot;value: {:?}, size: {}&quot;, t, std::mem::size_of::&lt;T&gt;());\n\
}\n\
/* indent print out by &quot;left&quot; spaces */\n\
fn print_offset(left:usize) {\n\
  for _i in 0..left {\n\
    print!(&quot; &quot;);\n\
  }\n\
}\n\
/* fold a vector slice into rows of w elements */\n\
fn show_fold&lt;T:Debug&gt;(d:&Vec&lt;T&gt;, w:usize, left:usize) {\n\
  print!(&quot;&#92;n&quot;);\n\
  print_offset(left);\n\
  for _i in 1..=d.len() {\n\
    if _i &lt; d.len() {\n\
      print!(&quot;{:?}, &quot;, d[_i - 1]);\n\
    }\n\
    else {\n\
      print!(&quot;{:?}&quot;, d[_i - 1]);\n\
      print!(&quot;&#92;n&quot;);\n\
      break;\n\
    }\n\
    if _i % w == 0  && _i != 0 && _i != w - 1 {\n\
      print!(&quot;&#92;n&quot;);\n\
      print_offset(left);\n\
    }\n\
  }\n\
}\n\
/* show string wrapped with dotted lines above and below */\n\
fn show_note(note:&str) {\n\
  print!(&quot;&#92;n-------------------------&#92;n&quot;);\n\
  print!(&quot;{}&quot;, note);\n\
  print!(&quot;&#92;n-------------------------&#92;n&quot;);\n\
}\n\
\n\
\n\\n\\n\</pre></div>\
";
    }

    function loadRsOut(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\
 -- demonstrate object creation --\n\
\n\
-------------------------\n\
std::library objects\n\
-------------------------\n\
\n\
--- let mut s1 = &quot;a string&quot;.to_string() ---\n\
--- show_type(&s1, &quot;&s1&quot;) ---\n\
call name: &quot;&s1&quot;, type: &quot;&alloc::string::String&quot;\n\
value: &quot;a string&quot;, size: 8\n\
\n\
--- s1.push_str(&quot; and more&quot;); ---\n\
call name: &quot;&s1&quot;, type: &quot;&alloc::string::String&quot;\n\
value: &quot;a string and more&quot;, size: 8\n\
\n\
--- let mut v:Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1]; ---\n\
call name: &quot;&v&quot;, type: &quot;&alloc::vec::Vec&lt;i32&gt;&quot;\n\
value: [1, 2, 3, 2, 1], size: 8\n\
\n\
--- v.push(42); ---\n\
call name: &quot;&v&quot;, type: &quot;&alloc::vec::Vec&lt;i32&gt;&quot;\n\
value: [1, 2, 3, 2, 1, 42], size: 8\n\
\n\
-------------------------\n\
instances of user-defined types\n\
-------------------------\n\
\n\
--- let mut p1 = Point1::new() ---\n\
Point1 { 0, 0, 0 }\n\
Point1 { 42, -3, 2 }\n\
call name: &quot;p1&quot;, type: &quot;rust_hello_objects::Point1&quot;\n\
value: Point1 { x: 42, y: -3, z: 2 }, size: 12\n\
\n\
--- let p1a = p1.clone() ---\n\
Point1 { 42, -3, 2 }\n\
\n\
--- show_type(p2a.clone(), &quot;p2a&quot;) ---\n\
call name: &quot;p2&quot;, type: &quot;rust_hello_objects::Point2&lt;f64&gt;&quot;\n\
value: Point2 { coor: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] }, size: 24\n\
\n\
call name: &quot;p2&quot;, type: &quot;rust_hello_objects::Point2&lt;f64&gt;&quot;\n\
value: Point2 { coor: [0.0, 0.0, 3.1415, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] }, size: 24\n\
\n\
--- show_type(p2a.clone(), &quot;p2a&quot;) ---\n\
call name: &quot;p2a&quot;, type: &quot;rust_hello_objects::Point2&lt;i32&gt;&quot;\n\
value: Point2 { coor: [0, 1, 2, 3, 4, 4, 3, 2, 1, 0] }, size: 24\n\
\n\
&quot;--- p2a.len() ---&quot;\n\
size of p2a = 10\n\
\n\
--- p2a.show(8,2) ---\n\
Point2&lt;T&gt; {\n\
  0, 1, 2, 3, 4, 4, 3, 2,\n\
  1, 0\n\
}\n\
\n\
--- show_type(&v, &quot;&v&quot;) ---\n\
call name: &quot;&v&quot;, type: &quot;&alloc::vec::Vec&lt;i32&gt;&quot;\n\
value: [0, -1, 2, -3, 4, -5, 6, -7, 8, -9, 10, -11, 12, -13, 14], size: 8      \n\
\n\
--- show_fold(&v, 5, 2) ---\n\
  0, -1, 2, -3, 4,\n\
  -5, 6, -7, 8, -9,\n\
  10, -11, 12, -13, 14\n\
\n\
\n\
  That's all Folks!\n\
\n\
\n\</pre>";
    }

    function loadRsBld(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_hello_objects\n\
&gt; cargo clean\n\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_hello_objects\n\
&gt; cargo run  \n\
   Compiling rust_hello_objects v0.1.0 (C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_hello_objects)\n\
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s                  \n\
     Running `target&#92;debug&#92;rust_hello_objects.exe`\n\
\n\
 -- demonstrate object creation --\n\
\n\
\n\</pre>";
    }
    /*-- Load Python Code, Output, Build --*/
    function loadPyCode(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div class='code' style='margin-top:0em;'>\n\
<div style='white-space:normal; margin-left:2em;'>\
<details>\
  <summary class='darkItem' style='margin-left:-2em;'>Code Notes&nbsp;&nbsp;</summary>\
  <ol class='tight' style='margin-left:0em;'>\
    <li>\
      This code is a simple demonstration of Python types string, list, complex,\n\
      and also user defined type Point1 and their instances.\
    </li>\
    <li>\
      All Python types are reference types with values stored in heap.\
    </li>\
    <li>\
      showType functions are designed to display type and calling name of\n\
      first argument and value and size.\
    </li>\
    <li>\
      Note that the display and analysis functions are simpler than those for\n\
      C++, Rust, and especially C#\
    </li>\
    <li>\
      Python does not have generics. It is dynamically typed, so\n\
      everything is already generic.\
    </li>\
  </ol >\
  <div style=&quot;height: 3em;&quot;>&nbsp;</div>\
</details >\
</div >\
<pre>\n\
import sys\n\
# Python/Py_Objects::Py_Objects.py\n\
# \n\
# Python Dynamic Data Types\n\
#   int, float, complex\n\
#   bytes, bytearray, memoryview\n\
#   list, tuple, range\n\
#   dict, set, frozenset\n\
#   bool\n\
#   str\n\
#   NoneType\n\
\n\
# Python requires definition before use ordering\n\
#  - no link phase to find definitions\n\
import copy\n\
nl = &quot;&#92;n&quot;\n\
\n\
# show name, type, value, and size of a Python instance\n\
def showType(t, nm, suffix = &quot;&quot;) :\n\
    print(nm, type(t), &quot;dynamic&quot;)\n\
    print(&quot;value: &quot;, t, ', size: ', sys.getsizeof(t), suffix)\n\
\n\
# same as showType except uses class method to show value\n\
def showTypeShowable(t, nm, suffix = &quot;&quot;):\n\
    print(nm, type(t), &quot;dynamic&quot;)\n\
    t.show(nm)\n\
\n\
# show Python id, unique for each instance\n\
def showIdent(t, n, suffix = &quot;&quot;) :\n\
    print(n, t, id(t), suffix)\n\
\n\
# show emphasized note\n\
def showNote(text, suffix = &quot;&quot;) :\n\
    print(&quot;-------------------------&quot;)\n\
    print(text)\n\
    print(&quot;-------------------------&quot;, suffix)\n\
\n\
# show delineated string to announce a program operation\n\
def showOp(text):\n\
    print(&quot;--- {} ---&quot;.format(text))\n\
\n\
# point class with three coordinates\n\
class Point1:\n\
    x = 0;\n\
    y = 0;\n\
    z = 0;\n\
\n\
    # supports constructor notation\n\
    def __init__(self) -&gt; None:\n\
        pass\n\
    \n\
    # show named value of Point1 instance\n\
    def show(self, name) :\n\
        print(&quot;{} {{ &quot;.format(name), end='')\n\
        print(&quot; x:{}, y:{}, z:{}&quot;.format(self.x, self.y, self.z), end='');\n\
        print(&quot; }&quot;);\n\
\n\
# Demonstration starts here\n\
def execute() : \n\
    print(&quot; Demonstrate Python Objects&quot;)\n\
    print(&quot;----------------------------&quot;)\n\
\n\
    showNote(   \n\
        &quot;All Python types are reference-based&#92;n&quot;&#92;\n\
        &quot;with values in the managed heap. That&#92;n&quot;&#92;\n\
        &quot;has consequences we explore in this demo.&quot;\n\
    )\n\
\n\
    s1 = &quot;a string&quot;\n\
    showType(s1, &quot;s1&quot;)\n\
    showOp(&quot;s2 = s1&quot;)\n\
    s2 = s1\n\
    showIdent(s1, &quot;s1&quot;)\n\
    showIdent(s2, &quot;s2&quot;)\n\
    #print(&quot;s2 = {}&quot;.format(s2))\n\
    showOp(&quot;s2 += &#92;&quot; and more&#92;&quot;&quot;)\n\
    s2 += &quot; and more&quot;\n\
    showIdent(s2, &quot;s2&quot;)\n\
    showIdent(s1, &quot;s1&quot;)\n\
    # print(&quot;s2 = {}&quot;.format(s2))\n\
    # print(&quot;s1 = {}&quot;.format(s1))\n\
    showNote(   \n\
        &quot;Assignment, in Python, assignes references not&#92;n&quot;&#92;\n\
        &quot;values.  So s1 and s2 share same heap instance&#92;n&quot;&#92;\n\
        &quot;But strings are immutable. So when a change is&#92;n&quot;&#92;\n\
        &quot;made to one, that creates a new instance without&#92;n&quot;&#92;\n\
        &quot;changing the original.&quot;\n\
    )\n\
    print()\n\
\n\
    l1 = [&quot;you&quot;, &quot;me&quot;, &quot;them&quot;, &quot;us&quot;]\n\
    showType(l1, &quot;l1&quot;, nl)\n\
\n\
    print(&quot;l1 = &quot;, l1)\n\
    showOp(&quot;l2 = l1&quot;)\n\
    l2 = l1\n\
    showOp('l2.append(&quot;everyone&quot;)')\n\
    l2.append(&quot;everyone&quot;)\n\
    print(&quot;l2 = &quot;, l2)\n\
    print(&quot;l1 = &quot;, l1)\n\
    showOp('l2[1] = &quot;myself&quot;')\n\
    l2[1] = &quot;myself&quot;\n\
    print(&quot;l2 = &quot;, l2)\n\
    print(&quot;l1 = &quot;, l1)\n\
    showNote(   \n\
        &quot;Assignment, in Python, assignes references&#92;n&quot;&#92;\n\
        &quot;not values.  So changes to target affect the&#92;n&quot;&#92;\n\
        &quot;source.  &#92;&quot;caveat emptor&#92;&quot;&quot;\n\
    )\n\
    print()\n\
\n\
    showOp(&quot;p1a = Point1()&quot;)\n\
    p1a = Point1()\n\
    showOp(&quot;showTypeShowable(p1a, &#92;&quot;p1a&#92;&quot;, nl)&quot;)\n\
    showTypeShowable(p1a, &quot;p1a&quot;, nl)\n\
    p1a.x = 2\n\
    p1a.y = -3.5\n\
    p1a.z = -42\n\
    p1a.show(&quot;p1a&quot;)\n\
\n\
    showOp(&quot;p1b = p1a&quot;)\n\
    p1b = p1a\n\
    p1b.show(&quot;p1b&quot;)\n\
\n\
    showOp(&quot;p1b.y = 13&quot;)\n\
    p1b.y = 13\n\
    p1b.show(&quot;p1b&quot;)\n\
    p1a.show(&quot;p1a&quot;)\n\
    showNote(\n\
        &quot;Reference assigned, not value.&#92;nSo change&quot;&#92;\n\
        &quot; in P1b changed source p1a.&quot;\n\
    )\n\
    print()\n\
\n\
    showOp(&quot;p1c = copy.deepcopy(p1b)&quot;)\n\
    p1c = copy.deepcopy(p1b)\n\
    p1c.show(&quot;p1c&quot;);\n\
    p1b.show(&quot;p1b&quot;)\n\
    showOp(&quot;p1c.z = 12&quot;)\n\
    p1c.z = 12\n\
    p1c.show(&quot;p1c&quot;)\n\
    p1b.show(&quot;p1b&quot;)\n\
    showNote(\n\
        &quot;p1c.z reference assigned, not value. But no&#92;n&quot;&#92;\n\
        &quot;change in p1b since p1c is deep clone of p1b.&quot;\n\
    )\n\
    print()\n\
\n\
    # # reference behavior - new child object\n\
    print(&quot;-- t5 = (1, 2, 3) --&quot;)\n\
    t5 = (1, 2, 3)\n\
    showIdent(t5, &quot;t5&quot;)\n\
    print(&quot;-- t6 = [1, t5, &#92;&quot;weird&#92;&quot;] --&quot;)\n\
    t6 = [1, t5, &quot;weird&quot;]\n\
    showIdent(t6, &quot;t6&quot;)\n\
    showType(t6, &quot;t6&quot;)\n\
    print(&quot;-- t5 = 1 + 1j : new object --&quot;)\n\
    t5 = 1 + 1j\n\
    showIdent(t5, &quot;t5&quot;)\n\
    showIdent(t6, &quot;t6&quot;)\n\
    showNote(&quot;new object for t5, t6 not affected&quot;, nl)\n\
    \n\
    # # reference behavior - iterate over children\n\
    print(&quot;-- iterate over t6 children --&quot;)\n\
    for i in t6:\n\
        showIdent(i, &quot;elem&quot;)\n\
\n\
    print(&quot;&#92;n-- iterate over t6 methods --&quot;)\n\
    print(dir(t6))\n\
      \n\
    print(&quot;&#92;nThat's all folks!&#92;n&quot;)\n\
\n\
execute()\n\
\n\
\n\</pre>\n\
</div>\n\
";
    }

    function loadPyOut(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div class='code'>\n\
<pre>\n\
 Demonstrate Python Objects\n\
----------------------------\n\
-------------------------\n\
All Python types are reference-based\n\
with values in the managed heap. That\n\
has consequences we explore in this demo.\n\
-------------------------\n\
s1 &lt;class 'str'&gt; dynamic\n\
value:  a string , size:  57\n\
--- s2 = s1 ---\n\
s1 a string 2624089302960\n\
s2 a string 2624089302960\n\
--- s2 += &quot; and more&quot; ---\n\
s2 a string and more 2624089315152\n\
s1 a string 2624089302960\n\
-------------------------\n\
Assignment, in Python, assignes references not\n\
values.  So s1 and s2 share same heap instance\n\
But strings are immutable. So when a change is\n\
made to one, that creates a new instance without\n\
changing the original.\n\
-------------------------\n\
\n\
l1 &lt;class 'list'&gt; dynamic\n\
value:  ['you', 'me', 'them', 'us'] , size:  88\n\
\n\
l1 =  ['you', 'me', 'them', 'us']\n\
--- l2 = l1 ---\n\
--- l2.append(&quot;everyone&quot;) ---\n\
l2 =  ['you', 'me', 'them', 'us', 'everyone']\n\
l1 =  ['you', 'me', 'them', 'us', 'everyone']\n\
--- l2[1] = &quot;myself&quot; ---\n\
l2 =  ['you', 'myself', 'them', 'us', 'everyone']\n\
l1 =  ['you', 'myself', 'them', 'us', 'everyone']\n\
-------------------------\n\
Assignment, in Python, assignes references\n\
not values.  So changes to target affect the\n\
source.  &quot;caveat emptor&quot;\n\
-------------------------\n\
\n\
--- p1a = Point1() ---\n\
--- showTypeShowable(p1a, &quot;p1a&quot;, nl) ---\n\
p1a &lt;class '__main__.Point1'&gt; dynamic\n\
p1a {  x:0, y:0, z:0 }\n\
p1a {  x:2, y:-3.5, z:-42 }\n\
--- p1b = p1a ---\n\
p1b {  x:2, y:-3.5, z:-42 }\n\
--- p1b.y = 13 ---\n\
p1b {  x:2, y:13, z:-42 }\n\
p1a {  x:2, y:13, z:-42 }\n\
-------------------------\n\
Reference assigned, not value.\n\
So change in P1b changed source p1a.\n\
-------------------------\n\
\n\
--- p1c = copy.deepcopy(p1b) ---\n\
p1c {  x:2, y:13, z:-42 }\n\
p1b {  x:2, y:13, z:-42 }\n\
--- p1c.z = 12 ---\n\
p1c {  x:2, y:13, z:12 }\n\
p1b {  x:2, y:13, z:-42 }\n\
-------------------------\n\
p1c.z reference assigned, not value. But no\n\
change in p1b since p1c is deep clone of p1b.\n\
-------------------------\n\
\n\
-- t5 = (1, 2, 3) --\n\
t5 (1, 2, 3) 2624089300224\n\
-- t6 = [1, t5, &quot;weird&quot;] --\n\
t6 [1, (1, 2, 3), 'weird'] 2624089307328\n\
t6 &lt;class 'list'&gt; dynamic\n\
value:  [1, (1, 2, 3), 'weird'] , size:  80\n\
-- t5 = 1 + 1j : new object --\n\
t5 (1+1j) 2624086515600\n\
t6 [1, (1, 2, 3), 'weird'] 2624089307328\n\
-------------------------\n\
new object for t5, t6 not affected\n\
-------------------------\n\
\n\
-- iterate over t6 children --\n\
elem 1 2624085491952\n\
elem (1, 2, 3) 2624089300224\n\
elem weird 2624089306288\n\
\n\
-- iterate over t6 methods --\n\
['__add__', '__class__', '__class_getitem__', '__contains__', \n\
'__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', \n\
'__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', \n\
'__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', \n\
'__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', \n\
'__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', \n\
'__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', \n\
'__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', \n\
'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\n\
\n\
That's all folks!\n\
\n\
\n\</pre>\n\
</div>";
    }

    function loadPyBld(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Python&#92;Py_Data\n\
&gt; python Py_Data.py\n\
 Demonstrate Python Types\n\
--------------------------\n\
>\
      </pre>";
    }
    /*-- Load Javascript Code, Output, Build --*/
    function loadJsCode(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div style='white-space:normal; margin-left:2em;'>\
<details>\
  <summary class='darkItem' style='margin-left:-2em;'>Code Notes&nbsp;&nbsp;</summary>\
  <ol class='tight' style='margin-left:0em;'>\
    <li>\
      This code is a not so simple demonstrations of numbers, strings, and arrays.\
    </li>\
    <li>\
      All JavaScript types are reference types with values stored in heap.\
    </li>\
    <li>\
      showType function is designed to display type and calling name of its\n\
      first argument and its value and size.\
    </li>\
    <li>\
      Note that the display functions are simple but the analysis function sizeof(object)\n\
      requires recursive iteration through the members and decendents of object.\
    </li>\
    <li>\
      JavaScript does not have generics. It is dynamically typed, so\n\
      everything is already generic.\
    </li>\
  </ol >\
  <div style=&quot;height: 3em;&quot;>&nbsp;</div>\
</details >\
</div >\
<div class='code'>\
<pre>\
</pre>\
</div>\
";
    }

    function loadJsOut(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\
</pre>";
    }

    function loadJsBld(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\
\n\      </pre>";
    }
    //function load1() {

    //}
    function remoteLeft() {
      let cp = document.getElementById("Cp1");
      if (cp.checked) {
        window.open('https://godbolt.org/z/d7PGec1qj', '_blank');
      }
      let cs = document.getElementById("Cs1");
      if (cs.checked) {
        window.open('https://godbolt.org/z/Pc89d8c3T', '_blank');
      }
      let rs = document.getElementById("Rs1");
      if (rs.checked) {
        window.open(
          'https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b30e17c45574a8f9f276250365f12250',
          '_blank'
        )
      }
      let py = document.getElementById("Py1");
      if (py.checked) {
        window.open(
          'https://godbolt.org/z/Y531MqoPT',
          '_blank'
        )
      }
      let js = document.getElementById("Js1");
      if (js.checked) {
        window.open(
          'Js_Data.html',
          '_blank'
        )
      }
    }
    function remoteRight() {
      let cp = document.getElementById("Cp2");
      if (cp.checked) {
        window.open('https://godbolt.org/z/d7PGec1qj', '_blank');
      }
      let cs = document.getElementById("Cs2");
      if (cs.checked) {
        window.open('https://godbolt.org/z/Pc89d8c3T', '_blank');
      }
      let rs = document.getElementById("Rs2");
      if (rs.checked) {
        window.open(
          'https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b30e17c45574a8f9f276250365f12250',
          '_blank'
        )
      }
      let py = document.getElementById("Py2");
      if (py.checked) {
        window.open(
          'https://godbolt.org/z/Y531MqoPT',
          '_blank'
        )
      }
      let js = document.getElementById("Js2");
      if (js.checked) {
        window.open(
          'Js_Data.html',
          '_blank'
        )
      }
    }
  </script>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="Bits_Objects.html">Next</a>
  <a id="Prev" href="Bits_Data.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="page">Bits Objects</div>
      <div id="modified">01/18/2022</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>

        <header>
          <hgroup id="pagetitle">
            <a class="repoLink" href="../../BitsRepo.html">Bits Repository</a>
            <h1 id="title">Bits_Objects</h1>
            <h3 id="subtitle" class="indent">
              code, output, and build for C++, Rust, C#, Python, and JavaScript on Windows, macOS, and Linux
            </h3>
          </hgroup>
        </header>
        <t-b>
          These pages support comparison of fragments of code in several different
          languages, much as you might compare a sentence of English with one in Spanish to help you learn
          Spanish.
        </t-b>
        <details>
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <t-b><hr /></t-b>
          <t-b>
            All of the languages covered in this demonstration support classes.  Each class provides
            a pattern for laying out a memory footprint and defines how data within are accessed.
          </t-b>
          <t-b>
            Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
            is a pattern for defining functions and classes of a specific type.  Thus a generic is a
            pattern for making patterns.
          </t-b>
          <t-b>
            The other two, Python and JavaScript, are dynamically typed and already support defining
            functions and classes for multiple types, e.g., no need for generics.
          </t-b>
          <t-b>
            This demonstration illustrates use of classes and objects, which for C++, Rust, and C#,
            are defined in a stackframe and also in the heap. All data for Python and JavaScript are
            stored in managed heaps.
          </t-b>
          <t-b><hr /></t-b>
        </details>
        <t-b>
          The examples below show how to use library and user defined types with emphasis on
          illustrating syntax and basic operations.
        </t-b>
        <div id="compare" style="height:0.0em;"></div>
        <div style="width:100%; text-align:center; position:relative; right:1.5em;">
          <input class="mover" type="button" name="size" value="-" onclick="movel()">
          <input class="mover" type="button" name="size" value="C" onclick="movec()">
          <input class="mover" type="button" name="size" value="+" onclick="mover()">
        </div>
        <div style="height:1.5em;"></div>
        <div id="ruler">&nbsp;</div>
        <table class="showcode" style="position:relative;">
          <tr>
            <th class="btns">
            </th>
            <th id="lb" class="leftblock" style="position:relative; z-index:10;">
              <input type="button" id="exeLeft" value="RemoteExecute" onclick="remoteLeft()" 
                     style="position:absolute; left:1em;" />
              <span id="lbt">Source Code</span>
            </th>
            <th class="centerblock"></th>
            <th id="rb" class="rightblock" style="position:relative;">
              <input type="button" id="exeRight" value="RemoteExecute" onclick="remoteRight()" 
                     style="position:absolute; right:1em;"/>
              <span id="rbt">Source Code</span>
            </th>
            <th class="btns">

            </th>
          </tr>
          <tr>
            <td class="btns">
              <form id="left" name="left" style="margin-left:-2em;">
                <label for="Cp1">C++</label>
                <input type="radio" id="Cp1" name="lang1" value="1" onclick="loadCppLeft()">
                <label for="Rs1">Rust</label>
                <input type="radio" id="Rs1" name="lang1" value="3" onclick="loadRsLeft()">
                <label for="Cs1">C#&nbsp;</label><br />
                <input type="radio" id="Cs1" name="lang1" value="2" onclick="loadCsLeft()">
                <label for="Py1">Python</label>
                <input type="radio" id="Py1" name="lang1" value="4" onclick="loadPyLeft()">
                <label for="Js1">JvScpt</label>
                <input type="radio" id="Js1" name="lang1" value="5" onclick="loadJsLeft()">
              </form>
            </td>
            <td class="leftblock">
              <div id="left1">
                left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1  
                left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1  
              </div>
            </td>
            <td class="centerblock"></td>
            <td class="rightblock">
              <div id="right1">
                right1 right1 right1 right1 right1 right1 right1 right1 right1 right1 right1 right1 right1 right1  
              </div>
            </td>
            <td class="btns">
              <form id="right" name="right" style="margin-left:-1.2em;">
                <label for="Cp2">C++</label>
                <input type="radio" id="Cp2" name="lang2" value="4" onclick="loadCppRight()">
                <label for="Rs2">Rust</label>
                <input type="radio" id="Rs2" name="lang2" value="6" onclick="loadRsRight()">
                <label for="Cs2">C#</label><br />
                <input type="radio" id="Cs2" name="lang2" value="5" onclick="loadCsRight()">
                <label for="Py2">Python</label>
                <input type="radio" id="Py2" name="lang2" value="4" onclick="loadPyRight()">
                <label for="Js2">JvScrpt</label><br />
                <input type="radio" id="Js2" name="lang2" value="5" onclick="loadJsRight()">
                <label for="No2">None</label><br />
                <input type="radio" id="No2" name="lang2" value="5" onclick="load1()">
              </form>
            </td>
          </tr>
          <tr id="outlabel">
            <th class="btns">

            </th>
            <th class="leftblock">Output</th>
            <th class="centerblock"></th>
            <th class="rightblock">Output</th>
            <th class="btns">

            </th>
          </tr>
          <tr id="outcontent">
            <td class="btns">

            </td>
            <td class="leftblock"><div id="left2">left2</div></td>
            <td class="centerblock"></td>
            <td class="rightblock"><div id="right2">right2</div></td>
            <td class="btns">

            </td>
          </tr>
          <tr id="bldlabel">
            <th class="btns">

            </th>
            <th class="leftblock">Build</th>
            <th class="centerblock"></th>
            <th class="rightblock">Build</th>
            <th class="btns">

            </th>
          </tr>
          <tr id="bldcontent">
            <td class="btns">

            </td>
            <td class="leftblock"><div id="left3">left3</div></td>
            <td class="centerblock"></td>
            <td class="rightblock"><div id="right3">right3</div></td>
            <td class="btns">

            </td>
          </tr>
        </table>
        <t-b>
          <!--<h3 id="notes">Notes</h3>
          <ul>
            <li>
              Rust is built with the Cargo tool: package manager, builder, executer, and more.
              Cargo is part of the Rust ecosystem available when you 
              <a href="https://www.rust-lang.org/tools/install">install Rust</a>.
            </li>
            <li>
              C++ is built with the CMake tool: a third party make tool. Here is a 
              <a href="../../CppMakeDemo.html">Demo</a>. You can <a href="https://cmake.org/">download CMake</a>
              free of charge.
            </li>
            <li>
              C# code is built with the dotnet command line package manager, builder, and executer.
              For simple console applications dotnet builds a stripped down source that gets
              wrapped with needed boilerplate when built. I chose to provide the boiler plate.
              The dotnet CLI is part of the Visual Studio infrastructure you can 
              <a href="https://visualstudio.microsoft.com/vs/community/">download here</a>.
            </li>
            <li>
              Python is built and executed with the Python interpreter using &quot;python filename.py&quot;
              You can download Python <a href="https://www.python.org/downloads/">here</a>.
            </li>
            <li>
              All you need for Javascript development is a text editor and browser. The major browsers,
              Firefox, Chrome, Edge, ... all have tools for inspecting and debugging JavaScript.
            </li>
          </ul>-->
        </t-b>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#notes">notes</a></menu-elem>
        <menu-elem class="secElem"><a href="#bldlabel">build</a></menu-elem>
        <menu-elem class="secElem"><a href="#outlabel">output</a></menu-elem>
        <menu-elem class="secElem"><a href="#compare">codeview</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <!--<menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.decrZoomScreen()">Zout</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.normZoomScreen()">Zdef</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.incrZoomScreen()">Zin</menu-elem>-->
    </frame-footer>
  </page-frame>
  <script>
    setChecks();
    startLeft();
    startRight();
    //var cb1 = document.getElementById("Rs1");
    //cb1.checked = true;
    //loadRsLeft();
    //var cb2 = document.getElementById("Cp2");
    //cb2.checked = true;
    //loadCppRight();
  </script>
</body>
</html>