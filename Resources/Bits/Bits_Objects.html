<!DOCTYPE html>
<html>
<!--
  Bits_Objects.html
-->
<head>
  <title>Bits_Objects</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeDefault.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesBits.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <script src="js/ScriptsPageFrameRadioButtons.js"></script>
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding:0.75em 1.5em;
      margin-top:1.25em;
      margin-bottom:1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width:50em;
    }
    #github h2 {
      margin-top: 0.75em;
    }
    #github #pagetitle {
      border:2px double var(--dark);
    }
    #github form {
      border:none;
      padding:0.5em 1em;
    }
    #github form span {
      padding:0em 0.5em;
    }
    #github code-container {
      display: flex;
      position:relative;
      width:calc(100%);
      flex-direction: row;
      justify-content: space-between;
      /*border-top: 1px solid var(--dark);*/
    }
    #github code-banner {
      display: block;
      border: 2px solid var(--dark);
      border-top:none;
      border-bottom:none;
      padding: 0.25em 1em;
      font-family: 'Comic Sans MS', Tahoma;
      width: calc(100% + 0.5em);
      background-color: var(--atten);
    }
    #github code-display {
      display: block;
      border: 2px solid var(--dark);
      white-space: pre;
      padding: 0.75em 1em;
      font-family: Consolas, monospace;
      font-size:0.9em;
      width: calc(50% - 0.5em);
      overflow-x: auto;
      /*height:20em;*/
    }
    #github label {
      margin-right:1em;
    }
    #github fieldset {
      border:none;
    }
    #github #exeRight, #exeLeft {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github #hideLeft, #hideRight {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github .hide {
      display:none;
    }
    body {
      position:relative;
    }
    #github table.showcode {
      table-layout:fixed;
      width:calc(100% + 4em);
      margin-left:-2em;
    }
    #github th.leftblock {
      border: 2px solid var(--dark);
      /*border: 1px solid red;*/
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.rightblock {
      border: 2px solid var(--dark);
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.centerblock {
      border: none;
      padding: 0em;
      width:1em;
    }
    #github td.leftblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em);
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.leftblock summary {
      border:1px solid #ffffbb;
    }

    #github td.rightblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em) !important;
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.rightblock summary {
      border: 1px solid #ffffbb;
    }

    #github td.centerblock {
      border: none;
      padding: 0em;
    }
    #github pre {
      overflow-x: auto !important;
    }
    #github #left1 {
      /*height:45em;*/
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }

    #github #right1 {
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }
    #github #left2 {
      /*height:45em;*/
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right2 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github #left3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github .mover {
      width:2em;
      padding: 0.05em;
      position:relative;
      right:-1.5em;
      top:0.6em;
    }
    #github #ruler {

      width:calc(50% - 1.5em);
      height:0.001em;
      margin:-0.45em 0em;
    }
    #github .btns {
      width:3em;
      border:none;
    }
  </style>
  <script>
    /*-- Load Cpp Code, Output, Build --*/
    function loadCppCode(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div style='white-space:normal; margin-left:2em;'>\
<details>\
  <summary class='darkItem' style='margin-left:-2em;'>Code Notes&nbsp;&nbsp;</summary>\
  <ol class='tight' style='margin-left:0em;'>\
    <li>\
      This code is a demonstration of classes and objects. It uses classes std::string,\n\
      std::vector<T>, Point1, and Point2&lt;T&gt; to show class anatomy and uses.\
    </li>\
    <li>\
      It illustrates stack and heap based storage.\
    </li>\
    <li>\
      showType and format functions are designed to display type and calling name of its\
      first argument and its value and size, to make program output easier to read and\
      interpret.\
    </li>\
    <li>\
      <c-s>template&lt;typename T&gt;</c-s>\n\
      <c-s>void showType(T t, const std::string &ts)</c-s> is generic on the type T.\
    </li>\
    <li>\
      Demonstrations in the body of main are relatively simple.  The setup in file\
      includes, Analysis.h and Points.h, are more intricate.  We will look at them when we\
      cover Bits_Functions.\
    </li>\
    <li>\
      You may wish to focus on the contents of main for now, and come back later after\
      looking at Bits_Functions (that doesn't exist as of 1/31/2023, but will appear soon).\
    </li>\
    <li>\
      These Bits use the Godbolt Compiler Explorer (GCE) for remote execution.  GCE provides\
      options to use one of several different compilers. This particular demo failed to\
      compile with several, but did successfully compile with x86-64 clang (thephd.dev) and\
      several others.\
    </li>\
    <li>\
      Compilation failures occurred with use of some advanced template techniques that were\
      standardized in 2020 or will be in 2023.\
    </li>\
  </ol >\
  <div style=&quot;height: 3em;&quot;>&nbsp;</div>\
</details >\
</div >\
<pre>\
\n\
/*-------------------------------------------------------------------\n\
  Cpp_Objects.cpp\n\
  - depends on Points.h to provide two user-defined point classes\n\
  - depends on Analysis.h for several display and analysis functions\n\
*/\n\
#include &lt;iostream&gt;     // std::cout\n\
#include &lt;memory&gt;       // std::unique_ptr\n\
#include &lt;vector&gt;       // vector&lt;T&gt; class\n\
#include &lt;array&gt;        // array&lt;T&gt; class\n\
#include &lt;map&gt;          // map&lt;K,V&gt; class\n\
#include &lt;set&gt;          // set&lt;T&gt; class\n\
#include &quot;Analysis.h&quot;   // Analysis functions for this demo\n\
</pre>\
<details>\
  <summary class='darkItem' style='margin-left:0em;'>Analysis.h&nbsp;&nbsp;</summary>\
<pre><div class=&quot;code&quot;>\
/*-------------------------------------------------------------------\n\
  Analysis.h\n\
  - Provides functions that analyze types, display results\n\
    and other program defined information.\n\
  - Some of this code requires complex template operations.\n\
  - You don't need to know how this code works in order to\n\
    understand the demos in this Bit. We will come back to\n\
    explore these functions in a later Bit.\n\
*/\n\
\n\
#include &lt;typeinfo&gt;     // typeid\n\
#include &lt;utility&gt;      // move()\n\
#include &lt;sstream&gt;      // stringstream\n\
#include &lt;type_traits&gt;  // is_scalar, if constexpr\n\
#include &lt;iostream&gt;     // cout\n\
#include &lt;vector&gt;       // vector\n\
\n\
/*-------------------------------------------------------------------\n\
  Analysis function declarations are provided here so that\n\
  definitions below may be placed in any order. That's\n\
  needed because C++ requires declaration before use.\n\
*/\n\
#pragma region\n\
template&lt;typename T&gt;\n\
void showType(T t, const std::string &nm, const std::string& suffix = &quot;&quot;);\n\
void showNote(const std::string& txt, const std::string& suffix = &quot;&quot;);\n\
void showOp(const std::string& opstr, const std::string& suffix = &quot;&quot;);\n\
void print(const std::string& txt = &quot;&quot;);\n\
void println(const std::string& txt = &quot;&quot;);\n\
std::string truncate(size_t N, const char* pStr);\n\
std::string indent(size_t n);\n\
template&lt;typename T&gt;\n\
std::string fold(std::vector&lt;T&gt;& v, size_t left, size_t width);\n\
template&lt;typename T&gt;\n\
std::string formatColl(\n\
  const T& t, const std::string& nm,\n\
  const std::string& suffix = &quot;&quot;, size_t left = 2, size_t width = 7\n\
);\n\
template&lt;typename T&gt;\n\
std::string formatScalar(\n\
  const T& t, const std::string& nm, \n\
  const std::string& suffix = &quot;&quot;, size_t left = 2\n\
);\n\
template&lt;typename T&gt;\n\
std::string formatString(\n\
  const T& t, const std::string& nm, const std::string& suffix,\n\
  size_t left = 2\n\
);\n\
template&lt;typename T&gt;\n\
std::string format(\n\
  const T& t, const std::string& nm, const std::string& suffix = &quot;&quot;,\n\
  size_t left = 2, size_t width = 7\n\
);\n\
#pragma endregion\n\
/*-------------------------------------------------------------------\n\
  Display and Analysis function and globals definitions\n\
---------------------------------------------------------------------\n\
*/\n\
const std::string nl = &quot;&#92;n&quot;;\n\
/*-------------------------------------------------------------------\n\
  Mutable globals are a common source of bugs.  We try not\n\
  to use them, but will use DisplayParams here to control how\n\
  the insertion operator sends instances to standard output.\n\
*/\n\
struct displayParams {\n\
  size_t left = 2;    // number of spaces to indent\n\
  size_t width = 7;   // width of display row\n\
  size_t trunc = 40;  // replace text after trunc with ...\n\
} DisplayParams;      // global object\n\
\n\
/*-----------------------------------------------\n\
  Overload operator&lt;&lt; required for \n\
  showType(std::vector&lt;T&gt; v, const std::vector&lt;T&gt;& nm) \n\
*/\n\
template&lt;typename T&gt;\n\
std::ostream& operator&lt;&lt;(std::ostream& out, std::vector&lt;T&gt;& v) {\n\
  out &lt;&lt; format(v, &quot;vector&lt;T&gt;&quot;, &quot;&quot;, DisplayParams.left, DisplayParams.width);\n\
  return out;\n\
}\n\
/*-----------------------------------------------\n\
  Display calling name, static class, and size\n\
*/\n\
template&lt;typename T&gt;\n\
void showType(T t, const std::string &callname, const std::string& suffix) {\n\
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; callname;          // show name at call site\n\
  std::cout &lt;&lt; &quot; type: &quot; \n\
            &lt;&lt; truncate(DisplayParams.trunc,typeid(t).name());  // show type\n\
  std::cout &lt;&lt; &quot;&#92;n  size:  &quot; &lt;&lt; sizeof(t);  // show size on stack\n\
  std::cout &lt;&lt; suffix;\n\
}\n\
/*-----------------------------------------------\n\
  Display emphasized text\n\
*/\n\
inline void showNote(const std::string& txt, const std::string& suffix) {\n\
  print(&quot;--------------------------------------------------&quot;);\n\
  print(&quot;  &quot; + txt);\n\
  print(&quot;--------------------------------------------------&quot;);\n\
  std::cout &lt;&lt; suffix;\n\
}\n\
/*-----------------------------------------------\n\
  Display emphasized line\n\
*/\n\
inline void showOp(const std::string& opstr, const std::string& suffix) {\n\
  std::cout &lt;&lt; &quot;&#92;n  --- &quot; &lt;&lt; opstr &lt;&lt; &quot; ---&quot; &lt;&lt; suffix;\n\
}\n\
/*-----------------------------------------------\n\
  Helper function for formatting output\n\
  - truncates line to N chars and adds ellipsis\n\
*/\n\
inline std::string truncate(size_t N, const char* pStr) {\n\
  std::string temp(pStr);\n\
  if(temp.length() &gt; N) {\n\
    temp.resize(N);\n\
    return temp + &quot;...&quot;;\n\
  }\n\
  return temp;\n\
}\n\
/*-----------------------------------------------\n\
  Helper function for formatting output\n\
  - generates string of n blanks to offset text\n\
*/\n\
inline std::string indent(size_t n) {\n\
  return std::string(n, ' ');\n\
}\n\
/*-----------------------------------------------\n\
  Helper function for formatting output\n\
  - folds lines after width elements\n\
*/\n\
template&lt;typename T&gt;\n\
std::string fold(std::vector&lt;T&gt;& v, size_t left, size_t width) {\n\
  std::stringstream out(&quot;&#92;n&quot;);\n\
  out &lt;&lt; indent(left);\n\
  for(int i=0; i&lt;v.size(); ++i) {\n\
    if((i % width) == 0 && i != 0 && i != width - 1) {\n\
      out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left);\n\
    }\n\
    if(i &lt; v.size() - 1) {\n\
      out &lt;&lt; v[i] &lt;&lt; &quot;, &quot;;\n\
    }\n\
    else {\n\
      out &lt;&lt; v[i] &lt;&lt; &quot;&#92;n&quot;;\n\
      break;\n\
    }\n\
  }\n\
  return out.str();\n\
}\n\
/*-----------------------------------------------\n\
  Helper function for formatColl\n\
  - defines out &lt;&lt; std::pair&lt;K,V&gt;\n\
  - used in formatColl for associative containers\n\
*/\n\
template&lt;typename K, typename V&gt;\n\
std::stringstream& operator&lt;&lt;(\n\
  std::stringstream& out, const std::pair&lt;K,V&gt;& p\n\
) {\n\
  out &lt;&lt; &quot;{&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot;}&quot;;\n\
  return out;\n\
}\n\
/*-----------------------------------------------\n\
  Format output for Collection types\n\
  - any type with begin() and end() like\n\
    all the STL containers.\n\
*/\n\
template&lt;typename Coll&gt;\n\
std::string formatColl(\n\
  const Coll& c, const std::string& nm, const std::string& suffix,\n\
  size_t left, size_t width\n\
) {\n\
  std::stringstream out;\n\
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: {&#92;n&quot; &lt;&lt; indent(left + 2);\n\
  size_t i = 0;\n\
  for(const Coll::value_type& elem : c) {\n\
    if((i % width) == 0 && i != 0 && i != width - 1) {\n\
      out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left + 2);\n\
    }\n\
    if(i &lt; c.size() - 1) {\n\
      out &lt;&lt; elem &lt;&lt; &quot;, &quot;;\n\
    }\n\
    else {\n\
      out &lt;&lt; elem &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; &quot;}&quot; &lt;&lt; suffix;\n\
      break;\n\
    }\n\
    ++i;\n\
  }\n\
  return out.str();\n\
}\n\
/*-----------------------------------------------\n\
  Format output for scalar types like primitives\n\
*/\n\
template&lt;typename T&gt;\n\
std::string formatScalar(\n\
  const T& t, const std::string& nm, const std::string& suffix,\n\
  size_t left\n\
) {\n\
  std::stringstream out;\n\
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: &quot; &lt;&lt; t &lt;&lt; suffix;\n\
  return out.str();\n\
}\n\
/*-----------------------------------------------\n\
  Format output for strings\n\
  - indent and embed in quotation marks\n\
*/\n\
template&lt;typename T&gt;\n\
std::string formatString(\n\
  const T& t, const std::string& nm, const std::string& suffix,\n\
  size_t left\n\
) {\n\
  std::stringstream out;\n\
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(left) &lt;&lt; nm &lt;&lt; &quot;: &#92;&quot;&quot; &lt;&lt; t &lt;&lt; &quot;&#92;&quot;&quot; &lt;&lt; suffix;\n\
  return out.str();\n\
}\n\
/*-----------------------------------------------\n\
  Defines is_iterable trait\n\
  - detects STL containers and user-defined types\n\
    that provide iteration\n\
https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\
*/\n\
template &lt;typename T, typename = void&gt;\n\
struct is_iterable : std::false_type {};\n\
\n\
// this gets used only when we can call \n\
// std::begin() and std::end() on that type\n\
template &lt;typename T&gt;\n\
struct is_iterable&lt;\n\
  T, \n\
  std::void_t\n\
    &lt;decltype(std::begin(std::declval&lt;T&gt;())),\n\
     decltype(std::end(std::declval&lt;T&gt;()))&gt;\n\
&gt; : std::true_type {};\n\
\n\
template &lt;typename T&gt;\n\
constexpr bool is_iterable_v = is_iterable&lt;T&gt;::value;\n\
\n\
/*-----------------------------------------------\n\
  Displays almost everything.\n\
  - strings work better with formatString(...)\n\
  https://www.cppstories.com/2018/03/ifconstexpr/\n\
*/\n\
template&lt;typename T&gt;\n\
std::string format(\n\
  const T& t, const std::string& nm, const std::string& suffix,\n\
  size_t left, size_t width\n\
) {\n\
  if constexpr(is_iterable_v&lt;T&gt;) {  // decision at compile-time\n\
    return formatColl(t, nm, suffix, left, width);\n\
  }\n\
  else {\n\
    return formatScalar(t, nm, suffix, left);\n\
  }\n\
}\n\
/*-----------------------------------------------\n\
  Display text after newline and indentation\n\
*/\n\
inline void print(const std::string& txt) {\n\
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt;\n\
}\n\
/*-----------------------------------------------\n\
  Display text after newline and indentation\n\
  - provides trailing newline\n\
*/\n\
inline void println(const std::string& txt) {\n\
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; txt &lt;&lt; &quot;&#92;n&quot;;\n\
}\n\
/*-----------------------------------------------------------------*/\n\
/*--- End of Analysis.h -------------------------------------------*/\n\
/*-----------------------------------------------------------------*/\n\
\n\</div></pre>\
      </details>\
<pre>\
#include &quot;Points.h&quot;     // Two Point class declarations\n\
</pre>\
<details>\
  <summary class='darkItem' style='margin-left:0em;'>Points.h&nbsp;&nbsp;</summary>\
<pre><div class=&quot;code&quot;>\
\n\
/*-------------------------------------------------------------------\n\
  Points.h defines two point classes\n\
  - Point1 represents points with three integer coordinates\n\
  - Point2&lt;T&gt; represents points with many coordinates of\n\
    unspecified type T\n\
*/\n\
#include &lt;iostream&gt;\n\
#include &lt;vector&gt;\n\
/*-------------------------------------------------------------------\n\
  Point1 class represents a point in an integral 3-Dimensional\n\
  lattice. Simple enough for illustration, but still useful.\n\
\n\
  It declares all of the special class methods, most with\n\
  default qualifiers to indicate that the compiler will\n\
  generate them as needed.\n\
\n\
  The word ctor is an abbreviation of constructor and dtor\n\
  an abbreviation for destructor.\n\
*/\n\
class Point1 {\n\
public:\n\
  Point1();                                       // default ctor\n\
  Point1(const Point1& pt) = default;             // copy ctor\n\
  Point1(Point1&& pt) = default;                  // move ctor\n\
  Point1& operator=(const Point1& pt) = default;  // copy assignment\n\
  Point1& operator=(Point1&& pt) = default;       // move assignment\n\
  ~Point1() = default;                            // dtor\n\
  void show();\n\
  int& xCoor() { return x; }\n\
  int& yCoor() { return y; }\n\
  int& zCoor() { return z; }\n\
private:\n\
  int x;\n\
  int y;\n\
  int z;\n\
};\n\
\n\
Point1::Point1() {\n\
  x = y = z = 0;\n\
}\n\
void Point1::show() {\n\
  std::cout &lt;&lt; &quot;&#92;n  &quot; &lt;&lt; &quot;Point1&quot;;\n\
  std::cout &lt;&lt; &quot; { &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; &quot; }&quot;;\n\
}\n\
/* required for showType(T t, const std::string& nm) */\n\
std::ostream& operator&lt;&lt;(std::ostream& out, Point1& t1) {\n\
  out &lt;&lt; &quot;Point1&quot;;\n\
  out &lt;&lt; &quot; { &quot; &lt;&lt; t1.xCoor() &lt;&lt; &quot;, &quot; &lt;&lt; t1.yCoor() &lt;&lt; &quot;, &quot; \n\
               &lt;&lt; t1.zCoor() &lt;&lt; &quot; }&quot;;\n\
  return out;\n\
}\n\
\n\
/*-------------------------------------------------------------------\n\
  Point2&lt;T&gt; class represents a point in an n-Dimensional hyperspace.\n\
  It is more flexible than Point1 by using a template to support\n\
  a variety of coordinate types, and by using a vector to hold\n\
  any finite number of coordinates.\n\
\n\
  Its default constructor Point2() is declared delete so it won't\n\
  be provided here nor generated by the compiler.\n\
*/\n\
template&lt;typename T&gt;\n\
class Point2 {\n\
public:\n\
  Point2() = delete;                              // default ctor\n\
  Point2(size_t N);\n\
  Point2(const Point2& pt) = default;             // copy ctor\n\
  Point2(Point2&& pt) = default;                  // move ctor\n\
  Point2& operator=(const Point2& pt) = default;  // copy assignment\n\
  Point2& operator=(Point2&& pt) = default;       // move assignemnt\n\
  ~Point2() = default;                            // dtor\n\
  void show();\n\
  std::vector&lt;T&gt;& coords() { return coord; }\n\
  size_t& left() { return _left; }\n\
  size_t& width() { return _width; }\n\
private:\n\
  std::vector&lt;T&gt; coord;\n\
  size_t _left = 2;   // default display indent\n\
  size_t _width = 7;  // default display row width\n\
};\n\
/*-----------------------------------------------\n\
  Point2&lt;T&gt; constructor with size \n\
*/\n\
template&lt;typename T&gt;\n\
Point2&lt;T&gt;::Point2(size_t N) {\n\
  for(size_t i=0; i&lt;N; i++) {\n\
    coord.push_back(T{0});\n\
  }\n\
}\n\
/*-----------------------------------------------\n\
  Pointt2&lt;T&gt; display function \n\
*/\n\
template&lt;typename T&gt;\n\
void Point2&lt;T&gt;::show() {\n\
  std::cout &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(_left) &lt;&lt; &quot;Point2&lt;T&gt;&quot;;\n\
  std::cout &lt;&lt; &quot; {&#92;n&quot;;\n\
  std::cout &lt;&lt; fold(coord, _left + 2, _width);\n\
  std::cout &lt;&lt; indent(_left) &lt;&lt; &quot;}&quot;;\n\
}\n\
/*-----------------------------------------------\n\
  Overload operator&lt;&lt; required for \n\
  showType(Point2&lt;T&gt; t, const std::string& nm) \n\
*/\n\
template&lt;typename T&gt;\n\
std::ostream& operator&lt;&lt;(std::ostream& out, Point2&lt;T&gt;& t2) {\n\
  out &lt;&lt; &quot;&#92;n&quot; &lt;&lt; indent(t2.left()) &lt;&lt; &quot;Point2&lt;T&gt;&quot;;\n\
  out &lt;&lt; &quot; {&#92;n&quot;;\n\
  out &lt;&lt; fold(t2.coords(), t2.left() + 2, t2.width());\n\
  out &lt;&lt; indent(t2.left()) &lt;&lt; &quot;}&quot;;\n\
  return out;\n\
/*-----------------------------------------------------------------*/\n\
/*--- End of Points.h ---------------------------------------------*/\n\
/*-----------------------------------------------------------------*/\n\
}\n\</div></pre>\
      </details>\
<pre>\
/*\n\
  This demo uses the std::string and std::vector&lt;T&gt; classes\n\
  and two user defined classes, Point1 and Point2&lt;T&gt;, to \n\
  illustrate how objects are defined and instantiated.\n\
\n\
  Operations:\n\
    All the classes discussed here provide operations for:\n\
      T t2 = t1          // copy construction\n\
      T t3 = temporary   // move construction\n\
      t1 = t2            // copy assignment\n\
      t3 = temporary     // move assignment\n\
\n\
    All instances return their resources when they go out of\n\
    scope by implicitly calling their destructor.\n\
    Primitive types can all be copied.\n\
\n\
    Most library and user-defined types can be copied, moved, \n\
    and deleted by providing member constructors and destructor.\n\
    Often compiler generation works well, but for classes with \n\
    pointer members developers must provide them.\n\
\n\
  Processing:\n\
    All types are static, operations run as native code, and no \n\
    garbage collection is needed. Resources are returned at end \n\
    of their declaration scope.\n\
*/\n\
#pragma warning(disable: 4984)  // warns about C++17 extension\n\
\n\
/*-----------------------------------------------\n\
  alias type name \n\
  - pU&lt;T&gt; is the same type as std::unique_ptr&lt;T&gt; \n\
  - this just provides a shorter name\n\
*/\n\
template&lt;typename T&gt;\n\
using pU = std::unique_ptr&lt;T&gt;;\n\
\n\
/*-------------------------------------------------------------------\n\
  Demonstration starts here \n\
*/\n\
int main() {\n\
\n\
    print(&quot;Demonstrate C++ Objects&#92;n&quot;);\n\
\n\
    showNote(&quot;primitive C++ types size_t and double&quot;);\n\
    size_t st = 42;\n\
    std::cout &lt;&lt; &quot;&#92;n  size_t st = &quot; &lt;&lt; st;\n\
    showType(st, &quot;st&quot;, nl);\n\
\n\
    double d = 3.1415927;\n\
    std::cout &lt;&lt; &quot;&#92;n  double d = &quot; &lt;&lt; d;\n\
    showType(d, &quot;ld&quot;, nl);\n\
\n\
    showNote(&quot;std library types string and vector&lt;T&gt;&quot;);\n\
    /* create and display std::string object */\n\
    auto str = std::string(&quot;&#92;&quot;Wile E. Coyote&#92;&quot;&quot;);\n\
    auto out = std::string(&quot;contents of str = &quot;) + str;\n\
    print(out);\n\
    print(&quot;--- showType(str, &#92;&quot;str&#92;&quot;); ---&quot;);\n\
    showType(str, &quot;str&quot;, nl);\n\
\n\
    /* create and display std::vector&lt;double&gt; */\n\
    auto vec = std::vector&lt;double&gt;{ 3.5, 3, 2.5, 2 };\n\
    std::cout &lt;&lt; vec;\n\
    showOp(&quot;showType(vec, &#92;&quot;vec&#92;&quot;);&quot;);\n\
    showType(vec, &quot;vec&quot;, nl);\n\
\n\
    #pragma region\n\
    showOp(&quot;vec[2] = -2.5;&quot;);\n\
    #pragma endregion\n\
    vec[2] = -2.5;\n\
    std::cout &lt;&lt; &quot;&#92;n  vec:&quot; &lt;&lt; vec;\n\
\n\
    #pragma region\n\
    showOp(&quot;auto vec2 = vec : copy construction&quot;);\n\
    #pragma endregion\n\
    /* copy construction */\n\
    auto vec2 = vec;\n\
    std::cout &lt;&lt; &quot;&#92;n  vec2:&quot; &lt;&lt; vec2;\n\
    \n\
    #pragma region\n\
    showOp(&quot;vec2[0] = 42;&quot;);\n\
    #pragma endregion\n\
    vec2[0] = 42;\n\
    std::cout &lt;&lt; &quot;&#92;n  vec2: &quot; &lt;&lt; vec2;\n\
    std::cout &lt;&lt; &quot;&#92;n  vec: &quot; &lt;&lt; vec;\n\
\n\
    showNote(\n\
      &quot;Copy construction, auto vec2 = vec, creates&#92;n    &quot; \n\
      &quot;independent instance. So changing target vec2&#92;n    &quot;\n\
      &quot;has no affect on source vec.&quot;, nl\n\
    );\n\
\n\
    showNote(&quot;user-defined types Point1 and Point2&lt;T&gt;&quot;);\n\
    Point1 p1;\n\
    p1.show();\n\
    p1.xCoor() = 42;\n\
    p1.zCoor() = -3;\n\
    p1.show();\n\
    print();\n\
    \n\
    print(&quot;--- showType(p1, &#92;&quot;p1&#92;&quot;, nl) ---&quot;);\n\
    showType(p1, &quot;p1&quot;, nl);\n\
    std::cout &lt;&lt; &quot;  p1.xCoor() returns value &quot; \n\
              &lt;&lt; p1.xCoor() &lt;&lt; &quot;&#92;n&quot;;\n\
\n\
    Point2&lt;double&gt; p2(5);\n\
    p2.show();\n\
\n\
    #pragma region\n\
    showNote(\n\
      &quot;p2.coords() = std::vector&lt;double&gt;&#92;n    &quot;\n\
      &quot;{ 1.0, -2.0, 3.0, 4.5, -42.0 }&quot;\n\
    );\n\
    #pragma endregion\n\
    p2.coords() = std::vector&lt;double&gt;{1.0, -2.0, 3.0, 4.5, -42.0 };\n\
    p2.show();\n\
    #pragma region\n\
    showOp(&quot;showType(p2, &#92;&quot;p2&#92;&quot;, nl);&quot;);\n\
    #pragma endregion\n\
    showType(p2, &quot;p2&quot;, nl);\n\
    std::cout &lt;&lt; &quot;  p2.coords()[2] = &quot; &lt;&lt; p2.coords()[2] &lt;&lt; &quot;&#92;n&quot;;\n\
    \n\
    showNote(&quot;heap-based string instance&quot;);\n\
  \n\
    /* standard library type std::string */\n\
    /* uses alias pU for std::unique_ptr, defined above */\n\
    #pragma region\n\
    showOp(\n\
      &quot;pU&lt;std::string&gt; &quot;\n\
      &quot;pStr(new std::string(&#92;&quot;&#92;&#92;&#92;&quot;Road Runner&#92;&#92;&#92;&quot;&#92;&quot;)&quot;\n\
    );\n\
    #pragma endregion\n\
    pU&lt;std::string&gt; pStr(new std::string(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;));\n\
    std::cout &lt;&lt; &quot;&#92;n  pStr contents = &quot; &lt;&lt; *pStr &lt;&lt; &quot;&#92;n&quot;;\n\
    \n\
    #pragma region\n\
    showOp(&quot;showType(*pStr, &#92;&quot;*pStr&#92;&quot;)&quot;);\n\
    #pragma endregion\n\
    showType(*pStr, &quot;*pStr&quot;, nl);\n\
\n\
    /* std::unique_ptr&lt;T&gt; cannot be copied but can be moved */\n\
    #pragma region\n\
    showOp(&quot;showType(move(pStr), &#92;&quot;pStr&#92;&quot;)&quot;);\n\
    #pragma endregion\n\
    showType(move(pStr), &quot;pStr&quot;, nl);\n\
\n\
    /* standard library type std::vector&lt;T&gt; */\n\
    showNote(&quot;heap-based vector instance&quot;);\n\
    #pragma region\n\
    showOp(\n\
      &quot;pU&lt;std::vector&lt;double&gt;&gt;&#92;n &quot;\n\
      &quot;     pVec(new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 });&quot;\n\
    );\n\
    #pragma endregion\n\
    pU&lt;std::vector&lt;double&gt;&gt; pVec(\n\
      new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }\n\
    );\n\
    std::cout &lt;&lt; &quot;&#92;n  *pVec = &quot; &lt;&lt; *pVec;\n\
    showType(*pVec, &quot;*pVec&quot;, nl);\n\
    std::cout &lt;&lt; &quot;&#92;n  pVec = &quot; &lt;&lt; pVec;\n\
    showType(move(pVec), &quot;move(pVec)&quot;, nl);\n\
\n\
    /* custom point types */\n\
    showNote(&quot;heap-based Point1 instance&quot;);\n\
    #pragma region\n\
    showOp(&quot;pU&lt;Point1&gt; pPoint1(new Point1())&quot;);\n\
    #pragma endregion\n\
    pU&lt;Point1&gt; pPoint1(new Point1());\n\
    pPoint1-&gt;show();\n\
    pPoint1-&gt;xCoor() = 1;\n\
    pPoint1-&gt;yCoor() = 2;\n\
    pPoint1-&gt;zCoor() = -3;\n\
    pPoint1-&gt;show();\n\
\n\
    std::cout &lt;&lt; &quot;&#92;n  pPoint1-&gt;zCoor() = &quot; &lt;&lt; pPoint1-&gt;zCoor();\n\
    #pragma region\n\
    showOp(&quot;showType(*pPoint1, &#92;&quot;*pPoint1&#92;&quot;);&quot;);\n\
    #pragma endregion\n\
    showType(*pPoint1, &quot;*pPoint1&quot;);\n\
    #pragma region\n\
    showOp(&quot;showType(std::move(pPoint1), &#92;&quot;pPoint1&#92;&quot;);&quot;);\n\
    #pragma endregion\n\
    showType(std::move(pPoint1), &quot;pPoint1&quot;, nl);\n\
    /* pPoint1 moved, so now invalid */\n\
\n\
    showNote(&quot;heap-based Point2&lt;T&gt; instance&quot;);\n\
    \n\
    #pragma region\n\
    showOp(&quot;pU&lt;Point2&lt;double&gt;&gt; pPoint2(new Point2&lt;double&gt;(4))&quot;);\n\
    #pragma endregion\n\
    pU&lt;Point2&lt;double&gt;&gt; pPoint2(new Point2&lt;double&gt;(4));\n\
    pPoint2-&gt;show();\n\
    \n\
    #pragma region\n\
    showOp(\n\
      &quot;pPoint2-&gt;coords() = &#92;n&quot;\n\
      &quot;      std::vector&lt;double&gt;{ 1.0, 3.5, -2.0, 42.0 };&quot;\n\
    );\n\
    #pragma endregion\n\
    pPoint2-&gt;coords() = std::vector&lt;double&gt;{ 1.0, 3.5, -2.0, 42.0 };\n\
    pPoint2-&gt;show();\n\
    std::cout &lt;&lt; &quot;&#92;n  value of pPoint2-&gt;coords()[1] is &quot; \n\
              &lt;&lt; pPoint2-&gt;coords()[1];\n\
    \n\
    #pragma region\n\
    showOp(&quot;showType(*pPoint2, &#92;&quot;*pPoint2&#92;&quot;);&quot;);\n\
    #pragma endregion\n\
    showType(*pPoint2, &quot;*pPoint2&quot;);\n\
    \n\
    #pragma region\n\
    showOp(&quot;showType(std::move(pPoint2), &#92;&quot;pPoint2&#92;&quot;);&quot;);\n\
    #pragma endregion\n\
    showType(std::move(pPoint2), &quot;pPoint2&quot;);\n\
    /* pPoint2 moved, so now invalid */\n\
    print();\n\
\n\
    showNote(&quot;Test and demonstrate formatting functions&quot;);\n\
    \n\
    #pragma region\n\
    showOp(&quot;demonstrate Point2 show()&quot;);\n\
    #pragma endregion\n\
    print(&quot;default indent = 4 and width = 7:&quot;);\n\
    Point2&lt;int&gt; p2a(15);\n\
    p2a.show();\n\
    size_t saveLeft = p2a.left();\n\
    size_t saveWidth = p2a.width();\n\
    print(&quot;&#92;n  indent = 6, width = 12:&quot;);\n\
    p2a.left() = 6;\n\
    p2a.width() = 12;\n\
    p2a.show();\n\
\n\
    #pragma region\n\
    showOp(\n\
      &quot;demonstrate operator&lt;&lt; overload for Point2 ---&quot;\n\
    );\n\
    #pragma endregion\n\
    p2a.left() = saveLeft;\n\
    p2a.width() = saveWidth;\n\
    print(&quot;default indent = 4 and width = 7:&quot;);\n\
    std::cout &lt;&lt; p2a;\n\
    print(&quot;&#92;n  indent = 6, width = 12:&quot;);\n\
    p2a.left() = 6;\n\
    p2a.width() = 12;\n\
    std::cout &lt;&lt; p2a;\n\
\n\
    #pragma region\n\
    showOp(\n\
      &quot;demonstrate operator&lt;&lt; overload for vector&quot;\n\
    );\n\
    #pragma endregion\n\
    auto vtest = std::vector&lt;int&gt;{1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\
    print(&quot;default indent = 4 and width = 7:&quot;);\n\
    std::cout &lt;&lt; vtest;\n\
    DisplayParams.left = 2;\n\
    DisplayParams.width = 5;\n\
    print(&quot;indent = 2, width = 5:&quot;);\n\
    std::cout &lt;&lt; vtest;\n\
\n\
    std::cout &lt;&lt; formatColl(vtest, &quot;vtest&quot;, nl, 2, 5);\n\
    std::cout &lt;&lt; formatColl(vtest, &quot;vtest&quot;, nl, 4, 7);\n\
    std::cout &lt;&lt; formatColl(vtest, &quot;vtest&quot;, nl, 2, 9);\n\
    std::cout &lt;&lt; formatColl(vtest, &quot;vtest: vector&lt;int&gt;&quot;, nl, 2, 10);\n\
\n\
    std::array&lt;double, 5&gt; arrtest = { 1, 2, 3, 4.5, -3.14159 };\n\
    std::cout &lt;&lt; formatColl(arrtest, &quot;arrtest&quot;, nl, 2, 4);\n\
\n\
    std::map&lt;int, std::string&gt; amap {\n\
       {1, &quot;one&quot;}, {2, &quot;two&quot;}, {3, &quot;three&quot;} \n\
    };\n\
    std::cout &lt;&lt; formatColl(amap, &quot;amap&quot;, nl, 2, 4);\n\
\n\
    std::set&lt;std::string&gt; aset { \n\
      &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot; \n\
    };\n\
    std::cout &lt;&lt; formatColl(aset, &quot;aset&quot;, nl, 2, 4);\n\
\n\
    std::string astring = &quot;this is a string&quot;;\n\
    std::cout &lt;&lt; formatString(astring, &quot;astring&quot;, nl, 2);\n\
\n\
    double adouble { 3.1415927 };\n\
    std::cout &lt;&lt; formatScalar(adouble, &quot;adouble&quot;, nl);\n\
\n\
    showNote(&quot;Using consolidated format function&quot;, nl);\n\
    \n\
    std::cout &lt;&lt; format(adouble, &quot;adouble&quot;, nl);\n\
    std::cout &lt;&lt; format(astring, &quot;astring&quot;, nl);\n\
    std::vector&lt;double&gt; avec{ 1, 2, 3, 4.5, -3.14159 };\n\
    std::cout &lt;&lt; format(avec, &quot;avec&quot;, nl);\n\
    std::cout &lt;&lt; format(amap, &quot;amap&quot;, nl);\n\
\n\
    print(&quot;&#92;n  That's all Folks!&#92;n&#92;n&quot;);\n\
}\n\</pre>\
";
    }

    function loadCppOut(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\n\n\
   Demonstrate C++ Objects\n\
\n\
  --------------------------------------------------\n\
    primitive C++ types size_t and double\n\
  --------------------------------------------------\n\
  size_t st = 42\n\
  st type: unsigned __int64\n\
  size:  8\n\
\n\
  double d = 3.14159\n\
  ld type: double\n\
  size:  8\n\
\n\
  --------------------------------------------------\n\
    std library types string and vector&lt;T&gt;\n\
  --------------------------------------------------\n\
  contents of str = &quot;Wile E. Coyote&quot;\n\
  --- showType(str, &quot;str&quot;); ---\n\
  str type: class std::basic_string&lt;char,struct std:...\n\
  size:  40\n\
\n\
  vector&lt;T&gt;: {\n\
    3.5, 3, 2.5, 2\n\
  }\n\
  --- showType(vec, &quot;vec&quot;); ---\n\
  vec type: class std::vector&lt;double,class std::allo...\n\
  size:  32\n\
\n\
  --- vec[2] = -2.5; ---\n\
  vec:\n\
  vector&lt;T&gt;: {\n\
    3.5, 3, -2.5, 2\n\
  }\n\
  --- auto vec2 = vec : copy construction ---\n\
  vec2:\n\
  vector&lt;T&gt;: {\n\
    3.5, 3, -2.5, 2\n\
  }\n\
  --- vec2[0] = 42; ---\n\
  vec2:\n\
  vector&lt;T&gt;: {\n\
    42, 3, -2.5, 2\n\
  }\n\
  vec:\n\
  vector&lt;T&gt;: {\n\
    3.5, 3, -2.5, 2\n\
  }\n\
  --------------------------------------------------\n\
    Copy construction, auto vec2 = vec, creates\n\
    independent instance. So changing target vec2\n\
    has no affect on source vec.\n\
  --------------------------------------------------\n\
\n\
  --------------------------------------------------\n\
    user-defined types Point1 and Point2&lt;T&gt;\n\
  --------------------------------------------------\n\
  Point1 { 0, 0, 0 }\n\
  Point1 { 42, 0, -3 }\n\
\n\
  --- showType(p1, &quot;p1&quot;, nl) ---\n\
  p1 type: class Point1\n\
  size:  12\n\
  p1.xCoor() returns value 42\n\
\n\
  Point2&lt;T&gt; {\n\
    0, 0, 0, 0, 0\n\
  }\n\
  --------------------------------------------------\n\
    p2.coords() = std::vector&lt;double&gt;\n\
    { 1.0, -2.0, 3.0, 4.5, -42.0 }\n\
  --------------------------------------------------\n\
  Point2&lt;T&gt; {\n\
    1, -2, 3, 4.5, -42\n\
  }\n\
  --- showType(p2, &quot;p2&quot;, nl); ---\n\
  p2 type: class Point2&lt;double&gt;\n\
  size:  48\n\
  p2.coords()[2] = 3\n\
\n\
  --------------------------------------------------\n\
    heap-based string instance\n\
  --------------------------------------------------\n\
  --- pU&lt;std::string&gt; pStr(new std::string(&quot;&#92;&quot;Road Runner&#92;&quot;&quot;) ---  \n\
  pStr contents = &quot;Road Runner&quot;\n\
\n\
  --- showType(*pStr, &quot;*pStr&quot;) ---\n\
  *pStr type: class std::basic_string&lt;char,struct std:...\n\
  size:  40\n\
\n\
  --- showType(move(pStr), &quot;pStr&quot;) ---\n\
  pStr type: class std::unique_ptr&lt;class std::basic_s...\n\
  size:  8\n\
\n\
  --------------------------------------------------\n\
    heap-based vector instance\n\
  --------------------------------------------------\n\
  --- pU&lt;std::vector&lt;double&gt;&gt;\n\
      pVec(new std::vector&lt;double&gt;{ 1.5, 2.5, 3.5 }); ---\n\
  *pVec =\n\
  vector&lt;T&gt;: {\n\
    1.5, 2.5, 3.5\n\
  }\n\
  *pVec type: class std::vector&lt;double,class std::allo...\n\
  size:  32\n\
\n\
  pVec = 000001948FAB3200\n\
  move(pVec) type: class std::unique_ptr&lt;class std::vector&lt;...     \n\
  size:  8\n\
\n\
  --------------------------------------------------\n\
    heap-based Point1 instance\n\
  --------------------------------------------------\n\
  --- pU&lt;Point1&gt; pPoint1(new Point1()) ---\n\
  Point1 { 0, 0, 0 }\n\
  Point1 { 1, 2, -3 }\n\
  pPoint1-&gt;zCoor() = -3\n\
  --- showType(*pPoint1, &quot;*pPoint1&quot;); ---\n\
  *pPoint1 type: class Point1\n\
  size:  12\n\
  --- showType(std::move(pPoint1), &quot;pPoint1&quot;); ---\n\
  pPoint1 type: class std::unique_ptr&lt;class Point1,struc...        \n\
  size:  8\n\
\n\
  --------------------------------------------------\n\
    heap-based Point2&lt;T&gt; instance\n\
  --------------------------------------------------\n\
  --- pU&lt;Point2&lt;double&gt;&gt; pPoint2(new Point2&lt;double&gt;(4)) ---        \n\
  Point2&lt;T&gt; {\n\
    0, 0, 0, 0\n\
  }\n\
  --- pPoint2-&gt;coords() =\n\
      std::vector&lt;double&gt;{ 1.0, 3.5, -2.0, 42.0 }; ---\n\
  Point2&lt;T&gt; {\n\
    1, 3.5, -2, 42\n\
  }\n\
  value of pPoint2-&gt;coords()[1] is 3.5\n\
  --- showType(*pPoint2, &quot;*pPoint2&quot;); ---\n\
  *pPoint2 type: class Point2&lt;double&gt;\n\
  size:  48\n\
  --- showType(std::move(pPoint2), &quot;pPoint2&quot;); ---\n\
  pPoint2 type: class std::unique_ptr&lt;class Point2&lt;doubl...        \n\
  size:  8\n\
\n\
  --------------------------------------------------\n\
    Test and demonstrate formatting functions\n\
  --------------------------------------------------\n\
  --- demonstrate Point2 show() ---\n\
  default indent = 4 and width = 7:\n\
  Point2&lt;T&gt; {\n\
    0, 0, 0, 0, 0, 0, 0,\n\
    0, 0, 0, 0, 0, 0, 0,\n\
    0\n\
  }\n\
\n\
  indent = 6, width = 12:\n\
      Point2&lt;T&gt; {\n\
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\
        0, 0, 0\n\
      }\n\
  --- demonstrate operator&lt;&lt; overload for Point2 --- ---\n\
  default indent = 4 and width = 7:\n\
  Point2&lt;T&gt; {\n\
    0, 0, 0, 0, 0, 0, 0,\n\
    0, 0, 0, 0, 0, 0, 0,\n\
    0\n\
  }\n\
\n\
  indent = 6, width = 12:\n\
      Point2&lt;T&gt; {\n\
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\
        0, 0, 0\n\
      }\n\
  --- demonstrate operator&lt;&lt; overload for vector ---\n\
  default indent = 4 and width = 7:\n\
  vector&lt;T&gt;: {\n\
    1, 2, 3, 4, 5, 6, 7,\n\
    8, 9\n\
  }\n\
  indent = 2, width = 5:\n\
  vector&lt;T&gt;: {\n\
    1, 2, 3, 4, 5,\n\
    6, 7, 8, 9\n\
  }\n\
  vtest: {\n\
    1, 2, 3, 4, 5,\n\
    6, 7, 8, 9\n\
  }\n\
\n\
    vtest: {\n\
      1, 2, 3, 4, 5, 6, 7,\n\
      8, 9\n\
    }\n\
\n\
  vtest: {\n\
    1, 2, 3, 4, 5, 6, 7, 8, 9\n\
  }\n\
\n\
  vtest: vector&lt;int&gt;: {\n\
    1, 2, 3, 4, 5, 6, 7, 8, 9\n\
  }\n\
\n\
  arrtest: {\n\
    1, 2, 3, 4.5,\n\
    -3.14159\n\
  }\n\
\n\
  amap: {\n\
    {1, one}, {2, two}, {3, three}\n\
  }\n\
\n\
  aset: {\n\
    five, four, one, three,\n\
    two\n\
  }\n\
\n\
  astring: &quot;this is a string&quot;\n\
\n\
  adouble: 3.14159\n\
\n\
  --------------------------------------------------\n\
    Using consolidated format function\n\
  --------------------------------------------------\n\
\n\
  adouble: 3.14159\n\
\n\
  astring: {\n\
    t, h, i, s,  , i, s,\n\
     , a,  , s, t, r, i,\n\
    n, g\n\
  }\n\
\n\
  avec: {\n\
    1, 2, 3, 4.5, -3.14159\n\
  }\n\
\n\
  amap: {\n\
    {1, one}, {2, two}, {3, three}\n\
  }\n\
\n\
\n\
  That's all Folks!\n\
\n\
\n\
\n\\n\</pre>";
    }

    function loadCppBld(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div class='code'>\
<pre style='overflow-x:auto;'>\n\
</pre>\
</div>\
";
    }
  </script>

  <script>
    /*-- Load C# Code, Output, Build --*/
    function loadCsCode(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div>\
<div style='white-space:normal; margin-left:2em;'>\
<details>\
  <summary class='darkItem' style='margin-left:-2em;'>Code Notes&nbsp;&nbsp;</summary>\
  <ol class='tight' style='margin-left:0em;'>\
    <li>\
      This code is a demonstration of the creation and use of instances of C# Value\n\
      and Reference types.\
    </li>\
    <li>\
      All implementation code is required to be placed inline within the class method\
      declarations.\
    </li>\
    <li>\
      This code explores instance sharing and copy on write.\
    </li>\
    <li>\
      show function is designed to display type and calling name of its\
      first argument and its value and size.\
    </li>\
    <li>\
      Some of the analysis methods require reflection. The method\
      int GetManagedSize(Type type), at the bottom of the code listing, requires\
      advanced reflection techniques.\
    </li>\
  </ol >\
  <div style=&quot;height: 3em;&quot;>&nbsp;</div>\
</details >\
</div >\
</div>\
<pre>\n\
/*-------------------------------------------------------------------\n\
  Cs_Objects::Cs_Objects.cs\n\
  - Demonstrates creation and assignment of objects as well as a few\n\
    peeks at other operations on objects.\n\
*/\n\
using System;\n\
using System.Collections;\n\
using System.Collections.Generic;   // IEnumerable&lt;T&gt;, List&lt;T&gt;\n\
using System.Linq;                  // IEnumerable&lt;T&gt;.ToArray\n\
using System.Text;                  // StringBuilder\n\
using Points;                       // defined in Points.cs\n\
</pre>\
<details>\
  <summary class='darkItem' style='margin-left:0em;'>Points.cs&nbsp;&nbsp;</summary>\
<pre><div class=&quot;code&quot;>\
/*-------------------------------------------------------------------\n\
  Points.cs\n\
  - provides definitions for user-defined classes\n\
    Point1 and Point2&lt;T&gt;\n\
*/\n\
\n\
using System.Collections;\n\
using System.Collections.Generic;   // IEnumerable&lt;T&gt;, List&lt;T&gt;\n\
using Analysis;\n\
\n\
namespace Points {\n\
  /*-----------------------------------------------------------------------\n\
    Point1 is a basic point class with three integer coordinates.\n\
    - It is a reference type because it's instances are created\n\
      from a class\n\
    - That affects the way assignments work - see demo near the\n\
      end of main.\n\
  */\n\
  public class Point1 : Analysis.IShow  // reference type with value type members\n\
  { \n\
    public Point1() {\n\
      /* \n\
        doesn't need to do anything because its properties have\n\
        default values\n\
      */\n\
    }\n\
    public int x { get; set; } = 0;\n\
    public int y { get; set; } = 0;\n\
    public int z { get; set; } = 0;\n\
    public int Length { get; } = 3;\n\
    public int Width { get; set; } = 3;\n\
    public int Left { get; set; } = 2;\n\
    /* translates IShow::show to needs of class */\n\
    public void Show(string name) {\n\
      PrintSelf(name);\n\
    }\n\
    /* Display Point1 structure and state */\n\
    public void PrintSelf(string name) {\n\
      string ofstr = Display.Indent(Left);\n\
      Console.WriteLine(\n\
        &quot;{4}{0}  {{ x:{1}, y:{2}, z:{3} }}&quot;, name, x, y, z, ofstr\n\
      );\n\
    }\n\
  }\n\
  /*----------------------------------------------------------------------\n\
    Point2&lt;T&gt; is a generalization of Point1 \n\
     - holds any finite number of generic coordinates\n\
     - coordinates are held in a List&lt;T&gt;\n\
     - implements IEnumerable&lt;T&gt; so it can be indexed and iterated\n\
     - it is a reference type because it is implemented with a class.\n\
       its List&lt;T&gt; is also a reference type\n\
  */\n\
  public class Point2&lt;T&gt; : IEnumerable&lt;T&gt; , Analysis.IShow {\n\
    /*--------------------------------------------------------------------\n\
      Constructs a point with N coordinates each with default value\n\
    */\n\
    public Point2(int N) {\n\
      coor = new List&lt;T&gt;();\n\
      for(int i = 0; i&lt;N; ++i) {\n\
        T? test = default(T);\n\
        if(test != null) {\n\
          coor.Add(test);\n\
        }\n\
      }\n\
    }\n\
    /* translates IShow::show() for needs of Point2 class */\n\
    public void Show(string name) {\n\
      PrintSelf(name);\n\
    }\n\
    /*\n\
      Displays structure and state of N-dimensional point.\n\
      - state is a set of rows of coordinate data\n\
      - property Width specifies number of elements in each row\n\
      - property Left specifies offset of row from terminal Left edge\n\
    */\n\
    public void PrintSelf(string name) {\n\
      Console.Write(Display.Indent(Left));\n\
      Console.Write(&quot;{0} {{&#92;n{1}&quot;, name, Display.Indent(Left + 2));\n\
      for(int i=0; i&lt;coor.Count; ++i) {\n\
        Console.Write(&quot;{0}&quot;, coor[i]);\n\
        if(i &lt; coor.Count - 1) {\n\
          Display.print(&quot;, &quot;);\n\
        }\n\
        if((i+1) % Width == 0 && i != coor.Count - 1) {\n\
          Console.Write(&quot;&#92;n&quot;);\n\
          Console.Write(Display.Indent(Left + 2));\n\
        }\n\
      }\n\
      Console.Write(&quot;&#92;n{0}&quot;, Display.Indent(Left));\n\
      Console.WriteLine(&quot;}&quot;);\n\
    }\n\
    /* The three functions below support indexing and iterating */\n\
    public T this[int index] {\n\
      get { return coor[index]; }\n\
      set { coor.Insert(index, value); }\n\
    }\n\
    public IEnumerator&lt;T&gt; GetEnumerator() {\n\
      return coor.GetEnumerator();\n\
    }\n\
    IEnumerator IEnumerable.GetEnumerator() {\n\
      return this.GetEnumerator();\n\
    }\n\
    public List&lt;T&gt; coor { get; set; }\n\
    public int Length { get { return coor.Count; } }\n\
    public int Width { get; set; } = 5;   // default row size\n\
    public int Left { get; set; } = 2;    // default offset\n\
    /* initializers */\n\
    public Point2&lt;T&gt; width(int w) {\n\
      this.Width = w;\n\
      return this;\n\
    } \n\
    public Point2&lt;T&gt; left(int l) {\n\
      this.Left = l;\n\
      return this;\n\
    } \n\
  }\n\
\n\
/*-------------------------------------------------------------*/\n\
/*--- End of Points.cs ----------------------------------------*/\n\
/*-------------------------------------------------------------*/\n\
\n\</div></pre>\
  </details>\
<pre>\
using Analysis;                     // defined in Analysis.cs\n\
</pre>\
<details>\
  <summary class='darkItem' style='margin-left:0em;'>Analysis.cs&nbsp;&nbsp;</summary>\
<pre><div class=&quot;code&quot;>\
/*-------------------------------------------------------------------\n\
  Analysis.cs\n\
  - provides several type analysis and display methods in the\n\
    class Display\n\
*/\n\
\n\
using System.Reflection;\n\
using System.Reflection.Emit;\n\
using System.Collections;\n\
using System.Collections.Generic;   // IEnumerable&lt;T&gt;, List&lt;T&gt;\n\
using System.Linq;                  // IEnumerable&lt;T&gt;.ToArray\n\
using System.Text;\n\
\n\
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\
    cut here\n\
\n\
    The functions below are used for analysis and display. They\n\
    have varying complexities. It is not essential to understand \n\
    them in order to follow the demonstrations in this demo.  \n\
    We will look at them in some detail in Bits_Functions. \n\
*/\n\
\n\
namespace Analysis {\n\
    /*----------------------------------------------------------------------\n\
        IShow allows analysis functions to operate on instances of any class \n\
        that implements it. See ShowTypeShowable&lt;T&gt;(T t, ...), below.\n\
    */\n\
    public interface IShow {\n\
        void Show(string name);   // show instance state as rows of elements\n\
        int Length { get; }       // total number of elements\n\
        int Width { get; set; }   // number of elements per row\n\
        int Left { get; set; }    // offset from terminal Left\n\
    }\n\
        \n\
    public class Display {\n\
        /*-------------------------------------------------\n\
          Show static type with some formatting adjustments\n\
          and name at callsite.\n\
        */\n\
        public static void ShowType&lt;T&gt;(T t, string nm) {\n\
            Type tt = t!.GetType();\n\
            string tnm = tt.Name;\n\
            if(tt.IsGenericType) {\n\
                if(tnm.Length &gt; 1) {\n\
                    tnm = tnm.Remove(tnm.Length - 2) + &quot;&lt;T&gt;&quot;;\n\
                }\n\
            }\n\
            Console.Write(&quot;{0}: {1}, &quot;, nm, tnm);\n\
            int size = GetManagedSize(tt);\n\
            Console.Write(&quot;size: {0}, &quot;, size);\n\
            if (tt.IsValueType) {\n\
                Console.WriteLine(&quot;value type&quot;);\n\
            }\n\
            else {\n\
                Console.WriteLine(&quot;reference type&quot;);\n\
            }\n\
        }\n\
        /*-------------------------------------------------\n\
        Display information about the type of any scalar type.\n\
        - scalar types are those with a single value like:\n\
            int, double, string, ...\n\
        - This function directly uses only simple reflection\n\
        */\n\
        public static void ShowTypeScalar&lt;T&gt;(\n\
            T t, string nm, string suffix = &quot;&quot;\n\
        )\n\
        {\n\
            ShowType(t, nm);\n\
            Console.WriteLine(&quot;value: &#92;&quot;{0}&#92;&quot;{1}&quot;, t, suffix);\n\
        }\n\
        /*-------------------------------------------------\n\
        Show type information for any type that implements\n\
        the IShow interface\n\
        */\n\
        public static void ShowTypeShowable&lt;T&gt;(\n\
            T t, string nm, string suffix=&quot;&quot;\n\
        )\n\
        where T:IShow\n\
        {\n\
            ShowType(t, nm);\n\
            Console.WriteLine(&quot;value:&quot;);\n\
            t.Show(nm);     // guaranteed by IShow implementation\n\
            Console.Write(suffix);\n\
        }\n\
        /*-------------------------------------------------\n\
        Provides name of caller, nm, as label for IShow() information.\n\
        - works for all Showable instances\n\
        */\n\
        public static void ShowLabeledObject&lt;T&gt;(\n\
            T t, string nm\n\
        ) where T:IShow {\n\
            Console.Write(nm);\n\
            t.Show(nm);\n\
        }\n\
        /*-------------------------------------------------\n\
        Provides name of caller, nm, as label for value.\n\
        - works for all T with ToString.\n\
        */\n\
        public static void DisplayLabeledObject&lt;T&gt;(T t, string nm) {\n\
            Console.WriteLine(&quot;{0}: {1}&quot;, nm, t!.ToString());\n\
        }\n\
        /*-------------------------------------------------\n\
        Show type information for any type that implements \n\
        IEnumerable&lt;T&gt; interface.\n\
        */\n\
        public static void ShowTypeEnum&lt;T&gt; (\n\
        IEnumerable&lt;T&gt; t, string nm, int w = 5, string suffix = &quot;&quot;\n\
        )\n\
        {\n\
            ShowType(t, nm);\n\
            Console.WriteLine(&quot;value:&#92;n{0}{1} {{&quot;, &quot;  &quot;, nm);\n\
            /* \n\
                beautify value list into rows of w elements \n\
                indented by 4 spaces\n\
            */\n\
            string tmp = FoldArray(t.ToArray(), w, 4);\n\
            Console.Write(tmp);\n\
            Console.WriteLine(&quot;&#92;n  }&quot;);\n\
            Console.Write(suffix);\n\
        }\n\
        /*-------------------------------------------------\n\
        create string of count spaces, used to offset output \n\
        */\n\
        public static string Indent(int count) {\n\
            StringBuilder sb = new StringBuilder();\n\
            sb.Append(' ', count);\n\
            return sb.ToString();\n\
        }\n\
        /*-------------------------------------------------\n\
        Truncate string to length of N, but only if\n\
        its length is greater than N\n\
        */\n\
        string truncate(int N, string bigStr) {\n\
            if(bigStr.Length &lt;= N) {\n\
                return bigStr;\n\
            }\n\
            StringBuilder sb =  new StringBuilder();\n\
            sb.Append(bigStr);\n\
            sb.Length = N;  // move back pointer to desired length\n\
            return sb.ToString();\n\
        }\n\
        /*------------------------------------------------- \n\
        fold array elements into rows of w elements \n\
        */\n\
        public static string FoldArray&lt;T&gt;(T[] arr, int w, int Left) {\n\
            StringBuilder tmp = new StringBuilder();\n\
            tmp.Append(Indent(Left));\n\
            for(int i=0; i&lt; arr.Length; ++i) {\n\
                tmp.Append(arr[i]!.ToString());\n\
                tmp.Append(&quot;, &quot;);\n\
                if((i+1) % w == 0 && i != arr.Length - 1) {\n\
                    tmp.Append(&quot;&#92;n&quot;);\n\
                    tmp.Append(Indent(Left));\n\
                }\n\
            }\n\
            if(tmp.Length &gt; 1) {\n\
                tmp.Length -= 2;  // don't return last comma and space\n\
            }\n\
            return tmp.ToString();\n\
        }\n\
        /*-------------------------------------------------\n\
        do t1 and t2 share the same address?\n\
        */\n\
        public static void IsSameObj&lt;T&gt;(\n\
        T t1, String n1, T t2, String n2, string suffix = &quot;&quot;\n\
        ) {\n\
        if(ReferenceEquals(t1, t2)) {\n\
            Console.WriteLine(\n\
            &quot;{0} is same object as {1}{2}&quot;, n1, n2, suffix\n\
            );\n\
        }\n\
        else {\n\
            Console.WriteLine(\n\
            &quot;{0} is not same object as {1}{2}&quot;, n1, n2, suffix);\n\
        }\n\
        }\n\
        /*-------------------------------------------------\n\
        Beware, two distinct objects may have same hashcode.\n\
        - Not used in this demo for that reason.\n\
        */\n\
        public static void showIdent&lt;T&gt;(\n\
            T t, String n, string suffix = &quot;&quot;\n\
        ) {\n\
            int id = t!.GetHashCode();\n\
            Console.WriteLine(&quot;{0}, {1}{2}&quot;, n, id, suffix);\n\
        }\n\
        /*-------------------------------------------------\n\
        Display function call or operation to help turn \n\
        output data into information \n\
        */\n\
        public static void ShowOp(string op, string suffix = &quot;&quot;) {\n\
            Console.WriteLine(&quot;--- {0} ---{1}&quot;, op, suffix);\n\
        }\n\
        public static void print(String s = &quot;&quot;) {\n\
            Console.Write(s);\n\
        }\n\
        public static void println(String s = &quot;&quot;) {\n\
            Console.WriteLine(s);\n\
        }\n\
        /*-------------------------------------------------\n\
        Emphasize text with borders\n\
        */\n\
        public static void ShowNote(string s, string suffix = &quot;&quot;) {\n\
            Console.WriteLine(\n\
                &quot;--------------------------------------------------&quot;\n\
            );\n\
            Console.WriteLine(&quot;{0}&quot;, s);  \n\
            Console.WriteLine(\n\
                &quot;--------------------------------------------------{0}&quot;, \n\
                suffix\n\
            );\n\
        }\n\
        /*-------------------------------------------------\n\
        Surround note with empty lines\n\
        */\n\
        public static void ShowLabel(string s) {\n\
            Console.WriteLine();\n\
            ShowNote(s);\n\
            Console.WriteLine();\n\
        }\n\
        /*\n\
          Show fields and methods for either reference or value types\n\
          using reflection\n\
        */\n\
        // https://stackoverflow.com/questions/7613782/iterating-through-struct-members\n\
        public static void iterate&lt;T&gt;(T t) /*where T:new()*/ {\n\
            Console.WriteLine(&quot;fields:&quot;);\n\
            foreach(\n\
                var field in typeof(T).GetFields(\n\
                BindingFlags.Instance | \n\
                BindingFlags.NonPublic | \n\
                BindingFlags.Public\n\
            )\n\
            ) {\n\
                Console.WriteLine(\n\
                &quot;  {0} = {1}&quot;, field.Name, field.GetValue(t)\n\
                );\n\
            }\n\
            Console.WriteLine(&quot;methods:&quot;);\n\
            foreach(\n\
                var method in typeof(T).GetMethods(\n\
                BindingFlags.Instance | BindingFlags.Public\n\
                )\n\
            ) {\n\
                Console.WriteLine(\n\
                &quot;  {0}&quot;, method.Name\n\
                );\n\
            }\n\
        }\n\
        /*-------------------------------------------------\n\
        Build string of comma separated values from \n\
        Enumerable collection\n\
        - no longer used here, but will be useful so kept\n\
        */\n\
        // https://stackoverflow.com/questions/330493/join-collection-of-objects-into-comma-separated-string\n\
        public static string ToCSV&lt;T&gt;(IEnumerable&lt;T&gt; coll) {\n\
            StringBuilder sb = new StringBuilder();\n\
            foreach(T elem in coll) {\n\
                sb.Append(elem!.ToString()).Append(&quot;, &quot;);\n\
            }\n\
            return sb.ToString(0, sb.Length - 2);\n\
        }\n\
        /*-------------------------------------------------\n\
        Returns value of T for IEnumerable&lt;T&gt; at runtime.  \n\
        Needed for some functions that operate on generic \n\
        collections.\n\
        - at this time, not used in this demo\n\
        */\n\
        // https://www.codeproject.com/Tips/5267157/How-To-Get-A-Collection-Element-Type-Using-Reflect\n\
        public static Type? GetTypeOfCollection(Object coll) {\n\
            Type type = (coll).GetType();\n\
            var etype = typeof(IEnumerable&lt;&gt;);\n\
            foreach (var bt in type.GetInterfaces()) {\n\
                if (bt.IsGenericType && bt.GetGenericTypeDefinition() == etype) {\n\
                    return (bt.GetGenericArguments()[0]);\n\
                }\n\
            }\n\
            return null;\n\
        }\n\
        /*----------------------------------------------------------------\n\
            Utils uses advanced relection \n\
            - GetMangedSize(Type type) is function that returns the size of \n\
            value types and handles, used to help discover how things work.\n\
            It is placed here because it uses advanced techniques that\n\
            will eventually be covered elsewhere in this site.  Knowing\n\
            how it works is not essential for the things we are examining\n\
            in this demo.\n\
        */\n\
        // https://stackoverflow.com/questions/8173239/c-getting-size-of-a-value-type-variable-at-runtime/8173293#8173293\n\
        public static int GetManagedSize(Type type)\n\
        {\n\
            // all this just to invoke one opcode with no arguments!\n\
            var method = new DynamicMethod(\n\
                &quot;GetManagedSizeImpl&quot;, typeof(uint), new Type[0], \n\
                typeof(TypeExtensions), false\n\
            );\n\
\n\
            ILGenerator gen = method.GetILGenerator();\n\
            gen.Emit(OpCodes.Sizeof, type);\n\
            gen.Emit(OpCodes.Ret);\n\
\n\
            var func = (Func&lt;uint&gt;)method.CreateDelegate(typeof(Func&lt;uint&gt;));\n\
            return checked((int)func());\n\
        }\n\
    }\n\
}\n\
\n\
/*-------------------------------------------------------------*/\n\
/*--- End of Analysis -----------------------------------------*/\n\
/*-------------------------------------------------------------*/\n\
\n\</div></pre>\
</details>\
<pre>\
\n\
/*\n\
  Static Data Types:\n\
    value types =&gt; assignment copies value\n\
    --------------------------------------\n\
      sbyte, byte, short, int, long, ushort, uint, ulong\n\
      float, double\n\
      decimal, char, bool\n\
      struct\n\
    Reference types =&gt; assignment copies reference\n\
    ----------------------------------------------\n\
      object, string, array, class\n\
    ----------------------------------------------\n\
      strings are immutable, so any change requires copy on write.\n\
      That simulates value behavior.\n\
*/\n\
namespace CSharpObjects\n\
{\n\
  /* \n\
    Demonstration composite value type.\n\
    - St is a value type because it is implemented with\n\
      a struct and all its data members are value types. \n\
  */\n\
  public struct St { \n\
    public St(int ai, double bi, char ci) {\n\
      a=ai; b=bi; c=ci;\n\
    }\n\
    public void Show(string name) {\n\
      Console.WriteLine(\n\
        &quot;  {0} {{ a:{1}, b:{2}, c:{3} }}&quot;, name, a, b, c \n\
      );\n\
    }\n\
    /*\n\
     These data members are public instead of public properties.\n\
     - we don't need that ceremony because St is simply a data\n\
       aggregator. It doesn't have any significant behavior.\n\
    */\n\
    public int a; \n\
    public double b; \n\
    public char c; \n\
  }\n\
\n\
  /*-- Object demonstration begins here --*/\n\
  class Program\n\
  {\n\
    const string nl = &quot;&#92;n&quot;;\n\
    static void Main(string[] args)\n\
    {\n\
      Display.ShowLabel(&quot; Demonstrate C# objects&quot;);\n\
\n\
      Display.ShowNote(\n\
        &quot;Examples of creation and display of Primitive Types&quot;\n\
      );\n\
      short s = 123;\n\
      Display.ShowTypeScalar(s, &quot;s&quot;, nl);\n\
      long l = 12345;\n\
      Display.ShowTypeScalar(l, &quot;l&quot;, nl);\n\
      float f = 3.1415927f;\n\
      Display.ShowTypeScalar(f, &quot;f&quot;, nl);\n\
      double d = 3.1415927;\n\
      Display.ShowTypeScalar(d, &quot;d&quot;, nl);\n\
      int[] arr = new int[]{ 4, 3, 2, 1, 0, -1};\n\
      Display.ShowTypeEnum(arr, &quot;arr&quot;, 10, nl);\n\
\n\
      Display.ShowNote(\n\
        &quot;Examples of creation and display of Library Types&#92;n&quot; + \n\
        &quot;- size is the size of reference, not instance&quot;\n\
      );\n\
      string aString = &quot;a string&quot;;  // hides construction\n\
      Display.ShowTypeScalar(aString, &quot;aString&quot;, nl);\n\
\n\
      string another = new string(&quot;another string&quot;);\n\
      Display.ShowTypeScalar(another, &quot;another&quot;, nl);\n\
\n\
      List&lt;double&gt; aList = \n\
        new List&lt;double&gt;{ 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0 };\n\
    \n\
      Display.ShowTypeEnum(aList, &quot;aList&quot;, 5, nl);\n\
\n\
      var d1 = new Dictionary&lt;int, string&gt;\n\
      {\n\
        { 0, &quot;zero&quot;}, {1, &quot;one&quot;}, {2, &quot;two&quot;}\n\
      };\n\
      Display.ShowTypeEnum(d1, &quot;d1&quot;, 5, nl);\n\
  \n\
      Display.ShowNote(\n\
        &quot;Examples of user-defined types:&#92;n&quot; + \n\
        &quot;- Point1, a point with x,y,z coordinates&#92;n&quot; +\n\
        &quot;- Point2, a point with N generic coordinates&quot;\n\
      );\n\
      Point1 p1 = new Point1();\n\
      p1.x = 3;\n\
      p1.y = -42;\n\
      p1.z = 1;\n\
      Display.ShowOp(&quot;ShowTypeShowable(p1, &#92;&quot;p1&#92;&quot;)&quot;);\n\
      Display.ShowTypeShowable(p1, &quot;p1&quot;, nl);\n\
\n\
      Display.ShowNote(\n\
        &quot;Point2&lt;T&gt; is both Enumerable and Showable. That is,&#92;n&quot; +\n\
        &quot;it implements both IEnumerable&lt;T&gt; and IShow.&#92;n&quot; +\n\
        &quot;- so both ShowTypeEnum and ShowTypeShowable work&quot;\n\
      );\n\
      Point2&lt;double&gt; p2 = new Point2&lt;double&gt;(7);\n\
      p2.coor = new List&lt;double&gt; {\n\
        1.5, 2.0, 3.5, 4.0, 5.5, 6.0, 7.5\n\
      };\n\
      #region\n\
      Display.ShowOp(&quot;ShowTypeShowable(p2, &#92;&quot;p2&#92;&quot;)&quot;);\n\
      #endregion\n\
      p2.Width = 6;\n\
      Display.ShowTypeShowable(p2, &quot;p2&quot;, nl);\n\
\n\
      #region\n\
      Display.ShowOp(&quot;ShowTypeEnum(p2, &#92;&quot;p2&#92;&quot;)&quot;);\n\
      #endregion\n\
      Display.ShowTypeEnum&lt;double&gt;(p2, &quot;p2&quot;, p2.Width, nl);\n\
\n\
      #region\n\
      Display.ShowOp(&quot;ShowTypeShowable(p3, &#92;&quot;p3&#92;&quot;)&quot;);\n\
      #endregion\n\
      Point2&lt;int&gt; p3 = new Point2&lt;int&gt;(7);\n\
      p3.left(4).width(7);\n\
\n\
      #region\n\
      Display.ShowOp(&quot;set left(4) and width(7)&quot;);\n\
      #endregion\n\
      p3.coor = new List&lt;int&gt;{1, 2, 3, 4, 5, 6, 7};\n\
      Display.ShowTypeShowable(p3, &quot;p3&quot;, nl);\n\
\n\
      Display.ShowLabel(\n\
        &quot;Differences between value and reference types&quot;\n\
      );\n\
      Display.ShowNote(\n\
        &quot;Assignment of reference types assigns their references,&#92;n&quot; +\n\
        &quot;creating two references to the same instance in managed&#92;n&quot; +\n\
        &quot;heap, so variables are coupled through single instance.&quot;\n\
      );\n\
\n\
      #region\n\
      Display.ShowOp(&quot;Point1 val1 = new Point1(), then initialize&quot;);\n\
      #endregion\n\
      Point1 val1 = new Point1();\n\
      val1.x = 1;\n\
      val1.y = 2;\n\
      val1.z = 3;\n\
      Display.ShowLabeledObject(val1, &quot;val1&quot;);\n\
\n\
      #region \n\
      Display.ShowOp(&quot;Point1 val2 = val1&quot;);\n\
      #endregion\n\
      Point1 val2 = val1;\n\
      Display.ShowLabeledObject(val2, &quot;val2&quot;);\n\
      Display.IsSameObj(val2, &quot;val2&quot;, val1, &quot;val1&quot;);\n\
      \n\
      #region \n\
      Display.ShowOp(&quot;val2.z = 42;&quot;);\n\
      #endregion\n\
      val2.z = 42;\n\
      Display.IsSameObj(val2, &quot;val2&quot;, val1, &quot;val1&quot;);\n\
      Display.ShowLabeledObject(val2, &quot;val2&quot;);\n\
      Display.ShowLabeledObject(val1, &quot;val1&quot;);\n\
      Display.ShowNote(\n\
        &quot;Note! Source of assignment, val1, changed when val2 changed.&#92;n&quot; +\n\
        &quot;Point1 is ref type, so assignment just assigns references.&quot;\n\
      );\n\
      Display.println();\n\
\n\
      Display.ShowNote(\n\
        &quot;Value types can be independently assigned and copied.&quot;\n\
      );\n\
\n\
      #region\n\
      Display.ShowOp(&quot;var s1 = new St(1, -0.5, 'z');&quot;);\n\
      #endregion\n\
      var s1 = new St(1, -0.5, 'z');\n\
\n\
      #region\n\
      Display.ShowOp(&quot;var s2 = s1&quot;);\n\
      #endregion\n\
      var s2 = s1;\n\
      Display.IsSameObj(s2, &quot;s2&quot;, s1, &quot;s1&quot;);\n\
      s2.Show(&quot;s2&quot;);\n\
      s1.Show(&quot;s1&quot;);\n\
\n\
      #region \n\
      Display.ShowOp(&quot;s2.c = 'q'&quot;);\n\
      #endregion\n\
      s2.c = 'q';\n\
      s2.Show(&quot;s2&quot;);\n\
      s1.Show(&quot;s1&quot;);\n\
      Display.ShowNote(\n\
        &quot;Change in destination, s2, did not alter source, s1.&#92;n&quot; +\n\
        &quot;Assignment of value types creates independent objects.&quot;\n\
      );\n\
\n\
      Display.ShowLabel(\n\
        &quot;Instances of string are reference types, but simulate&#92;n&quot; +\n\
        &quot;some value behaviors.  String objects are immutable.&#92;n&quot; +\n\
        &quot;To modify an instance, a new string is created with&#92;n&quot; +\n\
        &quot;copies of the source string characters inclucing any&#92;n&quot; +\n\
        &quot;modifications.  This is called copy on write.&quot;\n\
      );\n\
      var str1 = &quot;An immutable string&quot;;\n\
      var str2 = str1;  // copy handle not instance\n\
      Display.IsSameObj(str2, &quot;str2&quot;, str1, &quot;str1&quot;);\n\
      Display.DisplayLabeledObject&lt;string&gt;(str1, &quot;str1&quot;);\n\
      Display.DisplayLabeledObject(str2, &quot;str2&quot;);\n\
\n\
      str2 = str2.Remove(0,3);\n\
      Display.IsSameObj(str2, &quot;str2&quot;, str1, &quot;str1&quot;);\n\
      Display.DisplayLabeledObject(str1, &quot;str1&quot;);\n\
      Display.DisplayLabeledObject(str2, &quot;str2&quot;);\n\
      Display.ShowNote(\n\
        &quot;There is no way for change in str2 to affect str1.&quot;\n\
      );\n\
      Display.println();\n\
      \n\
      Display.ShowNote(\n\
        &quot;Test formatting for Enumerable types&quot;, nl\n\
      );\n\
\n\
      int[] testarr = { 0,1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\
      Display.ShowTypeEnum(testarr, &quot;testarr&quot;, 5, nl);\n\
\n\
      /*\n\
        Commented function calls below left to let viewers\n\
        uncomment and walk through with debugger.\n\
      */\n\
      #region \n\
      // ShowLabel(&quot;Test code for functions used above&quot;);\n\
      // print(&quot;--- double[] to folded CSV ---&quot;);\n\
      // int[] arr2 = { 0,1,2,3,4,5,6,7,8 };\n\
      // string tmp = FoldArray(arr2, 3, 2);\n\
      // Console.WriteLine(&quot;&#92;n{0}&quot;,tmp);\n\
\n\
      // ShowLabel(&quot;Alternate function for generating CSVs&quot;);\n\
      // print(&quot;--- coor to folded CSV ---&quot;);\n\
      // double[] arr3 = p2.coor.ToArray();\n\
      // tmp = FoldArray(arr3, 4, 2);\n\
      // Console.WriteLine(&quot;&#92;n{0}&quot;,tmp);\n\
\n\
      // string tmp1 = ToCSV&lt;double&gt;(p2.coor);\n\
      // string tmp2 = ToCSV(p2.coor);  // demo that type inference works here\n\
      // ShowTypeScalar(tmp2, &quot;tmp2&quot;);\n\
      #endregion\n\
\n\
      Console.WriteLine(&quot;&#92;nThat's all Folks!&#92;n&quot;);\n\
    }\n\
  }\n\
}\n\
\n\
\n\</pre>\n\
"
    }
    function loadCsOut(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\n\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Objects\n\
&gt; dotnet run\n\
\n\
--------------------------------------------------\n\
 Demonstrate C# objects\n\
--------------------------------------------------\n\
\n\
--------------------------------------------------\n\
Examples of creation and display of Primitive Types\n\
--------------------------------------------------\n\
s: Int16, size: 2, value type\n\
value: &quot;123&quot;\n\
\n\
l: Int64, size: 8, value type\n\
value: &quot;12345&quot;\n\
\n\
f: Single, size: 4, value type\n\
value: &quot;3.1415927&quot;\n\
\n\
d: Double, size: 8, value type\n\
value: &quot;3.1415927&quot;\n\
\n\
arr: Int32[], size: 8, reference type\n\
value:\n\
  arr {\n\
    4, 3, 2, 1, 0, -1\n\
  }\n\
\n\
--------------------------------------------------\n\
Examples of creation and display of Library Types\n\
- size is the size of reference, not instance\n\
--------------------------------------------------\n\
aString: String, size: 8, reference type\n\
value: &quot;a string&quot;\n\
\n\
another: String, size: 8, reference type\n\
value: &quot;another string&quot;\n\
\n\
aList: List&lt;T&gt;, size: 8, reference type\n\
value:\n\
  aList {\n\
    1, 1.5, 2, 2.5, 3,\n\
    3.5, 4\n\
  }\n\
\n\
d1: Dictionary&lt;T&gt;, size: 8, reference type\n\
value:\n\
  d1 {\n\
    [0, zero], [1, one], [2, two]\n\
  }\n\
\n\
--------------------------------------------------\n\
Examples of user-defined types:\n\
- Point1, a point with x,y,z coordinates\n\
- Point2, a point with N generic coordinates\n\
--------------------------------------------------\n\
--- ShowTypeShowable(p1, &quot;p1&quot;) ---\n\
p1: Point1, size: 8, reference type\n\
value:\n\
  p1  { x:3, y:-42, z:1 }\n\
\n\
--------------------------------------------------\n\
Point2&lt;T&gt; is both Enumerable and Showable. That is,\n\
it implements both IEnumerable&lt;T&gt; and IShow.\n\
- so both ShowTypeEnum and ShowTypeShowable work\n\
--------------------------------------------------\n\
--- ShowTypeShowable(p2, &quot;p2&quot;) ---\n\
p2: Point2&lt;T&gt;, size: 8, reference type\n\
value:\n\
  p2 {\n\
    1.5, 2, 3.5, 4, 5.5, 6,\n\
    7.5\n\
  }\n\
\n\
--- ShowTypeEnum(p2, &quot;p2&quot;) ---\n\
p2: Point2&lt;T&gt;, size: 8, reference type\n\
value:\n\
  p2 {\n\
    1.5, 2, 3.5, 4, 5.5, 6,\n\
    7.5\n\
  }\n\
\n\
--- ShowTypeShowable(p3, &quot;p3&quot;) ---\n\
--- set left(4) and width(7) ---\n\
p3: Point2&lt;T&gt;, size: 8, reference type\n\
value:\n\
    p3 {\n\
      1, 2, 3, 4, 5, 6, 7\n\
    }\n\
\n\
\n\
--------------------------------------------------\n\
Differences between value and reference types\n\
--------------------------------------------------\n\
\n\
--------------------------------------------------\n\
Assignment of reference types assigns their references,\n\
creating two references to the same instance in managed\n\
heap, so variables are coupled through single instance.\n\
--------------------------------------------------\n\
--- Point1 val1 = new Point1(), then initialize ---\n\
val1  val1  { x:1, y:2, z:3 }\n\
--- Point1 val2 = val1 ---\n\
val2  val2  { x:1, y:2, z:3 }\n\
val2 is same object as val1\n\
--- val2.z = 42; ---\n\
val2 is same object as val1\n\
val2  val2  { x:1, y:2, z:42 }\n\
val1  val1  { x:1, y:2, z:42 }\n\
--------------------------------------------------\n\
Note! Source of assignment, val1, changed when val2 changed.       \n\
Point1 is ref type, so assignment just assigns references.\n\
--------------------------------------------------\n\
\n\
--------------------------------------------------\n\
Value types can be independently assigned and copied.\n\
--------------------------------------------------\n\
--- var s1 = new St(1, -0.5, 'z'); ---\n\
--- var s2 = s1 ---\n\
s2 is not same object as s1\n\
  s2 { a:1, b:-0.5, c:z }\n\
  s1 { a:1, b:-0.5, c:z }\n\
--- s2.c = 'q' ---\n\
  s2 { a:1, b:-0.5, c:q }\n\
  s1 { a:1, b:-0.5, c:z }\n\
--------------------------------------------------\n\
Change in destination, s2, did not alter source, s1.\n\
Assignment of value types creates independent objects.\n\
--------------------------------------------------\n\
\n\
--------------------------------------------------\n\
Instances of string are reference types, but simulate\n\
some value behaviors.  String objects are immutable.\n\
To modify an instance, a new string is created with\n\
copies of the source string characters inclucing any\n\
modifications.  This is called copy on write.\n\
--------------------------------------------------\n\
\n\
str2 is same object as str1\n\
str1: An immutable string\n\
str2: An immutable string\n\
str2 is not same object as str1\n\
str1: An immutable string\n\
str2: immutable string\n\
--------------------------------------------------\n\
There is no way for change in str2 to affect str1.\n\
--------------------------------------------------\n\
\n\
--------------------------------------------------\n\
Test formatting for Enumerable types\n\
--------------------------------------------------\n\
\n\
testarr: Int32[], size: 8, reference type\n\
value:\n\
  testarr {\n\
    0, 1, 2, 3, 4,\n\
    5, 6, 7, 8, 9\n\
  }\n\
\n\
\n\
That's all Folks!\n\
\n\n\</pre>\n\
"
    }
    function loadCsBld(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre style='overflow-x:auto;'>\n\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Objects\n\
&gt; dotnet build\n\
MSBuild version 17.4.1+9a89d02ff for .NET\n\
  Determining projects to restore...\n\
  All projects are up-to-date for restore.\n\
  Cs_Objects -&gt; C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Objects&#92;bin&#92;De\n\
  bug&#92;net7.0&#92;Cs_Objects.dll\n\
\n\
Build succeeded.\n\
    0 Warning(s)\n\
    0 Error(s)\n\
\n\
Time Elapsed 00:00:00.80\n\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;CSharp&#92;Cs_Objects\n\
</pre>"
    }
  </script>

  <script>
    /*-- Load Rust Code, Output, Build --*/
    function loadRsCode(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div class='code'>\
      <div style='white-space:normal; margin-left:2em; margin-top:0em;'>\
        <details>\
          <summary class='darkItem' style='margin-left:-2em;'>Code Notes&nbsp;&nbsp;</summary>\
          <ol class='tight' style='margin-left:0em;'>\
            <li>\
              This Bit illustrates use of std::String, std::Vector, and two user-defined\n\
              types Point1 and Point2<T>.\
            </li>\
            <li>\
              It illustrates use of move, and clone operations, as well as stack\n\
              and heap memory.\
            </li>\
            <li>\
              show function is designed to display type and calling name of its\
              first argument and its value and size.\
            </li>\
            <li>\
              <c-s>show&lt;T: Debug&gt;(T:t, n:&str)</c-s> is generic on the type T\
              with the bound that T must satisfy the Debug trait.\
            </li>\
            <li>\
              The Debug trait provides a simple formatting using {:?} in print macro.\
            </li>\
            <li>\
              Macros end with &quot;!&quot; character.  The macro println! is an example.\
              <div style='height:0.75em;'></div>\
            </li>\
          </ol >\
        </details >\n\
      </div >\
<pre>\
#![allow(dead_code)]\n\
#![allow(clippy::approx_constant)]\n\
\n\
/*-------------------------------------------------------------------\n\
  rust_hello_objects::main.rs\n\
  - Demonstrates creation and use of Rust objects\n\
  - Rust uses struct instead of class to create objects\n\
*/\n\
mod analysis;     // identify module source file\n\
use analysis::*;  // import public functions and types\n\
</pre>\
<details>\
  <summary class='darkItem' style='margin-left:0em;'>Analysis.rs&nbsp;&nbsp;</summary>\
<pre><div class=&quot;code&quot;>\
/*-------------------------------------------------------------------\n\
  analysis.rs\n\
  - provides analysis and display functions for Objects demo.\n\
  - a few of these require advanced generics code.\n\
  - You don't need to know how these work to understand this\n\
    demo.\n\
  - We will come back to these functions in a later Bit.\n\
-------------------------------------------------------------------*/\n\
\n\
use std::fmt::*;\n\
\n\
/*---------------------------------------------------------\n\
  Show input's call name and type\n\
  - doesn't consume input\n\
  - show_type is generic function with Debug bound.\n\
    Using format &quot;{:?}&quot; requires Debug.\n\
*/\n\
pub fn show_type&lt;T:Debug&gt;(_t: &T, nm: &str) {\n\
    let typename = std::any::type_name::&lt;T&gt;();\n\
    println!(&quot;call name: {nm:?}, type: {typename:?}&quot;);\n\
}\n\
/*---------------------------------------------------------\n\
  Show enumerable input's values\n\
  - 'a is an annotation saying that T's lifetime\n\
    is as long as the function's lifetime.\n\
  - I is the type of T's elements, that is coll:T&lt;I&gt;.\n\
  - T can be any iterable type and both T and I must \n\
    satisfy Debug trait.\n\
  - Does not consume input t since passed by reference.\n\
*/\n\
pub fn show_value_enum&lt;T:Debug, I:Debug&gt;(\n\
    t: &T, nm: &str, left:usize, width:usize\n\
) \n\
  where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;\n\
{\n\
    print!(&quot;{nm:?} {{&#92;n&quot;);\n\
    show_fold(&t, left, width);\n\
    print!(&quot;}}&quot;);\n\
    println!(&quot;&#92;nsize: {}&quot;, std::mem::size_of::&lt;T&gt;());\n\
}\n\
/*---------------------------------------------------------\n\
  Show facts about a type's elements, e.g., name, type,\n\
  value, and size.\n\
  - show_type is generic function with Debug bound.\n\
    Using format &quot;{:?} requires Debug.&quot;\n\
  - works with small enumerable collections too because\n\
    {:?} knows how to format them, but won't fold long\n\
    sequences of elements. Use show_value_enum for that.\n\
*/\n\
pub fn show_type_scalar&lt;T:Debug&gt;(t: &T, nm: &str) {\n\
    show_type(t, nm);\n\
    println!(\n\
        &quot;value: {t:?}, size: {}&quot;, std::mem::size_of::&lt;T&gt;()\n\
    );\n\
}\n\
/*---------------------------------------------------------\n\
Show facts about an enumerable type's elements, e.g., \n\
name, type, values, and size.\n\
- show_type is generic function with Debug bound.\n\
  Using format &quot;{:?} requires Debug.&quot;\n\
*/\n\
pub fn show_type_enum&lt;T:Debug, I:Debug&gt;(t: &T, nm: &str, left:usize, width:usize) \n\
  where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;\n\
{\n\
    show_type(t, nm);\n\
    show_value_enum(t, nm, left, width);\n\
}\n\
/*--------------------------------------------------------- \n\
  build indent string with &quot;left&quot; spaces \n\
*/\n\
pub fn offset(left: usize) -&gt; String {\n\
    let mut accum = String::new();\n\
    for _i in 0..left {\n\
        accum += &quot; &quot;;\n\
    }\n\
    accum\n\
}\n\
/*---------------------------------------------------------\n\
  find index of last occurance of chr in s\n\
  - returns option in case chr is not found\n\
  https://stackoverflow.com/questions/50101842/how-to-find-the-last-occurrence-of-a-char-in-a-string\n\
*/\n\
fn find_last_utf8(s: &str, chr: char) -&gt; Option&lt;usize&gt; {\n\
    if let Some(rev_pos) = \n\
      s.chars().rev().position(|c| c == chr) {\n\
        Some(s.chars().count() - rev_pos - 1)\n\
    } else {\n\
        None\n\
    }\n\
}\n\
/*---------------------------------------------------------\n\
  fold an enumerable's elements into rows of w elements\n\
  - indent by left spaces\n\
  - does not consume t since passed as reference\n\
  - returns string\n\
  https://users.rust-lang.org/t/generic-code-over-iterators/10907/3\n\
*/\n\
pub fn fold&lt;T, I:Debug&gt;(\n\
    t: &T, left: usize, width: usize\n\
) -&gt; String\n\
    where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;, T:Debug\n\
{\n\
    let mut accum = String::new();\n\
    accum += &offset(left);\n\
    let mut i = 0usize;\n\
    for item in t {\n\
        accum += &format!(&quot;{item:?}, &quot;);\n\
        if ((i + 1) % width) == 0 && i != 0 {\n\
            accum += &quot;&#92;n&quot;;\n\
            accum += &offset(left);\n\
        }\n\
        i += 1;\n\
    }\n\
    let opt = find_last_utf8(&accum, ',');\n\
    if let Some(index) = opt {\n\
        accum.truncate(index);\n\
    }\n\
    accum\n\
}\n\
/*---------------------------------------------------------\n\
  show enumerables's elements as folded rows\n\
  - width is number of elements in each row\n\
  - left is indent from terminal left\n\
*/\n\
pub fn show_fold&lt;T:Debug, I:Debug&gt;(t:&T, left:usize, width:usize) \n\
  where for&lt;'a&gt; &'a T: IntoIterator&lt;Item = &'a I&gt;\n\
{\n\
  println!(&quot;{}&quot;,fold(t, left, width));\n\
}\n\
/*---------------------------------------------------------\n\
  show string wrapped with long dotted lines above and below \n\
*/\n\
pub fn show_label(note: &str, n:usize) {\n\
  let mut line = String::new();\n\
  for _i in 0..n {\n\
    line.push('-');\n\
  }\n\
  print!(&quot;&#92;n{}&#92;n&quot;, line);\n\
  print!(&quot;  {note}&quot;);\n\
  print!(&quot;&#92;n{}&#92;n&quot;, line);\n\
}\n\
pub fn show_label_def(note:&str) {\n\
  show_label(note, 50);\n\
}\n\
/*---------------------------------------------------------\n\
  show string wrapped with dotted lines above and below \n\
*/\n\
pub fn show_note(note: &str) {\n\
  print!(&quot;&#92;n-------------------------&#92;n&quot;);\n\
  print!(&quot; {note}&quot;);\n\
  print!(&quot;&#92;n-------------------------&#92;n&quot;);\n\
}\n\
/*---------------------------------------------------------\n\
  show string wrapped in short lines\n\
*/\n\
pub fn show_op(opt: &str) {\n\
  println!(&quot;--- {} ---&quot;, opt);\n\
}\n\
/*---------------------------------------------------------\n\
  print newline\n\
*/\n\
pub fn nl() {\n\
  println!();\n\
}\n\
/*----------------------------------------------------------*/\n\
/*--- End of Analysis.rs -----------------------------------*/\n\
/*----------------------------------------------------------*/\n\
</pre >\
</details >\
<pre>\
mod points;       // identify module source file\n\
use points::*;    // import public functions and types\n\
</pre>\
<details>\
  <summary class='darkItem' style='margin-left:0em;'>Points.rs&nbsp;&nbsp;</summary>\
<pre><div class=&quot;code&quot;>\
/*-------------------------------------------------------------------\n\
  points.rs\n\
  - defines types Point1 and Point2&lt;T&gt;\n\
-------------------------------------------------------------------*/\n\
\n\
use std::default::*;\n\
use std::fmt::*;\n\
\n\
use crate::analysis;    // identify source code\n\
use analysis::*;        // import public functions and types\n\
\n\
/*---------------------------------------------------------\n\
  - Declare Point1 struct, like a C++ class\n\
  - Request compiler implement traits Debug & Clone\n\
*/\n\
#[derive(Debug, Clone)]\n\
pub struct Point1 {\n\
    x: i32,\n\
    y: i32,\n\
    z: i32,\n\
}\n\
/*-- implement function new --*/\n\
impl Point1 {\n\
    pub fn new() -&gt; Point1 {\n\
        Point1 { x: 0, y: 0, z: 0 }\n\
    }\n\
    /*\n\
      For simple types like this it would be reasonable to\n\
      make x, y, z public and remove the getter and setter\n\
      functions.\n\
    */\n\
    pub fn get_x(&self) -&gt; &i32 {\n\
        &self.x\n\
    }\n\
    pub fn get_y(&self) -&gt; &i32 {\n\
        &self.y\n\
    }\n\
    pub fn get_z(&self) -&gt; &i32 {\n\
        &self.z\n\
    }\n\
    pub fn set_x(&mut self, x: i32) {\n\
        self.x = x\n\
    }\n\
    pub fn set_y(&mut self, y: i32) {\n\
        self.y = y\n\
    }\n\
    pub fn set_z(&mut self, z: i32) {\n\
        self.z = z\n\
    }\n\
    pub fn show(&self, nm:&str) {\n\
        print!(&quot;{:?}: Point1 {{ &quot;, nm);\n\
        print!(&quot;{0}, &quot;, self.x);\n\
        print!(&quot;{0}, &quot;, self.y);\n\
        println!(&quot;{0} }}&quot;, self.z);\n\
    }\n\
}\n\
\n\
/*---------------------------------------------------------\n\
  - Declare Point2&lt;T&gt; struct, like a C++ template class\n\
  - Request compiler implement traits Debug & Clone\n\
*/\n\
#[derive(Debug, Clone)]\n\
pub struct Point2&lt;T&gt;\n\
where\n\
    T: Debug,\n\
    T: Default,\n\
    T: Clone,\n\
{\n\
    coor: Vec&lt;T&gt;,\n\
}\n\
impl&lt;T&gt; Point2&lt;T&gt;\n\
where\n\
    T: Debug,\n\
    T: Default,\n\
    T: Clone,\n\
{\n\
    pub fn new(n: usize) -&gt; Point2&lt;T&gt; {\n\
        Point2::&lt;T&gt; {\n\
            coor: vec![T::default(); n],\n\
        }\n\
    }\n\
    pub fn init(mut self, coord: Vec&lt;T&gt;) -&gt; Point2&lt;T&gt; {\n\
        self.coor = coord;\n\
        self\n\
    }\n\
    pub fn len(&self) -&gt; usize {\n\
        self.coor.len()\n\
    }\n\
    /* acts as both get_coor() and set_coor(vec![1, 2, 3]) */\n\
    pub fn coors(&mut self) -&gt; &mut Vec&lt;T&gt; {\n\
        &mut self.coor\n\
    }\n\
    pub fn show(&self, nm:&str, left: usize, width:usize) {\n\
        print!(&quot;{:?}: Point2&lt;T&gt; {{&#92;n&quot;, nm);\n\
        show_fold(&self.coor, left, width);\n\
        println!(&quot;}}&quot;)\n\
    }\n\
}\n\
\n\
/*----------------------------------------------------------*/\n\
/*--- End of Points.rs -------------------------------------*/\n\
/*----------------------------------------------------------*/\n\
</pre>\
</details>\
<pre>\
\n\
/*---------------------------------------------------------\n\
  Demo object instances in action\n\
*/\n\
fn main() {\n\
    show_label(&quot;demonstrate object creation&quot;, 50);\n\
\n\
    show_label(\n\
      &quot;std::library objects, string and vector&lt;T&gt;&quot;, 46\n\
    );\n\
    nl();\n\
\n\
    /* #region - to use this feature install #region folding */\n\
    show_op(&quot;let mut s1 = &#92;&quot;a string&#92;&quot;.to_string()&quot;);\n\
    /* #endregion */\n\
    let mut s1 = &quot;a string&quot;.to_string();\n\
\n\
    /* #region */\n\
    show_op(&quot;show_type_scalar(&s1, &#92;&quot;&s1&#92;&quot;)&quot;);\n\
    /* #endregion */\n\
    show_type_scalar(&s1, &quot;&s1&quot;);\n\
    nl();\n\
\n\
    /* #region */\n\
    show_op(&quot;s1.push_str(&#92;&quot; and more&#92;&quot;);&quot;);\n\
    /* #endregion */\n\
    s1.push_str(&quot; and more&quot;);\n\
    show_type_scalar(&s1, &quot;&s1&quot;);\n\
    nl();\n\
    \n\
    /* #region */\n\
    show_op(&quot;let mut v:Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1];&quot;);\n\
    /* #endregion */\n\
    let mut v: Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1];\n\
    show_type_scalar(&v, &quot;&v&quot;);\n\
    nl();\n\
    \n\
    /* #region */\n\
    show_op(&quot;v.push(42);&quot;);\n\
    /* #endregion */\n\
    v.push(42);\n\
    show_type_scalar(&v, &quot;&v&quot;);\n\
\n\
    show_label(&quot;instances of user-defined types&quot;, 35);\n\
    nl();\n\
\n\
    /* #region */\n\
    show_op(&quot;let mut p1 = Point1::new()&quot;);\n\
    /* #endregion */\n\
    let mut p1 = Point1::new();\n\
    p1.show(&quot;p1&quot;);\n\
    p1.set_x(42);\n\
    p1.set_y(-3);\n\
    p1.set_z(2);\n\
    p1.show(&quot;p1&quot;);\n\
    show_type_scalar(&p1, &quot;p1&quot;);\n\
    nl();\n\
\n\
    /* #region */\n\
    show_op(&quot;let p1a = p1.clone()&quot;);\n\
    /* #endregion */\n\
    let p1a = p1.clone();\n\
    p1a.show(&quot;p1a.clone()&quot;);    \n\
    nl();\n\
\n\
    let mut p2 = Point2::&lt;f64&gt;::new(10);\n\
    p2.show(&quot;p2&quot;, 2, 7);\n\
\n\
    /* #region */\n\
    show_op(&quot;show_type(p2, &#92;&quot;p2&#92;&quot;)&quot;);\n\
    /* #endregion */\n\
    show_type(&p2, &quot;p2&quot;);\n\
\n\
    /* #region */\n\
    show_op(&quot;show_value_enum(p2.coors(), &#92;&quot;p2&#92;&quot;, 2, 7)&quot;);\n\
    /* #endregion */\n\
    show_value_enum(p2.coors(), &quot;p2.coors()&quot;, 2, 7);\n\
    nl();\n\
    \n\
    /* #region */\n\
    show_op(&quot;p2.coors()[2] = 3.1415&quot;);\n\
    /* #endregion */\n\
    p2.coors()[2] = 3.1415;\n\
\n\
    /* #region */\n\
    show_op(&quot;show_value_enum(p2.coors(), &#92;&quot;p2.coors()&#92;&quot;, 2, 7)&quot;);\n\
    /* #endregion */\n\
    show_value_enum(p2.coors(), &quot;p2.coors()&quot;, 2, 7);\n\
    nl();\n\
\n\
    let p2a = \n\
      Point2::&lt;i32&gt;::new(1).init(\n\
        vec![0, 1, 2, 3, 4, 4, 3, 2, 1, 0]\n\
      );\n\
    p2a.show(&quot;p2a&quot;, 2,7);\n\
    nl();\n\
\n\
    /* #region */\n\
    show_op(&quot;show_type_scalar(p2a, &#92;&quot;p2a&#92;&quot;)&quot;);\n\
    /* #endregion */\n\
    show_type_scalar(&p2a, &quot;p2a&quot;);\n\
    \n\
    println!(&quot;p2a.len() = {:?}&quot;, p2a.len());\n\
    nl();\n\
\n\
    /* #region */\n\
    show_op(&quot;p2a.show(&#92;&quot;p2a&#92;&quot;, 2, 7)&quot;);\n\
    /* #endregion */\n\
    p2a.show(&quot;p2a&quot;, 2, 7);\n\
\n\
    show_label(&quot;Testing formats for collections&quot;, 35);\n\
    nl();\n\
\n\
    let v = \n\
      vec![\n\
        0i32, -1, 2, -3, 4, -5, 6, -7, 8, -9, \n\
        10, -11, 12, -13, 14\n\
      ];\n\
\n\
    /* #region */\n\
    show_op(&quot;show_type_scalar(&v, &#92;&quot;&v&#92;&quot;)&quot;);\n\
    /* #endregion */\n\
    show_type_scalar(&v, &quot;&v&quot;);\n\
    nl();\n\
\n\
    /* #region */\n\
    show_op(&quot;show_fold(&v, 2, 5)&quot;);\n\
    /* #endregion */\n\
    show_fold(&v, 2, 5);\n\
    nl();\n\
\n\
    /* #region */\n\
    show_op(&quot;let v = vec![0i32, ... ];&quot;);\n\
    show_op(&quot;fold(&v, 2, 12)&quot;);\n\
    /* #endregion */\n\
    let stmp = fold(&v, 2, 12);\n\
    println!(&quot;{stmp}&quot;);\n\
    nl();\n\
\n\
    /* #region */\n\
    show_op(&quot;let a = &[f64; 8];&quot;);\n\
    /* #endregion */\n\
    let a = \n\
      &[1.0, 2.5, -3.1, 4.3, 5.0, 6.0, 7.0, -8.0];\n\
    show_op(&quot;show_fold(a, 4, 5)&quot;);\n\
    show_fold(a, 4, 5);\n\
    \n\
    print!(&quot;&#92;n&#92;n  That's all Folks!&#92;n&#92;n&quot;);\n\
}\n\
\n\</pre></div>\
";
    }

    function loadRsOut(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\
\n\
--------------------------------------------------\n\
  demonstrate object creation\n\
--------------------------------------------------\n\
\n\
----------------------------------------------\n\
  std::library objects, string and vector&lt;T&gt;\n\
----------------------------------------------\n\
\n\
--- let mut s1 = &quot;a string&quot;.to_string() ---\n\
--- show_type_scalar(&s1, &quot;&s1&quot;) ---\n\
call name: &quot;&s1&quot;, type: &quot;alloc::string::String&quot;\n\
value: &quot;a string&quot;, size: 24\n\
\n\
--- s1.push_str(&quot; and more&quot;); ---\n\
call name: &quot;&s1&quot;, type: &quot;alloc::string::String&quot;\n\
value: &quot;a string and more&quot;, size: 24\n\
\n\
--- let mut v:Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1]; ---\n\
call name: &quot;&v&quot;, type: &quot;alloc::vec::Vec&lt;i32&gt;&quot;\n\
value: [1, 2, 3, 2, 1], size: 24\n\
\n\
--- v.push(42); ---\n\
call name: &quot;&v&quot;, type: &quot;alloc::vec::Vec&lt;i32&gt;&quot;\n\
value: [1, 2, 3, 2, 1, 42], size: 24\n\
\n\
-----------------------------------\n\
  instances of user-defined types\n\
-----------------------------------\n\
\n\
--- let mut p1 = Point1::new() ---\n\
&quot;p1&quot;: Point1 { 0, 0, 0 }\n\
&quot;p1&quot;: Point1 { 42, -3, 2 }\n\
call name: &quot;p1&quot;, type: &quot;rust_hello_objects::points::Point1&quot;       \n\
value: Point1 { x: 42, y: -3, z: 2 }, size: 12\n\
\n\
--- let p1a = p1.clone() ---\n\
&quot;p1a.clone()&quot;: Point1 { 42, -3, 2 }\n\
\n\
&quot;p2&quot;: Point2&lt;T&gt; {\n\
  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n\
  0.0, 0.0, 0.0\n\
}\n\
--- show_type(p2, &quot;p2&quot;) ---\n\
call name: &quot;p2&quot;, type: &quot;rust_hello_objects::points::Point2&lt;f64&gt;&quot;  \n\
--- show_value_enum(p2.coors(), &quot;p2&quot;, 2, 7) ---\n\
&quot;p2.coors()&quot; {\n\
  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n\
  0.0, 0.0, 0.0\n\
}\n\
size: 24\n\
\n\
--- p2.coors()[2] = 3.1415 ---\n\
--- show_value_enum(p2.coors(), &quot;p2.coors()&quot;, 2, 7) ---\n\
&quot;p2.coors()&quot; {\n\
  0.0, 0.0, 3.1415, 0.0, 0.0, 0.0, 0.0,\n\
  0.0, 0.0, 0.0\n\
}\n\
size: 24\n\
\n\
&quot;p2a&quot;: Point2&lt;T&gt; {\n\
  0, 1, 2, 3, 4, 4, 3,\n\
  2, 1, 0\n\
}\n\
\n\
--- show_type_scalar(p2a, &quot;p2a&quot;) ---\n\
call name: &quot;p2a&quot;, type: &quot;rust_hello_objects::points::Point2&lt;i32&gt;&quot; \n\
value: Point2 { coor: [0, 1, 2, 3, 4, 4, 3, 2, 1, 0] }, size: 24  \n\
p2a.len() = 10\n\
\n\
--- p2a.show(&quot;p2a&quot;, 2, 7) ---\n\
&quot;p2a&quot;: Point2&lt;T&gt; {\n\
  0, 1, 2, 3, 4, 4, 3,\n\
  2, 1, 0\n\
}\n\
\n\
-----------------------------------\n\
  Testing formats for collections\n\
-----------------------------------\n\
\n\
--- show_type_scalar(&v, &quot;&v&quot;) ---\n\
call name: &quot;&v&quot;, type: &quot;alloc::vec::Vec&lt;i32&gt;&quot;\n\
value: [0, -1, 2, -3, 4, -5, 6, -7, 8, -9, 10, -11, 12, -13, 14], size: 24\n\
\n\
--- show_fold(&v, 2, 5) ---\n\
  0, -1, 2, -3, 4,\n\
  -5, 6, -7, 8, -9,\n\
  10, -11, 12, -13, 14\n\
\n\
--- let v = vec![0i32, ... ]; ---\n\
--- fold(&v, 2, 12) ---\n\
  0, -1, 2, -3, 4, -5, 6, -7, 8, -9, 10, -11,\n\
  12, -13, 14\n\
\n\
--- let a = &[f64; 8]; ---\n\
--- show_fold(a, 4, 5) ---\n\
    1.0, 2.5, -3.1, 4.3, 5.0,\n\
    6.0, 7.0, -8.0\n\
\n\
\n\
  That's all Folks!\n\
\n\
\n\</pre>";
    }

    function loadRsBld(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_hello_objects\n\
&gt; cargo clean\n\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_hello_objects\n\
&gt; cargo run  \n\
   Compiling rust_hello_objects v0.1.0 (C:&#92;github&#92;JimFawcett&#92;Bits&#92;Rust&#92;rust_hello_objects)\n\
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s                  \n\
     Running `target&#92;debug&#92;rust_hello_objects.exe`\n\
\n\
\n\</pre>";
    }
  </script>

  <script>
    /*-- Load Python Code, Output, Build --*/
    function loadPyCode(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div class='code' style='margin-top:0em;'>\n\
<div style='white-space:normal; margin-left:2em;'>\
<details>\
  <summary class='darkItem' style='margin-left:-2em;'>Code Notes&nbsp;&nbsp;</summary>\
  <ol class='tight' style='margin-left:0em;'>\
    <li>\
      This code is a simple demonstration of Python types string, list, complex,\n\
      and also user defined type Point1 and their instances.\
    </li>\
    <li>\
      All Python types are reference types with values stored in heap.\
    </li>\
    <li>\
      showType functions are designed to display type and calling name of\n\
      first argument and value and size.\
    </li>\
    <li>\
      Note that the display and analysis functions are simpler than those for\n\
      C++, Rust, and especially C#\
    </li>\
    <li>\
      Python does not have generics. It is dynamically typed, so\n\
      everything is already generic.\
    </li>\
  </ol >\
  <div style=&quot;height: 3em;&quot;>&nbsp;</div>\
</details >\
</div >\
<pre>\n\
import sys\n\
import copy\n\
import Analysis\n\
</pre>\
<details>\
  <summary class='darkItem' style='margin-left:0em;'>Analysis.py&nbsp;&nbsp;</summary>\
<pre><div class=&quot;code&quot;>\
# Analysis.py\n\
\n\
import sys\n\
\n\
# Python requires definition before use ordering\n\
#  - no link phase to find definitions\n\
import copy\n\
nl = &quot;&#92;n&quot;\n\
\n\
# show name, type, value, and size of a Python instance\n\
def showType(t, nm, suffix = &quot;&quot;) :\n\
    print(nm, type(t), &quot;dynamic&quot;)\n\
    print(&quot;value: &quot;, t, ', size: ', sys.getsizeof(t), suffix)\n\
\n\
# generate indent string with n spaces\n\
def indent(n):\n\
    tmpStr = &quot;&quot;\n\
    for i in range(n):\n\
        tmpStr += ' '\n\
    return tmpStr\n\
\n\
# fold indexable into rows of width elements indented by \n\
# left spaces\n\
def fold(enum, left, width):\n\
    tmpStr = indent(left)\n\
    for i in range(len(enum)):\n\
        tmpStr += str(enum[i]) + &quot;, &quot;\n\
        if(((i + 1) % width) == 0 and i != 0):\n\
            tmpStr += &quot;&#92;n&quot; + indent(left)\n\
    rIndex = tmpStr.rindex(',')\n\
    tmpStr = tmpStr[:rIndex]\n\
    return tmpStr\n\
\n\
# show name, type, value, and size of a Python instance\n\
def showTypeEnum(enum, nm, left = 2, width = 7, suffix = &quot;&quot;) :\n\
    # topStr = indent(left) + nm + type(enum) + &quot;dynamic&quot;\n\
    print(indent(left),nm, ' ', type(enum), ' ', &quot;dynamic&quot;, sep='')\n\
    print(indent(left), &quot;{&quot;, sep='')\n\
    print(fold(enum, left+2, width))\n\
    print(indent(left), &quot;}&quot;, sep = '')\n\
    print(indent(left), &quot;size: &quot;, sys.getsizeof(enum), suffix, sep='')\n\
\n\
# same as showType except uses class method to show value\n\
def showTypeShowable(t, nm, suffix = &quot;&quot;):\n\
    print(nm, type(t), &quot;dynamic&quot;)\n\
    t.show(nm)\n\
\n\
# show Python id, unique for each instance\n\
def showIdent(t, n, suffix = &quot;&quot;) :\n\
    print(n, t, id(t), suffix)\n\
\n\
# show emphasized note\n\
def showNote(text, suffix = &quot;&quot;, n: int = 50) :\n\
    tmpStr = &quot;&quot;\n\
    for i in range(n):\n\
      tmpStr += '-'\n\
    print(tmpStr)\n\
    print(text)\n\
    print(tmpStr, suffix)\n\
\n\
# show delineated string to announce a program operation\n\
def showOp(text):\n\
    print(&quot;--- {} ---&quot;.format(text))\n\
\n\
\n\
/*---------------------------------------------------------*/\n\
/*--- End Analysis.py -------------------------------------*/\n\
/*---------------------------------------------------------*/\n\
</div></pre>\
</details>\
<pre>\
import Points\n\
</pre>\
<details>\
  <summary class='darkItem' style='margin-left:0em;'>Points.py&nbsp;&nbsp;</summary>\
<pre><div class=&quot;code&quot;>\
import Analysis\n\
\n\
# point class with three coordinates\n\
class Point1:\n\
    x = 0;\n\
    y = 0;\n\
    z = 0;\n\
\n\
    # supports constructor notation\n\
    def __init__(self) -&gt; None:\n\
        pass\n\
    \n\
    # show named value of Point1 instance\n\
    def show(self, name) :\n\
        print(&quot;{} {{ &quot;.format(name), end='')\n\
        print(&quot; x:{}, y:{}, z:{}&quot;.format(self.x, self.y, self.z), end='');\n\
        print(&quot; }&quot;);\n\
\n\
# point class with three coordinates\n\
class Point2:\n\
    coors = []\n\
\n\
    # supports constructor notation\n\
    def __init__(self, n) -&gt; None:\n\
        self.coors = list()\n\
        for i in range(n):\n\
            self.coors.append(0)\n\
    \n\
    def append(self, t):\n\
        self.coors.append(t)\n\
\n\
    def __len__(self):\n\
        return len(self.coors)\n\
\n\
    def __getitem__(self, key):\n\
        return self.coors[key]\n\
\n\
    def __setitem__(self, key, val):\n\
        self.coors[key] = val\n\
\n\
    # show named value of Point2 instance\n\
    def show(self, name) :\n\
        print(&quot;{} {{ &quot;.format(name), end='')\n\
        print(&quot; coors:{}&quot;.format(self.coors), end='');\n\
        print(&quot; }&quot;);\n\
\n\
/*---------------------------------------------------------*/\n\
/*--- End Points.py ---------------------------------------*/\n\
/*---------------------------------------------------------*/\n\
\n\</pre >\
</details>\
<pre>\
\n\
# Python/Py_Objects::Py_Objects.py\n\
# \n\
# Python Dynamic Data Types\n\
#   int, float, complex\n\
#   bytes, bytearray, memoryview\n\
#   list, tuple, range\n\
#   dict, set, frozenset\n\
#   bool\n\
#   str\n\
#   NoneType\n\
\n\
# # Python requires definition before use ordering\n\
# #  - no link phase to find definitions\n\
# Demonstration starts here\n\
def execute() : \n\
    print(&quot; Demonstrate Python Objects&quot;)\n\
    print(&quot;----------------------------&quot;)\n\
\n\
    Analysis.showNote(   \n\
        &quot;  All Python types are reference-based&#92;n&quot;&#92;\n\
        &quot;  with values in the managed heap. That&#92;n&quot;&#92;\n\
        &quot;  has consequences we explore in this demo.&quot;\n\
    )\n\
    print()\n\
\n\
    d1 = 3.1415927\n\
    Analysis.showType(d1, &quot;d1&quot;)\n\
    \n\
    s1 = &quot;a string&quot;\n\
    Analysis.showType(s1, &quot;s1&quot;)\n\
\n\
    #region\n\
    Analysis.showOp(&quot;s2 = s1&quot;)\n\
    #endregion\n\
    s2 = s1\n\
    Analysis.showIdent(s1, &quot;s1&quot;)\n\
    Analysis.showIdent(s2, &quot;s2&quot;)\n\
    #print(&quot;s2 = {}&quot;.format(s2))\n\
\n\
    #region\n\
    Analysis.showOp(&quot;s2 += &#92;&quot; and more&#92;&quot;&quot;)\n\
    #endregion\n\
    s2 += &quot; and more&quot;\n\
    Analysis.showIdent(s2, &quot;s2&quot;)\n\
    Analysis.showIdent(s1, &quot;s1&quot;)\n\
    # print(&quot;s2 = {}&quot;.format(s2))\n\
    # print(&quot;s1 = {}&quot;.format(s1))\n\
    Analysis.showNote(   \n\
        &quot;Assignment, in Python, assigns references not&#92;n&quot;&#92;\n\
        &quot;values.  So s1 and s2 share same heap instance&#92;n&quot;&#92;\n\
        &quot;But strings are immutable. So when a change is&#92;n&quot;&#92;\n\
        &quot;made to one, that creates a new instance without&#92;n&quot;&#92;\n\
        &quot;changing the original.&quot;\n\
    )\n\
    print()\n\
\n\
    l1 = [&quot;you&quot;, &quot;me&quot;, &quot;them&quot;, &quot;us&quot;]\n\
    Analysis.showType(l1, &quot;l1&quot;, Analysis.nl)\n\
\n\
    print(&quot;l1 = &quot;, l1)\n\
    \n\
    #region\n\
    Analysis.showOp(&quot;l2 = l1&quot;)\n\
    #endregion\n\
    l2 = l1\n\
    \n\
    #region\n\
    Analysis.showOp('l2.append(&quot;everyone&quot;)')\n\
    #endregion\n\
    l2.append(&quot;everyone&quot;)\n\
    print(&quot;l2 = &quot;, l2)\n\
    print(&quot;l1 = &quot;, l1)\n\
    \n\
    #region\n\
    Analysis.showOp('l2[1] = &quot;myself&quot;')\n\
    #endregion\n\
    l2[1] = &quot;myself&quot;\n\
    print(&quot;l2 = &quot;, l2)\n\
    print(&quot;l1 = &quot;, l1)\n\
    Analysis.showNote(   \n\
        &quot;Changes to target of assignment affect source&#92;n&quot;&#92;\n\
        &quot;except for immutable strings, as we are required&#92;n&quot;&#92;\n\
        &quot;to create new string instead of modify.&#92;n&quot;&#92;\n\
        &quot;&#92;&quot;caveat emptor&#92;&quot;&quot;\n\
    )\n\
    print()\n\
\n\
    #region\n\
    Analysis.showOp(&quot;p1a = Point1()&quot;)\n\
    #endregion\n\
    p1a = Points.Point1()\n\
    \n\
    #region\n\
    Analysis.showOp(&quot;Analysis.showTypeShowable(p1a, &#92;&quot;p1a&#92;&quot;, nl)&quot;)\n\
    #endregion\n\
    Analysis.showTypeShowable(p1a, &quot;p1a&quot;, Analysis.nl)\n\
    p1a.x = 2\n\
    p1a.y = -3.5\n\
    p1a.z = -42\n\
    p1a.show(&quot;p1a&quot;)\n\
\n\
    #region\n\
    Analysis.showOp(&quot;p1b = p1a&quot;)\n\
    #endregion\n\
    p1b = p1a\n\
    p1b.show(&quot;p1b&quot;)\n\
\n\
    #region\n\
    Analysis.showOp(&quot;p1b.y = 13&quot;)\n\
    #endregion\n\
    p1b.y = 13\n\
    p1b.show(&quot;p1b&quot;)\n\
    p1a.show(&quot;p1a&quot;)\n\
    Analysis.showNote(\n\
        &quot;Reference assigned, not value.&#92;nSo change&quot;&#92;\n\
        &quot; in P1b changed source p1a.&quot;\n\
    )\n\
    print()\n\
\n\
    #region\n\
    Analysis.showOp(&quot;p1c = copy.deepcopy(p1b)&quot;)\n\
    #endregion\n\
    p1c = copy.deepcopy(p1b)\n\
    p1c.show(&quot;p1c&quot;);\n\
    p1b.show(&quot;p1b&quot;)\n\
\n\
    #region\n\
    Analysis.showOp(&quot;p1c.z = 12&quot;)\n\
    #endregion\n\
    p1c.z = 12\n\
    p1c.show(&quot;p1c&quot;)\n\
    p1b.show(&quot;p1b&quot;)\n\
    Analysis.showNote(\n\
        &quot;p1c.z reference assigned, not value. But no&#92;n&quot;&#92;\n\
        &quot;change in p1b since p1c is deep clone of p1b.&quot;\n\
    )\n\
    print()\n\
\n\
    p2 = Points.Point2(3)\n\
\n\
    #region\n\
    Analysis.showOp(&quot;p2.show(&#92;&quot;p2&#92;&quot;)&quot;)\n\
    #endregion\n\
    p2.show(&quot;p2&quot;)\n\
    p2[1] = 1\n\
    p2[2] = 2\n\
    p2.append(3)\n\
    p2.show(&quot;p2&quot;)\n\
    for i in range(10):\n\
         p2.append(10 - i)\n\
\n\
    #region\n\
    Analysis.showOp(&quot;p2.show(&#92;&quot;p2&#92;&quot;)&quot;)\n\
    #endregion\n\
    p2.show(&quot;p2&quot;)\n\
\n\
    #region\n\
    Analysis.showOp(&quot;showTypeEnum(p2, &#92;&quot;p2&#92;&quot;, 2, 7)&quot;)\n\
    #endregion\n\
    Analysis.showTypeEnum(p2,&quot;p2&quot;, 2, 7)\n\
    print()\n\
\n\
    # # reference behavior - new child object\n\
    #region\n\
    Analysis.showOp(&quot;t5 = (1, 2, 3)&quot;)\n\
    #endregion\n\
    t5 = (1, 2, 3)\n\
    Analysis.showIdent(t5, &quot;t5&quot;)\n\
\n\
    #region\n\
    Analysis.showOp(&quot;t6 = [1, t5, &#92;&quot;weird&#92;&quot;]&quot;)\n\
    #endregion\n\
    t6 = [1, t5, &quot;weird&quot;]\n\
    Analysis.showIdent(t6, &quot;t6&quot;)\n\
    Analysis.showType(t6, &quot;t6&quot;)\n\
    print(&quot;-- t5 = 1 + 1j : new object --&quot;)\n\
    t5 = 1 + 1j\n\
    Analysis.showIdent(t5, &quot;t5&quot;)\n\
    Analysis.showIdent(t6, &quot;t6&quot;)\n\
    Analysis.showNote(\n\
        &quot;new object for t5, t6 not affected&quot;, Analysis.nl\n\
    )\n\
    \n\
    # # reference behavior - iterate over children\n\
    print(&quot;-- iterate over t6 children --&quot;)\n\
    for i in t6:\n\
        Analysis.showIdent(i, &quot;elem&quot;)\n\
\n\
    # print(&quot;&#92;n-- iterate over t6 methods --&quot;)\n\
    # print(dir(t6))\n\
      \n\
    print(&quot;&#92;nThat's all folks!&#92;n&quot;)\n\
\n\
execute()\n\
\n\
\n\\n\</pre>\n\
</div>\n\
";
    }

    function loadPyOut(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div class='code'>\n\
<pre>\n\
 Demonstrate Python Objects\n\
----------------------------\n\
--------------------------------------------------\n\
  All Python types are reference-based\n\
  with values in the managed heap. That\n\
  has consequences we explore in this demo.\n\
--------------------------------------------------\n\
\n\
d1 &lt;class 'float'&gt; dynamic\n\
value:  3.1415927 , size:  24\n\
s1 &lt;class 'str'&gt; dynamic\n\
value:  a string , size:  57\n\
--- s2 = s1 ---\n\
s1 a string 2950105212208\n\
s2 a string 2950105212208\n\
--- s2 += &quot; and more&quot; ---\n\
s2 a string and more 2950105224480\n\
s1 a string 2950105212208\n\
--------------------------------------------------\n\
Assignment, in Python, assigns references not\n\
values.  So s1 and s2 share same heap instance\n\
But strings are immutable. So when a change is\n\
made to one, that creates a new instance without\n\
changing the original.\n\
--------------------------------------------------\n\
\n\
l1 &lt;class 'list'&gt; dynamic\n\
value:  ['you', 'me', 'them', 'us'] , size:  88\n\
\n\
l1 =  ['you', 'me', 'them', 'us']\n\
--- l2 = l1 ---\n\
--- l2.append(&quot;everyone&quot;) ---\n\
l2 =  ['you', 'me', 'them', 'us', 'everyone']\n\
l1 =  ['you', 'me', 'them', 'us', 'everyone']\n\
--- l2[1] = &quot;myself&quot; ---\n\
l2 =  ['you', 'myself', 'them', 'us', 'everyone']\n\
l1 =  ['you', 'myself', 'them', 'us', 'everyone']\n\
--------------------------------------------------\n\
Changes to target of assignment affect source\n\
except for immutable strings, as we are required\n\
to create new string instead of modify.\n\
&quot;caveat emptor&quot;\n\
--------------------------------------------------\n\
\n\
--- p1a = Point1() ---\n\
--- Analysis.showTypeShowable(p1a, &quot;p1a&quot;, nl) ---\n\
p1a &lt;class 'Points.Point1'&gt; dynamic\n\
p1a {  x:0, y:0, z:0 }\n\
p1a {  x:2, y:-3.5, z:-42 }\n\
--- p1b = p1a ---\n\
p1b {  x:2, y:-3.5, z:-42 }\n\
--- p1b.y = 13 ---\n\
p1b {  x:2, y:13, z:-42 }\n\
p1a {  x:2, y:13, z:-42 }\n\
--------------------------------------------------\n\
Reference assigned, not value.\n\
So change in P1b changed source p1a.\n\
--------------------------------------------------\n\
\n\
--- p1c = copy.deepcopy(p1b) ---\n\
p1c {  x:2, y:13, z:-42 }\n\
p1b {  x:2, y:13, z:-42 }\n\
--- p1c.z = 12 ---\n\
p1c {  x:2, y:13, z:12 }\n\
p1b {  x:2, y:13, z:-42 }\n\
--------------------------------------------------\n\
p1c.z reference assigned, not value. But no\n\
change in p1b since p1c is deep clone of p1b.\n\
--------------------------------------------------\n\
\n\
--- p2.show(&quot;p2&quot;) ---\n\
p2 {  coors:[0, 0, 0] }\n\
p2 {  coors:[0, 1, 2, 3] }\n\
--- p2.show(&quot;p2&quot;) ---\n\
p2 {  coors:[0, 1, 2, 3, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1] }   \n\
--- showTypeEnum(p2, &quot;p2&quot;, 2, 7) ---\n\
  p2 &lt;class 'Points.Point2'&gt; dynamic\n\
  {\n\
    0, 1, 2, 3, 10, 9, 8,\n\
    7, 6, 5, 4, 3, 2, 1\n\
  }\n\
  size: 48\n\
\n\
--- t5 = (1, 2, 3) ---\n\
t5 (1, 2, 3) 2950105210176\n\
--- t6 = [1, t5, &quot;weird&quot;] ---\n\
t6 [1, (1, 2, 3), 'weird'] 2950105545792\n\
t6 &lt;class 'list'&gt; dynamic\n\
value:  [1, (1, 2, 3), 'weird'] , size:  80\n\
-- t5 = 1 + 1j : new object --\n\
t5 (1+1j) 2950104588272\n\
t6 [1, (1, 2, 3), 'weird'] 2950105545792\n\
--------------------------------------------------\n\
new object for t5, t6 not affected\n\
--------------------------------------------------\n\
\n\
-- iterate over t6 children --\n\
elem 1 2950103564528\n\
elem (1, 2, 3) 2950105210176\n\
elem weird 2950105216560\n\
\n\
That's all folks!\n\
\n\
\n\</pre>\n\
</div>";
    }

    function loadPyBld(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\
<pre>\n\
C:&#92;github&#92;JimFawcett&#92;Bits&#92;Python&#92;Py_Data\n\
&gt; python Py_Data.py\n\
 Demonstrate Python Types\n\
--------------------------\n\
\n\</pre>";
    }
  </script>

  <script>
    /*-- Load Javascript Code, Output, Build --*/
    function loadJsCode(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<div style='white-space:normal; margin-left:2em;'>\
<details>\
  <summary class='darkItem' style='margin-left:-2em;'>Code Notes&nbsp;&nbsp;</summary>\
  <ol class='tight' style='margin-left:0em;'>\
    <li>\
      JavaScript is typically used to manipulate the document tree of a loaded\
      HTML page, responding to user and system events, e.g., implementing menus\
      and responding to user events.\
    </li>\
    <li>\
      That is not what we will be exploring in this page.  Our focus is on how the\
      JavaScript language works, especially its types and objects.\
    </li>\
    <li>\
      Specifically, this code is a demonstration of strings, arrays, and user-defined objects.\
    </li>\
    <li>\
      All JavaScript types are reference types with values stored in a managed heap. That has consequences\
      we address here too.\
    </li>\
    <li>\
      JavaScript does not have generics. It is dynamically typed, so\n\
      everything is already generic.\
    </li>\
    <li>\
      Several functions, defined at the bottom of this code are used to illustrate JavaScript features.\
    </li>\
    <li>\
      Note that the display functions are simple but the analysis function sizeof(object)\n\
      requires recursive iteration through the members and decendents of object.\
    </li>\
    <li>\
      showType function is designed to display type and calling name of its\n\
      first argument and its value and size.\
    </li>\
  </ol >\
  <div style=&quot;height: 3em;&quot;>&nbsp;</div>\
</details >\
</div >\
<div class='code'>\
<pre>\
&lt;!DOCTYPE html&gt;\n\
&lt;html&gt;\n\
&lt;!-- \n\
  Js_Objects.html \n\
\n\
  Illustrate creation and use of JavaScript objects.\n\
\n\
  JavaScript Types.\n\
    Number, Bigint, Boolean, String,\n\
    Undefined, Null, Symbol, Object\n\
    - arrays are typed as objects\n\
    Other important library types:\n\
    - Date, Maps, Sets, JSON, \n\
\n\
    All of these are reference types.\n\
    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\n\
--&gt;\n\
&lt;head&gt;\n\
  &lt;script src=&quot;Analysis.js&quot;&gt;&lt;/script&gt;\n\
</pre>\
<details>\
  <summary class='darkItem' style='margin-left:0em;'>Analysis.js&nbsp;&nbsp;</summary>\
<pre><div class=&quot;code&quot;>\
/*--------------------------------------------------------------------\n\
    Display and Analysis functions\n\
*/\n\
    function print(str) {\n\
    document.write(str);\n\
    }\n\
    function println(str) {\n\
    document.write(str + &quot;&lt;br /&gt;&quot;);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Display emphasized text\n\
    */\n\
    function showNote(text) {\n\
    document.write(&quot;-------------------------&lt;br /&gt;&quot;);\n\
    document.write(text, &quot;&lt;br /&gt;&quot;);\n\
    document.write(&quot;-------------------------&lt;br /&gt;&quot;);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Show an operation expression surrounded with a few dashes\n\
    */\n\
    function showOp(text) {\n\
    document.write(&quot;--- &quot;);\n\
    document.write(text)\n\
    document.write(&quot; ---&lt;br /&gt;&quot;);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Show basic type information\n\
    */\n\
    function showType(t, nm, left=4, width=7) {\n\
    if(typeof t != typeof Object()) {\n\
        println(nm + &quot;: &quot; + typeof t);\n\
        print(&quot;size: &quot; + sizeof(t) + &quot;, value: &quot; + t);\n\
    }\n\
    else {\n\
        println(&quot;type: &quot; + typeof t);\n\
        showObject(t, nm, left, width);\n\
        print(&quot;size: &quot; + sizeof(t));\n\
    }\n\
    println(nil);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Show type information using object's show() method\n\
    */\n\
    function showTypeShowable(t, nm) {\n\
    print(nm + &quot;, &quot; + typeof t);\n\
    print(&quot;, size: &quot;);\n\
    println(sizeof(t));\n\
    print(&quot;value: &quot;);\n\
    t.show(nm);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Do references o1 and o2 have same address (point to same instance)\n\
    */\n\
    function isSameObject(o1, nm1, o2, nm2) {\n\
    if (o1 === o2) {\n\
        println(nm1 + &quot; is same object as &quot; + nm2)\n\
    }\n\
    else {\n\
        println(nm1 + &quot; is not same object as &quot; + nm2)\n\
    }\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Create a string containing n non-breaking spaces, &nbsp;....\n\
    Part of formatJSONstr(...)\n\
    */\n\
    function indent(n) {\n\
    let tmp = &quot;&quot;;\n\
    for(i=0; i&lt;n; ++i) {\n\
        tmp += &quot;&nbsp;&quot;;\n\
    }\n\
    return tmp;\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Replace comma character with comma escape, e.g., &#44;.\n\
    Expects index to point to comma in str. This is done to\n\
    avoid splitting inner array by JSON.stringify.\n\
    Part of formatJSONstr(...)\n\
    */\n\
    function replaceComma(str, index) {\n\
    if(index &lt; 0 || str.length &lt;= index) {\n\
        return str;\n\
    }\n\
    let tmp = str.substr(0, index-1) + &quot;&#44;&quot; + str.substr(index);\n\
    // document.writeln(&quot;test: &quot; + JSON.stringify('1&#44;2'));\n\
    return tmp;\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Treat inner array as a single element for JSON string formatting.\n\
    Part of formatJSONstr(...)\n\
    */\n\
    function weldArray(jstr) {\n\
    isArray = false;\n\
    tmp = jstr;\n\
    let j=0;\n\
    for(i=0; i&lt;jstr.length; ++i) {\n\
        j += 1;\n\
        switch(jstr[i]) {\n\
        case '[':\n\
            if(i != 0) {  // don't count outer array\n\
            isArray = true;\n\
            }\n\
            break;\n\
        case ']':\n\
            isArray = false;\n\
            break;\n\
        case ',':\n\
            if(isArray) {\n\
            tmp = replaceComma(tmp, j);\n\
            j += 4;\n\
            }\n\
            break;\n\
        }\n\
    }\n\
    return tmp;\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Format JSON string to indent left spaces and show rows of width elements\n\
    */\n\
    function formatJSONstr(jstr, left=4, width=8) {\n\
    let indtCache = indent(left);\n\
    jstr = weldArray(jstr);\n\
    jstr = jstr.trim();\n\
    let char1 = jstr[0];\n\
    let char2 = jstr[jstr.length - 1];\n\
    let jstrm = jstr.substring(1, jstr.length - 1); // remove delimiters\n\
    let fstr = jstrm.split(/[,]+/); // regex selects on either &quot; &quot; or ,\n\
    let fm = char1 + &quot;&lt;br /&gt;&quot; + indtCache;\n\
    for(i=0; i&lt;fstr.length; ++i) {\n\
        fm += fstr[i] + &quot;, &quot;;\n\
        if((i+1) % width === 0 && i != fstr.length -1) {\n\
        fm += &quot;&lt;br /&gt;&quot; + indtCache;\n\
        }\n\
    }\n\
    fm = fm.substring(0, fm.length - 2);\n\
    fm += &quot;&lt;br /&gt;&quot; + char2 + &quot;&lt;br /&gt;&quot;;\n\
    return fm;\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Use JSONstringify to show all data members of object with body\n\
    indented by left spaces and elements shown in rows of specified \n\
    width. Used in showType(...)\n\
    */\n\
    function showObject(obj, nm, left=4, width=7) {\n\
    document.write(nm, &quot;: &quot;);\n\
    let fmts = formatJSONstr(JSON.stringify(obj), left, width);\n\
    document.write(fmts);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Iterate through object's own keys, ignore objects, and display\n\
    - only shows top level elements, e.g., no recursion\n\
    - not used in demo\n\
    - here to illustrate iterating through object elements\n\
    */\n\
    function showObject_alt(obj, nm) {\n\
    let str = &quot;&quot;;\n\
    for(let [key, value] of Object.entries(obj)) {\n\
        if(obj.hasOwnProperty(key) && typeof value != typeof Object) {\n\
        str += &quot;{&quot; + key + &quot;: &quot; + value + &quot;}, &quot;;\n\
        }\n\
    }\n\
    /* remove trailing comma and space */\n\
    str = str.substring(0, str.length - 2);\n\
    document.write(nm, &quot; { &quot;, str, &quot; }&quot;, nl);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
    Evaluate object's size by iterating through own properties\n\
    // https://gist.github.com/pgpbpadilla/10344038\n\
    */\n\
    function sizeof(object) {\n\
    var objectList = [],\n\
        stack = [ object ],\n\
        bytes = 0,\n\
        value,\n\
        i;\n\
\n\
    while (stack.length) {\n\
        value = stack.pop();\n\
\n\
        if (typeof value === 'boolean') {\n\
        bytes += 4;\n\
        } else if (typeof value === 'string') {\n\
        bytes += value.length * 2;\n\
        } else if (typeof value === 'number') {\n\
        bytes += 8;\n\
        } else if (typeof value === 'object'\n\
            && objectList.indexOf(value) === -1) {\n\
        objectList.push(value);\n\
\n\
        for (i in value) {\n\
            if (value.hasOwnProperty(i)) {\n\
            stack.push(value[i]);\n\
            }\n\
        }\n\
        }\n\
    }\n\
    return bytes;\n\
    }\n\
/*---------------------------------------------------------*/\n\
/*--- End Analysis.js -------------------------------------*/\n\
/*---------------------------------------------------------*/\n\
\n\</div></pre>\
</details>\
<pre>\
  &lt;script&gt;\n\
    /*--------------------------------------------------------------------\n\
      Used as program-wide constants for display\n\
    */\n\
    const nl = &quot;&lt;br /&gt;&quot;;\n\
    const tab = &quot;&nbsp;&nbsp;&quot;\n\
    const nil = &quot;&quot;;\n\
\n\
    function heading() {\n\
            document.getElementById(&quot;objects&quot;).innerHTML = &quot;&lt;h2&gt;Javascript Objects&lt;/h2&gt;&quot;;\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Demonstration starts here \n\
    */\n\
    function execute() {\n\
      showNote(&quot;Demo Objects&quot;)\n\
\n\
      /*------------------------------------------------------------------\n\
        built in objects\n\
      ------------------------------------------------------------------*/\n\
      showNote(&quot;Built-in instances&quot;);\n\
      let d = 3.1415927;\n\
      showType(d, &quot;d&quot;);\n\
      println(&quot;---&quot;);\n\
\n\
      let s = &quot;s&quot;;\n\
      showType(s, &quot;string&quot;);\n\
      println(&quot;---&quot;);\n\
      \n\
      let a = [1, 2, 3];\n\
      showType(a, &quot;array&quot;);\n\
      println(&quot;---&quot;);\n\
      \n\
      let o = new Object();\n\
      o.elem = &quot;some element&quot;;\n\
      o.say = function() { document.write(&quot;Hello&quot; + nl)};\n\
      showType(o, &quot;o&quot;);\n\
      o.say();\n\
      \n\
      showOp(&quot;more elaborate data&quot;);\n\
      let arr = [1, 'z', [1, 2, 3], true];\n\
      showType(arr, &quot;arr&quot;);\n\
      println(&quot;---&quot;);\n\
\n\
      /* add show method to existing array */\n\
      println(\n\
        &quot;you can add methods to any object, including&quot; + nl +\n\
        &quot;arrays and functions.&quot;\n\
      )\n\
      arr.show = function(nm) {\n\
        document.write(nm, &quot; [ &quot;);\n\
        arr.forEach(element =&gt; {\n\
          document.write(element, &quot; &quot;);\n\
        });\n\
        document.write(&quot;]&quot; + nl);\n\
      }\n\
      showOp(&quot;arr.show(nm)&quot;);\n\
      arr.show(&quot;arr&quot;);\n\
      println(nil);\n\
\n\
      println(\n\
        &quot;Here see the results of using two other analyzer methods&quot; +nl +\n\
        &quot;on the arr array:&quot;\n\
      )\n\
      /*------------------------------------------------------------------\n\
        showTypeShowable uses show(...) method provided by analyzed type.\n\
        It works with any object that provides a show(...) method.\n\
      */\n\
      /* so now showTypeShowable can be used */\n\
      showOp(&quot;showTypeShowable(arr, &#92;&quot;arr&#92;&quot;)&quot;);\n\
      showTypeShowable(arr, &quot;arr&quot;);\n\
      showOp(&quot;showObject(arr, &#92;&quot;arr&#92;&quot;)&quot;);\n\
      showObject(arr, &quot;arr&quot;);\n\
      print(nl);\n\
\n\
      /*------------------------------------------------------------------\n\
       crafting object by hand \n\
      ------------------------------------------------------------------*/\n\
      showNote(&quot;User-defined object literal&quot;);\n\
    \n\
      const dev = {\n\
        name:&quot;Jim&quot;, \n\
        job:&quot;Retired from Syracuse University&quot;, \n\
        hobby:&quot;Developing software&quot;,\n\
        projects: [ 'Bits language comparisons', 'Stories', 'Bites' ]\n\
      }\n\
      showObject(dev, &quot;dev&quot;);\n\
\n\
      /* creating show function tailored to dev objects */\n\
      dev.show = function(nm) {\n\
        document.write(nm, &quot;: {&quot;,nl,tab,&quot;name: &quot;, this.name, \n\
        nl, tab, &quot;job: &quot;, this.job, nl, tab, &quot;hobby: &quot;, \n\
        this.hobby, nl, tab, &quot;projects: &quot;, this.projects,  \n\
        nl, &quot;}&lt;br /&gt;&quot;);\n\
      }\n\
      /* using 3 ways to display information about an object */\n\
      showOp(&quot;dev.show(&#92;&quot;dev&#92;&quot;)&quot;);\n\
      dev.show(&quot;dev&quot;);\n\
      showOp(&quot;showTypeShowable(dev, &#92;&quot;dev&#92;&quot;)&quot;);\n\
      showTypeShowable(dev, &quot;dev&quot;);\n\
      showOp(&quot;showType(dev, &#92;&quot;dev&#92;&quot;)&quot;);\n\
      showType(dev, &quot;dev&quot;, 4, 1);\n\
\n\
      /*------------------------------------------------------------------\n\
        using JavaScript class \n\
      ------------------------------------------------------------------*/\n\
      showNote(&quot;Using JavaScript class&quot;);\n\
\n\
      class Point1 {\n\
        constructor(x, y, z) {\n\
          this.x = x;\n\
          this.y = y;\n\
          this.z = z;\n\
        }\n\
        show(name) {\n\
          document.write(name, &quot;: Point1 {&quot;, nl, tab);\n\
          document.write(this.x, &quot;, &quot;, this.y, &quot;, &quot;, this.z);\n\
          document.write(nl, &quot;}&quot;, nl);\n\
        }\n\
      }\n\
\n\
      let p1 = new Point1(1, 2, 3);\n\
\n\
      showOp(&quot;showObject(p1, &#92;&quot;p1&#92;&quot;)&quot;);\n\
      showObject(p1, &quot;p1&quot;);\n\
      showOp(&quot;p1.show(&#92;&quot;p1&#92;&quot;)&quot;);\n\
      p1.show(&quot;p1&quot;);\n\
      showOp(&quot;showTypeShowable(p1, &#92;&quot;p1&#92;&quot;)&quot;);\n\
      showTypeShowable(p1, &quot;p1&quot;);\n\
      showOp(&quot;showType(p1, &#92;&quot;p1&#92;&quot;)&quot;);\n\
      showType(p1, &quot;p1: Point1&quot;);\n\
      println(nil);\n\
\n\
      /*------------------------------------------------------------------\n\
        exploring concequences of JavaScript object model\n\
      */\n\
      showNote(\n\
        &quot;Exploring consequences of JavaScript reference types:&quot;\n\
      )\n\
      showOp(&quot;let p2 = p1&quot;);\n\
      let p2 = p1;\n\
      p2.show(&quot;p2&quot;);\n\
      isSameObject(p2, &quot;p2&quot;, p1, &quot;p1&quot;);\n\
      showOp(&quot;p2.z = -42&quot;);\n\
      p2.z = -42;\n\
      p2.show(&quot;p2&quot;);\n\
      p1.show(&quot;p1&quot;);\n\
      isSameObject(p2, &quot;p2&quot;, p1, &quot;p1&quot;);\n\
      showNote(\n\
        &quot;All JavaScript variables are reference types. So assignments assign&quot; + nl +\n\
        &quot;references, not values. And so changing target, p2, changed source, p1&quot;\n\
      )\n\
      print(nl);\n\
      /*------------------------------------------------------------------\n\
        Used for testing display functions\n\
      */\n\
      showNote(\n\
        &quot;The displays below are used to test and demonstrate how&quot; + nl +\n\
        &quot;display and analysis functions work. Those are all defined&quot; + nl +\n\
        &quot;after the end of the execute() function.&quot;\n\
      )\n\
      showOp(&quot;p1.show(&#92;&quot;p1&#92;&quot;)&quot;);\n\
      p1.show(&quot;p1&quot;);\n\
      println(nil);\n\
\n\
      showOp(&quot;showObject(p1, &#92;&quot;p1&#92;&quot;)&quot;);\n\
      showObject(p1, &quot;p1&quot;);\n\
      println(nil);\n\
\n\
      let tst = { &quot;a&quot;:&quot;1&quot;, &quot;b&quot;:[&quot;2&quot;, &quot;3&quot;] };\n\
      showType(tst, &quot;test display formatting&quot;);\n\
      println(nil);\n\
\n\
      showOp(&quot;let testarr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&quot;);\n\
      let testarr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
      /* using default values for width=7 and left=4 */\n\
      showObject(testarr, &quot;testarr&quot;);\n\
\n\
      print(nl + &quot;That&apos;s all Folks!&quot; + nl);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Display and Analysis functions\n\
    */\n\
    function print(str) {\n\
      document.write(str);\n\
    }\n\
    function println(str) {\n\
      document.write(str + &quot;&lt;br /&gt;&quot;);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Display emphasized text\n\
    */\n\
    function showNote(text) {\n\
      document.write(&quot;-------------------------&lt;br /&gt;&quot;);\n\
      document.write(text, &quot;&lt;br /&gt;&quot;);\n\
      document.write(&quot;-------------------------&lt;br /&gt;&quot;);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Show an operation expression surrounded with a few dashes\n\
    */\n\
    function showOp(text) {\n\
      document.write(&quot;--- &quot;);\n\
      document.write(text)\n\
      document.write(&quot; ---&lt;br /&gt;&quot;);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Show basic type information: works for scalar types\n\
    */\n\
    function showType(t, nm, left=4, width=7) {\n\
      if(typeof t != typeof Object()) {\n\
        println(nm + &quot;: &quot; + typeof t);\n\
        print(&quot;size: &quot; + sizeof(t) + &quot;, value: &quot; + t);\n\
      }\n\
      else {\n\
        println(&quot;type: &quot; + typeof t);\n\
        showObject(t, nm, left, width);\n\
        print(&quot;size: &quot; + sizeof(t));\n\
      }\n\
      println(nil);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Show type information using object's show() method\n\
    */\n\
    function showTypeShowable(t, nm) {\n\
      print(nm + &quot;, &quot; + typeof t);\n\
      print(&quot;, size: &quot;);\n\
      println(sizeof(t));\n\
      print(&quot;value: &quot;);\n\
      t.show(nm);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Do references o1 and o2 have same address (point to same instance)\n\
    */\n\
    function isSameObject(o1, nm1, o2, nm2) {\n\
      if (o1 === o2) {\n\
        println(nm1 + &quot; is same object as &quot; + nm2)\n\
      }\n\
      else {\n\
        println(nm1 + &quot; is not same object as &quot; + nm2)\n\
      }\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Create a string containing n non-breaking spaces, &nbsp;....\n\
      Part of formatJSONstr(...)\n\
    */\n\
    function indent(n) {\n\
      let tmp = &quot;&quot;;\n\
      for(i=0; i&lt;n; ++i) {\n\
        tmp += &quot;&nbsp;&quot;;\n\
      }\n\
      return tmp;\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Replace comma character with comma escape, e.g., &#44;.\n\
      Expects index to point to comma in str. This is done to\n\
      avoid splitting inner array by JSON.stringify.\n\
      Part of formatJSONstr(...)\n\
    */\n\
    function replaceComma(str, index) {\n\
      if(index &lt; 0 || str.length &lt;= index) {\n\
        return str;\n\
      }\n\
      let tmp = str.substr(0, index-1) + &quot;&#44;&quot; + str.substr(index);\n\
      // document.writeln(&quot;test: &quot; + JSON.stringify('1&#44;2'));\n\
      return tmp;\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Treat inner array as a single element for JSON string formatting.\n\
      Part of formatJSONstr(...)\n\
    */\n\
    function weldArray(jstr) {\n\
      isArray = false;\n\
      tmp = jstr;\n\
      let j=0;\n\
      for(i=0; i&lt;jstr.length; ++i) {\n\
        j += 1;\n\
        switch(jstr[i]) {\n\
          case '[':\n\
            if(i != 0) {  // don't count outer array\n\
              isArray = true;\n\
            }\n\
            break;\n\
          case ']':\n\
            isArray = false;\n\
            break;\n\
          case ',':\n\
            if(isArray) {\n\
              tmp = replaceComma(tmp, j);\n\
              j += 4;\n\
            }\n\
            break;\n\
        }\n\
      }\n\
      return tmp;\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Format JSON string to indent left spaces and show rows of width elements\n\
    */\n\
    function formatJSONstr(jstr, left=4, width=8) {\n\
      let indtCache = indent(left);\n\
      jstr = weldArray(jstr);\n\
      jstr = jstr.trim();\n\
      let char1 = jstr[0];\n\
      let char2 = jstr[jstr.length - 1];\n\
      let jstrm = jstr.substring(1, jstr.length - 1); // remove delimiters\n\
      let fstr = jstrm.split(/[,]+/); // regex selects on either &quot; &quot; or ,\n\
      let fm = char1 + &quot;&lt;br /&gt;&quot; + indtCache;\n\
      for(i=0; i&lt;fstr.length; ++i) {\n\
        fm += fstr[i] + &quot;, &quot;;\n\
        if((i+1) % width === 0 && i != fstr.length -1) {\n\
          fm += &quot;&lt;br /&gt;&quot; + indtCache;\n\
        }\n\
      }\n\
      fm = fm.substring(0, fm.length - 2);\n\
      fm += &quot;&lt;br /&gt;&quot; + char2 + &quot;&lt;br /&gt;&quot;;\n\
      return fm;\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Use JSONstringify to show all data members of object with body\n\
      indented by left spaces and elements shown in rows of specified \n\
      width. Used in showType(...)\n\
    */\n\
    function showObject(obj, nm, left=4, width=7) {\n\
      document.write(nm, &quot;: &quot;);\n\
      let fmts = formatJSONstr(JSON.stringify(obj), left, width);\n\
      document.write(fmts);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Iterate through object's own keys, ignore objects, and display\n\
      - only shows top level elements, e.g., no recursion\n\
      - not used in demo\n\
      - here to illustrate iterating through object elements\n\
    */\n\
    function showObject_alt(obj, nm) {\n\
      let str = &quot;&quot;;\n\
      for(let [key, value] of Object.entries(obj)) {\n\
        if(obj.hasOwnProperty(key) && typeof value != typeof Object) {\n\
          str += &quot;{&quot; + key + &quot;: &quot; + value + &quot;}, &quot;;\n\
        }\n\
      }\n\
      /* remove trailing comma and space */\n\
      str = str.substring(0, str.length - 2);\n\
      document.write(nm, &quot; { &quot;, str, &quot; }&quot;, nl);\n\
    }\n\
    /*--------------------------------------------------------------------\n\
      Evaluate object's size by iterating through own properties\n\
    // https://gist.github.com/pgpbpadilla/10344038\n\
    */\n\
    function sizeof(object) {\n\
      var objectList = [],\n\
        stack = [ object ],\n\
        bytes = 0,\n\
        value,\n\
        i;\n\
\n\
      while (stack.length) {\n\
        value = stack.pop();\n\
\n\
        if (typeof value === 'boolean') {\n\
          bytes += 4;\n\
        } else if (typeof value === 'string') {\n\
          bytes += value.length * 2;\n\
        } else if (typeof value === 'number') {\n\
          bytes += 8;\n\
        } else if (typeof value === 'object'\n\
            && objectList.indexOf(value) === -1) {\n\
          objectList.push(value);\n\
\n\
          for (i in value) {\n\
            if (value.hasOwnProperty(i)) {\n\
              stack.push(value[i]);\n\
            }\n\
          }\n\
        }\n\
      }\n\
      return bytes;\n\
    }\n\
  &lt;/script&gt;\n\
  &lt;style&gt;\n\
    body {\n\
      font-family:'Comic Sans MS', Tahoma;\n\
      padding:2em;\n\
    } \n\
  &lt;/style&gt;\n\
&lt;/head&gt;\n\
&lt;body&gt;\n\
  &lt;div id=&quot;objects&quot;&gt;&lt;/div&gt;\n\
  &lt;script&gt;\n\
    heading();\n\
    execute();\n\
  &lt;/script&gt;\n\
&lt;/body&gt;\n\
&lt;/html&gt;\n\
\n\</pre>\
</div>\
";
    }

    function loadJsOut(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\
Javascript Objects\n\
-------------------------\n\
Demo Objects\n\
-------------------------\n\
-------------------------\n\
Built-in instances\n\
-------------------------\n\
d: number\n\
size: 8, value: 3.1415927\n\
---\n\
string: string\n\
size: 2, value: s\n\
---\n\
type: object\n\
array: [\n\
    1, 2, 3\n\
]\n\
size: 24\n\
---\n\
type: object\n\
o: {\n\
    &quot;elem&quot;:&quot;some element&quot;\n\
}\n\
size: 24\n\
Hello\n\
--- more elaborate data ---\n\
type: object\n\
arr: [\n\
    1, &quot;z&quot;, [1,2,3], true\n\
]\n\
size: 38\n\
---\n\
you can add new elements to any object, including\n\
scalar data, composite data like arrays and functions.\n\
--- arr.show(nm) ---\n\
arr [ 1 z 1,2,3 true ]\n\
\n\
Here see the results of using two other analyzer methods\n\
on the arr array:\n\
--- showTypeShowable(arr, &quot;arr&quot;) ---\n\
arr, object, size: 38\n\
value: arr [ 1 z 1,2,3 true ]\n\
--- showObject(arr, &quot;arr&quot;) ---\n\
arr: [\n\
    1, &quot;z&quot;, [1,2,3], true\n\
]\n\
\n\
-------------------------\n\
User-defined object literal\n\
-------------------------\n\
dev: {\n\
    &quot;name&quot;:&quot;Jim&quot;, &quot;job&quot;:&quot;Retired from Syracuse University&quot;, &quot;hobby&quot;:&quot;Developing software&quot;, &quot;projects&quot;:[&quot;Bits language comparisons&quot;,&quot;Stories&quot;,&quot;Bites&quot;]\n\
}\n\
--- dev.show(&quot;dev&quot;) ---\n\
dev: {\n\
  name: Jim\n\
  job: Retired from Syracuse University\n\
  hobby: Developing software\n\
  projects: Bits language comparisons,Stories,Bites\n\
}\n\
--- showTypeShowable(dev, &quot;dev&quot;) ---\n\
dev, object, size: 182\n\
value: dev: {\n\
  name: Jim\n\
  job: Retired from Syracuse University\n\
  hobby: Developing software\n\
  projects: Bits language comparisons,Stories,Bites\n\
}\n\
--- showType(dev, &quot;dev&quot;) ---\n\
type: object\n\
dev: {\n\
    &quot;name&quot;:&quot;Jim&quot;,\n\
    &quot;job&quot;:&quot;Retired from Syracuse University&quot;,\n\
    &quot;hobby&quot;:&quot;Developing software&quot;,\n\
    &quot;projects&quot;:[&quot;Bits language comparisons&quot;,&quot;Stories&quot;,&quot;Bites&quot;]\n\
}\n\
size: 182\n\
-------------------------\n\
Using JavaScript class\n\
-------------------------\n\
--- showObject(p1, &quot;p1&quot;) ---\n\
p1: {\n\
    &quot;x&quot;:1, &quot;y&quot;:2, &quot;z&quot;:3\n\
}\n\
--- p1.show(&quot;p1&quot;) ---\n\
p1: Point1 {\n\
  1, 2, 3\n\
}\n\
--- showTypeShowable(p1, &quot;p1&quot;) ---\n\
p1, object, size: 24\n\
value: p1: Point1 {\n\
  1, 2, 3\n\
}\n\
--- showType(p1, &quot;p1&quot;) ---\n\
type: object\n\
p1: Point1: {\n\
    &quot;x&quot;:1, &quot;y&quot;:2, &quot;z&quot;:3\n\
}\n\
size: 24\n\
\n\
-------------------------\n\
Exploring consequences of JavaScript reference types:\n\
-------------------------\n\
--- let p2 = p1 ---\n\
p2: Point1 {\n\
  1, 2, 3\n\
}\n\
p2 is same object as p1\n\
--- p2.z = -42 ---\n\
p2: Point1 {\n\
  1, 2, -42\n\
}\n\
p1: Point1 {\n\
  1, 2, -42\n\
}\n\
p2 is same object as p1\n\
-------------------------\n\
All JavaScript variables are reference types. So assignments assign\n\
references, not values. And so changing target, p2, changed source, p1\n\
-------------------------\n\
\n\
-------------------------\n\
The displays below are used to test and demonstrate how\n\
display and analysis functions work. Those are all defined\n\
after the end of the execute() function.\n\
-------------------------\n\
--- p1.show(&quot;p1&quot;) ---\n\
p1: Point1 {\n\
  1, 2, -42\n\
}\n\
\n\
--- showObject(p1, &quot;p1&quot;) ---\n\
p1: {\n\
    &quot;x&quot;:1, &quot;y&quot;:2, &quot;z&quot;:-42\n\
}\n\
\n\
type: object\n\
test display formatting: {\n\
    &quot;a&quot;:&quot;1&quot;, &quot;b&quot;:[&quot;2&quot;,&quot;3&quot;]\n\
}\n\
size: 6\n\
\n\
--- let testarr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] ---\n\
testarr: [\n\
    0, 1, 2, 3, 4, 5, 6,\n\
    7, 8, 9\n\
]\n\
\n\
That's all Folks!\n\n\
</pre>";
    }

    function loadJsBld(id) {
      let codecont = document.getElementById(id);
      codecont.innerHTML = "<pre>\
\n\</pre>";
    }
  </script>

  <script>
    function remoteLeft() {
      let cp = document.getElementById("Cp1");
      if (cp.checked) {
        window.open('https://godbolt.org/z/qKT5jrv6K', '_blank');
      }
      let cs = document.getElementById("Cs1");
      if (cs.checked) {
        window.open('https://godbolt.org/z/Pc89d8c3T', '_blank');
      }
      let rs = document.getElementById("Rs1");
      if (rs.checked) {
        window.open(
          'https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b30e17c45574a8f9f276250365f12250',
          '_blank'
        )
      }
      let py = document.getElementById("Py1");
      if (py.checked) {
        window.open(
          'https://godbolt.org/z/Y531MqoPT',
          '_blank'
        )
      }
      let js = document.getElementById("Js1");
      if (js.checked) {
        window.open(
          'Js_Data.html',
          '_blank'
        )
      }
    }
    function remoteRight() {
      let cp = document.getElementById("Cp2");
      if (cp.checked) {
        window.open('https://godbolt.org/z/qKT5jrv6K', '_blank');
      }
      let cs = document.getElementById("Cs2");
      if (cs.checked) {
        window.open('https://godbolt.org/z/Pc89d8c3T', '_blank');
      }
      let rs = document.getElementById("Rs2");
      if (rs.checked) {
        window.open(
          'https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b30e17c45574a8f9f276250365f12250',
          '_blank'
        )
      }
      let py = document.getElementById("Py2");
      if (py.checked) {
        window.open(
          'https://godbolt.org/z/Y531MqoPT',
          '_blank'
        )
      }
      let js = document.getElementById("Js2");
      if (js.checked) {
        window.open(
          'Js_Data.html',
          '_blank'
        )
      }
    }
  </script>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="Bits_Objects.html">Next</a>
  <a id="Prev" href="Bits_Data.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="page">Bits Objects</div>
      <div id="modified">02/09/2022</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>

        <header>
          <hgroup id="pagetitle">
            <a class="repoLink" href="../../BitsRepo.html">Bits Repository</a>
            <h1 id="title">Bits_Objects</h1>
            <h3 id="subtitle" class="indent">
              code, output, and build for C++, Rust, C#, Python, and JavaScript on Windows, macOS, and Linux
            </h3>
          </hgroup>
        </header>
        <t-b>
          These pages support comparison of fragments of code in several different
          languages, much as you might compare a sentence of English with one in Spanish to help you learn
          Spanish.
          </t-b>
          <t-b style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
            <h4 style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
            This page demonstrates creation and simple uses of built-in and user-defined types for
            C++, Rust, C#, Python, and JavaScript. It also shows how to partition a project&apos;s
            code into multiple files.
          </t-b>
        <details>
          <summary class="darkItem">Demo Notes&nbsp;&nbsp;</summary>
          <t-b><hr /></t-b>
          <t-b>
            All of the languages covered in this demonstration support classes.  Each class provides
            a pattern for laying out a memory footprint and defines how data within are accessed.
          </t-b>
          <t-b>
            Three of the languages: C++, Rust, and C# provide generics.  Each generic function or class
            is a pattern for defining functions and classes of a specific type.  Thus a generic is a
            pattern for making patterns.
          </t-b>
          <t-b>
            The other two, Python and JavaScript, are dynamically typed and already support defining
            functions and classes for multiple types, e.g., no need for generics.
          </t-b>
          <t-b>
            This demonstration illustrates use of classes and objects, which for C++, Rust, and C#,
            are defined in a stackframe or in the heap or both. <strongs>All</strongs> data for Python and JavaScript are
            stored in managed heaps.
          </t-b>
          <t-b><hr /></t-b>
        </details>
        <t-b>
          The examples below show how to use library and user defined types with emphasis on
          illustrating syntax and basic operations.
        </t-b>
        <t-b>
          Note: the help page, activated by the &quot;Help&quot; button on the top menu will
          help you understand how to select one language or two language view in the panels below.
        </t-b>
        <div id="compare" style="height:0.0em;"></div>
        <div style="width:100%; text-align:center; position:relative; right:1.5em;">
          <input class="mover" type="button" name="size" value="-" onclick="movel()" />
          <input class="mover" type="button" name="size" value="C" onclick="movec()" />
          <input class="mover" type="button" name="size" value="+" onclick="mover()" />
        </div>
        <div style="height:1.5em;"></div>
        <div id="ruler">&nbsp;</div>
        <table class="showcode" style="position:relative;">
          <tr>
            <th class="btns"></th>
            <th id="lb" class="leftblock" style="position:relative; z-index:10;">
              <input type="button" id="exeLeft" value="RemoteExecute" onclick="remoteLeft()" 
                     style="position:absolute; left:1em;" />
              <span id="lbt">Source Code</span>
            </th>
            <th class="centerblock"></th>
            <th id="rb" class="rightblock" style="position:relative;">
              <input type="button" id="exeRight" value="RemoteExecute" onclick="remoteRight()" 
                     style="position:absolute; right:1em;"/>
              <span id="rbt">Source Code</span>
            </th>
            <th class="btns"></th>
          </tr>
          <tr>
            <td class="btns">
              <form id="left" name="left" style="margin-left:-2em;">
                <label for="Cp1">C++</label>
                <input type="radio" id="Cp1" name="lang1" value="1" onclick="loadCppLeft()" />
                <label for="Rs1">Rust</label>
                <input type="radio" id="Rs1" name="lang1" value="3" onclick="loadRsLeft()" />
                <label for="Cs1">C#&nbsp;</label><br />
                <input type="radio" id="Cs1" name="lang1" value="2" onclick="loadCsLeft()" />
                <label for="Py1">Python</label>
                <input type="radio" id="Py1" name="lang1" value="4" onclick="loadPyLeft()" />
                <label for="Js1">JvScpt</label>
                <input type="radio" id="Js1" name="lang1" value="5" onclick="loadJsLeft()" />
              </form>
            </td>
            <td class="leftblock">
              <div id="left1">
                left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1  
                left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1 left1  
              </div>
            </td>
            <td class="centerblock"></td>
            <td class="rightblock">
              <div id="right1">
                right1 right1 right1 right1 right1 right1 right1 right1 right1 right1 right1 right1 right1 right1  
              </div>
            </td>
            <td class="btns">
              <form id="right" name="right" style="margin-left:-1.2em;">
                <label for="Cp2">C++</label>
                <input type="radio" id="Cp2" name="lang2" value="4" onclick="loadCppRight()">
                <label for="Rs2">Rust</label>
                <input type="radio" id="Rs2" name="lang2" value="6" onclick="loadRsRight()">
                <label for="Cs2">C#</label><br />
                <input type="radio" id="Cs2" name="lang2" value="5" onclick="loadCsRight()">
                <label for="Py2">Python</label>
                <input type="radio" id="Py2" name="lang2" value="4" onclick="loadPyRight()">
                <label for="Js2">JvScrpt</label><br />
                <input type="radio" id="Js2" name="lang2" value="5" onclick="loadJsRight()">
                <label for="No2">None</label><br />
                <input type="radio" id="No2" name="lang2" value="5" onclick="load1()">
              </form>
            </td>
          </tr>
          <tr id="outlabel">
            <th class="btns"></th>
            <th class="leftblock">Output</th>
            <th class="centerblock"></th>
            <th class="rightblock">Output</th>
            <th class="btns">
            </th>
          </tr>
          <tr id="outcontent">
            <td class="btns"></td>
            <td class="leftblock"><div id="left2">left2</div></td>
            <td class="centerblock"></td>
            <td class="rightblock"><div id="right2">right2</div></td>
            <td class="btns"></td>
          </tr>
          <tr id="bldlabel">
            <th class="btns"></th>
            <th class="leftblock">Build</th>
            <th class="centerblock"></th>
            <th class="rightblock">Build</th>
            <th class="btns"></th>
          </tr>
          <tr id="bldcontent">
            <td class="btns"></td>
            <td class="leftblock"><div id="left3">left3</div></td>
            <td class="centerblock"></td>
            <td class="rightblock"><div id="right3">right3</div></td>
            <td class="btns"></td>
          </tr>
        </table>
        <div style="width:100%; text-align:center; position:relative; right:1.5em;">
          <input class="mover" type="button" name="size" value="-" onclick="movel()" />
          <input class="mover" type="button" name="size" value="C" onclick="movec()" />
          <input class="mover" type="button" name="size" value="+" onclick="mover()" />
        </div>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#notes">notes</a></menu-elem>
        <menu-elem class="secElem"><a href="#bldlabel">build</a></menu-elem>
        <menu-elem class="secElem"><a href="#outlabel">output</a></menu-elem>
        <menu-elem class="secElem"><a href="#compare">codeview</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <!--<menu-item style="width:1.0em;">&nbsp;</menu-item>-->
    </frame-footer>
  </page-frame>
  <script>
    setChecks();
    startLeft();
    startRight();
  </script>
</body>
</html>