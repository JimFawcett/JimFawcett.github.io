<!DOCTYPE html>
<html>
<!--
  Bits_DataRustContent.html
-->
<head>
  <title>Bits_Data Rust</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeRust.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrameTOC.js"></script>
  <script src="js/ScriptsPageFramePagesBitsRust.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <!--<script src="js/ScriptsPageFrameNewRadioButtons.js"></script>-->
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding:0.75em 1.5em;
      margin-top:1.25em;
      margin-bottom:1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width:50em;
    }
    #github h2 {
      margin-top: 0.75em;
    }
    #github #pagetitle {
      border:2px double var(--dark);
    }
    #github form {
      border:none;
      padding:0.5em 1em;
    }
    #github form span {
      padding:0em 0.5em;
    }
    #github code-container {
      display: flex;
      position:relative;
      width:calc(100%);
      flex-direction: row;
      justify-content: space-between;
      /*border-top: 1px solid var(--dark);*/
    }
    #github code-banner {
      display: block;
      border: 2px solid var(--dark);
      border-top:none;
      border-bottom:none;
      padding: 0.25em 1em;
      font-family: 'Comic Sans MS', Tahoma;
      width: calc(100% + 0.5em);
      background-color: var(--atten);
    }
    #github code-display {
      display: block;
      border: 2px solid var(--dark);
      white-space: pre;
      padding: 0.75em 1em;
      font-family: Consolas, monospace;
      font-size:0.9em;
      width: calc(50% - 0.5em);
      overflow-x: auto;
      /*height:20em;*/
    }
    #github label {
      margin-right:1em;
    }
    #github fieldset {
      border:none;
    }
    #github #exeRight, #exeLeft {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github #hideLeft, #hideRight {
      padding: 0.05em 0.5em;
      font-family: 'Comic Sans MS', Tahoma;
    }
    #github .hide {
      display:none;
    }
    body {
      position:relative;
    }
    #github table.showcode {
      table-layout:fixed;
      width:calc(100% + 4em);
      margin-left:-2em;
    }
    #github th.leftblock {
      border: 2px solid var(--dark);
      /*border: 1px solid red;*/
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.rightblock {
      border: 2px solid var(--dark);
      background-color: var(--menu);
      width: calc(50% - 0.5em);
      overflow-x: auto;
    }

    #github th.centerblock {
      border: none;
      padding: 0em;
      width:1em;
    }
    #github td.leftblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em);
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.leftblock summary {
      border:1px solid #ffffbb;
    }

    #github td.rightblock {
      border: 2px solid var(--dark);
      width: calc(50% - 0.5em) !important;
      overflow-x: auto;
      background-color: #222233;
      color: #ffffbb;
    }

    #github td.rightblock summary {
      border: 1px solid #ffffbb;
    }

    #github td.centerblock {
      border: none;
      padding: 0em;
    }
    #github pre {
      overflow-x: auto !important;
    }
    #github #left1 {
      /*height:45em;*/
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }

    #github #right1 {
      max-height: calc(100vh - 10em);
      overflow-y: auto;
    }
    #github #left2 {
      /*height:45em;*/
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right2 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github #left3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }

    #github #right3 {
      max-height: calc(100vh - 7em);
      overflow-y: auto;
    }
    #github .mover {
      width:2em;
      padding: 0.05em;
      position:relative;
      right:-1.5em;
      top:0.6em;
    }
    #github #ruler {

      width:calc(50% - 1.5em);
      height:0.001em;
      margin:-0.45em 0em;
    }
    #github .btns {
      width:3em;
      border:none;
    }
    #github .codeSnap {
      font-family: Consolas, Courier New, Courier, monospace, sans-serif;
      font-size: small;
      font-weight: bold;
      background-color: #eee;
      padding: 10px;
    }
    #github .remotebutton {
      padding:0.25em 0.5em;
    }
    #github .rightPanelLinks {
      position: fixed;
      right: 0.0em;
      top: 15em;
      z-index: 100;
      background: var(--light);
      padding: 0.75em 0.25em;
      border: 1px solid var(--dark);
    }

    #github div.rightPanelLinks a {
      display: block;
      height: 1.5em;
      padding: 0em 0.25em;
    }
    #github hr.spread {
      margin:0.75em 0em;
    }
    #github pre {
      width: max-content;
      min-width: 20em;
      max-width: 60em;
      user-select: all;
    }
    #github {
      user-select: none;
    }
    .code-container {
      display: flex;
      flex-direction: column;
      border: 1px solid red;
      width:max-content;
      margin:0em; padding:0em;
    }
    .code-block {
      /*display:flex;*/
      margin: 0.0em 1em;
      font-family: monospace;
    }
    .focus {
      padding:0.5em 1.0em 0.5em 1.0em;
      /*border:1px solid red;*/
    }
    *.focus ul {
      padding-top:-0.5em;
      /*background-color:green;*/
    }
    .cat {
      text-align:left;
      background-color: var(--menu);
    }

    #github pre {
      overflow-x: auto !important;
    }

    .block {
      border: 1px solid var(--dark);
      overflow: hidden;
      clear: both;
      max-width: 50em;
      margin-right: 0.75em;
    }

    .codewrap {
      float: left;
      padding-left: 0.5em;
      padding-right: 0.75em;
    }

    .textwrap {
      padding: 0.0em 0.75em 0.5em 0.5em;
      padding-left: 0.5em;
      padding-right: 0.75em;
    }

    table {
      margin-right: 0.75em;
    }
    /* under-construction {
          border:1px solid red;
          padding:0.5em 1em;
          margin:0.75em 0em;
        } */
    c-s {
      font-size: 1.1em;
    }
  </style>
  <script>
    function setScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = main.scrollTop;
      localStorage.setItem('scrollPositionDataRust', scrollPosition);
      let scroller = document.getElementById("scrollY")
      scroller.innerHTML = Math.trunc(scrollPosition);
    }
    function gotoLastScroll() {
      let main = document.querySelector("#main");
      const scrollPosition = localStorage.getItem('scrollPositionDataRust');
      if (scrollPosition) {
        main.scrollTo(0, scrollPosition);
      }
      main.addEventListener('scroll', setScroll);
    }
    function load() {
      //initialize();
      gotoLastScroll();
    }
  </script>

  <script>
    function remote() {
      window.open('https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ac93fd553ca70f9f6258bf0253bea2b3', '_blank');
    }
  </script>
</head>
<body id="github" onload="load()">

  <!--<a id="Next" target="_blank" href="Bits_ObjectsRust.html">Next</a>
  <a id="Prev" target="_blank" href="Bits_HelloRust.html">Prev</a>-->

  <page-frame>
    <!--<frame-header>
      <nav id="navbar"></nav>
    </frame-header>-->
    <main id="main">
      <div id="about">about</div>
      <div id="page">Bits Data Rust</div>
      <div id="modified">09/02/2023</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content id="content">
        <!-- <div class="rightPanelLinks">
          <a target='_parent' href="Bits_DataCpp.html">C++</a>
          <a target='_parent' class="darkItem" href="Bits_DataRustContent.html">Rust</a>
          <a target='_parent' href="Bits_DataCSharp.html">C#</a>
          <a target='_parent' href="Bits_DataPython.html">Python</a>
          <a target='_parent' href="Bits_DataJs.html">JvScrpt</a>
        </div> -->
        <div id="scrollY"
             style="position:fixed; bottom:0.50em; right:1.50em; width:max-content; height:1.5em;
           text-align:right; padding:0.15em 0.5em; border:1px solid red;">
          0
        </div>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Bits">Bits Repo Code</a>
          <a target="_blank" class="repoLink" href="../../BitsRepo.html" style="margin-right:7.5em;">Bits Repo Docs</a>
          <hgroup id="pagetitle">
            <h1 id="title">Bits:&nbsp;&nbsp;Rust Data</h1>
            <h3 id="subtitle" class="indent">
              types, initialization, ownership, borrowing
            </h3>
          </hgroup>
        </header>
        <t-b>
          This page guides you through the rust type system in several sections:
          The menu bar at the right has links to each of these, so they are always in view
          anywhere in this page. The bottom menu bar &quot;Sections&quot; item has the same information
          in a drop-up list.
        </t-b>
        <t-b>
          The small persistant fixed menu on the right switches between languages for the same topic.
          To simplify code comparisons these pages open to their last scroll positions. Most other pages
          open at the top.
        </t-b>
        <t-b style="border:1px solid maroon; padding:0.25em 1em 0.5em 1em;">
          <h4 id="syn" style="margin:0em 0em 0.25em 0em;">Synopsis:</h4>
          This page demonstrates simple uses of the most important Rust types.
          The purpose is to quickly acquire some familiarity with types and their uses.
          <hr class="spread" />
          <ul>
            <li>
              Rust provides two categories of types: copy and move. Copy types occupy a single contiguous
              block of stack memory. Move types have control blocks in stack memory used to manage
              resources in the heap.
            </li>
            <li>
              Primitive types and aggregates of primitive types are copy.  Construction, assignment, and
              pass-by-value <a target="_blank" href="#move">copies</a> the source&apos;s value to the destination.
            </li>
            <li>
              All other types are move. Construction, assignment, and pass-by-value
              <a target="_blank" href="#movediag">move ownership</a>
              of the value&apos;s heap resources to the destination.
              This makes the source invalid. Attempting to use a &quot;moved&quot; variable is a
              compile error.
            </li>
            <li>
              The source and destination of copy and move operations must have exactly the same type.
            </li>
            <li>
              More details about copy and move operations can be found in
              <a target="_blank" href="../RustBites/RustBites_Data.html">Rust Bite - Data Operatons</a>, including diagrams and code examples.
            </li>
            <li>
              Most move types provide <a target="_blank" href="#clonediag">clone operations</a> that support making copies, but using
              code must explicitly call clone().
            </li>
            <li>
              Rust supports making fixed references to either copy or move types. These may
              refer to instances in a function&apos;s stack memory, in the native heap,
              or in the program&apos;s static memory.
            </li>
            <li style="border: 1px solid var(--dark); padding:0.25em;">
              Rust references are constrained by Rust ownership rules to support memory
              and data race safety by construction. All values in memory have a single owner,
              responsible for its creation, access, and deallocation.
            </li>
            <li>
              Ownership can be borrowed by creating a reference. Program code may create an
              arbitrary number of non-mutable references to some variable, but may only create
              a single mutable reference that borrows exclusive access to the variable.
            </li>
            <li>
              Rust&apos;s type system plays a dominant role in providing memory and data race
              safety.
            </li>
            <li>
              Here we begin to see significant differences between the languages, especially
              when comparing statically typed languages like C++, Rust, and C#, with dynamically typed
              languages like Python and JavaScript.
            </li>
          </ul>
          <div style="height:0.25em;"></div>
        </t-b>
        <div style="height:0.25em;"></div>
        <details id="types">
          <summary class="darkItem">Rust&nbsp;Types&nbsp;Details&nbsp;</summary>
          <h3>Table 1.0 Rust Types</h3>
          <table style="font-size: 0.9em; max-width: 71em;">
            <tr>
              <th style="width:15em;">Type</th>
              <th>Comments</th>
              <th>Example</th>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Integral types ----</th>
            </tr>
            <tr>
              <td><c-s>bool</c-s></td>
              <td>values true and false</td>
              <td><c-s>let b = true;</c-s></td>
            </tr>
            <tr>
              <td>
                <c-s>i8, i16, i32, i64, isize, u8, u16, u32, u64, usize</c-s>
              </td>
              <td>signed and unsigned integer types</td>
              <td><c-s>let i = 42i8;</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Floating point types ----</th>
            </tr>
            <tr>
              <td><c-s>f32, f64</c-s></td>
              <td>values have finite precision, and may have approximate values</td>
              <td><c-s>let f:f32 = 3.14159;</c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- literal string types --</th>
            </tr>
            <tr>
              <td><c-s>&str</c-s></td>
              <td>A literal string</td>
              <td>
                <c-s>let ls = "literal string";<br />let second = ls.chars().nth(1);</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>&str</c-s></td>
              <td>Slice of a literal string</td>
              <td><c-s>let slice = &ls[1..5];<br /></c-s></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- Aggregate types ----</th>
            </tr>
            <tr>
              <td><c-s>[T; N]</c-s></td>
              <td>An array of N elements all of type <c-s>T</c-s></td>
              <td>
                <c-s>let arr = [1, 2, 3, 2, 1];<br />let first = arr[0];</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>&[T]</c-s></td>
              <td>Slice of array of elements of type <c-s>T</c-s></td>
              <td>
                <c-s>let arrs = &arr[1..3];<br />let second = arrs[1];</c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>Tupl</c-s></td>
              <td>collection of heterogeneous types accessed by position</td>
              <td>
                <c-s>
                  let tu = (42i32, 3.14159f64, 'z');<br />let third = tu.2;
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>Result&lt;T,E&gt;</c-s></td>
              <td>Result enum holds result <c-s>Ok(t:T)</c-s> or <c-s>Err(e:E)</c-s></td>
              <td><c-s>fn doOp1(..args) -> Result&lt;r:R, e:Err&gt;</c-s></td>
            </tr>
            <tr>
              <td><c-s>Option&lt;T&gt;</c-s></td>
              <td>Option enum holds optional value <c-s>Some(t:T)</c-s> or <c-s>None</c-s></td>
              <td><c-s>fn doOp2(..args) -> Option&lt;T&gt;</c-s></td>
            </tr>
            <tr><th colspan="3" class="cat">-- Std::library types ----</th></tr>
            <tr>
              <td><c-s>String</c-s></td>
              <td>Expandable collection of utf-8 characters allocated in the heap</td>
              <td><c-s>let strg = "a utf-8 String".to_string();</c-s></td>
            </tr>
            <tr>
              <td><c-s>Vec&lt;T&gt;</c-s></td>
              <td>Expandable generic collection of items of type <c-s>T</c-s></td>
              <td><c-s>let v = Vec::&lt;f64&gt;::new(), v.push(1.5); ...</c-s></td>
            </tr>
            <tr>
              <td><c-s>VecDeque&lt;T&gt;</c-s></td>
              <td>Expandable double-ended generic collection of items of type <c-s>T</c-s></td>
              <td>
                <c-s>
                  let vd = VecDeque::&lt;f64&gt;::new(),<br />
                  v.push_front(1.5); ...
                </c-s>
              </td>
            </tr>
            <tr>
              <td><c-s>HashMap&lt;K,V&gt;</c-s></td>
              <td>Associative container of Key-Value pairs, held in a table of bucket lists.</td>
              <td>
                <c-s>
                  let map = HashMap::&lt;&str, int&gt;::new(),<br />
                  map.insert("zero", 0); ...
                </c-s>
              </td>
            </tr>
            <tr>
              <td>LinkedList, BTreeMap, HashSet, BTreeSet, BinaryHeap, ...</td>
              <td>
                The Rust std::library defines types for threading and synchronization,<br />
                reading and writing to streams, anonymous functions, ...
              </td>
              <td><a href="https://doc.rust-lang.org/std/">Crate std</a></td>
            </tr>
            <tr>
              <th colspan="3" class="cat">-- User-defined Types --</th>
            </tr>
            <tr>
              <td>User-defined types</td>
              <td colspan="2">Based on structs and enums, these will be discussed in the next Bit.</td>
            </tr>
          </table>
          <div style="height:0.5em;"></div>
        </details>
        <div style="height:0.5em;"></div>
        <details id="typesys">
          <summary class="darkItem">Rust&nbsp;Type&nbsp;System&nbsp;Details&nbsp;</summary>
          <h3>Table 2. Rust Copy and Move Operations</h3>
          <table style="font-size:0.9em; max-width:65em;">
            <colgroup>
              <col span="1" style="width:12%;" />
              <col span="1" style="width:16%;" />
              <col span="1" style="width:36%;" />
              <col span="1" style="width:36%;" />
            </colgroup>
            <tr>
              <th>Operation</th>
              <th>Example</th>
              <th><a target="_blank" href="../../Pictures/StrCopy.jpg">Copy type</a></th>
              <th><a target="_blank" href="../../Pictures/StringMove.jpg">Move type</a></th>
            </tr>
            <tr>
              <td>Construction</td>
              <td><c-s>let t:T = u:T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is copied to <c-s>t</c-s>,<br /><c-s>u</c-s> is still valid</td>
              <td><c-s>u</c-s>&apos;s value is moved to <c-s>t</c-s>,<br /><c-s>u</c-s> now invalid</td>
            </tr>
            <tr>
              <td>Assignment</td>
              <td><c-s>t:T = u:T</c-s></td>
              <td><c-s>u</c-s>&apos;s value is copied to <c-s>t</c-s>,<br /><c-s>u</c-s> is still valid</td>
              <td><c-s>u</c-s>&apos;s value is moved to <c-s>t</c-s>,<br /><c-s>u</c-s> now invalid</td>
            </tr>
            <tr>
              <td>Pass-by-value</td>
              <td><c-s>fn doOp(t:T)</c-s></td>
              <td><c-s>t</c-s>&apos;s value is copied to doOp stack frame,<br /><c-s>t</c-s> is still valid</td>
              <td><c-s>t</c-s>&apos;s value is moved to doOp stack frame,<br /><c-s>t</c-s> is now invalid</td>
            </tr>
          </table>

          <h3>Table 3. Rust Copy and Move Types</h3>
          <table style="font-size:0.9em; max-width:65em;">
            <colgroup>
              <col span="1" style="width:20%;" />
              <col span="1" style="width:45%;" />
              <col span="1" style="width:35%;" />
            </colgroup>
            <tr>
              <th>Property</th>
              <th>Members</th>
              <th style="max-width:7em;">Notes</th>
            </tr>
            <tr>
              <td>Primitive types</td>
              <td>integers, floats, literal strings</td>
              <td>These are all copy types</td>
            </tr>
            <tr>
              <td>Aggregate types</td>
              <td>arrays, slices of arrays, tuples, Result&lt;T,E&gt;, Option&lt;T&gt;</td>
              <td>These are copy types if their members are copy, otherwise they are move types</td>
            </tr>
            <tr>
              <td>std::library collection types</td>
              <td>String, Vec&lt;T&gt;, VecDeque&lt;T&gt;, HashMap&lt;K,V&gt;, ...</td>
              <td>These are all move types</td>
            </tr>
          </table>
          <t-b>
            <h3>Table 4. Rust Type System Attributes</h3>
          </t-b>
          <table style="font-size:0.9em; max-width:65em;">
            <tr>
              <td>Static typing</td>
              <td>
                All types are known at compile time and are fixed throughout program execution.
              </td>
            </tr>
            <tr>
              <td>Inference</td>
              <td>
                Compiler infers types in expressions if not explicitly annotated.
                Occasionally inference fails and explicit annotation is required.
              </td>
            </tr>
            <tr>
              <td>Strong typing</td>
              <td>
                Types are exhaustively checked and there are very few implicit conversions.
                <ul class="tight">
                  <li>Numeric and boolean literals coerce to their correspoinding type, e.g., 42 to i32.</li>
                  <li>Variables without type annotations are coerced to their minimal types</li>
                  <li>Values can be coerced to a more specific type of same or larger size.</li>
                  <li>
                    Smart pointers like Box, Rc, Arc, ... implement the DeRef trait, supplying a method
                    deref() that returns a reference to their inner values. Applying * to these types
                    automatically calls deref() to return an inner reference.
                  </li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Algebraic data types</td>
              <td>
                Types created using enums and structs. Unlike other languages, Rust enums can
                hold named discriminants with associated data of arbitrary type. That combined with Rust&apos;s
                matching operations simplify state and error handling.<br />
                Examples: <c-s>Result&lt;T,E&gt; { Ok(T), Err(E), }, Option&lt;T&gt; { Some(T), None, }</c-s><br />
                Matching:<pre><c-s>    match result {
       Ok(value) => { // do something with value },
       Err(error) => { // do something with error }
    }
</c-s></pre>
              </td>
            </tr>
            <tr>
              <td>Generics</td>
              <td>
                Generics provide types and functions with unspecified parameters,
                supporting code reuse and abstraction
                over types. Generic parameters are specified at the call site, often bound by constraints,
                e.g., <c-s>fn doOp&lt;T:Debug, Clone&gt;(t:T)</c-s>.<br />
                The function <c-s>doOp</c-s> compiles only if <c-s>T</c-s> satisfies its named trait bounds
                <c-s>Debug</c-s> supporting use of format <c-s>{:?}</c-s> and
                <c-s>Clone</c-s> supporting explicit copy with <c-s>clone()</c-s>.
              </td>
            </tr>
            <tr>
              <td>Traits</td>
              <td>
                Traits are similar to Java and C# interfaces. They defined shared behavior that types can
                implement, supporting abstraction over behavior. Traits define behavior by declaring trait
                specific functions. A trait may, but need not, define its function&apos;s contents.
                Generics and Traits are covered <a target="_blank" href="Bits_GenericRust.html">here</a>.
              </td>
            </tr>
          </table>
        </details>
        <div style="height:0.5em;"></div>
        <h2 id="init">1.0 Initialization</h2>
        <t-b>
          Rust types are initialized with a let statement that binds a variable name to a memory location
          with specified value.
        </t-b>
        <h3 id="langdef">1.1 Initializing language-defined types</h3>
        <t-b>
          The Rust language defines scalar types: booleans, integers, and floats,
          and aggregate types:
          literal strings and slices, arrays and array slices, tuples, and enums Result&lt;T,E&gt;
          and Option&lt;T&gt;.
        </t-b>
        <t-b>
          All of the type variations, e.g., i8, i16, ... are are enumerated in the
          &quot;Rust Types Details&quot; dropdown, above.
        </t-b>
        <t-b>
          The code block below shows how to initialize them and how to access members of
          an aggregate.
        </t-b>
        <div class="block">
          <div class="codewrap">
            <pre><code class="language-rust">  /*-- initialize language defined types --*/

  let i = 42i8;         // data type specified

  let b = true;         // data type inferred

  let f:f32 = 3.14159;  // variable type specified&nbsp;&nbsp;

  let c:char = 'z';

  let sl:&str = "a literal string";
  let second = sl.chars().nth(1);

  let st = "an owned string".to_string();
  let fourth = st.chars().nth(3);

  let arr:[i32; 3] = [1, 2, 3];
  let first = arr[0];

  let tp: (i32, f64, char) = (1, 2.5, 'a');
  let second = tp.1;

  let iref: &i8 = &amp;i;

  let aref: &[i32; 3] = &arr;</code></pre>
          </div>
          <div class="textwrap">
            <t-b>
              Type specifications like i8 and f64 can be applied to the variable name or to it&apos;s initializing
              data, as shown here.
            </t-b>
            <t-b>
              Rust can usually infer appropriate types for data, but a code developer can
              explicitly define them.
              If the type annotations were removed in this example, Rust would infer i to be i32 and f to be f64.
            </t-b>
            <t-b>
              The char type occupies 4 bytes of storage, large enough to hold any of the utf-8 characters.
            </t-b>
            <t-b>
              The type <c-s>&str</c-s> is a reference to a fixed-size immutable literal string in stack memory.
              It may hold
              any of the utf-8 characters. It&apos;s size is the sum of the actual literal character sizes.
              For the literal string shown, all of the characters are 1 byte.
            </t-b>
            <t-b>
              Arrays are fixed size sequences of values of the specified type.  They are indexable and individual
              element values may be changed if the array has mutable type.
            </t-b>
            <t-b>
              Tuples are sequences of values of heterogeneous types.  Elements are accessed via position
              arguments, e.g., tp.1 accesses the second element, a float.
            </t-b>
            <t-b>
              References like &arr are fixed pointers to the beginning of the variable&apos;s data storage.
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre>
<code class="language-shell">  -------------------------
    create and initialize
  -------------------------

  --- initialize language-defined types ---&nbsp;&nbsp;

  --- i8 ---
  i, i8
  value: 42, size: 1

  --- bool ---
  b, bool
  value: true, size: 1

  --- f32 ---
  f, f32
  value: 3.15927, size: 4

  --- char ---
  c, char
  value: 'z', size: 4

  --- &str ---
  ls, &str
  value: &quot;literal string&quot;, size: 16
  second, core::option::Option&lt;char&gt;
  value: Some('i'), size: 4

  --- alloc::string::String ---
  st, alloc::string::String
  value: &quot;an owned string&quot;, size: 24
  fourth, core::option::Option&lt;char&gt;
  value: Some('o'), size: 4

  --- [i32; 3] ---
  arr, [i32; 3]
  value: [1, 2, 3], size: 12
  first, i32
  value: 1, size: 4

  --- (i32, f64, char) ---
  tp, (i32, f64, char)
  value: (1, 2.5, 'a'), size: 16
  second, f64
  value: 2.5, size: 8

  --- &i8 ---
  iref, &i8
  value: 42, size: 8

  --- &[i32; 3] ---
  aref, &[i32; 3]
  value: [1, 2, 3], size: 8
  second, i32
  value: 2, size: 4

  --- &str ---
  lscs, &str
  value: &quot;iter&quot;, size: 16
  second, core::option::Option&lt;char&gt;
  value: Some('t'), size: 4

  --- &[i32] ---
  sla, &[i32]
  value: [2, 3], size: 16
  second, i32
  value: 3, size: 4</code>
              </pre>
            </div>
            <div class="textwrap">
              <t-b>
                Each type in the code block on the left is characterized by its value,
                its type evaluated using <c-s>std::any::type_name::&lt;T&gt;()</c-s>
                and its size retrieved using <c-s>std::mem::size_of::&lt;T&gt;()</c-s>.
              </t-b>
              <t-b>
                The function <c-s>showType</c-s> formats that information for display
                and is defined in the bits_data_analysis.rs file, shown in Section 1.5, below.
              </t-b>
              <hr />
              <t-b>
                Scalar types are held in a single block of contiguous heap memory.  Copies of all scalar types
                are byte-wise copies of the source data.  That results
                in two unique instances residing in the invoking function&apos;s stackframe.
              </t-b>
              <hr />
              <t-b>
                Language-defined aggregate types with scalar members are also held in a contiguous region
                of stack memory, and are copied with byte-wise copy.
              </t-b>
              <t-b>
                Aggregates with members using heap
                allocations like <c-s>string</c-s>s and <c-s>vector</c-s>s are moved instead of copied.
              </t-b>
              <hr />
              <t-b>
                Copies, moves, and clones are discussed in section 1.4, below.
              </t-b>
              <hr />
              <t-b>
                The char type is large enough to hold any utf-8 character, e.g., 4 bytes.
              </t-b>
              <t-b>
                literal strings and instances of the <c-s>string</c-s> type are sequences of utf-8
                characters. Each utf-8 character consits of
                from 1 to 4 bytes.  That supports many different character sets , ASCII, Unicode,
                Mandarin, Kanji, Arabic, ...
              </t-b>
              <t-b>
                Rust strings pack the utf-8 characters so string elements are not fixed size. That
                means that they are not indexable.
              </t-b>
              <t-b>
                Instead, rust provides the <c-s>chars</c-s>
                iterator which returns an <c-s>Option</c-s> enumeration holding either <c-s>Some(ch)</c-s>
                or <c-s>None</c-s> when the iteration has reached the end of the characer sequence.
              </t-b>
              <t-b>
                The character value, ch, is accessed by (conditionally) unwrapping Option.
              </t-b>
              <t-b>
                Arrays are fixed size, indexable, collections of values of a single type, defined
                by the array&apos;s declaration. Values are accessed and mutable arrays are modified
                by index.
              </t-b>
              <t-b>
                Tuples are fixed size collections of values of heterogeneous types. Elements are accessed
                by position: 0, 1, ...
              </t-b>
            </div>
          </div>
        </details>
        <h4 id="locs">1.11 Specifying locations</h4>
        <t-b>
          Rust supports storing data in static memory for constants and static data, in stack memory
          for function arguments and data local to a function, and in the native heap. These are
          illustrated in the code block below.
        </t-b>
        <div class="block">
          <div class="codewrap">
            <pre>
<code class="language-rust">  /*-- static, stack, and heap allocations --*/

  static PI:f64 = 3.1415927;      // static memory&nbsp;&nbsp;
  // static address: &PI = 0x7ff730eb7668
  ------------------------------------
  let f:f64 = 3.1415927;          // stack memory
  // stack address:   &f = 0x40a1cff8c0
  ------------------------------------
  let s:&str = "3.1415927";       // stack memory
  // stack address: &str = 0x40a1cff910
  ------------------------------------
  let g = box::new(3.1415927f64); // heap memory
  // heap address:   &*g = 0x1b78cc05bd0
</code>
            </pre>
          </div>
          <div class="textwrap">
            <t-b>
              <t-b>
                Variables can be bound to locations in static memory, stack memory, or heap memory.
              </t-b>
              <t-b>
                Static memory is allocated at compile-time and so contents live for the duration of
                the program.
              </t-b>
              <t-b>
                Stack memory is implicitly allocated at run-time for each function call, including main.
                That serves as scratch-pad storage for input parameters and locally declared data. It is
                implicitly deallocated when the thread of execution leaves it&apos;s function&apos;s scope.
              </t-b>
              <t-b>
                Heap memory is explicitly allocated with construction of a smart Box pointer. That
                allocation is returned when the smart pointer, g, goes out of scope.
              </t-b>
            </t-b>
          </div>
        </div>
        <div style="clear:both;"></div>
        <h3 id="libdef">1.2 Initializing standard library types</h3>
        <div class="block">
          <div class="codewrap">
            <pre>
<code class="language-rust">  /*-- standard library types --*/

  let v:Vec&lt;i32&gt; = vec![1, 2, 3, 2, 1];
  // size: 24 bytes, control block holds
  // ptr to ints on heap, length, capacity
  ------------------------------------
  let st:String = "an owned string".to_string();
  // size: 24 bytes, control block holds
  // ptr to chars on heap, length, capacity
  ------------------------------------
  let mut vecdeq = VecDeque::&lt;f64&gt;::new();
  vecdeq.push_front(1.0);
  vecdeq.push_front(1.5);
  vecdeq.push_front(2.0);
  vecdeq.push_front(1.5);
  vecdeq.push_front(1.0);
  ------------------------------------
  let mut map = HashMap::<&str,i32>::new();
  map.insert("zero", 0);
  map.insert("one", 1);
  map.insert("two", 2);</code>
            </pre>
          </div>
          <div class="textwrap">
            <t-b>
              <t-b>
                Standard Library types are initialized with a call to new and possibly modified with
                subsequent additions of data.
              </t-b>
              <t-b>
                Here, <c-s>vec!</c-s> is a std::library macro that initializes variable <c-s>v</c-s> by
                creating a <c-s>Vec&lt;int&gt;</c-s>
                and pushing the elements 1, 2, ...
              </t-b>
              <t-b>
                <c-s>Vec</c-s>s consist of a control block in stack memory
                that holds a pointer to a resizeable array of elements in the heap, a count of the number of
                elements currently stored, and a count of the available capacity for data.
              </t-b>
              <t-b>
                When the length
                equals the <c-s>Vec</c-s>&apos;s capacity and a new element is pushed the <c-s>Vec</c-s>
                allocates a new heap array of twice the size of the current capacity, copies the elements
                to the new storage and deallocates the original heap array.
              </t-b>
              <t-b>
                The string, st, is initialized by converting a literal string to a
                String type.  Strings are sequences of utf-8 characters, each of which may contain
                from one to four bytes.  That supports representing characters from non-roman languages,
                e.g., arabic, kanji, etc., as well as emoji&apos;s and symbols.
              </t-b>
              <t-b>
                The structure of a <c-s>String</c-s> is very similar to a <c-s>Vec</c-s>. It has a control
                block in stack memory and a collection of characters in the heap. The main difference is that
                vectors hold elements of a fixed size, and so are indexable.  Strings hold utf-8 characters
                which vary in size from one to four bytes.  They are not indexable, but provide an iterator,
                <c-s>chars</c-s> that steps through the character collection.
              </t-b>
              <t-b>
                The statement <c-s>let mut vecdeq = ...</c-s>
                creates a double ended <c-s>VecDeque</c-s> queue.  It must be declared <c-s>mut</c-s>
                to allow later modifications with <c-s>push-front</c-s> statements. Data is stored
                in a circular buffer in the heap, supporting efficiently pushing data onto either front or back of the queue.
              </t-b>
              <t-b>
                <c-s>HashMap</c-s> is an associative container with, in this example, <c-s>Key:&str</c-s>, and <c-s>Value:i32</c-s>.
                The <c-s>&str</c-s> type is a reference to a literal string like <c-s>"zero"</c-s>.
                Key-value pairs are stored in a table of buckets which are linked lists.  Lookup
                applies a hash function to a unique key to find the table address of the bucket holding
                that key.  The HashMap retrieval API provides methods that use the hash to walk the
                bucket list searching for the specified key.
              </t-b>
              <t-b>
                The code block, below, displays some of the output of a demonstration program in
                Bits/Rust/rust_data, stored in a <a target="_blank" href="https://github.com/JimFawcett/Bits">Bits repository</a>
                for all the code used in the Bits for C++, Rust, C#, Python, and JavaScript.
                You are invited to clone or download the repository and explore these examples using Visual Studio Code.
              </t-b>
            </t-b>
          </div>
        </div>
        <details>
          <summary class="darkItem">Output</summary>
          <div class="block">
            <div class="codewrap">
              <pre>
<code class="language-shell">--- initialize std::lib types ---

vec, alloc::vec::Vec<i32>
value: [1, 2, 3, 2, 1], size: 24

st, alloc::string::String
value: "an owned string", size: 24

vecdeq, alloc::collections::vec_deque::VecDeque<f64>
value: [1.0, 1.5, 2.0, 1.5, 1.0], size: 32

map, std::collections::hash::map::HashMap<&str, i32>
value: {"one": 1, "zero": 0, "two": 2}, size: 48
</code>
              </pre>
            </div>
            <div class="textwrap">
              <t-b>
                Each type in the code block on the left is characterized by its value,
                its type evaluated using <c-s>std::any::type_name::&lt;T&gt;()</c-s>
                and its size retrieved using <c-s>std::mem::size_of::&lt;T&gt;()</c-s>.
              </t-b>
              <t-b>
                The function <c-s>showType</c-s> formats that information for display
                and is defined in the bits_data_analysis.rs file, shown in Section 1.5, below.
              </t-b>
              <hr />
              <t-b>
                Language-defined aggregate types with scalar members are held in a contiguous region
                of stack memory, and are copied with byte-wise copy.
              </t-b>
              <t-b>
                Aggregates with members using heap
                allocations like <c-s>string</c-s>s and <c-s>vector</c-s>s are moved instead of copied.
              </t-b>
              <t-b>
                Copies, moves, and clones are discussed in section 1.4, below.
              </t-b>
            </div>
          </div>
        </details>
        <!--         <div style="float:left; margin-left:1em; padding-right:2em;">
            <h4 style="margin-top: 0em;">Example: Code used to generate output</h4>
            <pre><code class="language-rust">use std::fmt::Debug;

  /*-- show_type --------------------------------------------
    Shows compiler recognized type and data value
  */
  pub fn show_type&lt;T: Debug&gt;(t: &T, nm: &str) {
    let typename = std::any::type_name::<T>();
    print!("  {nm}, {typename}");
    println!(
      "\n  value: {:?}, size: {}",
      t, std::mem::size_of::&lt;T&gt;()
    );
    // smart Debug formatting {:?}
    // handles both scalars and collections
  }
            </code></pre>
          </div>
          <div style="clear:both; height:1em;"></div>
          <t-b>
            The function <c-s>show_type</c-s>, above, accepts a generic type <c-s>T</c-s>, not specified until
            the compiler sees its argument type at the call site. It uses a function
            <c-s>std::any::type_name::&lt;T&gt;()</c-s> that returns a string describing
            the argument <c-s>t</c-s>&apos;s type <c-s>T</c-s>. It also uses
            <c-s>std::mem::size_of::&lt;T&gt;()</c-s> that
            evaluates the size of a primitive type.  If T is a non-primative type with
            contents on the heap, <c-s>size_of</c-s> returns the size of its control block in stack memory
            but does not count heap allocation for its stored data members.
          </t-b>
          <t-b>
            We discuss generic types and functions in more detail <a target="_blank" href="Bits_GenericRust.html">here</a>.
          </t-b>
   -->
        <div style="clear:both;"></div>
        <h2 id="safe">2.0 Safety and Ownership</h2>
        <t-b>
          The design of the Rust programming language and especially its type system focuses
          on memory and data race safety. That means:
          <div class="focus">
            <ul style="margin-left:1em;">
              <li>
                Read and write operations happen only within program allocated memory.
              </li>
              <li>
                References are guaranteed to refer to valid targets.
              </li>
              <li>
                Threads may share data only within the confines of a lock.
                Each thread must acquire a lock to access data and then
                release it to enable other threads acess.
              </li>
            </ul>
          </div>
          These properties are guaranteed by construction.  The compiler will not
          build code that violates them.
        </t-b>
        <t-b>
          <a target="_blank" href="../RustBites/RustBites_Safety.html">Rust Bites - Safety</a> has more details about
          memory and data race safety.
        </t-b>
        <h3 id="own">2.1 Single Ownership Policy</h3>
        <t-b>
          To support safety Rust has a &quot;single ownership&quot; policy. Each value in memory has
          a single owner that manages its allocation, initialization, deallocation and lifetime.
          this means that:
          <ul>
            <li>
              Binding a name to a value assigns ownership of the value to the named variable.
              Only the owner has the authority to modify, use, or deallocate the value. No other
              variable can access or modify the value without borrowing the priviledge to do so
              from the owner.
            </li>
            <li>
              A collection like <c-s>Vec&lt;T&gt;</c-s> owns its members.
              In the code segment below, <c-s>v</c-s> owns the vector, and the vector owns the
              elements <c-s>[1, 2, 3]</c-s>.
              Program code can access them by taking a reference:
              <div style="height:0.50em;"></div>
              <div style="float:left; margin-left:0em; padding-right:2em;">
                <!--<h4 style="margin-top: 0em;">Example: Vector with reference to member</h4>-->
                <pre><code class="language-rust">  let v = vec![1, 2, 3];
  let rv = &v3[1];
</code></pre>
              </div>
            </li>
          </ul>
          <div style="height:0.25em; clear:both;"></div>
          <h3 id="mutref" class="clear">2.2 Borrows - Rust References</h3>
          <ul>
            <li>
              References are used to borrow access to a variable from its owner, e.g.,
              <c-s>let rv = &v</c-s>. Rust enforces
              strict rules for the use of references in order to guarantee memory and thread
              safety.
            </li>
            <li style="list-style:none;">
              <ul>
                <li>
                  Non-mutable references can share read-only access to a value.  Multiple
                  shared references to a single owned value are valid.
                </li>
                <li>
                  Mutable references, often called exclusive references,
                  provide exclusive access to the value. No other references can access the value
                  until the end of the mutable reference&apos;s lifetime.  That usually occurs when
                  the mutable reference goes out of scope.
                </li>
                <li>
                  These rules apply to use, not declaration.
                </li>
              </ul>
            </li>
            <!--<li>
        Non-mutable references can share read-only access to a value.  Multiple
        shared references to a single owned value are valid.
      </li>
      <li>
        Mutable references, often called exclusive references,
        provide exclusive access to the value. No other references can access the value
        until the end of the mutable reference&apos;s lifetime.  That usually occurs when
        the mutable reference goes out of scope.
      </li>-->
            <li>
              This is a strong constraint that may occasionally affect the way programs are designed.
              No shared mutability ensures that references to a collection, like <c-s>Vec&lt;T&gt;</c-s>,
              don&apos;t dangle when
              the collection reallocates its resource memory to provide more capacity.
              <div style="height:1.0em;"></div>
              <div style="float:left; margin-left:0em; padding-right:2em;">
                <h4 style="margin-top: 0em;">Example: Attempt to mutate collection with active reference</h4>
                <pre><code class="language-rust">  show_op("attempt to mutate Vec while immutable ref exists");
  let mut v3 = vec![1, 2, 3];
  let rv3 = &v3[1]; // ok to declare
  v3.push(4);  // v3 will reallocate if capacity is 3
  println!("  rv3: {rv3:?}"); // not ok to use
</code></pre>
                <div style="clear:both; height:0.5em;"></div>
                <h4 style="margin-top: 0em;">Example: Compiler error message</h4>
                <pre><code class="language-rust">C:\github\JimFawcett\Bits\Rust\rust_data
> cargo run
   Compiling rust_data v0.1.0 (C:\github\JimFawcett\Bits\Rust\rust_data)
error[E0502]: cannot borrow `v3` as mutable because it is also borrowed as immutable
   --> src\main.rs:417:3
    |
416 |   let rv3 = &v3[1]; // ok to declare
    |              -- immutable borrow occurs here
417 |   v3.push(4);  // v3 will reallocate if capacity is 3
    |   ^^^^^^^^^^ mutable borrow occurs here
418 |   println!("  rv3: {rv3:?}"); // not ok to use
    |                     ------- immutable borrow later used here    

For more information about this error, try `rustc --explain E0502`.   
error: could not compile `rust_data` (bin "rust_data") due to previous error
</code></pre>
              </div>
            </li>
          </ul>
          <div style="clear:both; height:1em;"></div>
          <h3 id="move">2.3 Copy, Move, and Clone Operations</h3>
          <ul>
            <li>
              Copy of primitives and Move are efficient because they copy only a few bytes. Clone is
              expensive for a collection as it copies both the collection control block and all its
              heap resources.
            </li>
            <li>
              Some Rust types implement the Copy trait. All primitives and aggregations of primitives
              are <a target="_blank" href="../../Pictures/StrCopy.jpg">&quot;copy&quot;</a> types.
              All other types are <a target="_blank" href="../../Pictures/StringMove.jpg">&quot;move&quot;</a>.
            </li>
            <li>
              For all copy types, construction, assignment, and pass-by-value results in data copy
              with no transfer of ownership, so the source is still valid.
              <div id="strcpy" style="height:0.75em;"></div>
              The <c-s>str</c-s> type represents a constant literal string in static memory. All <c-s>str</c-s>&apos;s
              are accessed by a reference, <c-s>&str</c-s>. The reference <c-s>&str</c-s> is copy.
              So copying an <c-s>&str</c-s> results in a second reference pointing to the original address.
              <photosizer-block src="pictures/strCopy2.png" width="500" class="photoSizerBlock" style="margin-top:0;">
                <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS', Tahoma;
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
                  Figure 1. Str Copy
                </span>
              </photosizer-block>
              <div style="height:1.0em;"></div>
              <div style="float:left; margin-left:0em; padding-right:2em;">
                <h4 style="margin-top: 0em;">Example: &str copy</h4>
                <pre><code class="language-rust">  let lstrs = "literal string";  // copy type
  let lstrd = lstrs;
  println!("  source: {lstrs:?}, address: {:p}", lstrs);
  println!("  destin: {lstrd:?}, address: {:p}", lstrd);
  nl();
  println!("  Note: a literal string is a fixed value in memory.
  All access occurs through a reference, so copies just copy
  the reference. Both variables point to the same address." 
  );</code></pre>
              </div>
              <div style="height:1.0em; clear:both;"></div>
              <div style="float:left; margin-left:0em; padding-right:2em;">
                <h4 style="margin-top: 0em;">Example: Results of &str copy</h4>
                <pre><code class="language-rust">--- direct copy &str ---
  source: "literal string", address: 0x7ff7e742b590
  destin: "literal string", address: 0x7ff7e742b590

  Note: a literal string is a fixed value in memory.
  All access occurs through a reference, so copies just copy
  the reference. Both variables point to the same address.
</code></pre>
              </div>
              <div style="height:1.0em; clear:both;"></div>
            </li>
            <li id="strmove">
              For all move types ownership will be transferred to another variable by construction,
              assignment, or pass-by-value as a function argument.  A &quot;moved-from&quot; variable
              is invalid. Any use of that will result in a compile error.
              <div style="height:0.75em;"></div>
              Move is a very efficient operation, copying only a few bites instead of the entire object.
              When a copy is needed, the developer can choose to explicitly clone the original value.
              <photosizer-block id="movediag" src="../../Pictures/StringMove.jpg" width="400" class="photoSizerBlock" style="margin-top:0;">
                <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS', Tahoma;
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
                  Figure 2. String Move
                </span>
              </photosizer-block>
              <t-b>
                <div style="float:left; margin-left:0em; padding-right:2em;">
                  <h4 style="margin-top: 0em;">Example: String Move</h4>
                  <pre><code class="language-rust">let s = String::from("a string");
let addrvec = &s;
let addrzero = std::ptr::addr_of!(s.as_bytes()[0]);
println!("address of s: {:p}", addrvec);
println!("address of first byte of s&apos;s char buffer: {:p}\n", addrzero);

let t = s;  // move
let addrvec = &t;
let addrzero = std::ptr::addr_of!(t.as_bytes()[0]);
println!("address of t: {:p}", addrvec);
println!("address of first byte of t&apos;s char buffer: {:p}\n", addrzero);</code></pre>
                </div>
                <div style="clear:both; height:1em;"></div>
                <div style="float:left; margin-left:0em; padding-right:2em;">
                  <h4 style="margin-top: 0em;">Example: Results of String Move</h4>
                  <pre><code class="language-rust">--- demo_move for String ---

--- let s = String::from("a string") ---
address of s: 0x25758ff558
address of first byte of s&apos;s char buffer: 0x1725ee5dcd0

--- let t:String = s; // move ---
address of t: 0x25758ff600
address of first byte of t&apos;s char buffer: 0x1725ee5dcd0

Note: s and t are unique objects
that share same buffer
but now, s is invalid
</code></pre>
                  <div style="clear:both; height:1em;"></div>
                </div>
              </t-b>
              <div style="clear:both;"></div>
            </li>
            <li id="strclone">
              Move types usually implement the <c-s>Clone</c-s> trait with the function <c-s>clone()</c-s>.
              Calling clone makes an independent copy of the source. The original and clone are independent
              entities with different owners. They have the same values immediately following the clone
              operation, but may mutate to different values, independently.
              <photosizer-block id="clonediag" src="../../Pictures/StringClone.jpg" width="400" class="photoSizerBlock" style="margin-top:0;">
                <span style="
              display: inline-block;
              font-weight: bold;
              font-family: 'Comic Sans MS', Tahoma;
              background-color: #ddd;
              width: 100%;
              padding: 5px 0px;
            ">
                  Figure 3. String Clone
                </span>
              </photosizer-block>
              <div style="clear:both; height:1.0em;"></div>
              <div style="float:left; margin-left:0em; padding-right:2em;">
                <h4 style="margin-top: 0em;">Example: String Clone</h4>
                <pre><code class="language-rust">let s_src = String::from("a string");
let s_src_addr = &s_src;
let s_src_bufaddr = std::ptr::addr_of!(s_src.as_bytes()[0]);
println!("  s_src: {:?}, address: {:p}", s_src, s_src_addr);
println!("  s_src_bufaddr: {:p}", s_src_bufaddr);
let s_cln = s_src.clone();
let s_cln_addr = &s_cln;
let s_cln_bufaddr = std::ptr::addr_of!(s_cln.as_bytes()[0]);
println!("  s_cln: {:?}, address: {:p}", s_cln, s_cln_addr);
println!("  s_cln_bufaddr: {:p}", s_cln_bufaddr);
nl();
println!("  Note: s_src and s_cln have different addresses
and their buffers have different addresses.
So they are unique entities.");
</code></pre>
              </div>
              <div style="clear:both; height:1em;"></div>
              <div style="float:left; margin-left:0em; padding-right:2em;">
                <h4 style="margin-top: 0em;">Example: Results of String Clone</h4>
                <pre><code class="language-rust">--- string clone ---
s_src: "a string", address: 0x7610d0f390
s_src_bufaddr: 0x229473682f0
s_cln: "a string", address: 0x7610d0f448
s_cln_bufaddr: 0x22947375d00

Note: s_src and s_cln have different addresses
and their buffers have different addresses.
So they are unique entities.
</code></pre>
              </div>
            </li>
          </ul>
        </t-b>
        <div style="clear:both; height:1em;"></div>
        <t-b>
          <h4 id="index">2.4 Indexing</h4>
          The array, array slice, and all of the std::library sequential collections support indexing.
          Rust tracks index operations in real time and, if an out-of-bounds index is used, the current
          thread of execution will &quot;panic&quot; causing an orderly thread termination before
          any reads or writes are executed. This prevents a memory access vulnerability common to
          other languages.
        </t-b>
        <h3 id="funcs">2.5 Analysis and Display Functions</h3>
        <t-b style="margin-top:0em;">
          When you look at any of the &quot;Output&quot; details, you will see
          some output with detailed formatting, but you won&apos;t see code providing
          that output in corresponding code sections.
        </t-b>
        <t-b>
          Code responsible for formatting and supplying low-level details,
          like type information, has been elided from the code shown above.
          The elided code consists of calls to functions shown in the dropdown below.
        </t-b>
        <t-b>
          These functions use language features, like generics, that will be covered
          in later Bits. You can find the complete code, including all the elisions,
          in the <a target="_blank" href="https://github.com/JimFawcett/Bits">Bits Repository</a>.
        </t-b>
        <details>
          <summary class="darkItem">Analysis &amp; Display Function Code&nbsp;</summary>
          <div class="block">
            <div class="codewrap">
              <pre>
<code class="language-rust">  #![allow(unused_mut)]
  #![allow(dead_code)]
  #![allow(clippy::approx_constant)]

  /* rust_data::bits_data_analysis.rs */
  /*-----------------------------------------------
    Note:
    Find all Bits code, including this in
    https://github.com/JimFawcett/Bits
    You can clone the repo from this link.
  -----------------------------------------------*/

  use std::fmt::Debug;

  /*-- show_type --------------------------------------
  Shows compiler recognized type and data value
  */
  pub fn show_type&lt;T: Debug&gt;(t: &T, nm: &str) {
    let typename = std::any::type_name::&lt;T&gt;();
    print!(&quot;  {nm}, {typename}&quot;);
    println!(
      &quot;&#92;n  value: {:?}, size: {}&quot;,
        // smart formatting {:?}
      t, std::mem::size_of::&lt;T&gt;()   
        // handles both scalars and collections
    );
  }
  /*---------------------------------------------------
    show string wrapped with long dotted lines above 
    and below
  */
  pub fn show_label(note: &str, n:usize) {
    let mut line = String::new();
    for _i in 0..n {
      line.push('-');
    }
    print!(&quot;&#92;n{line}&#92;n&quot;);
    print!(&quot;  {note}&quot;);
    print!(&quot;&#92;n{line}&#92;n&quot;);
  }
  pub fn show_label_def(note:&str) {
    show_label(note, 50);
  }
  /*---------------------------------------------------
    show string wrapped with dotted lines above 
    and below
  */
  pub fn show_note(note: &str) {
    print!(&quot;&#92;n-------------------------&#92;n&quot;);
    print!(&quot; {note}&quot;);
    print!(&quot;&#92;n-------------------------&#92;n&quot;);
  }
  /*---------------------------------------------------
    show string wrapped in short lines
  */
  pub fn show_op(opt: &str) {
    println!(&quot;--- {opt} ---&quot;);
  }
  /*---------------------------------------------------
    print newline
  */
  pub fn nl() {
    println!();
  }
/*---------------------------------------------------
  Show initialization of Rust's types
*/
fn show_formatted&lt;T:Debug&gt;(t:&T, nm:&str) {
  show_op(std::any::type_name::&lt;T&gt;());
  show_type(t, nm);
}</code>
            </pre>
            </div>
            <div class="textwrap">
              <t-b>
                The functions <c-s>show_type</c-s> and <c-s>show_formatted</c-s>
                are generic functions that accept any type T that implements the
                <c-s>Debug</c-s> trait.
              </t-b>
              <t-b>
                We will cover these in <a target="_blank" href="Bits_GenericRust.html">GenericRust</a>.
                For now, it is not important to know generics to understand what they do.
              </t-b>
              <hr />
              <t-b>
                <c-s>show_type</c-s> displays the calling name via parameter nm and the
                type name of t &epsilon; T. It also shows the value and size of t.
              </t-b>
              <t-b>
                The print format <c-s>{:?}</c-s> is very useful, as all of the language and
                library types provide formatted views of their values. We will show in the
                next <a target="_blank" href="Bits_ObjectsRust.html">Objects</a> Bit how
                user-defined types can do that as well.
              </t-b>
              <t-b>
                The function <c-s>std::mem::size_of::&lt;T&gt;()</c-s> measures the size of
                that part of t that resides in the calling function&apos;s stackframe.  It does
                not evaluate the size of data members residing in the heap.
              </t-b>
              <hr />
              <t-b>
                <c-s>show_label</c-s> displays a block of text preceded and succeeded by
                demarkation lines of specified size.
              </t-b>
              <hr />
              <t-b>
                <c-s>show_note</c-s> does the same thing with fixed length lines and additional
                spaces.
              </t-b>
              <hr />
              <t-b>
                <c-s>show_op</c-s> displays a line of text with prefix and and suffix short dotted lines.
              </t-b>
              <hr />
              <t-b>
                <c-s>nl</c-s> is a shorthand for &quot;<c-s>printlin!()</c-s>.
              </t-b>
              <hr />
              <t-b>
                <c-s>show_formatted</c-s> combines <c-s>show_op</c-s> and <c-s>show_type</c-s>
                to display formatted information about a Rust variable t &epsilon; T.
              </t-b>
            </div>
          </div>
        </details>
        <t-b>
          <h3 id="epilogue">3.0 Epilogue</h3>
          Most of the operations for language-defined and std::library types dicussed in this
          page will be covered again for user-defined types in <a target="_blank" href="Bits_ObjectsRust.html">Bits_ObjectsRust</a>.
        </t-b>
        <t-b>
          <h3 id="ref">4.0 References</h3>
          <table>
            <tr>
              <th>Link</th>
              <th>Comments</th>
            </tr>
            <tr>
              <td>
                <a target="_blank" href="https://doc.rust-lang.org/std/#primitives">Crate std</a>
              </td>
              <td>
                Rust documentation about primitive and library defined types.
              </td>
            </tr>
            <tr>
              <td>
                <a target="_blank" href="https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer">
                  fat pointers
                </a>
              </td>
              <td>
                Pointer to slices or trait objects contain an address and a length for these dynamically sized
                types.
              </td>
            </tr>
            <tr>
              <td>
                <a target="_blank" href="https://sanjuvi.github.io/Blog/posts/Rust-type-system-part-1/">
                  Rust&nbsp;Type&nbsp;System&nbsp;#1
                </a>
              </td>
              <td>
                Ownership, aliasing, lifetime
              </td>
            </tr>
            <tr>
              <td>
                <a target="_blank" href="https://sanjuvi.github.io/Blog/posts/Rust-type-system-part-2/">
                  Rust&nbsp;Type&nbsp;System&nbsp;#2
                </a>
              </td>
              <td>
                Algebraic types, generic associated types
              </td>
            </tr>
            <tr>
              <td>
                <a target="_blank" href="https://sanjuvi.github.io/Blog/posts/Rust-type-system-part-3/">
                  Rust&nbsp;Type&nbsp;System&nbsp;#3
                </a>
              </td>
              <td>
                Generic container types, interior mutability
              </td>
            </tr>
          </table>
        </t-b>


        <div style="height:50em;"></div>
      </content>
      <a id="bottom"></a>
      <!--<page-TOC id="pages" style="display:none;">
      </page-TOC>-->
      <!--<page-sections id="sections" style="display:none;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>-->
        <!--<menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#ops">ops</a></menu-elem>-->
        <!--<menu-elem class="secElem"><a href="#ref">ref</a></menu-elem>
        <menu-elem class="secElem"><a href="#epilogue">epilogue</a></menu-elem>
        <menu-elem class="secElem"><a href="#index">indexing</a></menu-elem>
        <menu-elem class="secElem"><a href="#move">cpy-mv-cln</a></menu-elem>
        <menu-elem class="secElem"><a href="#mutref">Rust refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#own">ownership</a></menu-elem>
        <menu-elem class="secElem"><a href="#safe">safety</a></menu-elem>
        <menu-elem class="secElem"><a href="#init">init</a></menu-elem>
        <menu-elem class="secElem"><a href="#typesys">typesys</a></menu-elem>
        <menu-elem class="secElem"><a href="#types">types</a></menu-elem>
        <menu-elem class="secElem"><a href="#syn">syn</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>-->
    </main>
    <!--<frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>-->
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
  <script>
    //localStorage.clear();
    //gotoLastScroll();
  </script>
</body>
</html>