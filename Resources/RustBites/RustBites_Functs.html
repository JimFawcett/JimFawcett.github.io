<!DOCTYPE html>
<html id="top">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Functs</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <script src="js/BiteScripts.js"></script>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <span class="top-center">Functions</span>
      <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a>
    </div>
  </div>

      <toc-b id="toc">
        <div style="display:flex; flex-direction:row">
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.sects()" style="color:#fefefa;">Sects</a>&nbsp;
          <a href="../../RustBiteByByte.html" style="color:#fefefa;">Repo</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">Esc</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp;
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
        <up-b id="chaps">
          <a href="RustBites_Facts.html">Facts</a><br />
          <a href="RustBites_Intro.html">Intro</a><br />
          <a href="RustBites_Data.html">Data</a><br />
          <a href="RustBites_DataStr.html">DataStr</a><br />
          <a href="RustBites_LifeCycle.html">LifeCycle</a><br />
          <a href="RustBites_UDB.html">UndefBhvr</a><br />
          <a href="RustBites_Ownrs.html">Ownershp</a><br />
          <a href="RustBites_SmrtPtrs.html">SmartPtrs</a><br />
          <a href="RustBites_Intmut.html">InterMutat</a><br />
          <a href="RustBites_Functs.html">Functions</a><br />
          <a href="RustBites_ErrHnd.html">ErrHand</a><br />
          <a href="RustBites_Structs.html">Structs</a><br />
          <a href="RustBites_Traits.html">Traits</a><br />
          <a href="RustBites_Generics.html">Generics</a><br />
          <a href="RustBites_LifeTime.html">LifeTime</a><br />
          <a href="RustBites_Abstract.html">Abstract</a><br />
          <a href="RustBites_Collects.html">Collects</a><br />
          <a href="RustBites_Iterator.html">Iterator</a><br />
          <a href="RustBites_Threads.html">Threads</a><br />
          <a href="RustBites_Synchron.html">Synchronz</a><br />
          <a href="RustBites_Channels.html">Channels</a><br />
          <a href="RustBites_AsyncAwt.html">AsyncAwt</a><br />
          <a href="RustBites_Macros.html">Macros</a><br />
          <a href="Javascript.;#"></a><br />
        </up-b>
        <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#funcs">Functions</a>, <a href="#return_types">Returns</a>, 
          <a href="#generics">Generics</a>, <a href="#closures">Closures</a>,
          <a href="#methods">Methods</a>, <a href="#exer">Exercises</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>
       </div>
   <bb-55>
    <h1>Rust Bite - Functions</h1>
    <hr />
    <t-b class="bottom">
      Functions and methods are fundamental building blocks for programs in most languages. 
      Rust is no exception. In this Bite we will focus first on free-standing functions and then look at 
      methods, which are attached to structs to form objects.
      <a id="funcs"></a>
      <s-halfEm></s-halfEm>
    </t-b>
    <t-b class="top">
      <ol class="tight top">
        <li>
          <h2>Functions:</h2>
          <t-b>
            The Rust syntax for functions is familiar:
            <div class="indent pad10">
              <defn-block>
                <defn-head>Function Syntax - Pass by Value</defn-head>
                <defn-code class="code-large">
fn f(t:T, u:U, ...) -> V {
  /* code that uses t, u, ...
      and returns an instance of V */
}
                </defn-code>
              </defn-block>
            </div>
            Here, f accepts its arguments by value, so if the caller&apos;s values are Move types like String or Vec,
            they are moved into the function and become invalid when the function returns.  Copy types are simply copied 
            and remain valid after the call.
          </t-b>
          <t-b>
            In Rust, the value of a scope is the value of its last expression (a statment with no semicolon).
            It is standard practice for Rust functions to make the return value the result of a final expression,
            although using return statements are also syntactically correct.  The first &quot;Function Examples&quot; dropdown
            illustrates how that works.
          </t-b>
          <t-b>
            Arguments can also be passed by reference:
            <div class="indent pad10">
              <defn-block>
                <defn-head>Function Syntax - Pass by Reference</defn-head>
                <defn-code class="code-large">
fn g(rt:&T, ru:&U, ...) {
  /* code that uses references rt, ru, ... */
}
                </defn-code>
              </defn-block>
            </div>
            Since, g accepts its arguments by reference, the caller&apos;s values are not moved into the function 
            and so, do not become invalid when the function returns.  
          </t-b>
          <div>
            <details>
              <summary class="darkItem">Function Examples:</summary>
              <s-halfEm></s-halfEm>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>functions_and_methods::main.rs</defn-head>
                  <defn-code>
// functions_and_methods::main.rs

fn f(mut s:String, t:String) -&gt; String {
    s.push(' ');
    s.push_str(&amp;t);
    s
}

fn g(s:&amp;mut String, t:&amp;str) -&gt; String {
    s.push(' ');
    s.push_str(t);
    s.to_string()
}

fn main() {

    print!("\n  -- passing function arguments by value --");
    let s1 = String::from("a string");
    print!("\n  s1 = {:?}", s1);
    let s2 = String::from("and more");
    print!("\n  s2 = {:?}", s2);
    
    let s3 = f(s1, s2);
    
    print!("\n  s3 = {:?}", s3);
    // print!("\n  s2 = {:?}", s2);
    print!("\n  can't print s2, it's been moved");
    // print!("\n  s1 = {:?}", s1);
    print!("\n  can't print s1, it's been moved");
    println!();

    print!("\n  -- passing function arguments by reference --");
    let mut s1 = String::from("a refreshed string");
    let s2 = "and a new more";
    let s3 = g(&amp;mut s1, s2);

    print!("\n  s3 = {:?}", s3);
    print!("\n  s2 = {:?}", s2);
    print!("\n  s1 = {:?}", s1);
    print!("\n  note: s1 has been changed as a side-effect");

    print!("\n\n  That's all Folks!\n\n");
}
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Output:</defn-head>
                  <defn-code>
cargo run -q

-- passing function arguments by value --
s1 = "a string"
s2 = "and more"
s3 = "a string and more"
can't print s2, it's been moved
can't print s1, it's been moved

-- passing function arguments by reference --
s3 = "a refreshed string and a new more"
s2 = "and a new more"
s1 = "a refreshed string and a new more"
note: s1 has been changed as a side-effect

That's all Folks!
                  </defn-code>
                </defn-block>
              </defn-outerBlock>
            </details>
          </div>
          <t-b>
            It doesn&apos;t make sense to return by 
            reference for free-standing functions, as the references would be invalid after the return.
            Of course, g could create an instance of something on the heap, using Box. 
            But it is as cheap to return 
            a Box by value as a reference, since the Box is the size of a pointer.
          </t-b>
          <t-b>
            We will see that it does make sense to return references from methods where the references 
            are bound to member data.  We will look at that in a later section.
            <a id="return_types"></a>
            <s-halfEm></s-halfEm>
          </t-b>
        </li>
        <li>
          <h2>Special Return Types:</h2>
          <t-b>
            Rust provides two enumerations to support special needs for function return values.  The first is
            Option: 
            <div class="indent pad10">
              <defn-block>
                <defn-head>Option Enumeration</defn-head>
                <defn-code class="code-large">
enum Option&lt;T&gt; { Some(T), None, }
                </defn-code>
              </defn-block>
            </div>
            Unlike some other languages, Rust enumeration values can wrap instances of some type. 
            The Option::Some(T) wraps an instance of the type a function evaluates. But Option supports 
            the case where the function may have nothing to return.
          </t-b>
          <t-b>
            For example, if the function is passed a collection from which it computes a value to return, 
            if the collection is empty, the function may have nothing to return, so it can return None, 
            rather that Some(t:T).
          </t-b>
          <t-b>
            For functions that may encounter an error during processing, Rust provides the enumeration Result:
            <div class="indent pad10">
              <defn-block>
                <defn-head>Result Enumeration</defn-head>
                <defn-code class="code-large">
enum Result&lt;T&gt; { Ok(T), Err(E), }
                </defn-code>
              </defn-block>
            </div>
            Perhaps the function is attempting to open a file.  If that succeeds it may return <c-s>Ok(f: File)</c-s>.
            If not, it returns <c-s>Err(err: std::io::Error)</c-s>.
          </t-b>
          <t-b>
            Below, find examples that illustrate use of these return types in a practical setting.
          </t-b>
          <t-b>
            <div>
              <details>
                <summary class="darkItem">Examples of Return Types:</summary>
                <defn-outerBlock>
                  <defn-block>
                    <defn-head>return_values::main.rs</defn-head>
                    <defn-code>
/////////////////////////////////////////////////////////////
// return_values::main.rs - demo Option&lt;T&gt; and Result&lt;T,E&gt; //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 Jun 2020  //
/////////////////////////////////////////////////////////////

#![allow(dead_code)]

/*-- show that scopes evaluate to their last expression --*/
fn demo_scope_value() {
    let v1 = { 2 + 3 };
    assert_eq!(v1, 5);
    let v2 = { let s = "a string slice"; s };
    assert_eq!(v2, "a string slice");
    let v3 = { let _s = "another string"; };
    assert_eq!(v3, ());
}

/*-- demo Option&lt;T&gt; with collection --*/
fn sum(v:&Vec&lt;i32&gt;) -> Option&lt;i32&gt; {
    if v.is_empty() {
        return None;
    }
    let iter = v.iter();
    let sum = iter.sum();
    Some(sum)
}

/*-- demonstrate file error handling with Result&lt;T,E&gt; --*/
use std::fs::File;
use std::io::prelude::*;
use std::io::{ Result };

/*-- unwrap or bubble up error (uobue) --*/
fn create_test_file(f:&str, cnt:&str) -> Result&lt;File&gt; {
    print!("\n  attempting to create file {:?}", f);
    let mut file = File::create(f)?; //uobue
    print!("\n  attempting to write contents {:?}", cnt);
    file.write_all(cnt.as_bytes())?; // uobue
    Ok(file)
}

/*-- unwrap or bubble up error (uobue) --*/
fn open_file_and_read(f:&str) -> Result&lt;String&gt; {
    print!("\n  attempting to open file {:?}", f);
    let mut file = File::open(f)?; //uobue
    print!("\n  attempting to read contents");
    let mut buf = String::new();
    file.read_to_string(&mut buf)?; // uobue
    Ok(buf)
}

/*-- run demonstrations --*/
fn main() -> Result&lt;()&gt; {

    demo_scope_value();

  /*-----------------------------------------------------*/
    print!("\n  -- demonstrate Option --");
    let v = Vec::&lt;i32&gt;::new();
    let opt = sum(&v);
    if opt.is_none() {
        print!("\n  no content to sum");
    } 

    let v = vec![1, 2, 3, 4, 5];
    let opt = sum(&v);
    if opt.is_some() {
        print!(
          "\n  sum of {:?} is {}", v, opt.unwrap()
        );
    }
    println!();

  /*-------------------------------------------------*/
    print!("\n  -- demonstrate Result&lt;T,E&gt; --");
    let file_name = "new_file.txt";
    let content = "\n  first line\n  second line";

    print!(
      "\n  attempting to create file {:?}", file_name
    );
    let rslt = File::create(file_name);
    if rslt.is_ok() {
        print!("\n  open succeeded");
        let content = "\n  first line\n  second line";
        print!("\n  attempting to write {:?}", content);
        let mut fl = rslt.unwrap();
        let wrslt = fl.write_all(content.as_bytes());
        if wrslt.is_ok() {
            print!("\n  write succeeded");
        }
        else {
            print!("\n  write failed");
        }
    }
    print!("\n  attempting to open {:?}", file_name);
    let rslt = File::open(file_name);
    if rslt.is_ok() {
        print!("\n  attempting to read contents");
        let mut f = rslt.unwrap();
        let mut buf = String::new();
        let rrslt = f.read_to_string(&mut buf);
        if rrslt.is_ok() {
            print!("\n  contents:{}", buf);
        }
        else {
            print!("\n  can't read file {:?}", file_name);
        }
    }
    println!();

  /*-------------------------------------------------*/
    print!("\n  -- demonstrate Result&lt;T,E&gt; using ? --");
    let mut _file = 
        create_test_file(file_name, content)?; // uobue
    /*-- write more text using _file --*/
    _file.write_all(
        b"\n  third line\n  fourth line"
    )?; // uobue
    let text = open_file_and_read(file_name)?; // uobue
    print!("\n  file contents:{}", text);

    println!("\n\n  That's all Folks!\n\n");
    Ok(())
}
                    </defn-code>
                  </defn-block>
                  <defn-block>
                    <defn-head>Output:</defn-head>
                    <defn-code>
  cargo run -q

  -- demonstrate Option --
  no content to sum
  sum of [1, 2, 3, 4, 5] is 15

  -- demonstrate Result&lt;T,E&gt; --
  attempting to create file "new_file.txt"
  open succeeded
  attempting to write 
      "\n  first line\n  second line"
  write succeeded
  attempting to open "new_file.txt"
  attempting to read contents
  contents:
  first line
  second line

  -- demonstrate Result&lt;T,E&gt; using ? --
  attempting to create file "new_file.txt"
  attempting to write contents 
      "\n  first line\n  second line"
  attempting to open file "new_file.txt"
  attempting to read contents
  file contents:
  first line
  second line
  third line
  fourth line

  That's all Folks!
                    </defn-code>
                  </defn-block>
                </defn-outerBlock>
              </details>
            </div>
          </t-b>
          <t-b>
            One thing to note about the examples, above: 
          </t-b>
          <t-b>
            If the last construct in a scope is an expression (a statement minus its semicolon), then
            that is treated as the value of the scope.  If there is no terminating expression, the 
            value of the scope is (), the unit, signifying no value.  See demo_scope_value() in the 
            Examples, above, for confirmation.
          </t-b>
          <t-b>
            If a function signature declares some return value and if the function scope ends with an
            expression, the value of the expression is treated as the return value.  Return statements
            also work, but ending expressions are idiomatic Rust.
          </t-b>
          <t-b>
            You will observe that all the functions, including main, in the examples, above, use
            terminal expressions to return results.
            <a id="generics"></a>
          </t-b>
        </li>
        <li>
          <h2>Generic Functions:</h2>
          <t-b>
            Generic functions accept arguments, one or more of which depend on an 
            unspecified type.  Generic types are resolved to concrete types when the 
            invoking code is compiled.
          </t-b>
          <t-b>
            Usually a generic argument is constrained by one or more
            traits.  In the case of the generic function, show below, T is constrained 
            to support the Debug trait - Debug specifies a display format suitable for
            debugging applications.  
          </t-b>
          <t-b>
            If the invoking argument does not satisfy constraints 
            imposed by the function, it will fail to compile.
          </t-b>
          <div>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Generic Function</defn-head>
                <defn-code>
/*-----------------------------------------------
    Show slice as stack of rows
    - span is number of items in row
    - width is size of field holding item
*/
fn show_fold&lt;T:Debug&gt;(t:&[T], span:usize, width:usize) {
    print!("\n  ");
    let mut count = 0;
    for item in t {
        count = count + 1;
        print!("{:wd$?}", item, wd = width);
        if count == span {
            print!("\n  ");
            count = 0;
        }
    }
}
                </defn-code>
              </defn-block>
              <div>
                <defn-block>
                  <defn-head>Using Code:</defn-head>
                  <defn-code>
fn demo_array_int() -> Option&lt;()&gt; {

  // code elided - includes function returning Option
  
  let arr = 
      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
  show_fold(&arr, 5, 4);
  Some(())
}
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Output:</defn-head>
                  <defn-code>
// output elided

 0   1   2   3   4
 5   6   7   8   9
10  11
                  </defn-code>
                </defn-block>
                </div>
              </defn-outerBlock>
          </div>
          <t-b>
            In the example shown in the dropdown, below, you will find a generic 
            function used to display collection contents to the console.
          </t-b>
          <t-b>
            It displays a comma separated list of values from a collection of arbitrary 
            type that satisfies the constraints: the collection must define the IntoIterator
            trait, to support iterating through the collection, it must support the clone 
            type to avoid consuming the collection, and the collection and its items must
            satisfy the Debug trait.
          </t-b>
          <t-b>
            We will discuss traits in some detail in the <a href="RustBites_Traits.html">Traits</a> Bite.
          </t-b>
          <div>
            <details>
              <summary class="darkItem">Generic Function that displays collections: show_coll:</summary>
              <s-halfEm></s-halfEm>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>collections::main.rs</defn-head>
                  <defn-code>
use std::fmt::Debug;
use std::any::*;
/*-----------------------------------------------------------
    Display comma separated list of collection items
    - shows how to build function accepting iterable 
      collections
    - returns Option::None if collection is empty
*/
fn show_coll&lt;C&gt;(c:&amp;C) -&gt; Option&lt;()&gt; 
  where C:IntoIterator + Clone + Debug, C::Item: Debug {

    let mut iter = c.clone().into_iter();
    /*-------------------------------------------
      returns Option if no next element using 
      ? try operator
    */
    print!("\n  {:?}", iter.next()?);
    /*-- breaks when no next element --*/
    for item in iter {
        print!(", {:?}", &amp;item);
    }
    Some(())
}
                </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Using Code:</defn-head> 
                  <defn-code>
  fn demo_array_int() -> Option&lt;()&gt; {

    print!("\n  === demo_array_int ===");
    let mut arr : [i32; 5] = [0; 5];
    show_coll(&&arr)?;
    arr = [1, 2, 3, 4, 5];
    show_coll(&&arr)?;
    let arr_slice = &arr[..];
    show_coll(&arr_slice);
    arr[1] = -1;
    show_coll(&&arr)?;
    let arr = 
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    show_fold(&arr, 5, 4);
    Some(())
}

fn demo_vec_int() {

    print!("\n  === demo_vec_int ===");
    let mut vec = vec![1, 2, 3, 4, 5];
    show_coll(&vec);
    print!("\n  -- assign vectors --");
    vec = vec![5, 4, 3, 2, 1];
    show_coll(&vec);

    // rest of code elided
}
                  </defn-code>
                  <defn-head class="defnBorderTop">Output:</defn-head>
                  <defn-code>
  === demo_array_int ===
  0, 0, 0, 0, 0
  1, 2, 3, 4, 5
  1, 2, 3, 4, 5
  1, -1, 3, 4, 5
     0   1   2   3   4
     5   6   7   8   9
    10  11
  === demo_vec_int ===
  1, 2, 3, 4, 5
  -- assign vectors --
  5, 4, 3, 2, 1

  // rest of output elided
                  </defn-code>
                </defn-block>
              </defn-outerBlock>
            </details>
          </div>
          <t-b>
            In the dropdown, below, you will find two functions used to display 
            information about the value and type of a generic parameter.  These can be useful
            when you are investigating a third-party library or trying to get your own code to compile 
            and run correctly.
          </t-b>
          <t-b>
            The first of the two functions uses &apos;a to denote a lifetime.  Rust tracks the lifetimes
            of all references to be sure they do not outlive their referends.  The compiler&apos;s 
            borrow checker occasionally needs help to determine a lifetime, and that is done with this 
            notation.  We will discuss this more in the <a href="RustBites_lifetime.html">lifetime</a> Bite.
          </t-b>
          <div>
            <details>
              <summary class="darkItem">Examples of Generic Display Functions:</summary>
              <s-halfEm></s-halfEm>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>collections::main.rs</defn-head>
                  <defn-code>
use std::any::*;
/*-----------------------------------------------------------
    Display type name of generic input argument
    - returns reference, &str, to literal string
    - requires lifetime annotation, 'a
    - argument name _t tells compiler we don't intend to
      use the argument, just its type T
*/
fn show_type&lt;'a, T:Debug&gt;(_t:T) -&gt; &amp;'a str where T:Debug {
    type_name::&lt;T&gt;()
}

use std::fmt::Debug;
/*-----------------------------------------------------------
    Display argument name, argument value, and type of 
    generic input, t:T
*/
fn show_type_value&lt;T:Debug&gt;(name:&amp;str, t:&amp;T) {
  print!("\n  value of {} = {:?}", name, t);
  print!("\n  type is: {}", show_type(t));
}
                </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Using Code:</defn-head> 
                  <defn-code>
fn demo_struct() {
  print!("\n  -- demo_struct --");
  #[derive(Debug)]
  struct S { a:i8, b:String, c:f64 }
  let s: S = S { a:42, b:String::from("String"), c:3.1415927 };
  assert_eq!(s.a, 42);
  show_type_value("s", &s);
  print!("\n  s.a = {}, s.b = {}, s.c = {}", s.a, s.b, s.c);
  println!();

  #[derive(Debug)]
  struct T(i8, String, f64);
  let t:T = T(42, String::from("String"), 3.1415927);
  assert_eq!(t.0, 42);
  show_type_value("t", &t);
  print!("\n  t.0 = {}, t.1 = {}, t.2 = {}", t.0, t.1, t.2);
  println!();

  // code elided

}
                  </defn-code>
                  <defn-head class="defnBorderTop">Output:</defn-head>
                  <defn-code>
  -- demo_struct --
  value of s = S { a: 42, b: "String", c: 3.1415927 }
  type is: &collections::demo_struct::S
  s.a = 42, s.b = String, s.c = 3.1415927

  value of t = T(42, "String", 3.1415927)
  type is: &collections::demo_struct::T
  t.0 = 42, t.1 = String, t.2 = 3.1415927

  // output elided

                  </defn-code>
                </defn-block>
              </defn-outerBlock>
            </details>
          </div>
          <t-b>
            In the last dropdown for this section you will find basic and more advanced topics:
            <div>
              <ol class="tight">
                <li>pass and return by value and reference</li>
                <li>functions that take and return function arguments</li>
                <li>dynamic dispatch - compared to static dispatch</li>
                <li>local functions</li>
              </ol>
            </div>
          </t-b>
          <div>
            <details>
              <summary class="darkItem">Examples: Summary of function topics:</summary>
              <s-halfEm></s-halfEm>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>functions::main.rs</defn-head>
                  <defn-code>
/////////////////////////////////////////////////////////////
// functions_and_methods::main.rs - functions Bite demos   //
//                                                         //  
// Jim Fawcett, https://JimFawcett.github.com, 19 Jun 2020 //
/////////////////////////////////////////////////////////////

// https://stackoverflow.com/questions/36390665
//       /how-do-you-pass-a-rust-function-as-a-parameter
// https://joshleeb.com/blog/rust-traits-trait-objects/

/*-----------------------------------------------------
  pass arguments by value 
  - passing by value results in Move for non-copy types
  - we say that the s and t arguments are consumed
  */
fn f(mut s:String, t:String) -> String {
    s.push(' ');
    s.push_str(&t);
    s  // value of last expression is returned
}
/*-----------------------------------------------------
  pass arguments by reference
  - passing s and t does not consume their referends 
*/
fn g(s:&mut String, t:&str) -> String {
    s.push(' ');
    s.push_str(t);
    s.to_string()
}
/*-----------------------------------------------------
  h_in_2 accepts function argument via static dispatch
  - F: Fn ... specifies accepted function signatures
*/
fn h_in_1<F: Fn(i32) -> String>(i:i32, f: F) -> String {
  f(i)
}
/*-----------------------------------------------------
  h_in_2 accepts function argument via dynamic dispatch
  - Fn ... specifies accepted function signatures
*/
fn h_in_2(i:i32, f: &dyn Fn(i32) -> String) -> String {
  f(i)
}
/*-----------------------------------------------------
  function passed to, and returned from demonstration
  functions, below
*/
fn test_function(i:i32) -> String {
    i.to_string()
}
/*-----------------------------------------------------
  static dispatch of returned function
  - uses impl to specify that return satisfies Fn ... 
*/
fn h_out_1() -> impl Fn(i32) -> String {
    &test_function
}
/*-----------------------------------------------------
    dynamic dispatch of returned function 
    - uses lifetime annotation 'a
    - &dyn to include vtable
*/
fn h_out_2<'a>() -> &'a dyn Fn(i32) -> String {
    &test_function
}
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Using Code:</defn-head>
                  <defn-code>
  fn main() {

    print!(
      "\n  -- passing function args by value --"
    );
    let s1 = String::from("a string");
    print!("\n  s1 = {:?}", s1);
    let s2 = String::from("and more");
    print!("\n  s2 = {:?}", s2);
    
    let s3 = f(s1, s2);
    
    print!("\n  s3 = {:?}", s3);
    // print!("\n  s2 = {:?}", s2);
    print!("\n  can't print s2, it's been moved");
    // print!("\n  s1 = {:?}", s1);
    print!("\n  can't print s1, it's been moved");
    println!();

    print!(
      "\n  -- passing function args by reference --"
    );
    let mut s1 = String::from("a refreshed string");
    let s2 = "and a new more";
    let s3 = g(&mut s1, s2);

    print!("\n  s3 = {:?}", s3);
    print!("\n  s2 = {:?}", s2);
    print!("\n  s1 = {:?}", s1);
    print!(
      "\n  note - s1 has been changed as side-effect"
    );
    println!();

    print!("\n  -- passing function as argument --");
    /*-- static dispatch --*/
    let s = h_in_1(42, &test_function);
    print!("\n  s = {}", s);
    /*-- dynamic dispatch --*/
    let s = h_in_2(42, &test_function);
    print!("\n  s = {}", s);
    println!();

    print!("\n  -- function returning function --");
    let s = h_out_1()(42);  // static dispatch
    print!("\n  s = {}", s);
    let s = h_out_2()(42);  // dynamic dispatch
    print!("\n  s = {}", s);
    println!();

    print!(
      "\n  -- defining function inside function --"
    );
    fn whooaaa() {
        print!("\n  whooaaa - inside main!");
    }
    whooaaa();

    print!("\n\n  That's all Folks!\n\n");
}
                  </defn-code>
                  <defn-head class="defnBorderTop">Output:</defn-head>
                  <defn-code>
  cargo run -q

  -- passing function arguments by value --
  s1 = "a string"
  s2 = "and more"
  s3 = "a string and more"
  can't print s2, it's been moved
  can't print s1, it's been moved

  -- passing function arguments by reference --       
  s3 = "a refreshed string and a new more"
  s2 = "and a new more"
  s1 = "a refreshed string and a new more"
  note that s1 has been changed as a side-effect      

  -- passing function as argument --
  s = 42
  s = 42

  -- function returning function --
  s = 42
  s = 42

  -- defining function inside another function --     
  whooaaa - inside main!

  That's all Folks!
                  </defn-code>
                </defn-block>
              </defn-outerBlock>
            </details>
          </div>
          <t-b>
            In the next section we discuss closures, sometimes call lambdas.  They work a lot like locally
            defined functions, although their syntax is quite different, and they can do one thing that 
            functions can&apos;t.
            <a id="closures"></a>
            <s-halfEm></s-halfEm>
            </t-b>
        </li>
        <li>
          <h2>Closures:</h2>
          <a id="methods"></a>
        </li>
        <li>
          <h2>Methods:</h2>
          <a id="exer"></a>
        </li>
        <li>
          <h2>Exercises:</h2>
        </li>
      </ol>
    </t-b>
 </bb-55>
  </body>
</html>
