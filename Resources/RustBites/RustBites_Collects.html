<!DOCTYPE html>
<html>
<!--
  RustBites_Enums.html
-->
<head>
  <title>RustBite Collections</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeRust.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesRustTrack.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <style>
    #github table {
      max-width: 80%;
      border: 1px solid black;
      margin-top: 1em;
      margin-bottom: 1.0em;
    }

      #github table.flashcard {
        width: 100%;
        table-layout: fixed;
        border-collapse: collapse;
        border: 4px groove #222;
      }

        #github table.flashcard td {
          padding: 0.5rem 1.5rem;
          border: 4px groove #000;
          /*min-width:50px;*/
        }

        #github table.flashcard li {
          /*width:max-content;*/
          max-width: 30rem;
        }

        #github table.flashcard td {
          overflow: auto;
        }

        #github table.flashcard th.topic {
          width: 12rem;
        }

        #github table.flashcard td.topic {
          width: 10rem;
        }

        #github table.flashcard th.schema {
          width: 20rem;
          text-align: center;
        }

        #github table.flashcard td.schema {
          width: 20rem;
          text-align: center;
        }

        #github table.flashcard td img {
          width: 100%;
          height: auto;
          padding: 0rem;
        }

      #github table.invis {
        width: 90%;
        border: none;
      }

      #github table tr {
        border: 1px solid var(--dark);
      }

        #github table tr.invis {
          border: none;
        }

        #github table tr th {
          color: var(--dark);
          background-color: var(--menu);
        }

          #github table tr th.invis {
            border: none;
          }

        #github table tr td {
          color: var(--dark);
          background-color: var(--light);
        }

          #github table tr td.invis {
            border: none;
          }

      #github table a:link {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:visited {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:hover {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:active {
        color: var(--dark);
        background-color: transparent;
      }

    #github hr.dotted {
      border: none;
      border-top: 2px dashed var(--dark);
      color: var(--light);
      background-color: var(--light);
      height: 1px;
      width: 55em;
      margin-top: 0.5em;
      margin-bottom: 1.5em;
    }
  </style>
  <style>
    #github .topborder {
      border-top: 1px solid #363636;
    }

    #github th.num {
      width: 3em;
      text-align: right;
      padding-right: 1.0em;
    }

    #github td.num {
      width: 3em;
      text-align: right;
      padding-right: 1.0em;
    }

    #github th.elem {
      padding-right: 2.0em;
      white-space: nowrap;
    }

    #github td.elem {
      padding-right: 2.0em;
      white-space: nowrap;
    }

    t-b {
      display: block;
      margin-top: 0.75rem;
      margin-bottom: 0.75rem;
      max-width: 55rem;
    }

    #github td > hr {
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    #github c-s {
      font-size: 1.0em;
      font-weight: normal;
    }
  </style>
<!--   <script>
    window.onmessage = function () {
      // alert('msg received');
      bottomMenu.sections();
    }
  </script>
 --></head>
<body id="github" onload="initialize()">

  <a id="Next" href="RustBites_Iterator.html">Next</a>
  <a id="Prev" href="RustBites_Conversions.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="modified">05/11/2022</div>
      <div id="page">RustBites - Collections</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Consuming_Rust_bite_by_byte" style="margin-right:-0.2em;">
            Code Repository
          </a>
          <a target="_blank" class="repoLink" href="RustBites_CodeExamples.html" style="margin-right: 7.65em;">
            Code Examples
          </a>
          <a target="_blank" class="repoLink" href="../../RustBiteByByte.html" style="margin-right: 15.05em;">
            Rust Bites Repo
          </a>
          <hgroup id="pagetitle">
            <h1>Rust Bite - Collections</h1>
            <h3 id="subtitle" class="indent">frequently used Rust standard data structures</h3>
          </hgroup>
        </header>
   
    <t-b>
      In the table below you will find brief descriptions of many of the Rust collection types.  They each
      have a brief description, code snippet, diagram, and a small Rust playground example.
    </t-b>
    <t-b>
      The intent is to give you a quick mental model for these types.  Each of them, in the left
      column, are links to the Rust standard documentation for those types.
    </t-b>
    <div>
      <div style="height: 1rem;"></div>
        <table class="flashcard" style="max-width:100%">
          <tr>
            <th class="darkItem topic">Type</th>
            <th class="darkItem">Description</th>
            <th class="darkItem schema">Diagram</th>
          </tr>
          <tr id="array">
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/primitive.array.html">
                array&lt;T, N&gt;
              </a>
            </td>
            <td>
              Collection of instances of type T residing in contiguous stack memory.  
              <ul class="tight">
                <li>
                  create array:
                  <indent-block class="tight">
                    <c-s>let mut array: [i32; 3] = [1, 2, 3];</c-s><br />
                    <c-s>array[1] = -2;</c-s>
                  </indent-block>
                </li>
                <li>
                  An array is a copy type, provided that T is copy.
                </li>
                <li>
                  Code demo: 
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=9bcc16716d03add8b226f6adbafa845a">
                    create and display arrays
                  </a>
                </li>
              </ul>
              <div style="height:0.5rem;"></div>
            </td>
            <td class="schema">
              <img src="pictures/array.jpg" />
            </td>
          </tr>
          <tr id="tuple">
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/primitive.tuple.html">
                tuple&lt;T,&nbsp;U,&nbsp;V,&nbsp;...&gt;
              </a>
            </td>
            <td>
              Collection of instances of possibly different types residing in contiguous memory.  
              <ul class="tight">
                <li>
                  create tupl:
                  <indent-block class="tight">
                    <c-s>let t: (&'static str, i32, char)  =<br />&nbsp;&nbsp;&nbsp;&nbsp;("a tuple", 42, 'Z');</c-s><br />
                    <c-s>let mut u = t;</c-s><br />
                    <c-s>u.1 = -42;</c-s>
                  </indent-block>
                </li>
                <li>
                  Tupls are copy if, and only if, each member is copy.
                </li>
                <li>
                  Code demo: 
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=fbef855c9d8614b1ada99cacfd4b364f">
                    create and display tuples
                  </a>
                </li>
              </ul>
              <div style="height:0.5rem;"></div>
            </td>
            <td class="schema">
              <img src="pictures/tuple.jpg" />
            </td>
          </tr>
          <tr id="struct">
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/vec/struct.Vec.html">
                Struct&lt;T,&nbsp;U,&nbsp;V,&nbsp;...&gt;
              </a>
            </td>
            <td>
              Collection of instances of possibly different types residing in contiguous memory.  
              <ul class="tight">
                <li>
                  create struct:
                  <indent-block class="tight">
                    <c-s>struct MyType { d: f64, ... }</c-s><br />
                    <c-s>let s = MyType { d: 3.14, ... };</c-s>
                    <c-s>let t = s;</c-s>
                  </indent-block>
                </li>
                <li>
                  Structs are copy types if, and only if, each member is copy.
                </li>
                <li>
                  Code demo: 
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=9e296e3e651a84f0bf75408902cbb9a2">
                    create and display structs
                  </a>
                </li>
              </ul>
              <div style="height:0.5rem;"></div>
            </td>
            <td class="schema">
              <img src="pictures/struct.jpg" />
            </td>
          </tr>
          <tr id="vec">
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/vec/struct.Vec.html">
                Vec&lt;T&gt;
              </a>
            </td>
            <td>
              Collection of instances of type T residing in contiguous heap memory.  
              <ul class="tight">
                <li>
                  consists of control block in stack holding pointer to array of T instances in heap
                </li>
                <li>
                  reallocates heap memory to accept new instance when capacity is full
                </li>
                <li>
                  create vector:
                  <indent-block class="tight">
                    <c-s>let v = Vec::&lt;int&gt;::new();</c-s><br />
                    <c-s>let w: Vec&lt;T&gt; = vec![t1, t2, t3];</c-s>
                  </indent-block>
                </li>
                <li>
                  v and w are dropped, returning resources, when they go out of scope.
                </li>
                <li>
                  Code demo: 
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=43d6fc3c2898cc1421e05cd08f4dc408">
                    create and display vectors
                  </a>
                </li>
              </ul>
              <div style="height:0.5rem;"></div>
            </td>
            <td class="schema">
              <img src="pictures/Vec.jpg" />
            </td>
          </tr>
          <tr id="vecdeq">
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">
                VecDeque&lt;T&gt;
              </a>
            </td>
            <td>
              Collection of instances of type T residing in a circular buffer in heap memory.  
              <ul class="tight">
                <li>
                  consists of control block in stack holding pointer to circular buffer of T instances in heap
                </li>
                <li>
                  Control block contains references to the front and back of the VecDeque.
                </li>
                <li>
                  reallocates heap memory to accept new instance when capacity is full
                </li>
                <li>
                  create queue:
                  <indent-block class="tight">
                    <c-s>let v = VecDec::&lt;T&gt;::new();</c-s><br />
                    <c-s>v.push_back(t1); v.push_back(t2); let u = v.pop_front();</c-s>
                  </indent-block>
                </li>
                <li>
                  v and u are dropped, returning resources, when they go out of scope.
                </li>
                <li>
                  Code demo: 
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0b35526b63e5dfa873724a3fdac5b27f">
                    create and display vecdeque
                  </a>
                </li>
              </ul>
              <div style="height:0.5rem;"></div>
            </td>
            <td class="schema">
              <img src="pictures/VecDeque.jpg" />
            </td>
          </tr>
          <tr id="hashmap">
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">
                HashMap&lt;K,V&gt;
              </a>
            </td>
            <td>
              Collection of buckets (linked list of key-value pairs) rooted in table in heap memory.  
              <ul class="tight">
                <li>
                  Consists of control block in stack holding pointer to address table of buckets in heap
                </li>
                <li>
                  Hash function used to calculate table address from key.
                </li>
                <li>
                  If hash yields address with existing bucket, key-value pair added to bucket list.
                </li>
                <li>
                  Reallocates table memory when table bucket count approaches table size.
                </li>
                <li>
                  create hashmap:
                  <indent-block class="tight">
                    <c-s>let h = HashMap::&lt;K,V&gt;::new();</c-s><br />
                    <c-s>h.insert(k,v);</c-s>
                  </indent-block>
                </li>
                <li>
                  table and all bucket elements are dropped when they go out of scope.
                </li>
                <li>
                  Code demo: 
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=f11d241deb2b45d9eef4e4aba4c22112">
                    create and display HashMap
                  </a>
                </li>
              </ul>
              <div style="height:0.5rem;"></div>
            </td>
            <td class="schema">
              <img src="pictures/HashMap.jpg" />
            </td>
          </tr>
          <tr id="string">
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/string/struct.String.html">String</a>
            </td>
            <td>
              Collection of utf-8 characters residing in contiguous heap memory.  
              <ul class="tight">
                <li>
                  consists of control block in stack holding ptr to contiguous heap memory allocation.
                </li>
                <li>
                  a utf-8 character may occupy from 1 to 4 bytes, allowing a large collection of
                  language sets, e.g., ASCII, Unicode, Kanji, Arabic, ...
                </li>
                <li>
                  The item above means that Rust std::String instances cannot be indexed.  There is a
                  string iterator, called <c-s>chars()</c-s>, that understands byte sequences that define
                  utf-8 character boundaries.
                  <indent-block>
                    <c-s>
                      let s = String::from("a literal string");<br />
                      let c2 = s.chars().nth(4).unwrap();
                    </c-s>
                  </indent-block>
                </li>
                <li>
                  reallocates heap memory to accept new character(s) when capacity is full
                </li>
                <li>
                  create String:
                  <indent-block class="tight">
                  <c-s>let s = String::new();</c-s><br />
                  <c-s>let t = String::from("a string");</c-s>
                  </indent-block>
                </li>
                <li>
                  s and t are dropped, returning resources, when they go out of scope.
                </li>
                <li>
                  Code demo: 
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b8358deb93de35248f56b3ecfe5e67ef">
                    create and manipulate String and str
                  </a>
                </li>
              </ul>
              <div style="height:0.5rem;"></div>
            </td>
            <td class="schema">
              <img src="pictures/String.jpg" />
            </td>
          </tr>
          <tr id="str">
            <td>
              <a target="_blank" href="https://doc.rust-lang.org/std/str/index.html">str</a>
            </td>
            <td>
              str is a copy type that represents a literal string in contiguous block of memory
              <ul class="tight">
                <li>
                  converting between str and String:<br />
                  <c-s>
                    &nbsp;&nbsp;let s = "an ordered collection of utf-8 characters";<br />
                    &nbsp;&nbsp;let t = String::from(s);<br />
                    &nbsp;&nbsp;let u = &S;
                  </c-s>
                </li>
                <li>
                  Literal strings are almost always used via a reference, e.g., <c-s>&s</c-s>
                </li>
                <li>
                  Sample code in Rust Playground: 
                  <a target="_blank" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=5f353d3efd95b4ee529efe22908239ed">
                    copy str demo
                  </a>
                </li>
              </ul>
              <div style="height:0.5rem;"></div>
            </td>
            <td class="schema">
              <img src="pictures/str.jpg" />
            </td>
          </tr>
        </table>
        <div style="height:2.5em;">&nbsp;</div>

    </div>
    <div style="height:2.25rem;"></div>
    <a id="bottom"></a>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <sec-elem style="width:0.0em">&nbsp;</sec-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#str">str</a></menu-elem>
        <menu-elem class="secElem"><a href="#string">string</a></menu-elem>
        <menu-elem class="secElem"><a href="#hashmap">hashmap</a></menu-elem>
        <menu-elem class="secElem"><a href="#vecdeq">vecdeq</a></menu-elem>
        <menu-elem class="secElem"><a href="#vec">vec</a></menu-elem>
        <menu-elem class="secElem"><a href="#struct">struct</a></menu-elem>
        <menu-elem class="secElem"><a href="#tuple">tuple</a></menu-elem>
        <menu-elem class="secElem"><a href="#array">array</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
        <div style='margin:0em -1em; padding-bottom:0.25em; text-align:center' class='darkItem'>Sections</div>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
</body>
</html>