<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Colls</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <script src="js/BiteScripts.js"></script>
    <script src="js/ScriptsKeyboard.js"></script>
  <style>
    #github table.flashcard {
      width:100%;
      table-layout:fixed;
      border-collapse: collapse;
      border:4px groove #222;
    }
      #github table.flashcard td {
        padding: 0.5rem 1.5rem;
        border: 4px groove #000;
        /*min-width:50px;*/
      }
    #github table.flashcard li {
      /*width:max-content;*/
      max-width: 30rem;
    }
    #github table.flashcard td {
      overflow:auto;
    }
      #github table.flashcard th.topic {
        width: 10rem;
      }
      #github table.flashcard td.topic {
        width: 10rem;
      }
      #github table.flashcard th.schema {
        width: 18rem;
        text-align: center;
      }
      #github table.flashcard td.schema {
        width: 18rem;
        text-align: center;
      }
      #github table.flashcard td img {
        width: 100%;
        height: auto;
        padding: 0rem;
      }
  </style>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <span class="top-center">Collections</span>
      <!-- <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a> -->
    </div>
  <next-prev>
    <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
    <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
    <a id="Prev" href="RustBites_Conversions.html">prev</a> 
    <a id="Next" href="RustBites_Iterator.html">next</a>
  </next-prev>

      <toc-b id="toc">
        <div id="bottom-menu" style="display:flex; flex-direction:row">
          <!--<a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">E</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">C</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.sects()" style="color: #fefefa; ">Sects</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;-->
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
          <up-b id="chaps">
            <!--<a href="RustBites_Facts.html">Facts</a><br />
            <a href="RustBites_Intro.html">Introduction</a><br />
            <a href="RustBites_Safety.html">Safety</a><br />
            <a href="RustBites_UDB.html">UndefBehavior</a><br />
            <a href="RustBites_Data.html">Data</a><br />
            <a href="RustBites_DataStr.html">DataStructs</a><br />
            <a href="RustBites_SmrtPtrs.html">SmartPtrs</a><br />
            <a href="RustBites_LifeCycle.html">LifeCycle</a><br />
            <a href="RustBites_Ownrs.html">Ownership</a><br />
            <a href="RustBites_Traits.html">Generics&Traits</a><br />
            <a href="RustBites_Functs.html">Functions</a><br />
            <a href="RustBites_Structs.html">Structs</a><br />
            <a href="RustBites_LifeTime.html">LifeTime</a><br />
            <a href="RustBites_Abstract.html">Abstractions</a><br />
            <a href="RustBites_ErrHnd.html">ErrHandling</a><br />
            <a href="RustBites_Collects.html">Collections</a><br />
            <a href="RustBites_Iterator.html">Iterators</a><br />
            <a href="RustBites_Threads.html">Threads</a><br />
            <a href="RustBites_Synchron.html">Synchronize</a><br />
            <a href="RustBites_Channels.html">Channels</a><br />
            <a href="RustBites_AsyncAwt.html">AsyncAwait</a><br />
            <a href="RustBites_Macros.html">Macros</a><br />
            <a href="RustBites_TipsAndTricks.html">Hacks and Helpers</a><br />
            <a href="../../indexPage.html">Glossary</a><br />-->
            <!-- <a href="RustBites_Generics.html">Generics</a><br /> -->
            <!-- <a href="RustBites_Intmut.html">InterMutat</a><br /> -->
            <!--<a href="Javascript.;#"></a><br />-->
          </up-b>
            <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
          <a href="#contents">Contents</a>, <a href="#refs">References</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <!--<table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>N</td><td>Next Bite</td>
          </tr>
          <tr>
            <td>P</td><td>Prev Bite</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>-->
       </div>
   
    <h2>Rust Bite - Collections</h2>
    <div>
              <div style="height: 1rem;"></div>
        <table class="flashcard" style="max-width:100%">
          <tr>
            <th class="darkItem topic">Topic</th><th class="darkItem">Description</th><th class="darkItem schema">Diagram</th>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/primitive.array.html">
                array&lt;T, N&gt;
              </a>
            </td>
            <td>
              Collection of instances of type T residing in contiguous stack memory.  
              <ul class="tight">
                <li>
                  create array:
                  <indent-block class="tight">
                    <c-s>let mut array: [i32; 3] = [1, 2, 3];</c-s><br />
                    <c-s>array[1] = -2;</c-s>
                  </indent-block>
                </li>
                <li>
                  An array is a copy type, provided that T is copy.
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=9bcc16716d03add8b226f6adbafa845a">
                    create and display arrays
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/array.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/primitive.tuple.html">
                tuple&lt;T,&nbsp;U,&nbsp;V,&nbsp;...&gt;
              </a>
            </td>
            <td>
              Collection of instances of possibly different types residing in contiguous memory.  
              <ul class="tight">
                <li>
                  create tupl:
                  <indent-block class="tight">
                    <c-s>let t: (&'static str, i32, char)  = ("a tuple", 42, 'Z');</c-s><br />
                    <c-s>let mut u = t;</c-s><br />
                    <c-s>u.1 = -42;</c-s>
                  </indent-block>
                </li>
                <li>
                  Tupls are copy if, and only if, each member is copy.
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=fbef855c9d8614b1ada99cacfd4b364f">
                    create and display tuples
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/tuple.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">
                Struct&lt;T,&nbsp;U,&nbsp;V,&nbsp;...&gt;
              </a>
            </td>
            <td>
              Collection of instances of possibly different types residing in contiguous memory.  
              <ul class="tight">
                <li>
                  create struct:
                  <indent-block class="tight">
                    <c-s>struct MyType { d: f64, ... }</c-s><br />
                    <c-s>let s = MyType { d: 3.14, ... };</c-s>
                    <c-s>let t = s;</c-s>
                  </indent-block>
                </li>
                <li>
                  Structs are copy types if, and only if, each member is copy.
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ac0f7a7fa7d9d4c188484db3289a3c1d">
                    create and display structs
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/struct.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">
                Vec&lt;T&gt;
              </a>
            </td>
            <td>
              Collection of instances of type T residing in contiguous heap memory.  
              <ul class="tight">
                <li>
                  consists of control block in stack holding pointer to array of T instances in heap
                </li>
                <li>
                  reallocates heap memory to accept new instance when capacity is full
                </li>
                <li>
                  create vector:
                  <indent-block class="tight">
                    <c-s>let v = Vec::&lt;int&gt;::new();</c-s><br />
                    <c-s>let w: Vec&lt;T&gt; = vec![t1, t2, t3];</c-s>
                  </indent-block>
                </li>
                <li>
                  v and w are dropped, returning resources, when they go out of scope.
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=43d6fc3c2898cc1421e05cd08f4dc408">
                    create and display vectors
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/Vec.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">
                VecDeque&lt;T&gt;
              </a>
            </td>
            <td>
              Collection of instances of type T residing in a circular buffer in heap memory.  
              <ul class="tight">
                <li>
                  consists of control block in stack holding pointer to circular buffer of T instances in heap
                </li>
                <li>
                  Control block contains references to the front and back of the VecDeque.
                </li>
                <li>
                  reallocates heap memory to accept new instance when capacity is full
                </li>
                <li>
                  create queue:
                  <indent-block class="tight">
                    <c-s>let v = VecDec::&lt;T&gt;::new();</c-s><br />
                    <c-s>v.push_back(t1); v.push_back(t2); let u = v.pop_front();</c-s>
                  </indent-block>
                </li>
                <li>
                  v and u are dropped, returning resources, when they go out of scope.
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0b35526b63e5dfa873724a3fdac5b27f">
                    create and display vecdeque
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/VecDeque.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">
                HashMap&lt;K,V&gt;
              </a>
            </td>
            <td>
              Collection of buckets (linked list of key-value pairs) rooted in table in heap memory.  
              <ul class="tight">
                <li>
                  Consists of control block in stack holding pointer to address table of buckets in heap
                </li>
                <li>
                  Hash function used to calculate table address from key.
                </li>
                <li>
                  If hash yields address with existing bucket, key-value pair added to bucket list.
                </li>
                <li>
                  Reallocates table memory when table bucket count approaches table size.
                </li>
                <li>
                  create hashmap:
                  <indent-block class="tight">
                    <c-s>let h = HashMap::&lt;K,V&gt;::new();</c-s><br />
                    <c-s>h.insert(k,v);</c-s>
                  </indent-block>
                </li>
                <li>
                  table and all bucket elements are dropped when they go out of scope.
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=f11d241deb2b45d9eef4e4aba4c22112">
                    create and display HashMap
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/HashMap.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/string/struct.String.html">String</a>
            </td>
            <td>
              Collection of utf-8 characters residing in contiguous heap memory.  
              <ul class="tight">
                <li>
                  consists of control block in stack holding ptr to contiguous heap memory allocation.
                </li>
                <li>
                  a utf-8 character may occupy from 1 to 4 bytes, allowing a large collection of
                  language sets, e.g., ASCII, Unicode, Kanji, Arabic, ...
                </li>
                <li>
                  The item above means that Rust std::String instances cannot be indexed.  There is a
                  string iterator, called <c-s>chars()</c-s>, that understands byte sequences that define
                  utf-8 character boundaries.
                  <indent-block>
                    <c-s>
                      let s = String::from("a literal string");<br />
                      let c2 = s.chars().nth(4).unwrap();
                    </c-s>
                  </indent-block>
                </li>
                <li>
                  reallocates heap memory to accept new character(s) when capacity is full
                </li>
                <li>
                  create String:
                  <indent-block class="tight">
                  <c-s>let s = String::new();</c-s><br />
                  <c-s>let t = String::from("a string");</c-s>
                  </indent-block>
                </li>
                <li>
                  s and t are dropped, returning resources, when they go out of scope.
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b8358deb93de35248f56b3ecfe5e67ef">
                    create and manipulate String and str
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/String.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/str/index.html">str</a>
            </td>
            <td>
              str is a copy type that represents a literal string in contiguous block of memory
              <ul class="tight">
                <li>
                  converting between str and String:<br />
                  <c-s>
                    &nbsp;&nbsp;let s = "an ordered collection of utf-8 characters";<br />
                    &nbsp;&nbsp;let t = String::from(s);<br />
                    &nbsp;&nbsp;let u = &S;
                  </c-s>
                </li>
                <li>
                  Literal strings are almost always used via a reference, e.g., <c-s>&s</c-s>
                </li>
                <li>
                  Sample code in Rust Playground: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=5f353d3efd95b4ee529efe22908239ed">
                    copy str demo
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/str.jpg" />
            </td>
          </tr>
        </table>
        <div style="height:2.5em;">&nbsp;</div>

    </div>
  </body>
</html>
