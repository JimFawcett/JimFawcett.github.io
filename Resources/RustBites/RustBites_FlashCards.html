<!DOCTYPE html>
<html id="top">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites FlashCards</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <!--<script src="js/ScriptsKeyboard.js"></script>-->
    <script src="js/BiteScripts.js"></script>
    <script src="js/ScriptsKeyboard.js"></script>
    <style>
      #github .topborder { border-top: 1px solid #363636;}
      #github th.num { width:3em; text-align:right; padding-right:1.0em; }
      #github td.num { width:3em; text-align:right; padding-right:1.0em; }
      #github th.elem { padding-right: 2.0em; white-space:nowrap; }
      #github td.elem { padding-right: 2.0em; white-space:nowrap; }
      t-b { 
        display: block;
        margin-top: 0.75rem;
        margin-bottom: 0.75rem;
        max-width:55rem;
      }
    </style>
  <style>
    #github table.flashcard {
      width:100%;
      table-layout:fixed;
      border-collapse: collapse;
      border:4px groove #222;
    }
      #github table.flashcard td {
        padding: 0.5rem 1.5rem;
        border: 4px groove #000;
        /*min-width:50px;*/
      }
    #github table.flashcard li {
      /*width:max-content;*/
      max-width: 30rem;
    }
    #github table.flashcard td {
      overflow:auto;
    }
      #github table.flashcard th.topic {
        width: 8rem;
      }
      #github table.flashcard td.topic {
        width: 8rem;
      }
      #github table.flashcard th.schema {
        width: 20rem;
        text-align: center;
      }
      #github table.flashcard td.schema {
        width: 20rem;
        text-align: center;
      }
      #github table.flashcard td img {
        width: 100%;
        height: auto;
        padding: 0rem;
      }
  </style>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <div style="position:relative; left:calc(100vw - 15rem);">
        <span class="top-center">Rust Facts</span>
        <!-- <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a> -->
      </div>
    </div>
    <next-prev>
      <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
      <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
      <a id="Prev" href="RustBites_Data.html">prev</a> 
      <a id="Next" href="RustBites_Facts.html">next</a>
    </next-prev>

    <toc-b id="toc">
      <div id="bottom-menu" style="display:flex; flex-direction:row">
      </div>
      <up-b id="chaps">
      </up-b>
      <rt-b id="sects">
        <a href="#top">Top</a>, 
        <a href="#dops">DataOps</a>, 
        <a href="#dstr">DataStrs</a>, 
        <a href="#sptr">SmPtrs</a>, 
        <a href="#ownr">Ownrship</a>, 
        <a href="#genr">Generics</a>, 
        <a href="#bottom">Bottom</a>
      </rt-b>
    </toc-b>
    <div id="hlp" style="display:none;">
    </div>
   
    <!--<div>-->
      <h1>Rust Bite - FlashCards</h1>
      <hr />
         <a id="flashcards"></a>
        <t-b>
          Flash cards are brief descriptions of a Rust type, trait, or keyword.  Each has a description with
          a small useage example and diagram.  The purpose is to provide a quick way to grasp an important
          language model or feature.
        </t-b>
        <t-b>
          This could grow to be quite large, but for now it will be relatively small, trying to help people
          to start quickly with the Rust language.  In each of the Flash Cards you will find a link to sample
          code in the <a href="https://play.rust-lang.org/">Rust Playground</a> for that
          particular card.  You can run the code to see what it does and change it to see what that does too.
        </t-b>
        <div style="height: 1rem;"></div>
        <table class="flashcard" style="max-width:100%">
          <tr>
            <th class="darkItem topic">Topic</th><th class="darkItem">Description</th><th class="darkItem schema">Diagram</th>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">
                Copy type
              </a>
            </td>
            <td>
              Construction and assignment of copy type implicitly copies contents of source to destination.
              <ul class="tight">
                <li>contiguous memory, satisfies Copy trait</li>
                <li>
                  examples: primitive types like i8, i16, .., u8, u16, .., f32, f64, &str, immut refs, ..
                </li>
                <li>
                  constr: <c-s>let x = y;&nbsp;&nbsp;// copies</c-s><br />
                  assign: <c-s>x = y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// copies</c-s>
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c5b4da6d5bd09c8890d4cce12d08d17f">
                    Copy
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/CopyType.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/keyword.move.html">
                Move type
              </a>
            </td>
            <td>
              Construction and assignment of move type implicitly moves resources of source to destination.
              <ul class="tight">
                <li>non-contiguous memory, does not implement Copy trait</li>
                <li>move transfers ownership of resources from source to destination</li>
                <li>
                  examples:<br />
                  Vec&lt;T&gt;, String, aggregate types holding at least one move type, mut refs,
                  many user defined types
                </li>
                <li>
                  constr: <c-s>let x = y;&nbsp;&nbsp;// moves</c-s><br />
                  assign: <c-s>x = y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// moves</c-s>
                  <note-block>y invalid after operation</note-block>
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=64b2ba6e173465b567f1adde60aae74a">
                    move
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/MoveType.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">
                Clone&nbsp;type
              </a>
            </td>
            <td>
              Construction and assignment of clone type explicitly copies resources of source to destination.
              <ul class="tight">
                <li>
                  examples: Vec&lt;T&gt;, String, many user defined types
                </li>
                <li>
                  constr: <c-s>let x = y.clone();&nbsp;&nbsp;// clone</c-s><br />
                  assign: <c-s>x = y.clone();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// clone</c-s>
                  <note-block>y valid after operation</note-block>
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=860b830f0e5a6ba03ffdfa3908e929c9">
                    clone
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/CloneType.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/reference/types/pointer.html">
                Reference type
              </a>
            </td>
            <td>
              Pointer to instance of some type with special rules:
              <ul class="tight">
                <li>
                  must be initialized when declared: <c-s>let r = &u</c-s>, <c-s>let mr = &mut v</c-s>
                </li>
                <li>
                  references cannot concurrently share mutation of referend
                </li>
                <li>
                  lifetime is scoped based, from the point of declaration to the end of that scope
                </li>
                <li>
                  The rules above are basis for Rust&apos;s memory safety.  There are more details
                  explained in <a href="../RustBites/RustBites_Safety.html">Safety</a>
                </li>
                <li>
                  All other pointer types must reside in <c-s>unsafe { ... }</c-s>
                  <div style="margin: 0.25rem 0.75rem; padding:0.25rem 0.5rem; max-width:25rem; overflow:auto; border:1px solid black;">
                    Goal: don&apos;t use unsafe blocks in code you write.  Let std library types do any
                    required unsafe processing.  They have been written by the Rust team and are
                    thoroughly vetted and wrapped in a safe interface.
                  </div>
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ca2bd3e16eec697844015a819766c05c">
                    Reference
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/Reference.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">
                Vec&lt;T&gt;
              </a>
            </td>
            <td>
              Collection of instances of type T residing in contiguous heap memory.  
              <ul class="tight">
                <li>
                  consists of control block in stack holding pointer to array of T instances in heap
                </li>
                <li>
                  reallocates heap memory to accept new instance when capacity is full
                </li>
                <li>
                  create vector:
                  <indent-block class="tight">
                    <c-s>let v = Vec::&lt;int&gt;::new();</c-s><br />
                    <c-s>let w: Vec&lt;T&gt; = vec![t1, t2, t3];</c-s>
                  </indent-block>
                </li>
                <li>
                  v and w are dropped, returning resources, when they go out of scope.
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=43d6fc3c2898cc1421e05cd08f4dc408">
                    create and display vectors
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/Vec.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/string/struct.String.html">String</a>
            </td>
            <td>
              Collection of utf-8 characters residing in contiguous heap memory.  
              <ul class="tight">
                <li>
                  consists of control block in stack holding ptr to contiguous heap memory allocation.
                </li>
                <li>
                  a utf-8 character may occupy from 1 to 4 bytes, allowing a large collection of
                  language sets, e.g., ASCII, Unicode, Kanji, Arabic, ...
                </li>
                <li>
                  The item above means that Rust std::String instances cannot be indexed.  There is a
                  string iterator, called <c-s>chars()</c-s>, that understands byte sequences that define
                  utf-8 character boundaries.
                  <indent-block>
                    <c-s>
                      let s = String::from("a literal string");<br />
                      let c2 = s.chars().nth(4).unwrap();
                    </c-s>
                  </indent-block>
                </li>
                <li>
                  reallocates heap memory to accept new character(s) when capacity is full
                </li>
                <li>
                  create String:
                  <indent-block class="tight">
                  <c-s>let s = String::new();</c-s><br />
                  <c-s>let t = String::from("a string");</c-s>
                  </indent-block>
                </li>
                <li>
                  s and t are dropped, returning resources, when they go out of scope.
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b8358deb93de35248f56b3ecfe5e67ef">
                    create and manipulate String and str
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/String.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/str/index.html">str</a>
            </td>
            <td>
              str is a copy type that represents a literal string in contiguous block of memory
              <ul class="tight">
                <li>
                  converting between str and String:<br />
                  <c-s>
                    &nbsp;&nbsp;let s = "an ordered collection of utf-8 characters";<br />
                    &nbsp;&nbsp;let t = String::from(s);<br />
                    &nbsp;&nbsp;let u = &S;
                  </c-s>
                </li>
                <li>
                  Literal strings are almost always used via a reference, e.g., <c-s>&s</c-s>
                </li>
                <li>
                  Sample code in Rust Playground: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=5f353d3efd95b4ee529efe22908239ed">
                    copy str demo
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/str.jpg" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">Box&lt;T&gt</a>
            </td>
            <td>
              Box is a smart pointer to an instance of type T on the heap.
              <ul class="tight">
                <li>
                  Box is the only safe way to allocate an instance in the heap
                </li>
                <li>
                  <c-s>let s = String::from("string in heap");</c-s><br />
                  <c-s>let x = Box::new(s);  // moves s into Box</c-s>
                </li>
                <li>
                  a Box is dropped to release its resource when it goes out of scope
                </li>
                <li>
                  a Box instance is implicitly dereferenced to provide the interface of its
                  inner instance
                </li>
                <li>
                  Code demo: 
                  <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=bd50880fa736c484b17ba850da45e82d">
                    store, modify, and read value in heap                    
                  </a>
                </li>
              </ul>
            </td>
            <td class="schema">
              <img src="pictures/Box.jpg" />
            </td>
          </tr>
        </table>
        <div style="height:2.5em;">&nbsp;</div>


    <!--</bb-55>
    <s-halfEm></s-halfEm>
      <table style="position:relative; left:-1.5em;">
        <tr><td colspan="3" style="height: 1em;"><a id="dops" /></td></tr>
        <tr>
          <td>&nbsp;</td>
          <td class="darkItem">Data Operations</td>
          <td class="darkItem">Examples</td>
        </tr>
        <tr class="topborder">
          <td class="num">1.</td>
          <td class="elem topborder">
            <strong>Copy type</strong> - holds no resources in the heap.
          </td>
          <td class="elem topborder">
            <c-s>bool, char, i32, ... u8, ... f32, ...</c-s><br />
            <c-s>[i32;N], (i32, f64), struct { i32, f64 }</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">2.</td>
          <td class="elem topborder">
            <strong>Move type</strong> - holds resources in the heap.
          </td>
          <td class="elem topborder">
            <c-s>String, Vec&lt;T&gt;, Map&lt;K, V&gt;, ...</c-s><br />
            <c-s>[String;N], (i32, Vec&lt;f64&gt;), struct { i32, String }</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">3.</td>
          <td class="elem topborder">
            <strong>Bind</strong> - associates an identifier with a value.<br />
            This creates a new instance.
          </td>
          <td class="elem topborder">
            <c-s>let i:i32 = 3;</c-s><br />
            <c-s>let j = i;</c-s><br />
            <c-s>let s = String::new();</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">4.</td>
          <td class="elem topborder">
            <strong>Copy</strong> - copies value associated with an identifier.<br />
            - This applies to both binds and assignments for Copy types.<br />
            - Invoked implicitly by compiler generated code.<br />
            - Source of copy is <strong>valid</strong> after copy.
          </td>
          <td class="elem topborder">
            <c-s>let i:i32 = 3;<br />
            let j = i;<br />
            i = j;</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">5.</td>
          <td class="elem topborder">
            <strong>Move</strong> - moves resources from one instance to another.<br />
            - This applies to both binds and assignments for Move types.<br />
            - Invoked implicitly by compiler generated code.<br />
            - Source of move is <strong>invalid</strong> after move.
          </td>
          <td class="elem topborder">
            <c-s>let s = String::from("a string"); &nbsp;// bind<br />
            let t = s; &nbsp;// move and bind</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">6.</td>
          <td class="elem topborder">
            <strong>Clone</strong> - creates instance with copy of resources of cloner.<br />
            - This applies to both Copy and Move types.<br />
            - Invoked explicitly by developer code.<br />
            - Source is <strong>valid</strong> after clone operation.<br />
            - Source type must implement Clone trait.
          </td>
          <td class="elem topborder">
            <c-s>let s = String::from("a string");<br />let t = s.clone(); &nbsp;// clone</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">7.</td>
          <td class="elem topborder">
            <strong>Drop</strong> - returns resources when owner goes out of scope.<br />
            - This applies only to Move types.<br />
            - Invoked implicitly by compiler generated code.<br />
            - Can be invoked explicitly by program code.
          </td>
          <td class="elem topborder">
            <c-s>let s = String::from("a string");<br />std::mem::drop(s);</c-s>
          </td>
        </tr>
        <tr><td colspan="3" style="height: 1em;"><a id="dstr" /></td></tr>
        <tr>
          <td>&nbsp;</td>
          <td class="darkItem">Data Structures</td>
          <td class="darkItem">Examples</td>
        </tr>
          <td class="num">8.</td>
          <td class="elem topborder">
            <strong>Array</strong> - Contiguous set of values all of the same type.<br />
            - Indexable<br />
            - Fixed number of elements
          </td>
          <td class="elem topborder">
            <c-s>let a: [3; i32] = [1, 2, 3]; // static memory<br />
            let b = Box::new([0;3]); // heap memory</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">9.</td>
          <td class="elem topborder">
            <strong>String</strong> - Contiguous collection of utf-8 chars.<br />
            - Not indexable<br />
            - Iterable<br />
            - Expandable
          </td>
          <td class="elem topborder">
            <c-s>let s: String = String::new();<br />
            let t = String::from("a literal string");</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">10.</td>
          <td class="elem topborder">
            <strong>Vec&lt;T&gt;</strong> - Contiguous set of values all of the same type.<br />
            - Indexable<br />
            - Expandable number of elements<br />
            - May reallocate
          </td>
          <td class="elem topborder">
            <c-s>let v: Vec&lt;i32&gt; = vec![1, 2, 3];<br />
            let w = Vec::&lt;i32&gt;::new();</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">11.</td>
          <td class="elem topborder">
            <strong>HashMap&lt;K, V&gt;</strong> - Table of buckets (list of key/value pairs).<br />
            - Accessed by hash of key:K<br />
            - Each key has associated value v:V<br />
            - Add with insert, delete with remove
          </td>
          <td class="elem topborder">
            <c-s>let m = HashMap::&lt;String, Widget&gt;::new();<br />
            let v = m[k];</c-s>
          </td>
        </tr>
        <tr><td colspan="3" style="height: 1em;"><a id="sptr" /></td></tr>
        <tr>
          <td>&nbsp;</td>
          <td class="darkItem">Smart Pointers</td>
          <td class="darkItem">Examples</td>
        </tr>
        <tr class="topborder">
          <td class="num">12.</td>
          <td class="elem topborder">
            <strong>Box</strong> - Point to data on heap.<br />
            - Drop returns resource (when leaving scope)<br />
            - Auto DeRef supports methods of referend
          </td>
          <td class="elem topborder">
            <c-s>let d = Box::&lt;String&gt;::new("a string".to_string());<br />
            let b = Box::new(Point { x:1.0, y:1.5, z:-0.5 }</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">13.</td>
          <td class="elem topborder">
            <strong>RefCell</strong> - Defer ownership checking to run-time.<br />
            - borrow() view inner<br />
            - borrow_mut() gives mutable access to inner
          </td>
          <td class="elem topborder">
            <c-s>let sp = RefCell::new(String&gt;::new("a string".to_string()));<br />
            let r = sp.borrow_mut();</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">14.</td>
          <td class="elem topborder">
            <strong>Rc</strong> - reference counted sharing. Not thread-safe.<br />
            - Drops resource when last reference goes out of scope<br />
            - auto DeRef supports methods of referend
          </td>
          <td class="elem topborder">
            <c-s>let sp = Rc::new(String&gt;::new("a string".to_string()));<br />
            let r1 = sp.clone();<br />
            let r2 = Rc::clone(&r1);</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">15.</td>
          <td class="elem topborder">
            <strong>Arc</strong> - thread-safe reference counted sharing.<br />
            - Drops resource when last reference goes out of scope<br />
            - auto DeRef supports methods of referend
          </td>
          <td class="elem topborder">
            <c-s>let sp = Arc::new(String&gt;::new("a string".to_string()));<br />
            let r1 = sp.clone();<br />
            let r2 = Arc::clone(&r1);</c-s>
          </td>
        </tr>
        <tr>
          <tr><td colspan="3" style="height: 1em;"><a id="ownr" /></td></tr>
          <td>&nbsp;</td>
          <td class="darkItem">Ownership</td>
          <td class="darkItem">Examples</td>
        </tr>
        <tr><td colspan="3"><a id="Owner" /></td></tr>
        <tr class="topborder">
          <td class="num">16.</td>
          <td class="elem topborder">
            <strong>Ownership Rules</strong> - Memory and Data Race safety<br />
            - Only one owner of any data item<br />
            - May have any number of non-mutable references<br />
            - May have only one mutable reference with no others<br />
            - Owner may not mutate when there are references being used<br />
            - References become inactive when they go out of scope
          </td>
          <td class="elem topborder">
            <c-s>let d = 3;<br />
            let mut mr = &amp;d;<br />
            // let nmr = &amp;d;  // illegal<br /> 
            mr = 5;  // d now holds 5<br />
            // d = 42; // illegal
          </c-s>
          </td>
        </tr>
        <tr>
          <tr><td colspan="3" style="height: 1em;"><a id="genr" /></td></tr>
          <td>&nbsp;</td>
          <td class="darkItem">Generics</td>
          <td class="darkItem">Examples</td>
        </tr>
        <tr class="topborder">
          <td class="num">17.</td>
          <td class="elem topborder">
            <strong>Generic Functions</strong> - code generator for functions<br />
            - creates a new function for each distinct T<br />
            - T must satisfy trait constraints otherwise compile failure
          </td>
          <td class="elem topborder">
            <c-s>fn gf&lt;_t:T&gt;) {<br />
            &nbsp;&nbsp;let tn = std::any::type_name::&lt;T&gt;();<br />
            &nbsp;&nbsp;print!("\n  t is type {:?}", tn);<br /> 
            }
          </c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">18.</td>
          <td class="elem topborder">
            <strong>Generic Structs</strong> - code generator for user-defined types<br />
            - creates a new Struct for each distinct T<br />
            - T must satisfy trait constraints otherwise compile failure
          </td>
          <td class="elem topborder">
            <c-s>#[derive(Debug)]</c-s><br />
            <c-s>struct Point&lt;T&gt; { x:T, y:T, z:T }</c-s>
          </td>
        </tr>
      </table>-->
      <s-1em></s-1em>
      <a id="bottom"></a>
  </body>
</html>
