<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Facts</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <script src="js/BiteScripts.js"></script>
    <style>
      #github .topborder { border-top: 1px solid #363636;}
      #github th.num { width:3em; text-align:right; padding-right:1.0em; }
      #github td.num { width:3em; text-align:right; padding-right:1.0em; }
      #github th.elem { padding-right: 2.0em; white-space:nowrap; }
      #github td.elem { padding-right: 2.0em; white-space:nowrap; }
      t-b { 
        display: block;
        margin-top: 0.75rem;
        margin-bottom: 0.75rem;
        max-width:55rem;
      }
    </style>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <div style="position:relative; left:calc(100vw - 15rem);">
        <span class="top-center">Rust Facts</span>
        <!-- <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a> -->
      </div>
  </div>
  <next-prev>
    <a id="prev" href="RustBites_TipsAndTricks.html">prev</a> 
    <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
    <a id="next" href="RustBites_Intro.html">next</a>
  </next-prev>

      <toc-b id="toc">
        <div style="display:flex; flex-direction:row">
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.sects()" style="color: #fefefa; ">Sects</a>&nbsp;
          <a href="../../RustBiteByByte.html" style="color:#fefefa;">Repo</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">Esc</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp;
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
          <up-b id="chaps">
            <a href="RustBites_Facts.html">Facts</a><br />
            <a href="RustBites_Intro.html">Introduction</a><br />
            <a href="RustBites_UDB.html">UndefBehavior</a><br />
            <a href="RustBites_Data.html">Data</a><br />
            <a href="RustBites_DataStr.html">DataStructs</a><br />
            <a href="RustBites_SmrtPtrs.html">SmartPtrs</a><br />
            <a href="RustBites_LifeCycle.html">LifeCycle</a><br />
            <a href="RustBites_Ownrs.html">Ownership</a><br />
            <a href="RustBites_Traits.html">Generics&Traits</a><br />
            <a href="RustBites_Functs.html">Functions</a><br />
            <a href="RustBites_Structs.html">Structs</a><br />
            <a href="RustBites_LifeTime.html">LifeTime</a><br />
            <a href="RustBites_Abstract.html">Abstractions</a><br />
            <a href="RustBites_ErrHnd.html">ErrHandling</a><br />
            <a href="RustBites_Collects.html">Collections</a><br />
            <a href="RustBites_Iterator.html">Iterators</a><br />
            <a href="RustBites_Threads.html">Threads</a><br />
            <a href="RustBites_Synchron.html">Synchronize</a><br />
            <a href="RustBites_Channels.html">Channels</a><br />
            <a href="RustBites_AsyncAwt.html">AsyncAwait</a><br />
            <a href="RustBites_Macros.html">Macros</a><br />
            <!-- <a href="RustBites_Generics.html">Generics</a><br /> -->
            <!-- <a href="RustBites_Intmut.html">InterMutat</a><br /> -->
            <a href="Javascript.;#"></a><br />
          </up-b>
            <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#bottom">Bottom</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>N</td><td>Next Bite</td>
          </tr>
          <tr>
            <td>P</td><td>Prev Bite</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>
      </div>
   
    <bb-55>
      <h1>Rust Bite - Facts</h1>
      <t-b>
        The table, below, summarizes things we&apos;ve learned in the Rust Bytes that follow.
        Occasionally terms like &quot;object&quot; and &quot;trait&quot; are used with their
        intuitive meanings.  In later Bites we will give them, e.g., <a href="RustBites_Structs.html">object</a>
        and <a href="RustBites_Traits.html">trait</a> precise meanings.
      </t-b>
    </bb-55>
    <s-halfEm></s-halfEm>
      <table style="position:relative; left:-1.5em;">
        <tr>
          <td>&nbsp;</td>
          <td class="darkItem">Data Operations</td>
          <td class="darkItem">Examples</td>
        </tr>
        <tr class="topborder">
          <td class="num">1.</td>
          <td class="elem topborder">
            <strong>Copy type</strong> - holds no resources in the heap.
          </td>
          <td class="elem topborder">
            <c-s>bool, char, i32, ... u8, ... f32, ...</c-s><br />
            <c-s>[i32;N], (i32, f64), struct { i32, f64 }</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">2.</td>
          <td class="elem topborder">
            <strong>Move type</strong> - holds resources in the heap.
          </td>
          <td class="elem topborder">
            <c-s>String, Vec&lt;T&gt;, Map&lt;K, V&gt;, ...</c-s><br />
            <c-s>[String;N], (i32, Vec&lt;f64&gt;), struct { i32, String }</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">3.</td>
          <td class="elem topborder">
            <strong>Bind</strong> - associates an identifier with a value.<br />
            This creates a new instance.
          </td>
          <td class="elem topborder">
            <c-s>let i:i32 = 3;</c-s><br />
            <c-s>let j = i;</c-s><br />
            <c-s>let s = String::new();</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">4.</td>
          <td class="elem topborder">
            <strong>Copy</strong> - copies value associated with an identifier.<br />
            - This applies to both binds and assignments for Copy types.<br />
            - Invoked implicitly by compiler generated code.<br />
            - Source of copy is <strong>valid</strong> after copy.
          </td>
          <td class="elem topborder">
            <c-s>let i:i32 = 3;<br />
            let j = i;<br />
            i = j;</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">5.</td>
          <td class="elem topborder">
            <strong>Move</strong> - moves resources from one instance to another.<br />
            - This applies to both binds and assignments for Move types.<br />
            - Invoked implicitly by compiler generated code.<br />
            - Source of move is <strong>invalid</strong> after move.
          </td>
          <td class="elem topborder">
            <c-s>let s = String::from("a string"); &nbsp;// bind<br />
            let t = s; &nbsp;// move and bind</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">6.</td>
          <td class="elem topborder">
            <strong>Clone</strong> - creates instance with copy of resources of cloner.<br />
            - This applies to both Copy and Move types.<br />
            - Invoked explicitly by developer code.<br />
            - Source is <strong>valid</strong> after clone operation.<br />
            - Source type must implement Clone trait.
          </td>
          <td class="elem topborder">
            <c-s>let s = String::from("a string");<br />let t = s.clone(); &nbsp;// clone</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">7.</td>
          <td class="elem topborder">
            <strong>Drop</strong> - returns resources when owner goes out of scope.<br />
            - This applies only to Move types.<br />
            - Invoked implicitly by compiler generated code.<br />
            - Can be invoked explicitly by program code.
          </td>
          <td class="elem topborder">
            <c-s>let s = String::from("a string");<br />std::mem::drop(s);</c-s>
          </td>
        </tr>
        <tr>
          <td>&nbsp;</td>
          <td class="darkItem">Data Structures</td>
          <td class="darkItem">Examples</td>
        </tr>
        <tr class="topborder">
          <td class="num">8.</td>
          <td class="elem topborder">
            <strong>Array</strong> - Contiguous set of values all of the same type.<br />
            - Indexable<br />
            - Fixed number of elements
          </td>
          <td class="elem topborder">
            <c-s>let a: [3; i32] = [1, 2, 3]; // static memory<br />
            let b = Box::new([0;3]); // heap memory</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">9.</td>
          <td class="elem topborder">
            <strong>String</strong> - Contiguous collection of utf-8 chars.<br />
            - Not indexable<br />
            - Iterable<br />
            - Expandable
          </td>
          <td class="elem topborder">
            <c-s>let s: String = String::new();<br />
            let t = String::from("a literal string");</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">10.</td>
          <td class="elem topborder">
            <strong>Vec&lt;T&gt;</strong> - Contiguous set of values all of the same type.<br />
            - Indexable<br />
            - Expandable number of elements<br />
            - May reallocate
          </td>
          <td class="elem topborder">
            <c-s>let v: Vec&lt;i32&gt; = vec![1, 2, 3];<br />
            let w = Vec::&lt;i32&gt;::new();</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">11.</td>
          <td class="elem topborder">
            <strong>HashMap&lt;K, V&gt;</strong> - Table of buckets (list of key/value pairs).<br />
            - Accessed by hash of key:K<br />
            - Each key has associated value v:V<br />
            - Add with insert, delete with remove
          </td>
          <td class="elem topborder">
            <c-s>let m = HashMap::&lt;String, Widget&gt;::new();<br />
            let v = m[k];</c-s>
          </td>
        </tr>
        <tr>
          <td>&nbsp;</td>
          <td class="darkItem">Smart Pointers</td>
          <td class="darkItem">Examples</td>
        </tr>
        <tr class="topborder">
          <td class="num">12.</td>
          <td class="elem topborder">
            <strong>Box</strong> - Point to data on heap.<br />
            - Drop returns resource (when leaving scope)<br />
            - Auto DeRef supports methods of referend
          </td>
          <td class="elem topborder">
            <c-s>let d = Box::&lt;String&gt;::new("a string".to_string());<br />
            let b = Box::new(Point { x:1.0, y:1.5, z:-0.5 }</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">13.</td>
          <td class="elem topborder">
            <strong>RefCell</strong> - Defer ownership checking to run-time.<br />
            - borrow() view inner<br />
            - borrow_mut() gives mutable access to inner
          </td>
          <td class="elem topborder">
            <c-s>let sp = RefCell::new(String&gt;::new("a string".to_string()));<br />
            let r = sp.borrow_mut();</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">14.</td>
          <td class="elem topborder">
            <strong>Rc</strong> - reference counted sharing. Not thread-safe.<br />
            - Drops resource when last reference goes out of scope<br />
            - auto DeRef supports methods of referend
          </td>
          <td class="elem topborder">
            <c-s>let sp = Rc::new(String&gt;::new("a string".to_string()));<br />
            let r1 = sp.clone();<br />
            let r2 = Rc::clone(&r1);</c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">15.</td>
          <td class="elem topborder">
            <strong>Arc</strong> - thread-safe reference counted sharing.<br />
            - Drops resource when last reference goes out of scope<br />
            - auto DeRef supports methods of referend
          </td>
          <td class="elem topborder">
            <c-s>let sp = Arc::new(String&gt;::new("a string".to_string()));<br />
            let r1 = sp.clone();<br />
            let r2 = Arc::clone(&r1);</c-s>
          </td>
        </tr>
        <tr>
          <td>&nbsp;</td>
          <td class="darkItem">Ownership</td>
          <td class="darkItem">Examples</td>
        </tr>
        <tr class="topborder">
          <td class="num">16.</td>
          <td class="elem topborder">
            <strong>Ownership Rules</strong> - Memory and Data Race safety<br />
            - Only one owner of any data item<br />
            - May have any number of non-mutable references<br />
            - May have only one mutable reference with no others<br />
            - Owner may not mutate when there are references being used<br />
            - References become inactive when they go out of scope
          </td>
          <td class="elem topborder">
            <c-s>let d = 3;<br />
            let mut mr = &amp;d;<br />
            // let nmr = &amp;d;  // illegal<br /> 
            mr = 5;  // d now holds 5<br />
            // d = 42; // illegal
          </c-s>
          </td>
        </tr>
        <tr>
          <td>&nbsp;</td>
          <td class="darkItem">Generics</td>
          <td class="darkItem">Examples</td>
        </tr>
        <tr class="topborder">
          <td class="num">17.</td>
          <td class="elem topborder">
            <strong>Generic Functions</strong> - code generator for functions<br />
            - creates a new function for each distinct T<br />
            - T must satisfy trait constraints otherwise compile failure
          </td>
          <td class="elem topborder">
            <c-s>fn gf&lt;_t:T&gt;) {<br />
            &nbsp;&nbsp;let tn = std::any::type_name::&lt;T&gt;();<br />
            &nbsp;&nbsp;print!("\n  t is type {:?}", tn);<br /> 
            }
          </c-s>
          </td>
        </tr>
        <tr class="topborder">
          <td class="num">18.</td>
          <td class="elem topborder">
            <strong>Generic Structs</strong> - code generator for user-defined types<br />
            - creates a new Struct for each distinct T<br />
            - T must satisfy trait constraints otherwise compile failure
          </td>
          <td class="elem topborder">
            <c-s>#[derive(Debug)]</c-s><br />
            <c-s>struct Point&lt;T&gt; { x:T, y:T, z:T }</c-s>
          </td>
        </tr>
      </table>
      <s-1em></s-1em>
      <a id="bottom"></a>
  </body>
</html>
