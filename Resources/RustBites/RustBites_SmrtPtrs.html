<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites SmartPtrs</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <script src="js/BiteScripts.js"></script>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <div style="position:relative; left:calc(100vw - 15rem);">
        <a href="../../RustBiteByByte.html">RustBiteByByte.html</a>
      </div>
  </div>

      <toc-b id="toc">
        <div style="display:flex; flex-direction:row">
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.sects()" style="color:#fefefa;">Sects</a>&nbsp;
          <a href="../../RustBiteByByte.html" style="color:#fefefa;">Repo</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">Esc</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp;
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
        <up-b id="chaps">
          <a href="RustBites_Facts.html">Facts</a><br />
          <a href="RustBites_Intro.html">Intro</a><br />
          <a href="RustBites_Data.html">Data</a><br />
          <a href="RustBites_LifeCycle.html">LifeCycle</a><br />
          <a href="RustBites_UDB.html">UndefBhvr</a><br />
          <a href="RustBites_Ownrs.html">Ownershp</a><br />
          <a href="RustBites_SmrtPtrs.html">SmartPtrs</a><br />
          <a href="RustBites_Intmut.html">InterMutat</a><br />
          <a href="RustBites_Functs.html">Functions</a><br />
          <a href="RustBites_ErrHnd.html">ErrHand</a><br />
          <a href="RustBites_Structs.html">Structs</a><br />
          <a href="RustBites_Traits.html">Traits</a><br />
          <a href="RustBites_Generics.html">Generics</a><br />
          <a href="RustBites_LifeTime.html">LifeTime</a><br />
          <a href="RustBites_Abstract.html">Abstract</a><br />
          <a href="RustBites_Collects.html">Collects</a><br />
          <a href="RustBites_Iterator.html">Iterator</a><br />
          <a href="RustBites_Threads.html">Threads</a><br />
          <a href="RustBites_Synchron.html">Synchronz</a><br />
          <a href="RustBites_Channels.html">Channels</a><br />
          <a href="RustBites_AsyncAwt.html">AsyncAwt</a><br />
          <a href="RustBites_Macros.html">Macros</a><br />
          <a href="Javascript.;#"></a><br />
        </up-b>
        <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
          <a href="#contents">Contents</a>, <a href="#refs">References</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>
       </div>
   
       <h1>Rust Bite - Smart Pointers</h1>
       <bb-55>
         <t-b>
            The Rust std library provides an interesting set of smart pointers.  The Box&lt;T&gt; pointer provides the only 
            way to store and access data on the heap.  
          </t-b>
          <t-b>
            Rc&lt;T&gt; and Arc&lt;T&gt; are reference counted pointers 
            designed to support sharing of data for single threads and multiple threads, respectively.           </t-b>
          <t-b>
            RefCell&lt;T&gt; supports deferring borrow checking for ownership from compile-time to 
            run-time.  That is essential in some mult-threaded applications.
          </t-b>
          <t-b>
            This Bite is divided into sections for each of the pointers.  There we discuss each pointer&apos;s 
            purpose and ways to create them and use their contents.
          </t-b>
        <h2><a id="box"></a>std::Box&lt;T&gt;</h2>
        <t-b>
          std::Box&lt;T&gt; is a smart pointer to data in the heap.  Box manages allocation and deallocation 
          of heap memory, and provides an interface to interact with that data.
        </t-b>
        </bb-55>
       <div class="indent pad5">
         <defn-block>
           <defn-head>Box - smart pointer to allocation on heap</defn-head>
           <defn-code>
let sp = Box::new(T::new());
/*--------------------------------------------*/
    Box automatically derefernces to a T
    so you can call T methods on sp
/*--------------------------------------------*/
let vl = sp.getter();    // T method
sp.setter(vl);           // T method
let spc = sp.clone();    // Box method
let t = *sp;  // move heap value to stack
Box deallocates heap memory in its drop method
           </defn-code>
         </defn-block>
       </div>
       <bb-55>
         <t-b>
           An example of Box code is shown in the dropdown, below.
         </t-b>
       </bb-55>
       <div>
         <details>
           <summary class="darkItem">Example: Box&lt;T&gt;</summary>
           <defn-outerBlock>
             <defn-block>
               <defn-head>show_box::main.rs</defn-head>
               <defn-code>
/////////////////////////////////////////////////////////////
// show_box::main.rs - demo Box&lt;T&gt; pointer to heap         //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
/////////////////////////////////////////////////////////////

#![allow(clippy::print_literal)]

use core::fmt::{ Debug };

/*-- same as print!("\n  sp = {:?}", sp) --*/
fn show&lt;T:Debug&gt;(name:&amp;str, t:&amp;T) {
    print!("\n  {} = {:?}", name, t);
}

fn main() {

    let putline = || print!("\n");

    type TLC = test_type::TestLifeCycle;

    print!("\n  -- create Box pointer to TLC on heap --");
    let sp = Box::new(TLC::new());
    show("sp", &amp;sp);
    putline();

    print!("\n  -- access member of TLC using Box --");
    let v = sp.get_value();
    show("v ", &amp;v);
    putline();

    print!("\n  -- clone Box pointer to TLC on heap --");
    let mut spc = sp.clone();
    show("spc", &amp;spc);
    putline();

    print!("\n  -- mutate TLC through Box --");
    spc.set_value(42);
    show("spc", &amp;spc);
    show("v ", &amp;spc.get_value());
    show("sp", &amp;sp);
    putline();

    print!("\n  -- create reference to Box pointer --");
    let rspc = &amp;mut spc;
    rspc.set_value(21);
    show("rspc", &amp;rspc);    // holds new value
    show("spc", &amp;spc);      // holds new value too
    putline();

    print!("\n  -- move contents of Box back to stack with deref --");
    let tlc = *sp;  // move
    show("tlc", &amp;tlc);

    // statement below won't compile since sp has been moved
    // show("sp", &amp;sp);

    println!("\n\n  That's all Folks!");

}  /*-- drop Boxed item --*/
                </defn-code>
             </defn-block>
             <defn-block>
               <defn-head>Output:</defn-head>
               <defn-code>
cargo run -q

-- create Box pointer to TLC on heap --
creating instance 0 of TestLifeCycle
sp = TestLifeCycle { count: 0 }

-- access member of TLC using Box --
v  = 0

-- clone Box pointer to TLC on heap --
TestLifeCycle instance 0 cloned
spc = TestLifeCycle { count: 0 }

-- mutate TLC through Box --
spc = TestLifeCycle { count: 42 }
v  = 42
sp = TestLifeCycle { count: 0 }

-- create reference to Box pointer --
rspc = TestLifeCycle { count: 21 }
spc = TestLifeCycle { count: 21 }

-- move contents of Box back to stack with deref --    
tlc = TestLifeCycle { count: 0 }

That's all Folks!

TestLifeCycle instance 0 dropped
TestLifeCycle instance 21 dropped
                </defn-code>
             </defn-block>
           </defn-outerBlock>
         </details>
       </div>
    
       <h2><a id="rc"></a>Rc&lt;T&gt;</h2>
       <bb-55>
        <t-b>
          std::rc::Rc&lt;T&gt; is a reference counted pointer to an initialized value on the stack.
          Rc manages multiple references by dropping its inner value only when the last Rc pointer
          is dropped, e.g., there are no dangling references.
         </t-b>
         <t-b>
         </bb-55>
         <div class="indent pad5">
           <defn-block>
             <defn-head>Rc - reference counted pointer</defn-head>
             <defn-code>
  let tlc = test_type::TestLifeCycle;
  let mut rc1 = Rc::new(tlc)
  /*------------------------------------------------*/
    std::rc::Rc is a reference counted pointer.
    - Rc::new(value) creates a pointer to value. 
    - Rc::clone creates a new pointer to the same
      source inner value, adding 1 to ref count.
    - Rc automatically dereferences to a T, so you
      can call T methods on an Rc&lt;T&gt;.
    - Rc::drop decrements the ref count, dropping
      the inner value on zero.
    - Note, it does no harm to drop a stack value
      as long as there is no attempt to use after.
  /*------------------------------------------------*/
  let rc2 = rc1.clone();
  let rc3 = Rc::clone(&rc2);
  let opt = Rc::get_mut(&rc1);
  where opt: Option&lt;Some(&mut tlc)&gt;
  /*------------------------------------------------*/
     get_mut returns an Option because the Rust
     ownership rules allow only one active mutable
     reference.
     If there is already an active mutable reference
     the option contains the enumeration value None.
     Otherwise it contains Some(&mut inner_value).
  /*------------------------------------------------*/
             </defn-code>
           </defn-block>
         </div>
       </t-b>
       <bb-55>
        <t-b>
          Example code for Rc is shown below.  Note that most of the code complexity results from processing an Option, returned
          by Rc::get_mut(&mut inner_value).  That&apos;s the way the cookie crumbles.
        </t-b>
        </bb-55>
       <div>
         <details>
           <summary class="darkItem">Example: Rc&lt;T&gt;</summary>
           <s-halfEm></s-halfEm>
           <defn-outerBlock>
             <defn-block>
               <defn-head>show_rc::main.rs</defn-head>
               <defn-code>
/////////////////////////////////////////////////////////////
// show_rc::main.rs - demo Rc&lt;T&gt; ref counted ptr           //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
/////////////////////////////////////////////////////////////

use core::fmt::{ Debug };
use std::rc::Rc;

/*-- same as print!("\n  sp = {:?}", sp) --*/
#[allow(clippy::print_literal)]
fn show&lt;T:Debug&gt;(name:&amp;str, t:&amp;T) {
    print!("\n  {} = {:?}", name, t);
}

struct SpaceAtEnd;
impl Drop for SpaceAtEnd {
    fn drop(&amp;mut self) {
        print!("\n\n");
    }
}

fn main() {

    let putline = || print!("\n");
    let _cosmetic = SpaceAtEnd;

    print!("\n  -- create instance of TestLifeCycle in stack --");
    let tlc = test_type::TestLifeCycle::new();
    putline();

    print!("\n  -- create Rc ptr to value in stack --");
    let mut rc1 = Rc::new(tlc);
    show("rc1", &amp;rc1);
    show("Rc strong count", &amp;Rc::strong_count(&amp;rc1));
    show("rc1 inner value", &rc1.get_value());
    putline();

    print!("\n  -- attempt to mutate inst through Rc ptr --");
    let opt_mut_rc1 = Rc::get_mut(&amp;mut rc1);
    match opt_mut_rc1 {
        Some(val) =&gt; {
            /*-- make mutable reference --*/
            let mut_rc1 = &amp;mut *val;
            mut_rc1.set_value(42);
            show("rc1", &amp;rc1);
        },
        None =&gt; { 
            print!(
                "\n  can't have multiple mutable references"
            );
        }
    }
    putline();

    print!("\n  -- create new Rc ptr to inst in stack --");
    let mut rc2 = rc1.clone();
    show("rc2", &amp;rc2);
    show("Rc strong count", &amp;Rc::strong_count(&amp;rc2));
    putline();

    print!("\n  -- attempt to mutate inst through Rc ptr --");
    let opt_mut_rc2 = Rc::get_mut(&amp;mut rc2);
    match opt_mut_rc2 {
        Some(val) =&gt; {
            /*-- make mutable reference --*/
            let mut_rc2 = &amp;mut *val;
            mut_rc2.set_value(21);
            show("rc2", &amp;rc2);
        },
        None =&gt; { 
            print!(
                "\n  can't have multiple mutable references"
            );
        }
    }
    putline();

    /*-- alternate clone syntax --*/
    print!("\n  -- create another new Rc ptr to inst in stack --");
    let mut rc3 = Rc::clone(&amp;rc1); 
    show("rc3", &amp;rc3);
    show("Rc strong count", &amp;Rc::strong_count(&amp;rc1));
    putline();

    /*-- alternate matching syntax --*/
    print!("\n  -- attempt to mutate inst through Rc ptr --");
    let opt_mut_rc3 = Rc::get_mut(&amp;mut rc3);
    if let Some(val) = opt_mut_rc3 {
        /*-- make mutable reference --*/
        let mut_rc3 = &amp;mut *val;
        mut_rc3.set_value(21);
        show("rc3", &amp;rc2);
    }
    else {
        print!(
            "\n  can't have multiple mutable references"
        );
    }
    putline();

    // print!("\n  dropping rc1");
    // drop(rc1);
    // print!("\n  dropping rc2");
    // drop(rc2);
    // print!("\n  dropping rc3");
    // drop(rc3);
    // putline();    

    /*-------------------------------------------------------
        Help with Option processing, used above: 
        -----------------------------------------------------
        The code below illustrates destructuring an option
        with both if let and match constructs.
        These will be discussed again in the Error Handling
        Bite.
    */
    let maybe_cake = Some("this code is a piece of cake! :-)");
    let not_cake = std::option::Option::&lt;&amp;str&gt;::None;
    if let Some(cake) = maybe_cake {    // cake is a defined identifier
        print!("\n  {}", cake);         // due to if let destructuring
    }
    
    let maybe_cake: Option&lt;&amp;str&gt; = not_cake;
    match maybe_cake {
        Some(cake) =&gt; print!("\n  {}", cake),
                                        // now, cake is defined by
                                        // match destructuring
        None =&gt; print!("\n  this code is not a piece of cake!! :-(")
    }

    println!("\n\n  That's all Folks!");
}
                                </defn-code>
             </defn-block>
             <defn-block>
               <defn-head>Output:</defn-head>
               <defn-code>
cargo run -q

-- create instance of TestLifeCycle in stack --
creating instance 0 of TestLifeCycle

-- create Rc ptr to value in stack --
rc1 = TestLifeCycle { count: 0 }
Rc strong count = 1
rc1 inner value = 0

-- attempt to mutate inst through Rc ptr --
rc1 = TestLifeCycle { count: 42 }

-- create new Rc ptr to inst in stack --
rc2 = TestLifeCycle { count: 42 }
Rc strong count = 2

-- attempt to mutate inst through Rc ptr --
can't have multiple mutable references

-- create another new Rc ptr to inst in stack --
rc3 = TestLifeCycle { count: 42 }
Rc strong count = 3

-- attempt to mutate inst through Rc ptr --
can't have multiple mutable references

this code is a piece of cake! :-)
this code is not a piece of cake!! :-(

That's all Folks!

TestLifeCycle instance 42 dropped
               </defn-code>
             </defn-block>
           </defn-outerBlock>
         </details>
         <bb-55>
           <t-b>
             Rc is used most often with <a href="RustBites_Intmut.html">Interior Mutability</a>.  You will see
             its use in examples for that Bite. 
           </t-b>
         </bb-55>
       </div>
       <h2><a id="arc"></a>Arc&lt;T&gt;</h2>
       <bb-55>
        <t-b>
          std::sync::Arc&lt;T&gt; is a thread-safe reference counted pointer to an initialized value on the stack.
          Arc manages multiple references by dropping its inner value only when the last Rc pointer
          is dropped, e.g., there are no dangling references. Arc is a thread-safe version of Rc.
         </t-b>
         <t-b>
         </bb-55>
         <div class="indent pad5">
           <defn-block>
             <defn-head>Arc - atomic reference counted pointer</defn-head>
             <defn-code>
let tlc = test_type::TestLifeCycle;
let mut arc1 = Arc::new(tlc)
/*------------------------------------------------*/
  std::sync::Arc is a thread-safe reference counted 
  pointer, very like Rc, but using atomic ref count.
  - Arc::new(value) creates a pointer to value. 
  - Arc::clone creates a new pointer to the same
    source inner value, adding 1 to ref count.
  - Arc::drop decrements the ref count, dropping
    the inner value on zero.
  - Note, it does no harm to drop a stack value
    as long as there is no attempt to use after.
  - 
/*------------------------------------------------*/
let arc2 = arc1.clone();
let arc3 = Arc::clone(&amp;arc2);
let opt = Arc::get_mut(&amp;arc1);
where opt: Option&lt;Some(&amp;mut tlc)&gt;
          </defn-code>
           </defn-block>
         </div>
       </t-b>
       <bb-55>
        <t-b>
          Example code for Arc is shown below.  Note that most of the code complexity results from processing an Option, returned
          by Arc::get_mut(&mut inner_value).  That&apos;s still the way cookies crumble.
        </t-b>
        </bb-55>
       <div>
         <details>
           <summary class="darkItem">Example: Arc&lt;T&gt;</summary>
           <s-halfEm></s-halfEm>
           <defn-outerBlock>
             <defn-block>
               <defn-head>show_arc::main.rs</defn-head>
               <defn-code>
/////////////////////////////////////////////////////////////
// show_arc::main.rs - demo Arc&lt;T&gt; ref counted ptr         //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
/////////////////////////////////////////////////////////////

use core::fmt::{ Debug };
use std::sync::Arc;

/*-- same as print!("\n  sp = {:?}", sp) --*/
#[allow(clippy::print_literal)]
fn show&lt;T:Debug&gt;(name:&amp;str, t:&amp;T) {
    print!("\n  {} = {:?}", name, t);
}

struct SpaceAtEnd;
impl Drop for SpaceAtEnd {
    fn drop(&amp;mut self) {
        print!("\n\n");
    }
}

fn main() {

    let putline = || print!("\n");
    let _cosmetic = SpaceAtEnd;

    print!("\n  -- create instance of TestLifeCycle in stack --");
    let tlc = test_type::TestLifeCycle::new();
    putline();

    print!("\n  -- create Arc ptr to value in stack --");
    let mut arc1 = Arc::new(tlc);
    show("arc1", &amp;arc1);
    show("Arc strong count", &amp;Arc::strong_count(&amp;arc1));
    show("arc1 inner value", &amp;arc1.get_value());
    putline();

    print!("\n  -- attempt to mutate inst through Arc ptr --");
    let opt_mut_arc1 = Arc::get_mut(&amp;mut arc1);
    match opt_mut_arc1 {
        Some(val) =&gt; {
            /*-- make mutable reference --*/
            let mut_arc1 = &amp;mut *val;
            mut_arc1.set_value(42);
            show("arc1", &amp;arc1);
        },
        None =&gt; { 
            print!(
                "\n  can't have multiple mutable references"
            );
        }
    }
    putline();

    print!("\n  -- create new Arc ptr to inst in stack --");
    let mut arc2 = arc1.clone();
    show("arc2", &amp;arc2);
    show("Arc strong count", &amp;Arc::strong_count(&amp;arc2));
    putline();

    print!("\n  -- attempt to mutate inst through Arc ptr --");
    let opt_mut_arc2 = Arc::get_mut(&amp;mut arc2);
    match opt_mut_arc2 {
        Some(val) =&gt; {
            /*-- make mutable reference --*/
            let mut_arc2 = &amp;mut *val;
            mut_arc2.set_value(21);
            show("arc2", &amp;arc2);
        },
        None =&gt; { 
            print!(
                "\n  can't have multiple mutable references"
            );
        }
    }
    putline();

    /*-- alternate clone syntax --*/
    print!("\n  -- create another new Arc ptr to inst in stack --");
    let mut arc3 = Arc::clone(&amp;arc1); 
    show("arc3", &amp;arc3);
    show("Arc strong count", &amp;Arc::strong_count(&amp;arc1));
    putline();

    /*-- alternate matching syntax --*/
    print!("\n  -- attempt to mutate inst through Arc ptr --");
    let opt_mut_arc3 = Arc::get_mut(&amp;mut arc3);
    if let Some(val) = opt_mut_arc3 {
        /*-- make mutable reference --*/
        let mut_arc3 = &amp;mut *val;
        mut_arc3.set_value(21);
        show("arc3", &amp;arc2);
    }
    else {
        print!(
            "\n  can't have multiple mutable references"
        );
    }
    putline();

    // print!("\n  dropping rc1");
    // drop(rc1);
    // print!("\n  dropping rc2");
    // drop(rc2);
    // print!("\n  dropping rc3");
    // drop(rc3);
    // putline();    

    println!("\n\n  That's all Folks!");
}
                </defn-code>
             </defn-block>
             <defn-block>
               <defn-head>Output:</defn-head>
               <defn-code>
cargo run -q

-- create instance of TestLifeCycle in stack --
creating instance 0 of TestLifeCycle

-- create Arc ptr to value in stack --
arc1 = TestLifeCycle { count: 0 }
Arc strong count = 1
arc1 inner value = 0

-- attempt to mutate inst through Arc ptr --
arc1 = TestLifeCycle { count: 42 }

-- create new Arc ptr to inst in stack --
arc2 = TestLifeCycle { count: 42 }
Arc strong count = 2

-- attempt to mutate inst through Arc ptr --
can't have multiple mutable references

-- create another new Arc ptr to inst in stack --        
arc3 = TestLifeCycle { count: 42 }
Arc strong count = 3

-- attempt to mutate inst through Arc ptr --
can't have multiple mutable references


That's all Folks!

TestLifeCycle instance 42 dropped
             </defn-code>
             </defn-block>
           </defn-outerBlock>
         </details>
         <bb-55>
           <t-b>
             Arc is used most often with <a href="RustBites_Threads.html">Threading</a> applications.  You will see
             its use in examples for that Bite. 
           </t-b>
         </bb-55>
       </div>

       <h2><a id="refcell"></a>RefCell&lt;T&gt;</h2>
       <bb-55>
         <t-b>
            RefCell&lt;T&gt; is used to defer borrow checking until run-time.  We declare it
            as an immutable type, but are allowed to borrow a mutable reference.  If we 
            already have an active borrow, the program will  panic, because the ownership
            rules have been violated.
         </t-b>
         <t-b>
           The point of all this is that there are certain conditions under which correct code
           will not compile because the compiler&apos;s static analysis can&apos;t guarantee 
           that ownership rules haven&apos;t been violated.  RefCell&lt;T&gt; appears to the 
           compiler to be immutable, but supports return of mutable references to its inner 
           value.  This allows code to compile, and wait until run-time to verify that the 
           ownership rules have or have not been satisfied.
         </t-b>
         <t-b>
           A common place where this occurs is in mult-threaded code.  We will see some 
           examples when we look at the <a href="RustBites_Threads.html">Threads</a> Bite.
         </t-b>
         <t-b>
           When we borrow from a RefCell&lt;T&gt; we get a Ref&lt;T&gt; or a RefMut&lt;T&gt;,
           depending on the type of borrow.  These types are essentially transparent because
           they support automatic dereferencing to the RefCell&lt;T&gt; inner value.
         </t-b>
       </bb-55>
       <div class="indent pad5">
         <defn-block>
           <defn-head>RefCell, Ref, and RefMut</defn-head>
           <defn-code>
RefCell holds a mutable memory location with dynamically
checked borrow rules.

let sp = std::cell::RefCell::new(T::new());
let r1 = sp.borrow()     // returns a Ref<T>
                          // panics if r1 was mutably borrowed
                          // access inner with sp.borrow()
                          //   due to auto dereferencing
let r2 = sp.borrow_mut() // returns a RefMut<T>
                          // panics if r2 was already borrowed
                          // access inner with sp.borrow_mut()
                          //   due to auto dereferencing
drop(r1) dropps inner t
           </defn-code>
         </defn-block>
       </div>
       <bb-55>
         <t-b>
           The example, below, illustrates the basic mechanics for using RefCell&lt;T&gt; and the
           wrappers Ref&lt;T&gt; and RefMut&lt;T&gt;.  It doens&apos;t give you much insight into 
           how they are used in practice.  That will have to wait until we get to 
           <a href="RustBites_Threads.html">Threads</a>.  There we will see that Mutex&lt;T&gt; and 
           RwLock&lt;T&gt; need RefCell to implement their functionality.
         </t-b>
       </bb-55>
       <div>
         <details>
           <summary class="darkItem">Example: RefCell&lt;T&gt;</summary>
           <s-halfEm></s-halfEm>
           <defn-outerBlock>
             <defn-block>
               <defn-head>show_refcell::main.rs</defn-head>
               <defn-code>
/////////////////////////////////////////////////////////////
// show_refcell::main.rs - demo RefCell<T> smart pointer   //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
/////////////////////////////////////////////////////////////

#![allow(clippy::print_literal)]
#![allow(unused_imports)]

use core::fmt::{ Debug };
use std::cell::{ RefCell, Ref, RefMut };
use std::any::type_name;

/*-- same as print!("\n  sp = {:?}", sp) --*/
fn show<T:Debug>(name:&str, t:&T) {
    print!("\n  {} = {:?}", name, t);
}

fn show_type<'a, T:Debug>(_t:T) -> &'a str where T:Debug {
    type_name::<T>()
}

struct SpaceAtEnd;
impl Drop for SpaceAtEnd {
    fn drop(&mut self) {
        print!("\n\n");
    }
}

fn main() {
    /*-------------------------------------------------------
        Note: 
        This program will panic if both Blk #1 and Blk #2
        are uncommented.  That's because the borrowing
        rules are violated.

        If one is commented out - it doesn't matter which 
        one - the program completes successfully.

        This illustrates that RefCell defers borrow checking
        to run-time.
    */

    let putline = || print!("\n");
    let _cosmetic = SpaceAtEnd;

    let tlc = test_type::TestLifeCycle::new();

    print!("\n  -- create RefCell pointer to tlc --");
    /*-- note sp is statically immutable --*/
    let sp = RefCell::new(tlc);
    show("sp", &sp);
    putline();

    // Blk #1
    // print!("\n  -- borrow inner TLC from RefCell --");
    // let b = sp.borrow();
    // show("b ", &b);
    // let v = b.get_value();
    // show("v ", &v);
    // putline();

    // Blk #2
    print!("\n  -- attempt to mutably borrow inner TLC from RefCell --");
    /*-------------------------------------------------------
        - Even though sp is immutable, we can get a mutable
          reference, b2.
        - RefCell defers borrow checking to runtime. 
        - This succeeds only if there are no other current borrows.
          You can see that by uncommenting the code in blk #1
    */
    let mut b2 = sp.borrow_mut();   // returns RefMut<T>
    show("b2", &b2);
    b2.set_value(42);               // automatically dereferenced
    show("b2", &b2);
    let v = b2.get_value();         // here too
    show("v ", &v);
    putline();

    print!("\n  -- exploring borrowed type --");
    type TLC = test_type::TestLifeCycle;
    let sp2 = RefCell::new(TLC::new());
    let r:Ref<TLC> = sp2.borrow();
    show("r:Ref<TLC>", &show_type(r));
    putline();

    print!("\n  -- exploring automatic dereferencing of Ref<T> --");
    /*-- r was moved in show_type(r) so get another --*/
    let r = sp2.borrow();
    let tlc = &*r;
    show("r:Ref<T>", &r);
    show("tlc", &tlc);
    putline();

    print!("\n  -- exploring mutably borrowed type --");
    let sp2 = RefCell::new(TLC::new());
    let r:RefMut<TLC> = sp2.borrow_mut();
    show("r:RefMut<TLC>", &show_type(r));
    putline();

    print!("\n  -- exploring automatic dereferencing of RefMut<T> --");
    /*-- r was moved in show_type(r) so get another --*/
    let r = sp2.borrow_mut();
    let tlc = &*r;
    show("r:RefMut<T>", &r);
    show("tlc", &tlc);

    println!("\n\n  That's all Folks!");

}
               </defn-code>
             </defn-block>
             <defn-block>
               <defn-head>Output:</defn-head>
               <defn-code>
creating instance 0 of TestLifeCycle
-- create RefCell pointer to tlc --
sp = RefCell { value: TestLifeCycle { count: 0 } }

-- attempt to mutably borrow inner TLC from RefCell --
b2 = TestLifeCycle { count: 0 }
b2 = TestLifeCycle { count: 42 }
v  = 42

-- exploring borrowed type --
creating instance 0 of TestLifeCycle
r:Ref<TLC> = "core::cell::Ref<test_type::TestLifeCycle>"

-- exploring automatic dereferencing of Ref<T> --
r:Ref<T> = TestLifeCycle { count: 0 }
tlc = TestLifeCycle { count: 0 }

-- exploring mutably borrowed type --
creating instance 0 of TestLifeCycle
r:RefMut<TLC> = "core::cell::RefMut<test_type::TestLifeCycle>"

-- exploring automatic dereferencing of RefMut<T> --
r:RefMut<T> = TestLifeCycle { count: 0 }
tlc = TestLifeCycle { count: 0 }

That's all Folks!

TestLifeCycle instance 0 dropped
TestLifeCycle instance 0 dropped
TestLifeCycle instance 42 dropped
              </defn-code>
             </defn-block>
           </defn-outerBlock>
         </details>
       </div>
       <bb-55>
         <t-b>
           If you look through the Rust documentation you will find other applications of 
           RefCell&lt;T&gt; for building 
           <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">Mock Objects</a> for
           testing and for initializing objects that have an immutable interface.
         </t-b>
         <h2><a id="exer"></a>Exercises:</h2>
         <div>
           <ol class="tight">
             <li>
               Create an array of Strings on the heap, where the size of the array is defined at 
               run-time.  Display the strings, then swap the first and last strings and display the 
               results.  Did you have to copy any characters to swap the two strings?
             </li>
             <li>
               Create a string that is simultaneously shared by three different identifiers. What do you have
               to do to modify the string.
             </li>
             <li>
               Can you create a sequence of program statements that does not violate the ownership 
               rules, but will fail to compile because the borrow checker can&apos;t verify safety?
             </li>
           </ol>
         </div>
       </bb-55>
    <div style="height:5rem;"></div>
  </body>
</html>
