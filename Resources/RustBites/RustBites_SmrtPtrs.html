<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites SmartPtrs</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <script src="js/BiteScripts.js"></script>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <div style="position:relative; left:calc(100vw - 15rem);">
        <a href="../../RustBiteByByte.html">RustBiteByByte.html</a>
      </div>
  </div>

      <toc-b id="toc">
        <div style="display:flex; flex-direction:row">
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.sects()" style="color:#fefefa;">Sects</a>&nbsp;
          <a href="../../RustBiteByByte.html" style="color:#fefefa;">Repo</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">Esc</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp;
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
        <up-b id="chaps">
          <a href="RustBites_Facts.html">Facts</a><br />
          <a href="RustBites_Intro.html">Intro</a><br />
          <a href="RustBites_Data.html">Data</a><br />
          <a href="RustBites_LifeCycle.html">LifeCycle</a><br />
          <a href="RustBites_UDB.html">UndefBhvr</a><br />
          <a href="RustBites_Ownrs.html">Ownershp</a><br />
          <a href="RustBites_SmrtPtrs.html">SmartPtrs</a><br />
          <a href="RustBites_Intmut.html">InterMutat</a><br />
          <a href="RustBites_Functs.html">Functions</a><br />
          <a href="RustBites_ErrHnd.html">ErrHand</a><br />
          <a href="RustBites_Structs.html">Structs</a><br />
          <a href="RustBites_Traits.html">Traits</a><br />
          <a href="RustBites_Generics.html">Generics</a><br />
          <a href="RustBites_LifeTime.html">LifeTime</a><br />
          <a href="RustBites_Abstract.html">Abstract</a><br />
          <a href="RustBites_Collects.html">Collects</a><br />
          <a href="RustBites_Iterator.html">Iterator</a><br />
          <a href="RustBites_Threads.html">Threads</a><br />
          <a href="RustBites_Synchron.html">Synchronz</a><br />
          <a href="RustBites_Channels.html">Channels</a><br />
          <a href="RustBites_AsyncAwt.html">AsyncAwt</a><br />
          <a href="RustBites_Macros.html">Macros</a><br />
          <a href="Javascript.;#"></a><br />
        </up-b>
        <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
          <a href="#contents">Contents</a>, <a href="#refs">References</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>
       </div>
   
       <h1>Rust Bite - Smart Pointers</h1>
       <bb-55>
        purpose, create, access, modify, drop
        <h2><a id="box"></a>std::Box&lt;T&gt;</h2>
        <t-b>
          std::Box&lt;T&gt; is a smart pointer to data in the heap.  Box manages allocation and deallocation 
          of heap memory, and provides an interface to interact with that data.
        </t-b>
        </bb-55>
       <div class="indent pad5">
         <defn-block>
           <defn-head>Box - smart pointer to allocation on heap</defn-head>
           <defn-code>
let sp = Box::new(T::new());
/*--------------------------------------------*/
    Box automatically derefernces to a T
    so you can call T methods on sp
/*--------------------------------------------*/
let vl = sp.getter();    // T method
sp.setter(vl);           // T method
let spc = sp.clone();    // Box method
let t = *sp;  // move heap value to stack
Box deallocates heap memory in its drop method
           </defn-code>
         </defn-block>
       </div>
       <bb-55>
         <t-b>
           An example of Box code is shown in the dropdown, below.
         </t-b>
       </bb-55>
       <div>
         <details>
           <summary class="darkItem">Example: Box&lt;T&gt;</summary>
           <defn-outerBlock>
             <defn-block>
               <defn-head>show_box::main.rs</defn-head>
               <defn-code>
/////////////////////////////////////////////////////////////
// show_box::main.rs - demo Box&lt;T&gt; pointer to heap         //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
/////////////////////////////////////////////////////////////

#![allow(clippy::print_literal)]

use core::fmt::{ Debug };

/*-- same as print!("\n  sp = {:?}", sp) --*/
fn show&lt;T:Debug&gt;(name:&amp;str, t:&amp;T) {
    print!("\n  {} = {:?}", name, t);
}

fn main() {

    let putline = || print!("\n");

    type TLC = test_type::TestLifeCycle;

    print!("\n  -- create Box pointer to TLC on heap --");
    let sp = Box::new(TLC::new());
    show("sp", &amp;sp);
    putline();

    print!("\n  -- access member of TLC using Box --");
    let v = sp.get_value();
    show("v ", &amp;v);
    putline();

    print!("\n  -- clone Box pointer to TLC on heap --");
    let mut spc = sp.clone();
    show("spc", &amp;spc);
    putline();

    print!("\n  -- mutate TLC through Box --");
    spc.set_value(42);
    show("spc", &amp;spc);
    show("v ", &amp;spc.get_value());
    show("sp", &amp;sp);
    putline();

    print!("\n  -- create reference to Box pointer --");
    let rspc = &amp;mut spc;
    rspc.set_value(21);
    show("rspc", &amp;rspc);    // holds new value
    show("spc", &amp;spc);      // holds new value too
    putline();

    print!("\n  -- move contents of Box back to stack with deref --");
    let tlc = *sp;  // move
    show("tlc", &amp;tlc);

    // statement below won't compile since sp has been moved
    // show("sp", &amp;sp);

    println!("\n\n  That's all Folks!");

}  /*-- drop Boxed item --*/
                </defn-code>
             </defn-block>
             <defn-block>
               <defn-head>Output:</defn-head>
               <defn-code>
cargo run -q

-- create Box pointer to TLC on heap --
creating instance 0 of TestLifeCycle
sp = TestLifeCycle { count: 0 }

-- access member of TLC using Box --
v  = 0

-- clone Box pointer to TLC on heap --
TestLifeCycle instance 0 cloned
spc = TestLifeCycle { count: 0 }

-- mutate TLC through Box --
spc = TestLifeCycle { count: 42 }
v  = 42
sp = TestLifeCycle { count: 0 }

-- create reference to Box pointer --
rspc = TestLifeCycle { count: 21 }
spc = TestLifeCycle { count: 21 }

-- move contents of Box back to stack with deref --    
tlc = TestLifeCycle { count: 0 }

That's all Folks!

TestLifeCycle instance 0 dropped
TestLifeCycle instance 21 dropped
                </defn-code>
             </defn-block>
           </defn-outerBlock>
         </details>
       </div>
    
       <h2><a id="rc"></a>Rc&lt;T&gt;</h2>
       <bb-55>
        <t-b>
          std::rc::Rc&lt;T&gt; is a reference counted pointer to an initialized value on the stack.
          Rc manages multiple references by dropping its inner value only when the last Rc pointer
          is dropped, e.g., there are no dangling references.
         </t-b>
         <t-b>
         </bb-55>
         <div class="indent pad5">
           <defn-block>
             <defn-head>Rc - reference counted pointer</defn-head>
             <defn-code>
  let tlc = test_type::TestLifeCycle;
  let mut rc1 = Rc::new(tlc)
  /*------------------------------------------------*/
    std::rc::Rc is a reference counted pointer.
    - Rc::new(value) creates a pointer to value. 
    - Rc::clone creates a new pointer to the same
      source inner value, adding 1 to ref count.
    - Rc automatically dereferences to a T, so you
      can call T methods on an Rc&lt;T&gt;.
    - Rc::drop decrements the ref count, dropping
      the inner value on zero.
    - Note, it does no harm to drop a stack value
      as long as there is no attempt to use after.
  /*------------------------------------------------*/
  let rc2 = rc1.clone();
  let rc3 = Rc::clone(&rc2);
  let opt = Rc::get_mut(&rc1);
  where opt: Option&lt;Some(&mut tlc)&gt;
  /*------------------------------------------------*/
     get_mut returns an Option because the Rust
     ownership rules allow only one active mutable
     reference.
     If there is already an active mutable reference
     the option contains the enumeration value None.
     Otherwise it contains Some(&mut inner_value).
  /*------------------------------------------------*/
             </defn-code>
           </defn-block>
         </div>
       </t-b>
       <bb-55>
        <t-b>
          Example code for Rc is shown below.  Note that most of the code complexity results from processing an Option, returned
          by Rc::get_mut(&mut inner_value).  That&apos;s the way the cookie crumbles.
        </t-b>
        </bb-55>
       <div>
         <details>
           <summary class="darkItem">Example: Rc&lt;T&gt;</summary>
           <s-halfEm></s-halfEm>
           <defn-outerBlock>
             <defn-block>
               <defn-head>show_rc::main.rs</defn-head>
               <defn-code>
/////////////////////////////////////////////////////////////
// show_rc::main.rs - demo Rc&lt;T&gt; ref counted ptr           //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
/////////////////////////////////////////////////////////////

use core::fmt::{ Debug };
use std::rc::Rc;

/*-- same as print!("\n  sp = {:?}", sp) --*/
#[allow(clippy::print_literal)]
fn show&lt;T:Debug&gt;(name:&amp;str, t:&amp;T) {
    print!("\n  {} = {:?}", name, t);
}

struct SpaceAtEnd;
impl Drop for SpaceAtEnd {
    fn drop(&amp;mut self) {
        print!("\n\n");
    }
}

fn main() {

    let putline = || print!("\n");
    let _cosmetic = SpaceAtEnd;

    print!("\n  -- create instance of TestLifeCycle in stack --");
    let tlc = test_type::TestLifeCycle::new();
    putline();

    print!("\n  -- create Rc ptr to value in stack --");
    let mut rc1 = Rc::new(tlc);
    show("rc1", &amp;rc1);
    show("Rc strong count", &amp;Rc::strong_count(&amp;rc1));
    show("rc1 inner value", &rc1.get_value());
    putline();

    print!("\n  -- attempt to mutate inst through Rc ptr --");
    let opt_mut_rc1 = Rc::get_mut(&amp;mut rc1);
    match opt_mut_rc1 {
        Some(val) =&gt; {
            /*-- make mutable reference --*/
            let mut_rc1 = &amp;mut *val;
            mut_rc1.set_value(42);
            show("rc1", &amp;rc1);
        },
        None =&gt; { 
            print!(
                "\n  can't have multiple mutable references"
            );
        }
    }
    putline();

    print!("\n  -- create new Rc ptr to inst in stack --");
    let mut rc2 = rc1.clone();
    show("rc2", &amp;rc2);
    show("Rc strong count", &amp;Rc::strong_count(&amp;rc2));
    putline();

    print!("\n  -- attempt to mutate inst through Rc ptr --");
    let opt_mut_rc2 = Rc::get_mut(&amp;mut rc2);
    match opt_mut_rc2 {
        Some(val) =&gt; {
            /*-- make mutable reference --*/
            let mut_rc2 = &amp;mut *val;
            mut_rc2.set_value(21);
            show("rc2", &amp;rc2);
        },
        None =&gt; { 
            print!(
                "\n  can't have multiple mutable references"
            );
        }
    }
    putline();

    /*-- alternate clone syntax --*/
    print!("\n  -- create another new Rc ptr to inst in stack --");
    let mut rc3 = Rc::clone(&amp;rc1); 
    show("rc3", &amp;rc3);
    show("Rc strong count", &amp;Rc::strong_count(&amp;rc1));
    putline();

    /*-- alternate matching syntax --*/
    print!("\n  -- attempt to mutate inst through Rc ptr --");
    let opt_mut_rc3 = Rc::get_mut(&amp;mut rc3);
    if let Some(val) = opt_mut_rc3 {
        /*-- make mutable reference --*/
        let mut_rc3 = &amp;mut *val;
        mut_rc3.set_value(21);
        show("rc3", &amp;rc2);
    }
    else {
        print!(
            "\n  can't have multiple mutable references"
        );
    }
    putline();

    // print!("\n  dropping rc1");
    // drop(rc1);
    // print!("\n  dropping rc2");
    // drop(rc2);
    // print!("\n  dropping rc3");
    // drop(rc3);
    // putline();    

    /*-------------------------------------------------------
        Help with Option processing, used above: 
        -----------------------------------------------------
        The code below illustrates destructuring an option
        with both if let and match constructs.
        These will be discussed again in the Error Handling
        Bite.
    */
    let maybe_cake = Some("this code is a piece of cake! :-)");
    let not_cake = std::option::Option::&lt;&amp;str&gt;::None;
    if let Some(cake) = maybe_cake {    // cake is a defined identifier
        print!("\n  {}", cake);         // due to if let destructuring
    }
    
    let maybe_cake: Option&lt;&amp;str&gt; = not_cake;
    match maybe_cake {
        Some(cake) =&gt; print!("\n  {}", cake),
                                        // now, cake is defined by
                                        // match destructuring
        None =&gt; print!("\n  this code is not a piece of cake!! :-(")
    }

    println!("\n\n  That's all Folks!");
}
                                </defn-code>
             </defn-block>
             <defn-block>
               <defn-head>Output:</defn-head>
               <defn-code>
cargo run -q

-- create instance of TestLifeCycle in stack --
creating instance 0 of TestLifeCycle

-- create Rc ptr to value in stack --
rc1 = TestLifeCycle { count: 0 }
Rc strong count = 1
rc1 inner value = 0

-- attempt to mutate inst through Rc ptr --
rc1 = TestLifeCycle { count: 42 }

-- create new Rc ptr to inst in stack --
rc2 = TestLifeCycle { count: 42 }
Rc strong count = 2

-- attempt to mutate inst through Rc ptr --
can't have multiple mutable references

-- create another new Rc ptr to inst in stack --
rc3 = TestLifeCycle { count: 42 }
Rc strong count = 3

-- attempt to mutate inst through Rc ptr --
can't have multiple mutable references

this code is a piece of cake! :-)
this code is not a piece of cake!! :-(

That's all Folks!

TestLifeCycle instance 42 dropped
               </defn-code>
             </defn-block>
           </defn-outerBlock>
         </details>
         <bb-55>
           <t-b>
             Rc is used most often with <a href="RustBites_Intmut.html">Interior Mutability</a>.  You will see
             its use in examples for that Bite. 
           </t-b>
         </bb-55>
       </div>
       <h2><a id="arc"></a>Arc&lt;T&gt;</h2>
       <bb-55>
        <t-b>
          std::sync::Arc&lt;T&gt; is a thread-safe reference counted pointer to an initialized value on the stack.
          Arc manages multiple references by dropping its inner value only when the last Rc pointer
          is dropped, e.g., there are no dangling references. Arc is a thread-safe version of Rc.
         </t-b>
         <t-b>
         </bb-55>
         <div class="indent pad5">
           <defn-block>
             <defn-head>Arc - atomic reference counted pointer</defn-head>
             <defn-code>
let tlc = test_type::TestLifeCycle;
let mut arc1 = Arc::new(tlc)
/*------------------------------------------------*/
  std::sync::Arc is a thread-safe reference counted 
  pointer, very like Rc, but using atomic ref count.
  - Arc::new(value) creates a pointer to value. 
  - Arc::clone creates a new pointer to the same
    source inner value, adding 1 to ref count.
  - Arc::drop decrements the ref count, dropping
    the inner value on zero.
  - Note, it does no harm to drop a stack value
    as long as there is no attempt to use after.
  - 
/*------------------------------------------------*/
let arc2 = arc1.clone();
let arc3 = Arc::clone(&amp;arc2);
let opt = Arc::get_mut(&amp;arc1);
where opt: Option&lt;Some(&amp;mut tlc)&gt;
          </defn-code>
           </defn-block>
         </div>
       </t-b>
       <bb-55>
        <t-b>
          Example code for Arc is shown below.  Note that most of the code complexity results from processing an Option, returned
          by Arc::get_mut(&mut inner_value).  That&apos;s still the way cookies crumble.
        </t-b>
        </bb-55>
       <div>
         <details>
           <summary class="darkItem">Example: Arc&lt;T&gt;</summary>
           <s-halfEm></s-halfEm>
           <defn-outerBlock>
             <defn-block>
               <defn-head>show_arc::main.rs</defn-head>
               <defn-code>
/////////////////////////////////////////////////////////////
// show_arc::main.rs - demo Arc&lt;T&gt; ref counted ptr         //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
/////////////////////////////////////////////////////////////

use core::fmt::{ Debug };
use std::sync::Arc;

/*-- same as print!("\n  sp = {:?}", sp) --*/
#[allow(clippy::print_literal)]
fn show&lt;T:Debug&gt;(name:&amp;str, t:&amp;T) {
    print!("\n  {} = {:?}", name, t);
}

struct SpaceAtEnd;
impl Drop for SpaceAtEnd {
    fn drop(&amp;mut self) {
        print!("\n\n");
    }
}

fn main() {

    let putline = || print!("\n");
    let _cosmetic = SpaceAtEnd;

    print!("\n  -- create instance of TestLifeCycle in stack --");
    let tlc = test_type::TestLifeCycle::new();
    putline();

    print!("\n  -- create Arc ptr to value in stack --");
    let mut arc1 = Arc::new(tlc);
    show("arc1", &amp;arc1);
    show("Arc strong count", &amp;Arc::strong_count(&amp;arc1));
    show("arc1 inner value", &amp;arc1.get_value());
    putline();

    print!("\n  -- attempt to mutate inst through Arc ptr --");
    let opt_mut_arc1 = Arc::get_mut(&amp;mut arc1);
    match opt_mut_arc1 {
        Some(val) =&gt; {
            /*-- make mutable reference --*/
            let mut_arc1 = &amp;mut *val;
            mut_arc1.set_value(42);
            show("arc1", &amp;arc1);
        },
        None =&gt; { 
            print!(
                "\n  can't have multiple mutable references"
            );
        }
    }
    putline();

    print!("\n  -- create new Arc ptr to inst in stack --");
    let mut arc2 = arc1.clone();
    show("arc2", &amp;arc2);
    show("Arc strong count", &amp;Arc::strong_count(&amp;arc2));
    putline();

    print!("\n  -- attempt to mutate inst through Arc ptr --");
    let opt_mut_arc2 = Arc::get_mut(&amp;mut arc2);
    match opt_mut_arc2 {
        Some(val) =&gt; {
            /*-- make mutable reference --*/
            let mut_arc2 = &amp;mut *val;
            mut_arc2.set_value(21);
            show("arc2", &amp;arc2);
        },
        None =&gt; { 
            print!(
                "\n  can't have multiple mutable references"
            );
        }
    }
    putline();

    /*-- alternate clone syntax --*/
    print!("\n  -- create another new Arc ptr to inst in stack --");
    let mut arc3 = Arc::clone(&amp;arc1); 
    show("arc3", &amp;arc3);
    show("Arc strong count", &amp;Arc::strong_count(&amp;arc1));
    putline();

    /*-- alternate matching syntax --*/
    print!("\n  -- attempt to mutate inst through Arc ptr --");
    let opt_mut_arc3 = Arc::get_mut(&amp;mut arc3);
    if let Some(val) = opt_mut_arc3 {
        /*-- make mutable reference --*/
        let mut_arc3 = &amp;mut *val;
        mut_arc3.set_value(21);
        show("arc3", &amp;arc2);
    }
    else {
        print!(
            "\n  can't have multiple mutable references"
        );
    }
    putline();

    // print!("\n  dropping rc1");
    // drop(rc1);
    // print!("\n  dropping rc2");
    // drop(rc2);
    // print!("\n  dropping rc3");
    // drop(rc3);
    // putline();    

    println!("\n\n  That's all Folks!");
}
                </defn-code>
             </defn-block>
             <defn-block>
               <defn-head>Output:</defn-head>
               <defn-code>
cargo run -q

-- create instance of TestLifeCycle in stack --
creating instance 0 of TestLifeCycle

-- create Arc ptr to value in stack --
arc1 = TestLifeCycle { count: 0 }
Arc strong count = 1
arc1 inner value = 0

-- attempt to mutate inst through Arc ptr --
arc1 = TestLifeCycle { count: 42 }

-- create new Arc ptr to inst in stack --
arc2 = TestLifeCycle { count: 42 }
Arc strong count = 2

-- attempt to mutate inst through Arc ptr --
can't have multiple mutable references

-- create another new Arc ptr to inst in stack --        
arc3 = TestLifeCycle { count: 42 }
Arc strong count = 3

-- attempt to mutate inst through Arc ptr --
can't have multiple mutable references


That's all Folks!

TestLifeCycle instance 42 dropped
             </defn-code>
             </defn-block>
           </defn-outerBlock>
         </details>
         <bb-55>
           <t-b>
             Rc is used most often with <a href="RustBites_Intmut.html">Interior Mutability</a>.  You will see
             its use in examples for that Bite. 
           </t-b>
         </bb-55>
       </div>

       <h2><a id="refcell"></a>RefCell&lt;T&gt;</h2>
       <h2><a id="ref"></a>Ref&lt;T&gt;</h2>
       <h2><a id="refmut"></a>RefMut&lt;T&gt;</h2>

  </body>
</html>
