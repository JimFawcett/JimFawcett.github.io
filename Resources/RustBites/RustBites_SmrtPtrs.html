<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites SmartPtrs</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <script src="js/BiteScripts.js"></script>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <div style="position:relative; left:calc(100vw - 15rem);">
        <a href="../../RustBiteByByte.html">RustBiteByByte.html</a>
      </div>
  </div>

      <toc-b id="toc">
        <div style="display:flex; flex-direction:row">
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.sects()" style="color:#fefefa;">Sects</a>&nbsp;
          <a href="../../RustBiteByByte.html" style="color:#fefefa;">Repo</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">Esc</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp;
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
        <up-b id="chaps">
          <a href="RustBites_Facts.html">Facts</a><br />
          <a href="RustBites_Intro.html">Intro</a><br />
          <a href="RustBites_Data.html">Data</a><br />
          <a href="RustBites_LifeCycle.html">LifeCycle</a><br />
          <a href="RustBites_UDB.html">UndefBhvr</a><br />
          <a href="RustBites_Ownrs.html">Ownershp</a><br />
          <a href="RustBites_SmrtPtrs.html">SmartPtrs</a><br />
          <a href="RustBites_Intmut.html">InterMutat</a><br />
          <a href="RustBites_Functs.html">Functions</a><br />
          <a href="RustBites_ErrHnd.html">ErrHand</a><br />
          <a href="RustBites_Structs.html">Structs</a><br />
          <a href="RustBites_Traits.html">Traits</a><br />
          <a href="RustBites_Generics.html">Generics</a><br />
          <a href="RustBites_LifeTime.html">LifeTime</a><br />
          <a href="RustBites_Abstract.html">Abstract</a><br />
          <a href="RustBites_Collects.html">Collects</a><br />
          <a href="RustBites_Iterator.html">Iterator</a><br />
          <a href="RustBites_Threads.html">Threads</a><br />
          <a href="RustBites_Synchron.html">Synchronz</a><br />
          <a href="RustBites_Channels.html">Channels</a><br />
          <a href="RustBites_AsyncAwt.html">AsyncAwt</a><br />
          <a href="RustBites_Macros.html">Macros</a><br />
          <a href="Javascript.;#"></a><br />
        </up-b>
        <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
          <a href="#contents">Contents</a>, <a href="#refs">References</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>
       </div>
   
       <h1>Rust Bite - Smart Pointers</h1>
       <bb-55>
        purpose, create, access, modify, drop
        <h2><a id="box"></a>std::Box&lt;T&gt;</h2>
        <t-b>
          std::Box&lt;T&gt; is a smart pointer to data in the heap.  Box manages allocation and deallocation 
          of heap memory, and provides an interface to interact with that data.
        </t-b>
        </bb-55>
       <div class="indent pad5">
         <defn-block>
           <defn-head>Box - smart pointer to allocation on heap</defn-head>
           <defn-code>
let sp = Box::new(T::new());
/*--------------------------------------------*/
    sp has the interface of both Box and T
    so you can call T methods on sp
/*--------------------------------------------*/
let vl = sp.getter();    // T method
sp.setter(vl);           // T method
let spc = sp.clone();    // Box method
let t = *sp;  // move heap value to stack
Box deallocates heap memory in its drop method
           </defn-code>
         </defn-block>
       </div>
       <bb-55>
         <t-b>
           An example of Box code is shown in the dropdown, below.
         </t-b>
       </bb-55>
       <div>
         <details>
           <summary class="darkItem">Example: Box&lt;T&gt;</summary>
           <defn-outerBlock>
             <defn-block>
               <defn-head>show_box::main.rs</defn-head>
               <defn-code>
/////////////////////////////////////////////////////////////
// show_box::main.rs - demo Box&lt;T&gt; pointer to heap         //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
/////////////////////////////////////////////////////////////

#![allow(clippy::print_literal)]

use core::fmt::{ Debug };

/*-- same as print!("\n  sp = {:?}", sp) --*/
fn show&lt;T:Debug&gt;(name:&amp;str, t:&amp;T) {
    print!("\n  {} = {:?}", name, t);
}

fn main() {

    let putline = || print!("\n");

    type TLC = test_type::TestLifeCycle;

    /*-- create Box pointing to TLC on heap --*/
    print!("\n  -- create Box pointer to TLC on heap --");
    let sp = Box::new(TLC::new());
    show("sp", &amp;sp);
    putline();

    /*-- extract data from boxed TLC --*/
    print!("\n  -- access member of TLC using Box --");
    let v = sp.get_value();
    show("v ", &amp;v);
    putline();

    /*-- clone Boxed item --*/
    print!("\n  -- clone Box pointer to TLC on heap --");
    let mut spc = sp.clone();
    show("spc", &amp;spc);
    putline();

    /*-- mutate Boxed value --*/
    print!("\n  -- mutate TLC through Box --");
    spc.set_value(42);
    show("spc", &amp;spc);
    show("v ", &amp;spc.get_value());
    show("sp", &amp;sp);
    putline();

    /*-- make mut reference to Box --*/
    print!("\n  -- create reference to Box pointer --");
    let rspc = &amp;mut spc;
    rspc.set_value(21);
    show("rspc", &amp;rspc);    // holds new value
    show("spc", &amp;spc);      // holds new value too
    putline();

    /*-- move TLC from Box back to stack with deref --*/
    print!("\n  -- move contents of Box back to stack with deref --");
    let tlc = *sp;  // move
    show("tlc", &amp;tlc);

    // statement below won't compile since sp has been moved
    // show("sp", &amp;sp);

    println!("\n\n  That's all Folks!");

}  /*-- drop Boxed item --*/
                </defn-code>
             </defn-block>
             <defn-block>
               <defn-head>Output:</defn-head>
               <defn-code>
cargo run -q

-- create Box pointer to TLC on heap --
creating instance 0 of TestLifeCycle
sp = TestLifeCycle { count: 0 }

-- access member of TLC using Box --
v  = 0

-- clone Box pointer to TLC on heap --
TestLifeCycle instance 0 cloned
spc = TestLifeCycle { count: 0 }

-- mutate TLC through Box --
spc = TestLifeCycle { count: 42 }
v  = 42
sp = TestLifeCycle { count: 0 }

-- create reference to Box pointer --
rspc = TestLifeCycle { count: 21 }
spc = TestLifeCycle { count: 21 }

-- move contents of Box back to stack with deref --    
tlc = TestLifeCycle { count: 0 }

That's all Folks!

TestLifeCycle instance 0 dropped
TestLifeCycle instance 21 dropped
                </defn-code>
             </defn-block>
           </defn-outerBlock>
         </details>
       </div>
    
       <h2><a id="rc"></a>Rc&lt;T&gt;</h2>
       <h2><a id="arc"></a>Arc&lt;T&gt;</h2>
       <h2><a id="refcell"></a>RefCell&lt;T&gt;</h2>
       <h2><a id="ref"></a>Ref&lt;T&gt;</h2>
       <h2><a id="refmut"></a>RefMut&lt;T&gt;</h2>

  </body>
</html>
