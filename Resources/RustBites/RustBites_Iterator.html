<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Iters</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <link rel="stylesheet" href="css/BiteTables.css" />
    <script src="js/BiteScripts.js"></script>
    <script src="js/ScriptsKeyboard.js"></script>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <span class="top-center">Iterators</span>
      <!-- <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a> -->
    </div>
  
    <next-prev>
      <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
      <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
      <a id="Prev" href="RustBites_Collects.html">prev</a> 
      <a id="Next" href="RustBites_Idioms.html">next</a>
    </next-prev>

    <toc-b id="toc">
      <div id="bottom-menu" style="display:flex; flex-direction:row">
      </div>
        <up-b id="chaps">
        </up-b>
        <rt-b id="sects">
        <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
        <a href="#contents">Contents</a>, <a href="#refs">References</a>
      </rt-b>
    </toc-b>
    <div id="hlp" style="display:none;">
      </div>
   
    <h2>Rust Bite - Iterators</h2>

    <t-b><hr class="spread" /></t-b>
    <t-b>
      Iterators have an associated type, Item, and a number of member functions, shown in Table 2., below.
    </t-b>
    <t-b>
      <div class="indent">
        <defn-OuterBlock>
          <defn-block>
            <defn-head>Basic Iteration</defn-head>
            <defn-code>
fn do_iter&lt;T&gt;(iter: &mut T) 
  where T: Iterator + Debug, T::Item: Debug {
    print!("\n  ");
    loop {
        let item = iter.next();
        if item.is_none() {
            break;
        }
        print!("{:?} ", item.unwrap());
    }
}
            </defn-code>
            <defn-body class="defnBorderTop">
              The iterator&apos;s function <c-s>next()</c-s> returns an Option&lt;Item&gt;.<br />
              While there are items it returns <c-s>Some(item)</c-s> else <c-s>None</c-s>.
            </defn-body>
          </defn-block>
          <defn-block>
            <defn-head>Idiomatic iteration</defn-head>
            <defn-code>
fn do_idiomatic_iter&lt;T&gt;(t:T) 
  where T: IntoIterator, T::Item: Debug {
    print!("\n  ");
    for item in t {
        print!("{:?} ", item);
    }
}




            </defn-code>
            <defn-body class="defnBorderTop">
              Rust for loops are simply wrappers for an<br />appropriate iterator.
            </defn-body>
          </defn-block>
        </defn-OuterBlock>
      </div>
    </t-b>
    <div style="height: 0.25rem;"></div>
    <t-b><hr class="spread" /></t-b>
    <h3>Iterating over Collections</h3>
    <t-b>
      Most Rust collections implement at least one of three methods that return iterators:
      <div class="indent">
      <table>
        <tr>
          <td>iter()</td>
          <td>Iterates over &T</td>
        </tr>
        <tr>
          <td>iter_mut()</td>
          <td>Iterates over &mut T</td>
        </tr>
        <tr>
          <td>into_iter()</td>
          <td>Iterates over T, consuming collection</td>
        </tr>
      </table>
      </div>
      These functions expect items which all have the same size.
    </t-b>
    <t-b>
      <div class="indent">
        <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=a07dace160f8c097a2d14e51be4fb4d3">
          playground examples
        </a>
      </div>
    </t-b>
    <div style="height: 0.25rem;"></div>
    <t-b><hr class="spread" /></t-b>
    <h3>Iterating over Strings</h3>
    <t-b>
      Since types of <c-s>String</c-s> and <c-s>&str</c-s> contain utf-8 characters, their items may have
      sizes that vary from 1 to 4 bytes.  So their iterators have to search for character boundaries.
    </t-b>
    <t-b>
      <div class="indent">
        <h4>Table 1. utf-8 character boundaries</h4>
        <table>
          <tr>
            <th>char size</th><th>indicator</th>
          </tr>
          <tr>
            <td>1 byte, e.g. ASCII</td><td>byte starts with bit 0</td>
          </tr>
          <tr>
            <td>2 bytes</td><td>First byte starts with bits 110</td>
          </tr>
          <tr>
            <td>3 bytes</td><td>First byte starts with bits 1110</td>
          </tr>
          <tr>
            <td>4 bytes</td><td>First byte starts with bits 11110</td>
          </tr>
          <tr>
            <td>not first byte</td><td>byte starts with bits 10</td>
          </tr>
        </table>
      </div>
    </t-b>
    <t-b>
      For that reason, instances of std::String and primitive str provide iterators:
      <ul class="tight">
        <li>
          <c-s>chars(&self) -> Option&lt;char&gt;</c-s>
        </li>
        <li>
          <c-s>char_indices(&self) -> CharIndices&lt;'_&gt;</c-s> &lt;=&gt; Option&lt;(usize, char)&gt;.
        </li>
      </ul>
    </t-b>
    <t-b>
      The type <c-s>char</c-s> is not what <c-s>String</c-s> and <c-s>str</c-s> hold.  The type char consists of
      4 bytes which can hold any of the <c-s>String</c-s> and <c-s>str</c-s> characters.  So, a Vec&lt;char&gt;
      would be expected to usually be up to four times larger than a std::String with the same logical contents.
    </t-b>
    <t-b>
      <div class="indent">
        <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c225c594cd22e3b3f9452e70af16de9c">
          playground examples
        </a>
      </div>
    </t-b>
    <div style="height: 0.25rem;"></div>
    <t-b><hr class="spread" /></t-b>
    <h3>Iterator Adapters</h3>
    <t-b>
      Iterator adapters are methods that select and/or modify elements of a collection and may then collect them into
      an instance of a new specified collection type by coping, cloning, or referencing the original collection.
    </t-b>
    <t-b>
      <div class="indents">
      <h4>Table 2. - Iterator Methods</h4>
      <table style="width:calc(100vw - 7rem);">
        <tr>
          <th>Member function</th>
          <th>Operation</th>
          <th>Note</th>
        </tr>
        <tr>
          <td class="no-wrap"><strong>next</strong>(&mut self) -> Option&lt;Self::Item&gt;</td>
          <td>Return next element in collection</td>
          <td>Consumes&nbsp;returned&nbsp;element</td>
        </tr>
        <tr>
          <td class="no-wrap"><strong>count</strong>(self) -> usize</td>
          <td>Returns number of iterations</td>
          <td>Consumes iterator</td>
        </tr>
        <tr>
          <td class="no-wrap"><strong>last</strong>(self) -> Option&lt;Self::Item&gt;</td>
          <td>Returns last item</td>
          <td>Consumes iterator</td>
        </tr>
        <tr>
          <td class="no-wrap"><strong>nth</strong>(&mut self, n: usize) -> Option&lt;Self::Item&gt;</td>
          <td>Returns nth element</td>
          <td>Consumes all preceding elements</td>
        </tr>
        <tr>
          <td class="no-wrap"><strong>step-by</strong>(self, step: usize) ->StepBy&lt;Self&gt;</td>
          <td>
            Creates new iterator starting at same point, but
            stepping by given amount at each iteration.
          </td>
          <td>Consumes original iterator</td>
        </tr>
        <tr>
          <td class="no-wrap"><strong>skip</strong>(self, n: usize) -> Skip&lt;Self&gt;</td>
          <td>Creates an iterator that skips the first n elements</td>
          <td>Consumes iterator</td>
        </tr>
        <tr>
          <td class="no-wrap"><strong>
            skip_while</strong>&lt;P&gt;(self, p: P) -> Skip_while&lt;Self, P&gt;<br />
            &nbsp;&nbsp;where P: FnMut(&Self::Item) -> bool
          </td>
          <td>
            Creates an iterator that skips elements if predicate is true.  Returns after first false.
          </td>
          <td>Consumes iterator</td>
        </tr>
        <tr>
          <td class="no-wrap"><strong>take</strong>(self, n:usize) -> Take&lt;Self&gt;</td>
          <td>Creates an iterator that returns first n elements</td>
          <td>Consumes original iterator</td>
        </tr>
        <tr>
          <td class="no-wrap">
            <strong>find</strong>&lt;P&gt;(&mut self, predicate: P) -> Option&lt;Self::Item&gt;<br />
            &nbsp;&nbsp;where P: FnMut(&Self::Item) -> bool
          </td>
          <td>Searches for first element that satisfies predicate.</td>
          <td></td>
        </tr>
        <tr>
          <td class="no-wrap">
            <strong>enumerate</strong>(self) -> Enumerate&lt;Self&gt;<br />
            &nbsp;&nbsp;&lt;=&gt; Option&lt;(usize, &Item)&gt;
          </td>
          <td>Returns (i, val) where i is current index and val is the value of the current item.</td>
          <td>Consumes original iterator</td>
        </tr>
        <tr>
          <td class="no-wrap"><strong>map</strong>&lt;B, F&gt;(self, f: F) -> Map&lt;Self, F&gt;</td>
          <td>
            Takes a closure and creates an iterator that calls the closure
            on each element
          </td>
          <td>Consumes original iterator</td>
        </tr>
        <tr>
          <td class="no-wrap">
            <strong>filter</strong>&lt;P&gt;(self, predicate: P) - > Filter&lt;Self, P&gt;<br />
            &nbsp;&nbsp;where P: FnMut(&Self::Item) -> bool
          </td>
          <td>
            Creates an iterator which takes a closure to decide if element
            should be included in result
          </td>
          <td>Consumes original iterator</td>
        </tr>
        <tr>
          <td class="no-wrap"><strong>collect</strong>&lt;B&gt;(self) -> B</td>
          <td>Transforms iterator into collection</td>
          <td>Consumes iterator</td>
        </tr>
        <tr>
          <td class="no-wrap">
            <strong>any</strong>&lt;F&gt;(&mut self, f: F) -> bool<br />
            &nbsp;&nbsp;where F: FnMut(Self::Item) -> bool
          </td>
          <td>Tests if any element of iterator matches a predicate</td>
          <td></td>
        </tr>
        <tr>
          <td class="no-wrap">
            <strong>all</strong>&lt;F&gt;(&mut self, f: F) -> bool<br />
            &nbsp;&nbsp;where F: FnMut(Self::Item) -> bool
          </td>
          <td>Tests if every element of iterator matches a predicate</td>
          <td></td>
        </tr>
        <tr>
          <td class="no-wrap">
            <strong>for_each</strong>&lt;F&gt;(self, f: F)<br />
            &nbsp;&nbsp;where F: FnMut(Self::Item)
          </td>
          <td>Calls closure on each element of iterator</td>
          <td></td>
        </tr>
        <tr>
          <td class="no-wrap">
            <strong>position</strong>&lt;P&gt;(&mut self, p: P) -> Option&lt;usize&gt;<br />
            &nbsp;&nbsp;where F: FnMut(Self::Item) -> bool
          </td>
          <td>Returns index of first match</td>
          <td></td>
        </tr>
        <tr>
          <td class="no-wrap">
            <strong>product</strong>&lt;P&gt;(self) -> P<br />
            &nbsp;&nbsp;where P: Product&lt;Self::Item&gt;
          </td>
          <td>Returns product of all elements, else 1 if empty</td>
          <td></td>
        </tr>
        <tr>
          <td class="no-wrap">
            <strong>sum</strong>&lt;S&gt;(self) -> S<br />
            &nbsp;&nbsp;where S: Sum&lt;Self::Item&gt;
          </td>
          <td>Returns sum of all elements, else 0 if empty</td>
          <td></td>
        </tr>
        <tr>
          <td class="no-wrap"><strong>by_ref</strong>(&mut self) -> &mut Self</td>
          <td>
            Supports using these adapters while retaining ownership
            of the original iterator
          </td>
          <td>Avoids consuming original</td>
        </tr>
        <tr>
          <td class="no-wrap">
            <strong>copied</strong>&lt;'a, T&gt;(self) -> Copied&lt;Self&gt;<br />
            &nbsp;&nbsp;where Self: Itertor&lt;Item = &'a T&gt;,<br />
            &nbsp;&nbsp;T: 'a + Copy;
          </td>
          <td>
            Creates iterator which copies all of its elements
          </td>
          <td>Consumes original iterator</td>
        </tr>
        <tr>
          <td class="no-wrap">
            <strong>cloned</strong>&lt;'a, T&gt;(self) -> Cloned&lt;Self&gt;<br />
            &nbsp;&nbsp;where Self: Itertor&lt;Item = &'a T&gt;,<br />
            &nbsp;&nbsp;T: 'a + Clone;
          </td>
          <td>
            Creates iterator which clones all of its elements
          </td>
          <td>Consumes original iterator</td>
        </tr>
        <tr>
          <th> </th><th> </th><th> </th>
        </tr>
        <tr>
          <td style="height:2rem;">More adapter functions ...</td>
          <td><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">std::iter::Iterator</a></td>
        </tr>
        <tr>
          <th>&nbsp;</th><th> </th><th> </th>
        </tr>
      </table>
      </div>
    </t-b>
    <t-b>
      <div class="indent">
        <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=bc074b78c9217bb15d92d7596992e89d">
          playground examples
        </a>
      </div>
    </t-b>
    <t-b>
      <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=5d79d5fb1a8332537eb292530fdc43f1">
        iter playground
      </a><br />
      <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0d8e31f6875954da50fa1a53f161dd82">
        hashmap playground
      </a>
    </t-b>
  </body>
</html>
