<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Macros</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <script src="js/BiteScripts.js"></script>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <span class="top-center">Hacks and Helpers</span>
      <!-- <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a> -->
    </div>
  </div>
  <next-prev>
    <a id="prev" href="RustBites_Macros.html">prev</a> 
    <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
    <a id="next" href="RustBites_Facts.html">next</a>
  </next-prev>

      <toc-b id="toc">
        <div style="display:flex; flex-direction:row">
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.sects()" style="color:#fefefa;">Sects</a>&nbsp;
          <a href="../../RustBiteByByte.html" style="color:#fefefa;">Repo</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">Esc</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp;
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
          <up-b id="chaps">
            <a href="RustBites_Facts.html">Facts</a><br />
            <a href="RustBites_Intro.html">Introduction</a><br />
            <a href="RustBites_UDB.html">UndefBehavior</a><br />
            <a href="RustBites_Data.html">Data</a><br />
            <a href="RustBites_DataStr.html">DataStructs</a><br />
            <a href="RustBites_SmrtPtrs.html">SmartPtrs</a><br />
            <a href="RustBites_LifeCycle.html">LifeCycle</a><br />
            <a href="RustBites_Ownrs.html">Ownership</a><br />
            <a href="RustBites_Traits.html">Generics&Traits</a><br />
            <a href="RustBites_Functs.html">Functions</a><br />
            <a href="RustBites_Structs.html">Structs</a><br />
            <a href="RustBites_LifeTime.html">LifeTime</a><br />
            <a href="RustBites_Abstract.html">Abstractions</a><br />
            <a href="RustBites_ErrHnd.html">ErrHandling</a><br />
            <a href="RustBites_Collects.html">Collections</a><br />
            <a href="RustBites_Iterator.html">Iterators</a><br />
            <a href="RustBites_Threads.html">Threads</a><br />
            <a href="RustBites_Synchron.html">Synchronize</a><br />
            <a href="RustBites_Channels.html">Channels</a><br />
            <a href="RustBites_AsyncAwt.html">AsyncAwait</a><br />
            <a href="RustBites_Macros.html">Macros</a><br />
            <a href="RustBites_TipsAndTricks.html">Hacks and Helpers</a><br />
            <!-- <a href="RustBites_Generics.html">Generics</a><br /> -->
            <!-- <a href="RustBites_Intmut.html">InterMutat</a><br /> -->
            <a href="Javascript.;#"></a><br />
          </up-b>
            <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
          <a href="#contents">Contents</a>, <a href="#refs">References</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>N</td><td>Next Bite</td>
          </tr>
          <tr>
            <td>P</td><td>Prev Bite</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>
       </div>
   
      <h2>Rust Bite - Hacks and Helpers</h2>
      <t-b>
        This Bite will present a few tips to help you with tough problems.
      </t-b>
      <h3>1.0 - Struct with method hosting thread</h3>
      <t-b>
        Asynchronous processing often needs to share some mutable data with the thread host.
        For a method, that usually means sharing member data of a host object.  But that needs to
        be constructed carefully so that:
        <ol class="tight mtz" style="padding-top:0px;">
          <li>
            Both read and write access needs to be serialized to satisfy the Rust ownership
            policies.  We do that with a Mutex.
          </li>
          <li>
            The construction needs to guarantee that the thread&apos;s reference won&apos;t 
            become invalid if the thread outlives the host object.  We do that by using an
            Arc, a thread-safe reference-counted pointer.  The Arc stores its content
            on the heap, returning a reference to that.  Any other code that needs access
            to the Arc&apos;s data calls Arc::clone(&original).  Now, the content will live
            until every reference to it has been dropped. 
          </li>
          <li>
            The problem with the incorrect code is that it attempts to take an unshared
            reference to count.  The correct code simply changes that to take a shared
            reference by using Arc::clone().
          </li>
          <li>
            Note that, in the correct example code below, local_count is moved into the thread,
            but that moves a reference to the heap data, not the heap data, so that remains
            valid.
          </li>
        </ol>
      </t-b>
      <t-b>
        Compiler error messages give a lot of help: lifetime errors are usually problems 
        handling the Arc correctly. Move errors are often attempting to use a value instead
        of a reference in the thread. 
      </t-b>
      <div>
        <defn-outerBlock>
          <defn-block>
            <defn-head>methods_with_threads::main.rs</defn-head>
            <defn-code>
struct Test1 {
    count: Arc&lt;Mutex&lt;i32&gt;&gt;,
}
impl Test1 {
    fn new() -&gt; Test1 {
        Test1 {
            count: Arc::new(Mutex::new(0)),
        }
    }
    /*-----------------------------------------------------
      Uncommenting the code, below, causes compile error.
      The problem is that Rust can't guarantee that the
      reference to count will remain valid.  The thread 
      lifetime could exceed the lifetime of Test1 instance.
    */
    // fn start2(&amp;mut self) -&gt; JoinHandle&lt;()&gt; {
    //     std::thread::spawn(move || {
    //         for i in 0..5 {
    //             let mut data = self.count.lock().unwrap();
    //             *data += i;
    //             print!("\n  {:?}", data);
    //         }
    //     })
    // }
    /*-----------------------------------------------------
      The following compiles because local_count uses a
      shared pointer to the mutex protected value on the
      heap returned by Arc clone().

      The pointed to value isn't dropped until the last 
      reference is dropped.

      The incorrect code above didn't use a shared pointer,
      it attempted to use the member's inner data directly.
    */
    fn start(&amp;mut self) -&gt; JoinHandle&lt;()&gt; {
        let local_count = self.count.clone();  // get a shared ptr
        std::thread::spawn(move || {
            for i in 0..5 {
                let mut data = local_count.lock().unwrap();
                *data += i;
                print!("\n  {:?}", data);
            }  // mutex is unlocked here
        })
    }
    fn show_count(&amp;self) {
        print!("\n\n  t1 result = {:?}",self.count.lock().unwrap());
    }
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Using Code</defn-head>
            <defn-code>
fn main() {

  print!("\n  -- demo Test1 --");
  let mut t1 = Test1::new();
  let handle = t1.start();

  /* do some useful work here */
  
  let _ = handle.join();
  t1.show_count();
  println!();
}
          </defn-code>
            <defn-head class="defnBorderTop">Output</defn-head>
            <defn-code>
-- demo Test1 --
0
1
3
6
10

t1 result = 10  
          </defn-code>
          </defn-block>
        </defn-outerBlock>
      </div>
      <t-b>
        You will find variations on the construction above in 
        <a href="https://github.com/JimFawcett/Consuming_Rust_bite_by_byte">
          RustBiteByByte/hacks_and_helps/methods_with_threads
        </a>
      </t-b>
      <h3>2.0 - Timer</h3>
      
      <under-construction>
        Coming soon
        <ol class="tight">
          <li>
            structs with asynchrounous methods
          </li>
          <li>
            timer
          </li>
          <li>
            string conversions
          </li>
          <li>
            cast only for primitives, else From and Into
          </li>
          <li>
            Traits - see donovan pain-points.html, section 10
          </li>
          <li>
            HashMap entry api (donovan again)
          </li>
          <li>
            Reading values of Move types from Arrays and Vectors
            <ul class="tight">
              <li>Clone</li>
              <li>Option::take()</li>
            </ul>
          </li>
          <li>Living well with the ownership rules - pass-by-reference functions</li>
          <li> ... </li>
        </ol>
      </notice-block>
</body>
</html>
