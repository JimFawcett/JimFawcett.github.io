<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Hacks & Helps</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <script src="js/BiteScripts.js"></script>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <span class="top-center">Hacks and Helpers</span>
      <!-- <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a> -->
    </div>
  </div>
  <next-prev>
    <a id="prev" href="RustBites_Macros.html">prev</a> 
    <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
    <a id="next" href="RustBites_Facts.html">next</a>
  </next-prev>

      <toc-b id="toc">
        <div style="display:flex; flex-direction:row">
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.sects()" style="color:#fefefa;">Sects</a>&nbsp;
          <a href="../../RustBiteByByte.html" style="color:#fefefa;">Repo</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">Esc</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp;
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
          <up-b id="chaps">
            <a href="RustBites_Facts.html">Facts</a><br />
            <a href="RustBites_Intro.html">Introduction</a><br />
            <a href="RustBites_UDB.html">UndefBehavior</a><br />
            <a href="RustBites_Data.html">Data</a><br />
            <a href="RustBites_DataStr.html">DataStructs</a><br />
            <a href="RustBites_SmrtPtrs.html">SmartPtrs</a><br />
            <a href="RustBites_LifeCycle.html">LifeCycle</a><br />
            <a href="RustBites_Ownrs.html">Ownership</a><br />
            <a href="RustBites_Traits.html">Generics&Traits</a><br />
            <a href="RustBites_Functs.html">Functions</a><br />
            <a href="RustBites_Structs.html">Structs</a><br />
            <a href="RustBites_LifeTime.html">LifeTime</a><br />
            <a href="RustBites_Abstract.html">Abstractions</a><br />
            <a href="RustBites_ErrHnd.html">ErrHandling</a><br />
            <a href="RustBites_Collects.html">Collections</a><br />
            <a href="RustBites_Iterator.html">Iterators</a><br />
            <a href="RustBites_Threads.html">Threads</a><br />
            <a href="RustBites_Synchron.html">Synchronize</a><br />
            <a href="RustBites_Channels.html">Channels</a><br />
            <a href="RustBites_AsyncAwt.html">AsyncAwait</a><br />
            <a href="RustBites_Macros.html">Macros</a><br />
            <a href="RustBites_TipsAndTricks.html">Hacks and Helpers</a><br />
            <!-- <a href="RustBites_Generics.html">Generics</a><br /> -->
            <!-- <a href="RustBites_Intmut.html">InterMutat</a><br /> -->
            <a href="Javascript.;#"></a><br />
          </up-b>
            <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
          <a href="#contents">Contents</a>, <a href="#refs">References</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>N</td><td>Next Bite</td>
          </tr>
          <tr>
            <td>P</td><td>Prev Bite</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>
       </div>
   
      <h2>Rust Bite - Hacks and Helpers</h2>
      <t-b>
        This Bite presents techniques for solving code problems that I encountered or which
        appear often in QA forums.  Of course there are many of those.  I've selected ones that I 
        thought were interesting.
      </t-b>
      <t-b>
        I expect to add to this page continuously as I work on Rust-based projects.
      </t-b>
      <h3>1.0 - Struct with method hosting thread</h3>
      <t-b>
        Asynchronous processing often needs to share some mutable data with the thread host.
        For a method, that usually means sharing member data of a host object.  But that needs to
        be constructed carefully so that:
        <ol class="tight mtz" style="padding-top:0px;">
          <li>
            Both read and write access needs to be serialized to satisfy the Rust ownership
            policies.  We do that with a Mutex.
          </li>
          <li>
            The construction needs to guarantee that the thread&apos;s reference won&apos;t 
            become invalid if the thread outlives the host object.  We do that by using an
            Arc, a thread-safe reference-counted pointer.  The Arc stores its content
            on the heap, returning a reference to that.  Any other code that needs access
            to the Arc&apos;s data calls Arc::clone(&original).  Now, the content will live
            until every reference to it has been dropped. 
          </li>
        </ol>
      </t-b>
      <t-b>
        Compiler error messages give a lot of help: lifetime errors are usually problems 
        handling the Arc correctly. Move errors are often attempting to use a value instead
        of a reference in the thread. 
      </t-b>
      <t-b>
        You will find code for all examples below in 
        <a href="https://github.com/JimFawcett/Consuming_Rust_bite_by_byte">
          RustBiteByByte/hacks_and_helps/methods_with_threads
        </a>
      </t-b>
     <h3>1.1 - User-defined Type with thread start() method</h3>
      <t-b>
        This example is a simple demo that sums a loop index in its thread closure.  This
        same technique was used in the <a href="../../RustComm.html">RustComm</a> library
        that does something much more useful; it uses message passing to communicate between 
        two endpoints using std::net::TcpStream and std::net::TcpListener.
      </t-b>
      <div>
        <defn-outerBlock>
          <defn-block>
            <defn-head>Test1 - User-defined type with thread start()</defn-head>
            <defn-code>
use std::thread::{JoinHandle};
use std::sync::{Arc, Mutex};

struct Test1 {
    count: Arc&lt;Mutex&lt;i32&gt;&gt;,
}
impl Test1 {
    fn new() -&gt; Test1 {
        Test1 {
            count: Arc::new(Mutex::new(0)),
        }
    }
    fn start(&amp;mut self) -&gt; JoinHandle&lt;()&gt; {
        /* get a shared pointer */
        let local_count = self.count.clone();
        std::thread::spawn(move || {
            for i in 0..5 {
                let mut data = local_count.lock().unwrap();
                *data += i;
                print!("\n  {:?}", data);
            }
        })
    }
    fn show_count(&amp;self) {
        print!(
          "\n\n  t1 result = {:?}",
          self.count.lock().unwrap()
        );
    }
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Using Code:</defn-head>
            <defn-code>
  fn main() {

    print!("\n  -- demo Test1 --");
    let mut t1 = Test1::new();
    let handle = t1.start();

    /* do some useful work here */

    let _ = handle.join();
    t1.show_count();
    println!();
}
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
-- demo Test1 --
0
1
3
6
10

t1 result = 10
          </defn-code>
          </defn-block>
        </defn-outerBlock>
      </div>
      <t-b>
        <h3>1.2 - User-defined Type with thread starting in constructor new()</h3>
      </t-b>
      <t-b>
        The code below illustrates how to start a thread in the type&apos;s 
        constructor, new().  That would be appropriate if an instance&apos;s functionality
        depended on the thread running.
      </t-b>
      <div>
        <defn-OuterBlock>
          <defn-block>
            <defn-head>Test3 - thread starting in new()</defn-head>
            <defn-code>
struct Test3 {
    counter: Arc&lt;Mutex&lt;i32&gt;&gt;,
}
impl Test3 {
    /*-----------------------------------------------------
      This example uses the same technique as Test1, but
      moves the thread into new(), the Test3 constructor.  
      That would be a good idea for any type whose instances 
      need the running thread to operate as expected. 

      Note that new() now returns a tuple with the newly
      constructed Test2 instance and the thread handle.
      Look at main to see how that is used.
    */
    fn new() -&gt; (Test3, JoinHandle&lt;()&gt;) {

        /* create mutex guarded i32 in heap memory */
        let scount = Arc::new(Mutex::new(0));
        
        /* create shared reference to that value */
        let share = Arc::clone(&amp;scount);

        /* scount is moved into thread&apos;s closure */
        
        let handle = std::thread::spawn(move || {
            for i in 0..5 {
                let mut data = scount.lock().unwrap();
                *data += i;
                print!("\n  {:?}", data);
            }
        });
        /* share holds a valid ref to guarded i32 in heap */
        (
            Test3 { counter: share, },  
            handle
        )
    }
    fn show_count(&amp;self) {
        print!(
          "\n\n  t3 result = {:?}",
          self.counter.lock().unwrap()
        );
    }
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Using Code:</defn-head>
            <defn-code>
fn main() {

  print!("\n  -- demo Test3 --");
  let (t3, handle) = Test3::new();
  
  /* do some useful work here */

  let _ = handle.join();
  t3.show_count();
}
          </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
-- demo Test3 --
0
1
3
6
10

t3 result = 10
            </defn-code>
          </defn-block>
        </defn-OuterBlock>
      </div>
      <t-b>
        <h3>1.3 - User-defined Type with stop() method</h3>
      </t-b>
      <t-b>
        This example illustrates how to stop an asynchrounous method with a user command.
        The Test4 type provides an AtomicBool to record the user&apos;s intent to stop,
        and a method, stop(), to reset it.
      </t-b>
      <t-b>
        The method show_count() displays the number of thread iterations before being
        stopped by the user.
      </t-b>
      <div>
        <defn-OuterBlock>
          <defn-block>
            <defn-head>Test4 - graceful thread stop</defn-head>
            <defn-code>
struct Test4 {
    counter: Arc&lt;Mutex&lt;i32&gt;&gt;,
    do_run : Arc&lt;AtomicBool&gt;,
}
impl Test4 {
    /*-----------------------------------------------------
      This example demonstrates graceful thread shutdown
      using an AtomicBool, set by the user and tested in 
      the thread loop.
    */
    fn new() -&gt; (Test4, JoinHandle&lt;()&gt;) {
        let scount = Arc::new(Mutex::new(0));
        let share = Arc::clone(&amp;scount);
        let run = Arc::new(AtomicBool::new(true));
        let run_clone = Arc::clone(&amp;run);
        let handle = std::thread::spawn(move || {
            for i in 0..5000 {
                if !run.load(Ordering::Relaxed) {
                    break;
                }
                /* slow down loop for display */
                std::thread::sleep(
                  Duration::from_micros(200)
                );
                let mut data = scount.lock().unwrap();
                *data = i;
                print!("\n  {:?}", data);
            }
        });
        (
            Test4 { 
              counter: share, do_run: run_clone 
            },  
            handle
        )
    }
    fn stop(&amp;self) {
        self.do_run.store(false, Ordering::Relaxed);
    } 
    fn show_count(&amp;self) {
        print!(
          "\n\n  t4 result = {:?}",
          self.counter.lock().unwrap()
        );
    }
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Using Code:</defn-head>
            <defn-code>
  fn main() {

    print!(
      "\n  -- demo Test4 - graceful stop --"
    );
    let (t4, handle) = Test4::new();
    std::thread::sleep(
      Duration::from_millis(100)
    );
    t4.stop();
    let _ = handle.join();
    t4.show_count();
}
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
-- demo Test4 - graceful stop --
0
1
2
3
4
5
6
7

t4 result = 7
          </defn-code>
          </defn-block>
        </defn-OuterBlock>
      </div>
      <h3>2.0 - Timer</h3>

      <under-construction>
        Coming soon
        <ol class="tight">
          <li>
            timer
          </li>
          <li>
            string conversions
          </li>
          <li>
            cast only for primitives, else From and Into
          </li>
          <li>
            Traits - see donovan pain-points.html, section 10
          </li>
          <li>
            HashMap entry api (donovan again)
          </li>
          <li>
            Reading values of Move types from Arrays and Vectors
            <ul class="tight">
              <li>Clone</li>
              <li>Option::take()</li>
            </ul>
          </li>
          <li>Living well with the ownership rules - pass-by-reference functions</li>
          <li> ... </li>
        </ol>
      </notice-block>
</body>
</html>
