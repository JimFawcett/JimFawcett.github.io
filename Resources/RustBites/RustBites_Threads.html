<!DOCTYPE html>
<html id="top">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Threads</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <link rel="stylesheet" href="css/BiteTables.css" />
    <script src="js/ScriptsWebComponents.js"></script>
    <link rel="stylesheet" href="css/StylesWebComponents.css" />
    <script src="js/BiteScripts.js"></script>
    <script src="js/ScriptsKeyboard.js"></script>
    <style>
      #github c-s { font-size:1.1rem; }
    </style>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <span class="top-center">Threads</span>
    </div>
    <next-prev>
      <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
      <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
      <a id="Prev" href="RustBites_Macros.html">prev</a> 
      <a id="Next" href="RustBites_Synchron.html">next</a>
    </next-prev>

    <toc-b id="toc">
      <div id="bottom-menu" style="display:flex; flex-direction:row">
      </div>
        <up-b id="chaps">
        </up-b>
          <rt-b id="sects">
            <a href="#top">Top</a>, <a href="#intermut">InterMut</a>, <a href="#threads">Threads</a>, 
            <a href="#sharing">Sharing</a>, <a href="#thrdrslt">ThrdRslt</a>, <a href="#bq">BlkgQ</a>, 
            <a href="#epilog">Epilog</a>
      </rt-b>
    </toc-b>
    <div id="hlp" style="display:none;">
      </div>

    <h2>Rust Bite - Threads</h2>
    <hr class="spread" />
    <t-b>
      Rust guarantees data safety - it is impossible to read from or write to memory that the current program
      scope does not own.  
      To ensure data safety Rust maintains an invariant:
      <div class="indent pad10">
        &quot;no simultaneous shared mutability through references&quot;
      </div>
      This is nearly equivalent to the conditions: any given program scope code may hold any number of 
      immutable references to a data item but only one immutable reference with no immutable references.
    </t-b>
    <t-b>
      These are sufficient conditions for data safety, but not necessary
      (see <a href="RustBites_Safety.html">RustBites Safety</a>).  That means that safe code may fail the static tests
      and so fail to build.
    </t-b>
    <t-b>
      The Rust compiler checks the invariant at compile time through static analysis.  But it can only do partial
      analysis of the &quot;simultaneous&quot; part using 
      <a href="RustBites_Safety.html#nlscope">non-lexical analysis</a>.  For applications that need to share data
      between threads, Rust code defers checking of thread accesses to run-time.  It does that with types that
      internally use 
      <c-s><a href="https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html">UnsafeCell&lt;T&gt;</a></c-s>.
      This type wraps an unsafe block holding an instance of T.  We examine partial code for this type and two types 
      that use it and show how that enables building safe code that would otherwise fail to build.
      <a id="intermut"></a>
    </t-b>
    <div style="height:0.25rem;"></div>
    <h3>1.0 - Interior Mutability</h3>
    <t-b>
      The types that wrap <c-s>UnsafeCell&lt;T&gt;</c-s>, e.g., 
      <c-s>Cell&lt;T&gt;</c-s> and <c-s>RefCell&lt;T&gt;</c-s> provide safe interfaces that support deferring
      borrow checking to run time.
    </t-b>
    <t-b class="indent">
      <div style="float:left; padding-right:1rem; margin-left:-0.75rem;">
        <photosizer-block src="pictures/InteriorMutTypes.jpg" width="400" class="photoSizerBlock left clear">
          <span style="font-family:'Comic Sans MS';">Fig 1. Supporting Interior Mutability</span>
        </photosizer-block>
      </div>
    </t-b>
    <t-b>
      Calling methods on <c-s>UnsafeCell&lt;T&gt;</c-s> is unsafe, but the types <c-s>Cell&lt;T&gt;</c-s> and
      <c-s>RefCell&lt;T&gt;</c-s> provide safe interfaces by calling into <c-s>UnsafeCell&lt;T&gt;</c-s>
      in ways that are verifiably safe.
    </t-b>
    <t-b>
      The purpose of <c-s>UnsafeCell&lt;T&gt;</c-s> is to support mutation from methods with immutable interfaces.
      That is, at compile-time mutability is hidden from the static checker so code that is sound but does not
      statisfy the static &quot;no shared mutability&quot; invariant will build.  That means that borrow checking now must
      be enforced at run-time, and that is the purpose of <c-s>RefCell&lt;T&gt;</c-s>.
    </t-b>
    <t-b>
      The <c-s>Cell&lt;T&gt;</c-s> type has a pass and return by value interface so no run-time checks are needed.
    </t-b>
    <t-b>
      Before diving into code for <c-s>UnsafeCell&lt;T&gt;</c-s> and its <c-s>Cell&lt;T&gt;</c-s> and 
      <c-s>RefCell&lt;T&gt;</c-s> users, let&apos;s look at a simple demonstration of the later.  In the
      left panel we present code that doesn&apos;t use interior mutability.  It fails to build if the last
      print! is uncommented.  That violates the rule about no use of immutable references when a mutable
      reference is in scope.
    </t-b>
    <t-b>
      In the right panel we use <c-s>RefCell</c-s> to support interior mutability.  That all works.  The code
      builds and works as expected.  But if we uncomment the drop(rx) statement we get a run-time panic.  That
      shows that the run-time checking is working.  This behavior is just enough to allow threads to share
      and mutate a common resource.  That works because, due to locking, the shares are isolated in the scope
      of a lock.
    </t-b>
    <t-b>
      <div style="height:1.0rem;"></div>
      <div class="indent">
        <defn-OuterBlock>
          <defn-block>
            <defn-head>No Interior Mutability</defn-head>
            <defn-code>
/*-----------------------------------------------------
  Illustrates that perfectly safe code can fail to 
  compile.  The safety invariant is very strong.
-----------------------------------------------------*/
fn may_fail_to_build() {
    print!("\n  -- no interior mutability --");
    let mut x = 42i32;
    print!("\n    x = {}", x);
    print!("\n    - immutable reference -");
    let rx = &x;
    print!("\n    *rx = {}", rx);
    print!("\n    - mutable reference -");
    let mrx = &mut x;
    *mrx += 1;
    // drop(mrx); won't save compilation - not used by borrow chkr
    print!("\n    *mrx = {}", mrx);
    // error: attempt to use immutable ref with mutable ref in scope
    //        causes compile failure
    // print!("\n    *rx = {}", rx);
    println!();
    // final observation: error is not due to declaration
    // it's due to use.
}

fn main() {
    may_fail_to_build();
}
            </defn-code>
            <defn-head class="defnBorderTop">Output</defn-head>
            <defn-code>
  -- no interior mutability --
    x = 42
    - immutable reference -
    *rx = 42
    - mutable reference -
    *mrx = 43

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Interior Mutability</defn-head>
            <defn-code>
/*-----------------------------------------------------
  Illustrates that code violating safety invariant
  can compile with the help of interior mutability.
  - you still can't break the iinvariant rule due to
    run-time checks.  However, using locks avoids 
    run-time failure (not illustrated here, but later).
-----------------------------------------------------*/
fn may_fail_at_runtime() {
    print!("\n  -- interior mutability --");
    let x = RefCell::new(42i32);
    print!("\n    x = {}", x.into_inner());
    // RefCell is not copy so now invalid
    print!("\n    - immutable reference -");
    let x = RefCell::new(42i32);
    let rx = x.borrow();
    print!("\n    *rx = {}", rx);
    // commenting out drop causes run-time panic
    drop(rx);
    print!("\n    - mutable reference -");
    *x.borrow_mut() += 1;  // mutable ref ends here
    print!("\n    *mrx = {}", x.borrow());
    
}
fn main() {
    may_fail_at_runtime();
}

              </defn-code>
            <defn-head class="defnBorderTop">Output</defn-head>
            <defn-code>
  -- interior mutability --
    x = 42
    - immutable reference -
    *rx = 42
    - mutable reference -
    *mrx = 43
            
            </defn-code>
          </defn-block>
        </defn-OuterBlock>
      </div>
    </t-b>
    <t-b class="indent">
      <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=a168386d3691f5c2ebf8286591a7602e">
        code in playground
      </a>
    </t-b>
    <t-b>
      So, you say to yourself "we&apos;ve moved failure from compile-time to run-time.  That&apos;s good??". The answer
      is yes, that&apos;s good, because now, as shown in Section 2., the use of locks avoids run-time failure.  Without interior
      mutability we could&apos;t get there.
    </t-b>
    <t-b>
      Now, let&apos;s see how interior mutability is molded out of the <c-s>std::cell</c-s> components.  
      All the important stuff happens in the
      <c-s>RefCell&lt;T&gt;</c-s> functions:
      <div class="indent pad10">
        - <c-s>fn borrow_mut(&self) -> RefMut<'_, T></c-s><br />
        - <c-s>fn deref_mut(&mut self) -> &mut T</c-s>.
      </div>
      The signature for <c-s>borrow_mut</c-s> is immutable, but we get a wrapper <c-s>RefMut</c-s> which can be
      implicitly dereferenced to yield a mutable pointer!  This lie satisfies the borrow checker and lets our
      code build.  But now, <c-s>RefCell</c-s> is obligated to undo the lie by checking the borrowing invariants
      at run-time.  If you look closely you will see some of that in the details section below this block.
    </t-b>
    <div style="height:0.15rem;"></div>
    <t-b>
      <div class="indent">
        <defn-block>
          <defn-head><c-s>RefCell&lt;T&gt;</c-s> - Excerpts from std::cell code</defn-head>
          <defn-code>
pub struct RefCell&lt;T: ?Sized&gt; {
    borrow: Cell&lt;BorrowFlag&gt;,
    value: UnsafeCell&lt;T&gt;,
}
type BorrowFlag = isize;
const UNUSED: BorrowFlag = 0;

impl&lt;T&gt; RefCell&lt;T&gt; {

    // elided code

    /// Mutably borrows the wrapped value.
    ///
    /// Borrow lasts until returned `RefMut` or all `RefMut`s
    /// derived from it exit scope. Value cannot be borrowed
    /// while this borrow is active.
    ///
    /// # Panics
    ///
    /// Panics if value is currently borrowed. For non-panicking    
    /// variant, use [`try_borrow_mut`](#method.try_borrow_mut).
    ///
    /*--------------------------------------------------------
      Here is the core of interior mutability - Part 1
    --------------------------------------------------------*/
    pub fn borrow_mut(&self) -&gt; RefMut&lt;'_, T&gt; {
        self.try_borrow_mut().expect("already borrowed")
    }

    /// Mutably borrows wrapped value, returning error if value 
    /// is currently borrowed.
    ///
    /// Borrow lasts until returned `RefMut` or all `RefMut`s
    /// derived from it exit scope. Value cannot be borrowed
    /// while this borrow is active.
    ///
    pub fn try_borrow_mut(&self) 
            -&gt; Result&lt;RefMut&lt;'_, T&gt;, BorrowMutError&gt; {
        match BorrowRefMut::new(&self.borrow) {
            // SAFETY: `BorrowRef` guarantees unique access.
            Some(b) =&gt; Ok(
                  RefMut { 
                      value: unsafe { 
                          &mut *self.value.get() }, 
                          borrow: b 
                      }
            ),
            None =&gt; Err(BorrowMutError { _private: () }),
        }
    }

    // elided code

}

/*--------------------------------------------------------
  Here is the core of interior mutability - Part 2
--------------------------------------------------------*/
impl&lt;T: ?Sized&gt; DerefMut for RefMut&lt;'_, T&gt; {
    fn deref_mut(&mut self) -&gt; &mut T {
        self.value
    }
}

          </defn-code>
        </defn-block>
      </div>
    </t-b>
    <t-b>
      The code block above shows how &quot;interior mutability&quot; is implemented.  
      Excerpts of more of the std::cell library code are shown in the details below.
    </t-b>
    <t-b>
      <div class="indent">
        <details>
          <summary class="darkItem">Larger Code Excerpts for std::cell types</summary>
    <t-b>
      If you are interested you can see all the details in the <c-s>std::cell::RefCell</c-s> library, linked at the
      top of the right panel.
    </t-b>
    <div class="clear" style="height:0.5rem;"></div>
    <div class="indents">
      <defn-OuterBlock>
        <defn-block>
          <defn-head>
            <a href="https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html">UnsafeCell&lt;T&gt;</a> - partial definition
          </defn-head>
          <defn-code>
pub struct UnsafeCell&lt;T: ?Sized&gt; {
    value: T,
}

impl&lt;T: ?Sized&gt; !Sync for UnsafeCell&lt;T&gt; {}

impl&lt;T&gt; UnsafeCell&lt;T&gt; {
    pub const fn new(value: T) -&gt; UnsafeCell&lt;T&gt; {
        UnsafeCell { value }
    }

    pub const fn into_inner(self) -&gt; T {
        self.value
    }
}

impl&lt;T: ?Sized&gt; UnsafeCell&lt;T&gt; {
    /// immutable interface yields mutable pointer !!
    pub const fn get(&self) -&gt; *mut T {
        // We can just cast pointer from `UnsafeCell&lt;T&gt;` to `T` 
        self as *const UnsafeCell&lt;T&gt; as *const T as *mut T
    }

    /// This call borrows the `UnsafeCell` mutably 
    /// (at compile-time) which guarantees that we 
    /// possess the only reference.
     pub fn get_mut(&mut self) -&gt; &mut T {
        &mut self.value
    }

    pub const fn raw_get(this: *const Self) -&gt; *mut T {
        // We can just cast pointer from `UnsafeCell&lt;T&gt;` to `T` 
        this as *const T as *mut T
    }
}
          </defn-code>
          <defn-head class="defnBorderTop">
            <a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html">Cell&lt;T&gt;</a> - Partial Definition
          </defn-head>
          <defn-code>
pub struct Cell&lt;T: ?Sized&gt; {
    value: UnsafeCell&lt;T&gt;,
}

unsafe impl&lt;T: ?Sized&gt; Send for Cell&lt;T&gt; where T: Send {}
impl&lt;T: ?Sized&gt; !Sync for Cell&lt;T&gt; {}

impl&lt;T: Copy&gt; Clone for Cell&lt;T&gt; {
    fn clone(&self) -&gt; Cell&lt;T&gt; {
        Cell::new(self.get())
    }
}

impl&lt;T: Default&gt; Default for Cell&lt;T&gt; {
    /// Creates a `Cell&lt;T&gt;`, with the `Default` value for T.
    fn default() -&gt; Cell&lt;T&gt; {
        Cell::new(Default::default())
    }
}

impl&lt;T&gt; From&lt;T&gt; for Cell&lt;T&gt; {
    fn from(t: T) -&gt; Cell&lt;T&gt; {
        Cell::new(t)
    }
}

impl&lt;T&gt; Cell&lt;T&gt; {
    /// Creates a new `Cell` containing the given value.
    pub const fn new(value: T) -&gt; Cell&lt;T&gt; {
        Cell { value: UnsafeCell::new(value) }
    }

    /// Sets the contained value.
    pub fn set(&self, val: T) {
        let old = self.replace(val);
        drop(old);
    }

    /// Swaps the values of two Cells.
    /// Difference with `std::mem::swap` is that this 
    /// function doesn't require `&mut` reference.
    pub fn swap(&self, other: &Self) {
        if ptr::eq(self, other) {
            return;
        }
        // SAFETY: This can be risky if called from 
        // separate threads, but `Cell` is `!Sync` 
        // so this won't happen. This also won't 
        // invalidate any pointers since `Cell` makes
        // sure nothing else will be pointing into
        // either of these `Cell`s.
        unsafe {
            ptr::swap(self.value.get(), other.value.get());
        }
    }

    /// Replaces the contained value, and returns it.
    pub fn replace(&self, val: T) -&gt; T {
        // SAFETY: This can cause data races if called 
        // from a separate thread,
        // but `Cell` is `!Sync` so this won't happen.
        mem::replace(unsafe { &mut *self.value.get() }, val)
    }

    /// Unwraps the value.
    pub const fn into_inner(self) -&gt; T {
        self.value.into_inner()
    }
}

impl&lt;T: Copy&gt; Cell&lt;T&gt; {
    /// Returns a copy of the contained value.
    pub fn get(&self) -&gt; T {
        // SAFETY: This can cause data races if called
        // from a separate thread,
        // but `Cell` is `!Sync` so this won't happen.
        unsafe { *self.value.get() }
    }
}

impl&lt;T: ?Sized&gt; Cell&lt;T&gt; {
    /// Returns raw pointer to underlying data in cell.
    pub const fn as_ptr(&self) -&gt; *mut T {
        self.value.get()
    }

    /// Returns mutable reference to underlying data.
    ///
    /// Call borrows `Cell` mutably (at compile-time)
    /// which guarantees that we possess the only
    /// reference.
    pub fn get_mut(&mut self) -&gt; &mut T {
        self.value.get_mut()
    }

    /// Returns a `&Cell&lt;T&gt;` from a `&mut T`
    pub fn from_mut(t: &mut T) -&gt; &Cell&lt;T&gt; {
        // SAFETY: `&mut` ensures unique access.
        unsafe { &*(t as *mut T as *const Cell&lt;T&gt;) }
    }
}

impl&lt;T: Default&gt; Cell&lt;T&gt; {
    /// Takes value of cell, leaving `Default::default()` 
    /// in its place.
    pub fn take(&self) -&gt; T {
        self.replace(Default::default())
    }
}

impl&lt;T&gt; Cell&lt;[T]&gt; {
    /// Returns a `&[Cell&lt;T&gt;]` from a `&Cell&lt;[T]&gt;`
    pub fn as_slice_of_cells(&self) -&gt; &[Cell&lt;T&gt;] {
        // SAFETY: `Cell&lt;T&gt;` has same memory layout as `T`.
        unsafe { 
            &*(self as *const Cell&lt;[T]&gt; as *const [Cell&lt;T&gt;]) 
        }
    }
}
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>
            <a href="https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html">RefCell&lt;T&gt;</a> - partial definition
          </defn-head>
          <defn-code>
pub struct RefCell&lt;T: ?Sized&gt; {
    borrow: Cell&lt;BorrowFlag&gt;,
    value: UnsafeCell&lt;T&gt;,
}

/// An error returned by [`RefCell::try_borrow`].
pub struct BorrowError {
    _private: (),
}

/// An error returned by [`RefCell::try_borrow_mut`].
pub struct BorrowMutError {
    _private: (),
}

type BorrowFlag = isize;
const UNUSED: BorrowFlag = 0;

impl&lt;T&gt; RefCell&lt;T&gt; {
    pub const fn new(value: T) -&gt; RefCell&lt;T&gt; {
        RefCell { 
            value: UnsafeCell::new(value), 
            borrow: Cell::new(UNUSED) 
        }
    }

    pub const fn into_inner(self) -&gt; T {
        // Since function takes `self` (the `RefCell`) by value,
        // compiler statically verifies that it is not currently
        // borrowed.
        self.value.into_inner()
    }

    pub fn replace(&self, t: T) -&gt; T {
        mem::replace(&mut *self.borrow_mut(), t)
    }

    pub fn swap(&self, other: &Self) {
        mem::swap(
            &mut *self.borrow_mut(), 
            &mut *other.borrow_mut()
        )
    }
}

impl&lt;T: ?Sized&gt; RefCell&lt;T&gt; {
    /// Immutably borrows the wrapped value.
    ///
    /// Borrow lasts until returned `Ref` exits scope. 
    /// Multiple immutable borrows can be taken out at 
    /// the same time.
    ///
    /// # Panics
    ///
    /// Panics if value is currently mutably borrowed. 
    /// For a non-panicking variant, use
    /// [`try_borrow`](#method.try_borrow).
    ///
    pub fn borrow(&self) -&gt; Ref&lt;'_, T&gt; {
        self.try_borrow()
            .expect("already mutably borrowed")
    }

    /// Immutably borrows wrapped value, returning error 
    /// if value is currently mutably borrowed.
    ///
    /// Borrow lasts until returned `Ref` exits scope. 
    /// Multiple immutable borrows can be taken out at 
    /// the same time.
    ///
    pub fn try_borrow(&self) 
            -&gt; Result&lt;Ref&lt;'_, T&gt;, BorrowError&gt; {
        match BorrowRef::new(&self.borrow) {
            // SAFETY: 
            //   `BorrowRef` ensures there is only immutable
            //   access to value while borrowed.
            Some(b) =&gt; Ok(
                    Ref { 
                      value: unsafe { &*self.value.get() }, 
                      borrow: b 
                    }
            ),
            None =&gt; Err(BorrowError { _private: () }),
        }
    }

    /// Mutably borrows the wrapped value.
    ///
    /// Borrow lasts until returned `RefMut` or all `RefMut`s
    /// derived from it exit scope. Value cannot be borrowed
    /// while this borrow is active.
    ///
    /// # Panics
    ///
    /// Panics if value is currently borrowed. For non-panicking
    /// variant, use [`try_borrow_mut`](#method.try_borrow_mut).
    ///
    /*--------------------------------------------------------
      Here is the core of interior mutability - Part 1
    --------------------------------------------------------*/
    pub fn borrow_mut(&self) -&gt; RefMut&lt;'_, T&gt; {
        self.try_borrow_mut().expect("already borrowed")
    }

    /// Mutably borrows wrapped value, returning error if value 
    /// is currently borrowed.
    ///
    /// Borrow lasts until returned `RefMut` or all `RefMut`s
    /// derived from it exit scope. Value cannot be borrowed
    /// while this borrow is active.
    ///
    pub fn try_borrow_mut(&self) 
            -&gt; Result&lt;RefMut&lt;'_, T&gt;, BorrowMutError&gt; {
        match BorrowRefMut::new(&self.borrow) {
            // SAFETY: `BorrowRef` guarantees unique access.
            Some(b) =&gt; Ok(
                  RefMut { 
                      value: unsafe { 
                          &mut *self.value.get() }, 
                          borrow: b 
                      }
            ),
            None =&gt; Err(BorrowMutError { _private: () }),
        }
    }

    /// Returns a raw pointer to the underlying data in this cell.
    pub fn as_ptr(&self) -&gt; *mut T {
        self.value.get()
    }

    /// Returns a mutable reference to the underlying data.
    ///
    /// Call borrows `RefCell` mutably (at compile-time) so no
    /// need for dynamic checks.
    ///
    pub fn get_mut(&mut self) -&gt; &mut T {
        self.value.get_mut()
    }

}

impl&lt;T: Default&gt; RefCell&lt;T&gt; {
    /// Takes wrapped value, leaving `Default::default()` 
    /// in its place.
    pub fn take(&self) -&gt; T {
        self.replace(Default::default())
    }
}

unsafe impl&lt;T: ?Sized&gt; Send for RefCell&lt;T&gt; where T: Send {}
impl&lt;T: ?Sized&gt; !Sync for RefCell&lt;T&gt; {}

impl&lt;T: Clone&gt; Clone for RefCell&lt;T&gt; {
    /// Panics if the value is currently mutably borrowed.
    fn clone(&self) -&gt; RefCell&lt;T&gt; {
        RefCell::new(self.borrow().clone())
    }
}

impl&lt;T: Default&gt; Default for RefCell&lt;T&gt; {
    /// Creates `RefCell&lt;T&gt;`, with `Default` value for T.
    fn default() -&gt; RefCell&lt;T&gt; {
        RefCell::new(Default::default())
    }
}

impl&lt;T&gt; From&lt;T&gt; for RefCell&lt;T&gt; {
    fn from(t: T) -&gt; RefCell&lt;T&gt; {
        RefCell::new(t)
    }
}

struct BorrowRef&lt;'b&gt; {
    borrow: &'b Cell&lt;BorrowFlag&gt;,
}

/// Wraps borrowed reference to value in a `RefCell` box.
/// Wrapper type for immutably borrowed value from 
/// `RefCell&lt;T&gt;`.
pub struct Ref&lt;'b, T: ?Sized + 'b&gt; {
    value: &'b T,
    borrow: BorrowRef&lt;'b&gt;,
}

impl&lt;T: ?Sized&gt; Deref for Ref&lt;'_, T&gt; {
    type Target = T;

    fn deref(&self) -&gt; &T {
        self.value
    }
}

struct BorrowRefMut&lt;'b&gt; {
    borrow: &'b Cell&lt;BorrowFlag&gt;,
}

impl Drop for BorrowRefMut&lt;'_&gt; {
    fn drop(&mut self) {
        let borrow = self.borrow.get();
        debug_assert!(is_writing(borrow));
        self.borrow.set(borrow + 1);
    }
}

impl&lt;'b&gt; BorrowRefMut&lt;'b&gt; {
    fn new(borrow: &'b Cell&lt;BorrowFlag&gt;) 
            -&gt; Option&lt;BorrowRefMut&lt;'b&gt;&gt; {
        // NOTE: 
        // Unlike BorrowRefMut::clone, new is called to 
        // create initial mutable reference, and so there 
        // must currently be no existing references. Thus, 
        // while clone increments mutable refcount,
        // we only allow going from UNUSED to UNUSED - 1.
        match borrow.get() {
            UNUSED =&gt; {
                borrow.set(UNUSED - 1);
                Some(BorrowRefMut { borrow })
            }
            _ =&gt; None,
        }
    }
}

/// Wrapper type for mutably borrowed value from `RefCell&lt;T&gt;`.
pub struct RefMut&lt;'b, T: ?Sized + 'b&gt; {
    value: &'b mut T,
    borrow: BorrowRefMut&lt;'b&gt;,
}

impl&lt;T: ?Sized&gt; Deref for RefMut&lt;'_, T&gt; {
    type Target = T;

    fn deref(&self) -&gt; &T {
        self.value
    }
}

/*--------------------------------------------------------
  Here is the core of interior mutability - Part 2
--------------------------------------------------------*/
impl&lt;T: ?Sized&gt; DerefMut for RefMut&lt;'_, T&gt; {
    fn deref_mut(&mut self) -&gt; &mut T {
        self.value
    }
}

          </defn-code>
        </defn-block>
      </defn-OuterBlock>
    </div>
          <div style="height:0.75rem;"></div>
        </details>
      </div>
    </t-b>
    <!--<div style="height:0.75rem;"></div>-->
    <t-b>
      <c-s>RefCell&lt;T&gt;</c-s> tracks references at run-time, using its borrow member to remember
      the current state of references and if an attempt to create a mutable reference is made when
      there are any other active references the cell will panic.
    </t-b>
    <t-b class="indent">
      <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=9d173d6a85d88532be2eab9ea24d67f9">
        demonstration code in playground
      </a>
    </t-b>
    <t-b>
      Adding synchronization with <c-s>Mutex&lt;T&gt;</c-s> or <c-s>RWLock&lt;T&gt;</c-s> will then ensure
      that locked data can only be accessed by a single thread at any given time.  Both of these locking constructs
      use <c-s>RefCell&lt;T&gt;</c-s>s to allow multiple threads to mutably share a guarded data item, but not
      simultaneously, so there won&apos;t be any data races or memory faults.
    </t-b>
    <t-b>
      A Rust <c-s>Mutex&lt;T&gt;</c-s> guards data, t &epsilon; T, not regions of code.      
      The only way to access protected shared data is through its <c-s>Mutex&lt;T&gt;</c-s> or other lock.  
      <a id="threads"></a>
    </t-b>
    <div style="height:0.1rem;"></div>
    <h3>2.0 - Basic Threads:</h3>
    <t-b>
      Rust threads are represented by the <c-s>thread</c-s> type and created
      with an associated function:
      <div class="indent pad5">
        <c-s>spawn&lt;F, T&gt;(f: F) -> JoinHandle&lt;T&gt;<br />
        &nbsp;&nbsp;where F: FnOnce() -> T, F: send + `static, T: Send + `static
      </div>
      <c-s>spawn</c-s> accepts a closure that implements thread processing.  The std::thread library&apos;s implementation
      of <c-s>spawn</c-s> uses the platform api to start a native thread running the supplied closure.
      When the thread exits this closure it is terminated.
    </t-b>
    <t-b>
      Note that f: F is passed by value, e.g., moved into the closure.  If the closure uses any captured local
      data then you must explicitly move the closure into <c-s>spawn</c-s>.  That&apos;s illustrated in the next
      demonstration.
    </t-b>
    <t-b>
      The code, below, illustrates creation of a child thread.  The main thread and child share std::output
      and an AtomicUsize global variable.  Global variables are usually avoided in Rust and other languages as well
      due to possibly widely distributed side affects.  It&apos;s used here for local thread-safe sharing between
      main and child threads just to illustrate how that works.
    </t-b>
    <div class="indent">
      <defn-OuterBlock>
        <defn-block>
          <defn-head>Basic Thread Demo</defn-head>
          <defn-code>
// Basic Threads
// sharing std::output and AtomicUsize - both thread safe

use std::thread;
use std::time::Duration;
use std::sync::atomic::{AtomicUsize, Ordering};

static COUNT: AtomicUsize = AtomicUsize::new(0usize);

fn test() {
    // child thread processing
    let dur = Duration::from_millis(2);
    let handle = thread::spawn(
        move || {
            for _i in 0..10 {
                print!("\n  child thread printing");
                let _ = COUNT.fetch_add(1, Ordering::SeqCst);
                thread::sleep(dur);
            }
        }
    );
    // main thread processing
    let dur = Duration::from_millis(3);
    for _i in 0..10 {
        print!("\n   main thread printing");
        let _ = COUNT.fetch_add(1, Ordering::SeqCst);
        thread::sleep(dur);
    }
    // wait for thread to complete
    let _ = handle.join();
    print!("\n\n  number of prints = {:?}", COUNT);
}

fn main() {
    print!("\n  -- Basic Threads --\n");
    test();
    print!("\n\n  That's all Folks!\n\n");
}
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>Output</defn-head>
          <defn-code>
  -- Basic Threads --

   main thread printing    
  child thread printing
  child thread printing
  child thread printing
   main thread printing
  child thread printing
   main thread printing
  child thread printing
   main thread printing
  child thread printing
  child thread printing
   main thread printing
  child thread printing
   main thread printing
  child thread printing
  child thread printing
   main thread printing
   main thread printing
   main thread printing
   main thread printing

  number of prints = 20

  That's all Folks!
         </defn-code>
        </defn-block>
      </defn-OuterBlock>
    </div>
    <t-b class="indent">
      <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c792e1f6af676048cbe51fce925085d5">
        code in playground
      </a>
    </t-b>
    <t-b>
      Note that the global COUNT atomic is not declared as mutable, but in fact is mutated by both main and child.
      That works because Atomics, Arcs, and Mutexes implement interior mutability, as discussed above and in the 
      <a href="RustBites_Safety.html">Safety Bite</a>.  Interior mutability defers borrowing checks from compile-time
      to run-time.  See 
      <a href="https://ricardomartins.cc/2016/06/25/interior-mutability-thread-safety">
        Interior mutability in Rust, by Ricardo Martins
      </a>.
      <a id="sharing"></a>
    </t-b>
    <div style="height:0.25rem;"></div>
    <h3>3.0 - Sharing non-thread-safe Resources:</h3>
    <t-b>
      The previous example was relatively simple because threads only shared inherently thread-safe objects, e.g., 
      an Atomic and std::output.  The example below illustrates how non-thread-safe objects need to be handled.
    </t-b>
    <t-b>
      One way to share objects that are not thread safe is to use locks.  In the example below a
      <c-s>Mutex</c-s> wraps a <c-s>String</c-s> that three threads will share.  Rust <c-s>Mutex</c-s>es are unique
      in that they protect data not areas of code.  That eliminates a blunder, observed in other languages, 
      of not sharing a common lock, so no protection is afforded to the shared item.
    </t-b>
    <t-b>
      <c-s>Mutex</c-s>es are usually shared by using a thread safe reference-counted pointer, <c-s>Arc&lt;T&gt;</c-s>,
      using the syntax:
      <div class="indent pad5">
        <c-s>let shared = Arc::new(Mutex::new(s));</c-s>
      </div>
      where s is the entity to be shared.  Sharing is then effected with:
      <div class="indent pad5">
        <c-s>let shared1 = Arc::clone(&shared)</c-s><br />
        <c-s>let shared2 = Arc::clone(&shared)</c-s>
      </div>
      <c-s>shared1</c-s> and <c-s>shared2</c-s> are pointers to the wrapped <c-s>Mutex</c-s> which, in turn, wraps
      the shared entity, <c-s>s</c-s>, affording sychronized access.  
    </t-b>
    <t-b>
      Note that shared1 and shared2 will both mutate
      a shared String resource.  But they are not declared mutable because that would violate the static safety
      invariant.  Instead they both use interior mutability offered by <c-s>Mutex&lt;T&gt;</c-s> because it holds
      a <c-s>RefCell&lt;T&gt;</c-s>.
    </t-b>
    <div style="height:0.25rem;"></div>
    <div class="indent">
      <defn-OuterBlock>
        <defn-block>
          <defn-head>Thread Sharing</defn-head>
          <defn-code>
// threads sharing string

use std::thread;
use std::sync::{Arc, Mutex};
use std::time::Duration;

fn test() {
    let a = "        main thread pushes \'0\'";
    let b = " first child thread pushes \'1\'";
    let c = "second child thread pushes \'2\'";
    print!("\n  {}", a);
    print!("\n  {}", b);
    print!("\n  {}\n", c);
    
    let s = String::new();
    let shared = Arc::new(Mutex::new(s));
    // main thread gets first edit
    let shared0 = Arc::clone(&shared);
    if let Ok(mut temp) = shared0.lock() {
        temp.push('0');
    }
    // create child threads
    let shared1 = Arc::clone(&shared);
    let dur = Duration::from_millis(2);  // faster
    let handle1 = thread::spawn(
        move || {
            for _i in 0..15 {
                // child edits shared string
                if let Ok(mut temp) = shared1.lock() {
                    temp.push('1');
                }
                thread::sleep(dur);
            }
        }
    );
    // create second child thread
    let shared2 = Arc::clone(&shared);
    let dur = Duration::from_millis(3);  // slower
    let handle2 = thread::spawn(
        move || {
            for _i in 0..15 {
                // child edits string
                if let Ok(mut temp) = shared2.lock() {
                    temp.push('2');
                }
                thread::sleep(dur);
            }
        }
    );
    let _ = handle1.join();
    let _ = handle2.join();
    let mut s = String::new();
    if let Ok(mut temp) = shared0.lock() {
        temp.push('0');
        s = temp.to_string();
    }
    print!("\n  {}", s);
}

fn main() {
    print!("\n  -- Threads sharing String --\n");
    test();
    print!("\n\n  That's all Folks!\n\n");
}
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>Output</defn-head>
          <defn-code>
  -- Threads sharing String --

          main thread pushes '0'
   first child thread pushes '1'
  second child thread pushes '2'

  01121121211212112112121212222220    

  That's all Folks!
          </defn-code>
        </defn-block>
      </defn-OuterBlock>
    </div>
    <t-b class="indent">
      <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=d6d4d57036dd488009c3854ae9147491">
        code in playground
      </a>
    </t-b>
    <t-b>
      Rust has two other synchronizing constructs that are often used in threaded code: <c-s>RWLock</c-s>, a
      reader-writer lock, and <c-s>Condvar</c-s> a condition variable.  We use <c-s>Condvar</c-s> in the next
      example.
      <a id="thrdrslt"></a>
    </t-b>
    <div style="height:0.1rem;"></div>
    <h3>4.0 - ThreadResult:</h3>
    <t-b>
      The C++ programming language has a <c-s>std::future</c-s> type that allows a thread to return a promise 
      to deliver a result when it&apos;s done.  Users can do work then block on the thread&apos;s future until
      the thread finishes.
    </t-b>
    <t-b>
      Rust also has a Future type, associated with async/await processing, but its operation is tied to the
      mechanisms used for that, e.g., a special-purpose runtime, often provided by the 
      <a href="https://crates.io/crates/tokio">Tokio crate</a>.
    </t-b>
    <t-b>
      In this section we develop a <c-s>ThreadResult&lt;T&gt;</c-s> type that behaves in a way very similar
      to the C++ std::future.
    </t-b>
    <t-b>
      <div class="indent">
        <defn-OuterBlock>
          <defn-block>
            <defn-head>ThreadResult&lt;T&gt;</defn-head>
            <defn-code>
////////////////////////////////////////////////
// thread_result::lib.rs                      //
//     - Wait for thread to complete          //
//                                            //
// Jim Fawcett, https://JimFawcett.github.io  //
////////////////////////////////////////////////

#![allow(clippy::mutex_atomic)]
#![allow(dead_code)]
use std::sync::*;
use std::fmt::Debug;

#[derive(Debug, Default)]
pub struct ThreadResult&lt;T&gt; {
    pub result: Mutex&lt;T&gt;,
    cv: Condvar,
    ready: Mutex&lt;bool&gt;
}

impl&lt;T: Debug + Default + Clone&gt; ThreadResult&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self {
            result: Mutex::new(T::default()),
            cv: Condvar::new(),
            ready: Mutex::new(false),
        }
    }
    /*--------------------------------------------
      Unwrapping is appropriate here.  The 
      operation fails if the Mutex becomes
      poisoned, due to panic on a thread
      holding the lock.  But then you can't
      do much except quit, which the unwrap
      does for you.
    --------------------------------------------*/
    pub fn set(&self, t:T) {
        let mut lr = self.ready.lock().unwrap();
        *lr = true;
        let mut lrslt = self.result.lock().unwrap();
        *lrslt = t;
        self.cv.notify_all();
    }
    pub fn get(&self) -&gt; T {
        let mut rdy = self.ready.lock().unwrap();
        while !*rdy {
            rdy = self.cv.wait(rdy).unwrap();
        }
        let rslt = self.result.lock().unwrap();
        rslt.clone()
    }
    pub fn ready(&self) -&gt; bool {
        *self.ready.lock().unwrap()
    }
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Using Code</defn-head>
            <defn-code>
////////////////////////////////////////////////
// thread_result::test1.rs                    //
//     - basic ThreadResult test              //
//                                            //
// Jim Fawcett, https://JimFawcett.github.io  //
////////////////////////////////////////////////

use std::sync::Arc;
use std::thread;
use std::time::{Duration, Instant};

fn test() {
    let thrd_rslt 
        = Arc::new(ThreadResult::&lt;i32&gt;::new());
    let thrd_rslt1 = Arc::clone(&thrd_rslt);
    let thrd_rslt2 = Arc::clone(&thrd_rslt);

    let cls = |share:Arc&lt;ThreadResult&lt;i32&gt;&gt;| {
        print!("\n  starting thread");
        let dur = Duration::from_millis(100u64);
        thread::sleep(dur);
        share.set(42);
    };
    let handle1 = thread::spawn(
        move || {cls(thrd_rslt1).clone()}
    );

    print!("\n  -- poll for result --");
    let dur = Duration::from_millis(20);
    loop {
        print!("\n  main polling");
        if !thrd_rslt2.ready() {
            thread::sleep(dur);
        }
        else {
            print!(
              "\n  thread result is {}\n", 
              thrd_rslt2.get()
            );
            break;
        }
    }
    print!("\n  -- wait for result --");
    let thrd_rslt 
        = Arc::new(ThreadResult::&lt;i32&gt;::new());
    let thrd_rslt1 = Arc::clone(&thrd_rslt);
    let thrd_rslt2 = Arc::clone(&thrd_rslt);

    let dur = Duration::from_millis(50);
    let now = Instant::now();
    let handle2 = thread::spawn(
        move || {cls(thrd_rslt1).clone()}
    );
    thread::sleep(dur);
    let elapsed = now.elapsed().as_millis();
    print!(
        "\n  after {:?} millis calling get()", 
        elapsed
    );
    let rslt = thrd_rslt2.get();
    let elapsed = now.elapsed().as_millis();
    print!(
        "\n  at {:?} millis, thread result is {}", 
        elapsed, rslt
    );
    
    let _ = handle1.join();
    let _ = handle2.join();
    println!();
}
fn main() {
    test();
} 
              </defn-code>
            <defn-head class="defnBorderTop">Output</defn-head>
            <defn-code>
  -- poll for result --
  main polling
  starting thread
  main polling
  main polling
  main polling
  main polling
  main polling
  thread result is 42

  -- wait for result --
  starting thread
  after 50 millis calling get()
  at 100 millis, thread result is 42
            </defn-code>
          </defn-block>
        </defn-OuterBlock>
      </div>
    </t-b>
    <t-b class="indent">
      <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=56d47eafa4d2859a81b6cecdf40b68b2">
        code in playground
      </a>
    </t-b>
    <t-b>
      Normally we would not continuously poll the <c-s>ThreadResult</c-s>.  Instead start the thread, go off and do work
      until you must use the result and then call <c-s>get()</c-s> which blocks until the result is ready.  
    </t-b>
    <t-b>
      Note that the <c-s>ThreadResult&lt;T&gt;</c-s> is generic so the thread can return a rich set of possible data.
      <a id="bq"></a>
    </t-b>
    <div style="height:0.25rem;"></div>
    <h3>5.0 BlockingQueue:</h3>
    <t-b>
      The last example in this Bite is an implementation of a 
      <a href="https://jimfawcett.github.io/RustBlockingQueue.html">BlockingQueue&lt;T&gt;</a>.
      It is thread-safe, supporting multiple enqueuers.  A dequeuer blocks if the queue is empty until
      an enqueuer posts a message.
    </t-b>
    <t-b>
      With a little more work we can use <c-s>BlockingQueue&lt;T&gt;</c-s> to build a 
      <a href="https://jimfawcett.github.io/RustThreadPool.html">ThreadPool&lt;T&gt;</a> that supports
      multiple dequeuers too.  That you can explore using the link.
    </t-b>
    <t-b>
      <div class="indent">
        <defn-OuterBlock>
          <defn-block>
            <defn-head>BlockingQueue&lt;T&gt; library</defn-head>
            <defn-code>
/////////////////////////////////////////////////
// rust_blocking_queue::lib.rs - BlockingQueue //
//                                             //
// Jim Fawcett, https://JimFawcett.github.io   //
/////////////////////////////////////////////////
/*
   This is a BlockingQueue abstraction.  To be shared
   between threads, without using unsafe code, any 
   abstraction must be composed only of Mutexes and 
   Condvars or struct or tuple with only those members.

   That means that the blocking queue must hold its 
   native queue in a Mutex, as shown below.
   
   There is another alternative, based on Rust 
   channels, which are essentially blocking queues.
*/
#![allow(dead_code)]
use std::sync::*;
use std::collections::*;

#[derive(Debug)]
/// Thread-safe queue that blocks de_q on empty
pub struct BlockingQueue&lt;T&gt; {
    q: Mutex&lt;VecDeque&lt;T&gt;&gt;,
    cv: Condvar,
}
impl&lt;T&gt; BlockingQueue&lt;T&gt; {
    /// Create empty blocking queue
    pub fn new() -&gt; Self {
        Self {
            q: Mutex::new(VecDeque::new()),
            cv: Condvar::new(),
        }
    }
    /// push input on back of queue
    /// - unrecoverable if lock fails so just unwrap
    pub fn en_q(&self, t:T) {
        let mut lq = self.q.lock().unwrap();
        lq.push_back(t);
        self.cv.notify_one();
    }
    /// pop element from front of queue
    /// - unrecoverable if lock fails so just unwrap
    /// - same for condition variable
    pub fn de_q(&self) -&gt; T {
        let mut lq = self.q.lock().unwrap();
        while lq.len() == 0 {
            lq = self.cv.wait(lq).unwrap();
        }
        lq.pop_front().unwrap()
    }
    /// return number of elements in queue
    pub fn len(&self) -&gt; usize {
        self.q.lock().unwrap().len()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn bq_len() {
        let bq = BlockingQueue::&lt;f64&gt;::new();
        assert_eq!(bq.len(), 0);
    }
    #[test]
    fn bq_en_queue() {
        let bq = BlockingQueue::&lt;f64&gt;::new();
        bq.en_q(3.5);
        assert_eq!(bq.len(), 1);
    }
    #[test]
    fn bq_de_queue() {
        let bq = BlockingQueue::&lt;f64&gt;::new();
        bq.en_q(3.5);
        assert_eq!(bq.de_q(), 3.5);
        assert_eq!(bq.len(), 0);
    }
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Using Code</defn-head>
            <defn-code>
////////////////////////////////////////////////
// rust_blocking_queue::test1.rs              //
//     - demo blocking queue                  //
//                                            //
// Jim Fawcett, https://JimFawcett.github.io  //
////////////////////////////////////////////////
/*
   This is a good demonstration of the way 
   BlockingQueue will be used in applications.
*/
use std::io::*;
use std::sync::*;
use std::thread;
use rust_blocking_queue::{BlockingQueue};
use std::time::Duration;

fn main() {

    print!(
        "\n  Demonstrate queue shared between threads"
    );
    print!(
        "\n =========================================="
    );

    test();
    print!("\n\n  That's all Folks!\n");
}

/*-- simple test of BlockingQueue --*/
fn test() {

    let share = Arc::new(BlockingQueue::&lt;String&gt;::new());
    let share1 = Arc::clone(&share);
    let share2 = Arc::clone(&share);

    let flush = || { let _ = std::io::stdout().flush(); };

    /*-- child thread dequeues messages --*/
    let handle = thread::spawn(move || {
        print!("\n  child thread started");
        flush();
        let dur = Duration::from_millis(50);
        loop {
            let t = share1.de_q();
            print!("\n  dequeued {} on child thread", t);
            flush();
            if &t == "quit" {
                break;
            }
            thread::sleep(dur);
        }
        print!("\n  thread shutting down");
        flush();
    });

    /*-- main thread enqueues messages --*/
    let dur = Duration::from_millis(20);
    for i in 0..5 {
        let msg = format!("msg #{}", i.to_string());
        print!("\n  enqueued {:?} on main thread", msg);
        flush();
        share2.en_q(msg);
        thread::sleep(dur);
    }
    /*-- shut down child thread --*/
    print!("\n  enqueued {:?} on main thread", "quit");
    flush();
    share2.en_q("quit".to_string());

    /*-- child thread must complete before exiting --*/
    print!("\n  waiting for child thread to stop");
    flush();
    let _ = handle.join();

    print!("\n  queue length = {}", share2.len());
}
            </defn-code>
            <defn-head class="defnBorderTop">Output</defn-head>
            <defn-code>
  Demonstrate queue shared between threads
 ==========================================
  enqueued "msg #0" on main thread
  child thread started
  dequeued msg #0 on child thread
  enqueued "msg #1" on main thread
  dequeued msg #1 on child thread
  enqueued "msg #2" on main thread
  enqueued "msg #3" on main thread
  dequeued msg #2 on child thread
  enqueued "msg #4" on main thread
  enqueued "quit" on main thread
  waiting for child thread to stop
  dequeued msg #3 on child thread
  dequeued msg #4 on child thread
  dequeued quit on child thread
  thread shutting down
  queue length = 0

  That's all Folks!

            </defn-code>
          </defn-block>
        </defn-OuterBlock>
      </div>
      <a id="epilog"></a>
    </t-b>
    <div style="height:0.25rem;"></div>
    <h3>6.0 - Epilogue:</h3>
    <t-b>
      Well, this has been some journey - yeah!  Lot&apos;s of interesting things in the thread code mix.
      And, we haven&apos;t talked seriously about synchronization: 
      <ul class="tight" style="margin-left:0.0rem;">
        <li>How does CondVar work and why do we need to use it?</li>
        <li>What does RWLock&lt;T&gt; do and when would we use it?</li>
        <li>What is a Barrier and should we care?</li>
      </ul>
      For those, stay tuned for the <a href="RustBites_Synchron.html">Synchronization</a> bite.  
      That probably will appear soon.  In the mean
      time, look here: <a href="https://doc.rust-lang.org/std/sync/">std::sync</a>.  That will eventually
      be followed by <a href="RustBites_Channels.html">Channels</a>.  For now, look here:
      <a href="https://doc.rust-lang.org/std/sync/mpsc/index.html">mpsc</a>.  Both locks and channels are
      treated lightly in the <a href="../../RustStory_Libraries.html">Rust Story</a>.
    </t-b>
  </body>
</html>
