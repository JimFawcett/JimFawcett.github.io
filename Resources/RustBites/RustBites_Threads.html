<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Threads</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <link rel="stylesheet" href="css/BiteTables.css" />
    <script src="js/BiteScripts.js"></script>
    <script src="js/ScriptsKeyboard.js"></script>
    <style>
      #github c-s { font-size:1.1rem; }
    </style>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <span class="top-center">Threads</span>
    </div>
    <next-prev>
      <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
      <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
      <a id="Prev" href="RustBites_Macros.html">prev</a> 
      <a id="Next" href="RustBites_Synchron.html">next</a>
    </next-prev>

    <toc-b id="toc">
      <div id="bottom-menu" style="display:flex; flex-direction:row">
      </div>
        <up-b id="chaps">
        </up-b>
          <rt-b id="sects">
        <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
        <a href="#contents">Contents</a>, <a href="#refs">References</a>
      </rt-b>
    </toc-b>
    <div id="hlp" style="display:none;">
      </div>

    <h2>Rust Bite - Threads</h2>
    <hr class="spread" />
    <h3>Basic Threads:</h3>
    <t-b>
      Rust threads are represented by the <c-s>thread</c-s> type and created
      with an associated function:
      <div class="indent pad5">
        <c-s>spawn&lt;F, T&gt;(f: F) -> JoinHandle&lt;T&gt;<br />
        &nbsp;&nbsp;where F: FnOnce() -> T, F: send + `static, T: Send + `static
      </div>
      <c-s>spawn</c-s> accepts a closure that implements thread processing.  The std::thread library&apos;s implementation
      of <c-s>spawn</c-s> uses the platform api to start a native thread running the supplied closure.
      When the thread exits this closure it is terminated.
    </t-b>
    <t-b>
      The demonstration, below, illustrates creation of a child thread.  The main thread and child share std::output
      and an AtomicUsize global variable.  Global variables are usually avoided in Rust and other languages as well
      due to possibly widely distributed side affects.  It&apos;s used here for local thread-safe sharing between
      main and child threads just to illustrate how that works.
    </t-b>
    <div class="indent">
      <defn-OuterBlock>
        <defn-block>
          <defn-head>Basic Thread Demo</defn-head>
          <defn-code>
// Basic Threads
// sharing std::output and AtomicUsize - both thread safe

use std::thread;
use std::time::Duration;
use std::sync::atomic::{AtomicUsize, Ordering};

static COUNT: AtomicUsize = AtomicUsize::new(0usize);

fn test() {
    // child thread processing
    let dur = Duration::from_millis(2);
    let handle = thread::spawn(
        move || {
            for _i in 0..10 {
                print!("\n  child thread printing");
                let _ = COUNT.fetch_add(1, Ordering::SeqCst);
                thread::sleep(dur);
            }
        }
    );
    // main thread processing
    let dur = Duration::from_millis(3);
    for _i in 0..10 {
        print!("\n   main thread printing");
        let _ = COUNT.fetch_add(1, Ordering::SeqCst);
        thread::sleep(dur);
    }
    // wait for thread to complete
    let _ = handle.join();
    print!("\n\n  number of prints = {:?}", COUNT);
}

fn main() {
    print!("\n  -- Basic Threads --\n");
    test();
    print!("\n\n  That's all Folks!\n\n");
}
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>Output</defn-head>
          <defn-code>
  -- Basic Threads --

   main thread printing
  child thread printing
  child thread printing
  child thread printing
   main thread printing
  child thread printing
   main thread printing
  child thread printing
   main thread printing
  child thread printing
  child thread printing
   main thread printing
  child thread printing
   main thread printing
  child thread printing
  child thread printing
   main thread printing
   main thread printing
   main thread printing
   main thread printing

  number of prints = 20

  That's all Folks!
         </defn-code>
        </defn-block>
      </defn-OuterBlock>
    </div>
    <t-b class="indent">
      <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c792e1f6af676048cbe51fce925085d5">
        code in playground
      </a>
    </t-b>
    <t-b>
      Note that the global COUNT atomic is not declared as mutable, but in fact is mutated by both main and child.
      That works because Atomics, Arcs, and Mutexes implement interior mutability, as discussed in the 
      <a href="RustBites_Safety.html">Safety Bite</a>.  Interior mutability defers borrowing checks from compile-time
      to run-time.  See 
      <a href="https://ricardomartins.cc/2016/06/25/interior-mutability-thread-safety">
        Interior mutability in Rust, by Ricardo Martins
      </a>.
    </t-b>
    <h3>Sharing non-thread-safe Resources:</h3>
    <t-b>
      The previous example was relatively simple because threads only shared inherently thread-safe objects, e.g., 
      an Atomic and std::output.  The example below illustrates how non-thread-safe objects need to be handled.
    </t-b>
    <t-b>
      One way to share objects that are not thread safe is to use locks.  In the example below a
      <c-s>Mutex</c-s> wraps a <c-s>String</c-s> that three threads will share.  Rust <c-s>Mutex</c-s>es are unique
      in that they protect data not areas of code.  That eliminates a blunder, observed in other languages, 
      of not sharing a common lock, so no protection is afforded to the shared item.
    </t-b>
    <t-b>
      <c-s>Mutex</c-s>es are usually shared by using a thread safe reference-counted pointer, <c-s>Arc&lt;T&gt;</c-s>,
      using the syntax:
      <div class="indent pad5">
        <c-s>let shared = Arc::new(Mutex::new(s));</c-s>
      </div>
      where s is the entity to be shared.  Sharing is then effected with:
      <div class="indent pad5">
        <c-s>let shared1 = Arc::clone(&shared)</c-s><br />
        <c-s>let shared2 = Arc::clone(&shared)</c-s>
      </div>
      <c-s>shared1</c-s> and <c-s>shared2</c-s> are pointers to the wrapped <c-s>Mutex</c-s> which, in turn, wraps
      the shared entity, <c-s>s</c-s>, affording sychronized access.
    </t-b>
    <div style="height:0.25rem;"></div>
    <div class="indent">
      <defn-OuterBlock>
        <defn-block>
          <defn-head>Thread Sharing</defn-head>
          <defn-code>
// threads sharing string

use std::thread;
use std::sync::{Arc, Mutex};
use std::time::Duration;

fn test() {
    let a = "        main thread pushes \'0\'";
    let b = " first child thread pushes \'1\'";
    let c = "second child thread pushes \'2\'";
    print!("\n  {}", a);
    print!("\n  {}", b);
    print!("\n  {}\n", c);
    
    let s = String::new();
    let shared = Arc::new(Mutex::new(s));
    // main thread gets first edit
    let shared0 = Arc::clone(&shared);
    if let Ok(mut temp) = shared0.lock() {
        temp.push('0');
    }
    // create child threads
    let shared1 = Arc::clone(&shared);
    let dur = Duration::from_millis(2);  // faster
    let handle1 = thread::spawn(
        move || {
            for _i in 0..15 {
                // child edits shared string
                if let Ok(mut temp) = shared1.lock() {
                    temp.push('1');
                }
                thread::sleep(dur);
            }
        }
    );
    // create second child thread
    let shared2 = Arc::clone(&shared);
    let dur = Duration::from_millis(3);  // slower
    let handle2 = thread::spawn(
        move || {
            for _i in 0..15 {
                // child edits string
                if let Ok(mut temp) = shared2.lock() {
                    temp.push('2');
                }
                thread::sleep(dur);
            }
        }
    );
    let _ = handle1.join();
    let _ = handle2.join();
    let mut s = String::new();
    if let Ok(mut temp) = shared0.lock() {
        temp.push('0');
        s = temp.to_string();
    }
    print!("\n  {}", s);
}

fn main() {
    print!("\n  -- Threads sharing String --\n");
    test();
    print!("\n\n  That's all Folks!\n\n");
}
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>Output</defn-head>
          <defn-code>
  -- Threads sharing String --

          main thread pushes '0'
   first child thread pushes '1'
  second child thread pushes '2'

  01121121211212112112121212222220    

  That's all Folks!
          </defn-code>
        </defn-block>
      </defn-OuterBlock>
    </div>
    <t-b class="indent">
      <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=d6d4d57036dd488009c3854ae9147491">
        code in playground
      </a>
    </t-b>
    <t-b>
      Rust has two other synchronizing constructs that are often used in threaded code: <c-s>RWLock</c-s>, a
      reader-writer lock, and <c-s>Condvar</c-s> a condition variable.
    </t-b>
  </body>
</html>
