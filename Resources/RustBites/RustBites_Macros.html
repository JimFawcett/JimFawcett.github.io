<!DOCTYPE html>
<html id="top">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Macros</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <link rel="stylesheet" href="css/BiteTables.css" />
    <script src="js/BiteScripts.js"></script>
    <script src="js/ScriptsKeyboard.js"></script>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <span class="top-center">Macros</span>
    </div>
    <next-prev>
      <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
      <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
      <a id="Prev" href="RustBites_AsyncAwt.html">prev</a> 
      <a id="Next" href="RustBites_Experiments.html">next</a>
    </next-prev>

    <toc-b id="toc">
      <div id="bottom-menu" style="display:flex; flex-direction:row">
      </div>
        <up-b id="chaps">
        </up-b>
          <rt-b id="sects">
        <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
        <a href="#contents">Contents</a>, <a href="#refs">References</a>
      </rt-b>
    </toc-b>
    <div id="hlp" style="display:none;"></div>
   
    <h2>Rust Bite - Macros</h2>
    <t-b><hr class="spread" /></t-b>
    <h3>Basics:</h3>
    <t-b>
      Rust macros come in two flavors: declarative and procedural.  We will focus on declarative macros.  They take
      the form:
      <div class="indent pad10">
        <defn-OuterBlock>
          <defn-block>
            <defn-head>
              Macro structure
            </defn-head>
            <defn-code>
  macro_rules! $name {
      $rule0 ;
      $rule1 ;
      // …
      $ruleN ;
  }
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Rule structure</defn-head>
            <defn-code>
($pattern) => {$expansion}
            </defn-code>
          </defn-block>
        </defn-OuterBlock>
      </div>
      <t-b>
        The
      </t-b>
      <div class="indent pad10">
        <defn-OuterBlock>
          <defn-block>
            <defn-head>
              Indented print macro
            </defn-head>
            <defn-code>
macro_rules! indent_print {
/* first rule */
    /* pattern */
    ($a:expr) => {
        {
            /* template */
            print!("\n  {}", $a)
        }
    };
/* second rule */
    () => {
        {
            print!("\n  no argument to print")
        }
    }
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Using code</defn-head>
            <defn-code>
fn main() {
    indent_print!("this is a demo");
    indent_print!();
}
            </defn-code>
            <defn-head class="defnBorderTop">Output</defn-head>
            <defn-code>
  this is a demo
  no argument to print
            </defn-code>
          </defn-block>
        </defn-OuterBlock>
      </div>
    </t-b>
    <h3>Variadic Macros</h3>
    <t-b>
      Patterns and expansions support repetitions using a syntax reminiscent of regular expressions.
      <div class="indent">
        <h4>Table 1. - Repetition Syntax</h4>
        <table>
          <tr>
            <th>Syntax</th><th>Semantics</th>
          </tr>
          <tr>
            <td><c-s>$(...)*</c-s></td><td>repeat zero or more ... with no seperator</td>
          </tr>
          <tr>
            <td><c-s>$(...),*</c-s></td><td>repeat zero or more ... with comma seperator</td>
          </tr>
          <tr>
            <td><c-s>$(...)+</c-s></td><td>repeat one or more ... with no seperator</td>
          </tr>
          <tr>
            <td><c-s>$(...),+</c-s></td><td>repeat one or more ... with comma seperator</td>
          </tr>
        </table>
      </div>
    </t-b>
    <t-b>
      <div class="indent pad10">
        <defn-OuterBlock>
          <defn-block>
            <defn-head>
              Indented print with multiple arguments
            </defn-head>
            <defn-code>
macro_rules! ma_indent_print {
    /*--------------------------------------------
      pattern matches $fmt expression followed 
      by zero or more expressions 
    --------------------------------------------*/
    ($fmt:expr, $($a:expr),*) => {
        /*----------------------------------------
          template creates $fmt followed by zero
          or more expressions follwed by commas
        ----------------------------------------*/
        print!($fmt, $($a),*)  // each $a taken by ref
    }
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Using code</defn-head>
            <defn-code>
fn main() {
    let s = String::from("Rust");
    ma_indent_print!(
        "\n  {}, {}, {}", "hi", 42, s
    );
    /* s taken by ref so not moved */
    print!("\n  {}", s);
}
              </defn-code>
            <defn-head class="defnBorderTop">Output</defn-head>
            <defn-code>
  hi, 42, Rust
  Rust
            </defn-code>
          </defn-block>
        </defn-OuterBlock>
      </div>
      <div class="indent">
        <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c946dda8951e7696651da110fe13efe6">
          code in playground
        </a>
      </div>
    </t-b>
    <h3>Practical Example:</h3>
    <t-b>
      <div class="indent">
        <h4>Table 2. - Partial list of Macro Fragments</h4>
        <table>
          <tr>
            <th>Fragment Type</th><th>Matches</th><th>Examples</th>
          </tr>
          <tr>
            <td>expr</td>
            <td>
              an expression
            </td>
            <td><c-s>1 + 2, v.len(), "a string"</c-s></td>
          </tr>
          <tr>
            <td>ident</td>
            <td>
              an identifier
            </td>
            <td><c-s>x, my_struct</c-s></td>
          </tr>
          <tr>
            <td>ty</td>
            <td>
              a type
            </td>
            <td><c-s>String, Vec&lt;String&gt;</c-s></td>
          </tr>
          <tr>
            <td>path</td>
            <td>
              a std::path
            </td>
            <td><c-s>C:\\temp\\CodeExperiments</c-s></td>
          </tr>
          <tr>
            <td>pat</td>
            <td>
              a pattern
            </td>
            <td><c-s>_, Some(ref x)</c-s></td>
          </tr>
          <tr>
            <td>literal</td>
            <td>
              a literal value
            </td>
            <td><c-s>2, "a literal string"</c-s></td>
          </tr>
          <tr>
            <td>tt</td>
            <td>
              token tree
            </td>
            <td><c-s>let x=2; let y=x;, [0, 1, 2], fn f{...}</c-s></td>
          </tr>
        </table>
      </div>
    </t-b>
    <t-b>
      <div class="indent">
        <defn-OuterBlock>
          <defn-block>
            <defn-head>Timer Macro</defn-head>
            <defn-code>
use std::{thread, time};
use std::result::*;
use std::io::prelude::*;
use std::fs::File;

macro_rules! time_it {
/* measure time to process token tree &tt */
    ($context:literal, $($tt:tt)*) => {
        let timer = std::time::Instant::now();
        $(
            $tt
        )*
        let t = timer.elapsed();
        println!("{}: {:?}", $context, t);
    };
/* measure time to scaffold without execution */
    ($context:literal) => {
        let timer = std::time::Instant::now();
        let t = timer.elapsed();
        println!("{}: {:?}", $context, t);
    };
}
            </defn-code>
            <defn-head class="defnBorderTop">Output</defn-head>
            <defn-code>
empty: 928ns
let _x = 1 + 2: 956ns
mults: 2.636µs
sleep(10) + sleep(20): 30.241214ms
file open: 139.476µs
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Using Code</defn-head>
            <defn-code>
fn do_sleep(ms:u64) {
    let millis = 
        time::Duration::from_millis(ms);
    thread::sleep(millis);
}

fn open_file_for_write(file_name:&str) 
     ->Result<(), std::io::Error> {
    let mut file = File::create(file_name)?;
    file.write_all(b"Hello, Rust BuildOn!")?;
    Ok(())
}

fn main() {
    time_it!("empty");
    time_it!(
        "let _x = 1 + 2",
        let _x = 1 + 2;
    );
    time_it!(
        "mults", 
        let mut x:f64 = 1.5;
        for _i in 0..10 {
            x *= x;
        }
    );
    time_it!(
        "sleep(10) + sleep(20)", 
        do_sleep(10); 
        do_sleep(20);
    );
    time_it!(
        "file open", 
        let _ = open_file_for_write("foobar");
    );
}
            </defn-code>
          </defn-block>
        </defn-OuterBlock>
      </div>
    </t-b>
    <t-b>
      <div class="indent">
        <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=1b06dd11c3bd47317ddf224d4e1bbf63">
          code in playground
        </a>
      </div>
    </t-b>
  </body>
</html>
