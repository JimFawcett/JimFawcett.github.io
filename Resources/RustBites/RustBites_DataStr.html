<!DOCTYPE html>
<html id="top">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites DataStr</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <script src="js/BiteScripts.js"></script>
    <style>
      #github table, td, th { 
        border:1px solid #333; 
        border-collapse: collapse;
      }
      #github table {
        margin-top: 0.5em;
        margin-bottom: 0.75em;
      }
      #github th { /* darkItem */
           background-color: #363636;
           color: #fef9ee;
           padding: 3px 10px;
           border: 1px solid #fef9ee;
      }
      #github td { /* lightItem */
        background-color: #fef9ee;
        color: #5c2107;
        padding: 3px 10px;
        border: 1px solid #5c2107;
        white-space: nowrap;
      }
      #github table.fixed {
        table-layout: fixed;
        width: 100%;
        max-width: 95%;
      }
      td.left {
        max-width: 30%;
      }
    </style>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <div style="position:relative; left:calc(100vw - 15rem);">
        <span class="top-center">Data Structures</span>
        <!-- <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a> -->
      </div>
  </div>
  <next-prev>
    <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
    <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
    <a id="prev" href="RustBites_Data.html">prev</a> 
    <a id="next" href="RustBites_SmrtPtrs.html">next</a>
  </next-prev>

      <toc-b id="toc">
        <div style="display:flex; flex-direction:row">
          <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
          <a href="Javascript:;" onclick="storyMenu.sects()" style="color: #fefefa; ">Sects</a>&nbsp;
          <!-- <a href="../../RustBiteByByte.html" style="color:#fefefa;">Repo</a>&nbsp; -->
          <!-- <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp; -->
          <!-- <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">esc</a>&nbsp; -->
          <!-- <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp; -->
        </div>
        <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
          <up-b id="chaps">
            <a href="RustBites_Facts.html">Facts</a><br />
            <a href="RustBites_Intro.html">Introduction</a><br />
            <a href="RustBites_UDB.html">UndefBehavior</a><br />
            <a href="RustBites_Data.html">Data</a><br />
            <a href="RustBites_DataStr.html">DataStructs</a><br />
            <a href="RustBites_SmrtPtrs.html">SmartPtrs</a><br />
            <a href="RustBites_LifeCycle.html">LifeCycle</a><br />
            <a href="RustBites_Ownrs.html">Ownership</a><br />
            <a href="RustBites_Traits.html">Generics&Traits</a><br />
            <a href="RustBites_Functs.html">Functions</a><br />
            <a href="RustBites_Structs.html">Structs</a><br />
            <a href="RustBites_LifeTime.html">LifeTime</a><br />
            <a href="RustBites_Abstract.html">Abstractions</a><br />
            <a href="RustBites_ErrHnd.html">ErrHandling</a><br />
            <a href="RustBites_Collects.html">Collections</a><br />
            <a href="RustBites_Iterator.html">Iterators</a><br />
            <a href="RustBites_Threads.html">Threads</a><br />
            <a href="RustBites_Synchron.html">Synchronize</a><br />
            <a href="RustBites_Channels.html">Channels</a><br />
            <a href="RustBites_AsyncAwt.html">AsyncAwait</a><br />
            <a href="RustBites_Macros.html">Macros</a><br />
            <a href="RustBites_TipsAndTricks.html">Hacks and Helpers</a><br />
            <!-- <a href="RustBites_Generics.html">Generics</a><br /> -->
            <!-- <a href="RustBites_Intmut.html">InterMutat</a><br /> -->
            <a href="Javascript.;#"></a><br />
          </up-b>
            <rt-b id="sects">
          <a href="#top">Top</a>, <a href="#primitives">Primtvs</a>, <a href="#iters">Iters</a>, 
          <a href="#str">Str</a>, <a href="#format">Format</a>, 
          <a href="#vec">Vec</a>, <a href="#map">Map</a>, 
          <a href="#collect">Other</a>, <a href="#exer">Exer</a>
        </rt-b>
      </toc-b>
      <div id="hlp" style="display:none;">
        <table>
          <tr>
            <td style="padding-right:5px;">Esc</td>
            <td>toggle menus</td>
          </tr>
          <tr>
            <td>C</td>
            <td>close menus</td>
          </tr>
          <tr>
            <td>R</td><td>Refresh</td>
          </tr>
          <tr>
            <td>N</td><td>Next Bite</td>
          </tr>
          <tr>
            <td>P</td><td>Prev Bite</td>
          </tr>
          <tr>
            <td>T</td><td>scroll to top</td>
          </tr>
          <tr>
            <td>B</td><td>scroll to bottom</td>
          </tr>
          <tr>
            <td>H</td><td>Help</td>
          </tr>
        </table>
       </div>
      <bb-55>
        <h1>Rust Bite - std Data Structures</h1>
        <hr />
        <t-b>
          This Bite presents primitive data types and data structures from the Rust std libraries.
          It provides a reference and brief examples, pulling in information from
          several libraries into one top-level view.
          <a id="primitives"></a>
          <s-halfEm></s-halfEm>
        </t-b>
        <div>
          <div>
            <div>
              <h3>1. Primitives and Aggregates</h3>
              <ul class="tight" style="margin-left:0.5em;">
                <li>
                  Scalar primitives are all Copy types:
                  <table>
                    <tr>
                      <th>Type</th><th>Example</th>
                    </tr>
                    <tr>
                      <td>bool, char</td><td>let b:bool = true;</td>
                    </tr>
                    <tr>
                      <td>i8, i16, i32, i64, isize</td><td>let i:i8 = -42;</td>
                    </tr>
                    <tr>
                      <td>u8, u16, u32, u64, usize</td><td>let u:u8 = 42;</td>
                    </tr>
                    <tr>
                      <td>f32, f64</td><td>let f:f64 = 3.1415927;</td>
                    </tr>
                  </table>
                </li>
                <li>
                  Aggregate primitives are all Copy types if and only if their elements are Copy:
                  <table>
                    <tr>
                      <th>Type</th><th>Example</th>
                    </tr>
                    <tr>
                      <td>
                        array: [T;N], 
                        contiguous sequence of T
                      </td>
                      <td>
                        let a:[i32;4] = [1, 2, 3, 4];
                        &nbsp;&nbsp;assert_eq!(a[1], 2);<br />
                        a[1] = -2;
                      </td>
                    </tr>
                    <tr>
                      <td>
                        slice:
                        dynamically sized view into contiguous sequence [T]
                      </td>
                      <td>let s = &a[1..3]; => [2, 3]</td>
                    </tr>
                    <tr>
                      <td>str: string slice</td><td>let s = "an str";</td>
                    </tr>
                  </table>
                </li>
                <li>
                  tuples and structs are Copy if and only if they hold no Move types:
                  <table>
                    <tr>
                      <th>Type</th><th>Example</th>
                    </tr>
                    <tr>
                      <td>tuple: finite heterogeneous sequence (T,U,...)</td>
                      <td>
                        let t:(u16, String, f64) = (42, String::from("42"), 3.1415927);
                        &nbsp;&nbsp;assert_eq!(t.0, 42);
                      </td>
                    </tr>
                    <tr>
                      <td>struct: named fields</td>
                      <td>
                        struct S { a:i8, b:String, c:f64 }<br />
                        let s = S { a:42, b:String::from("String"), c:3.1415927 };
                        &nbsp;&nbsp;assert_eq!(s.a, 42);
                      </td>
                    </tr>
                    <tr>
                      <td>struct: tuple</td>
                      <td>
                        struct T(i8, String, f64)<br />
                        let t:T = (42, String::from("a string"), 3.1415927);
                        &nbsp;&nbsp;assert_eq!(t.0, 42);
                      </td>
                    </tr>
                    <tr>
                      <td>struct: unit</td>
                      <td>
                        let s = struct S;
                        &nbsp;&nbsp;s.what().more();
                        &nbsp;&nbsp;units have no data members, only methods.
                      </td>
                    </tr>
                  </table>
                </li>
              </ul>
              <a id="iters"></a>
              <s-halfEm></s-halfEm>
            </div>
            <div>
              <h3>2. Iterators:</h3>
              <div class="indent">
                <t-b>
                  The contiguous data structures, slice, array, and Vec, provide iter()
                  member functions that iterate through the structure, e.g.:
                  <div class="indent pad5">
                    <c-s>
                      let iter = [1, 2, 3, 4].iter();<br />
                      for item in iter {
                      /* do something with item */
                      }
                    </c-s>
                  </div>
                  <div class="indent pad5">
                    <c-s>
                      let iter = vec![1, 2, 3, 4, 5].iter();<br />
                      for item in iter {
                      /* do something with item */
                      }
                    </c-s>
                  </div>
                </t-b>
                <t-b>
                  Strings have the member function chars() that returns an iterator over
                  its UTF-8 characters:
                  <div class="indent pad5">
                    <c-s>
                      let iter = String::from("a string").chars();<br />
                      for ch in iter {
                      /* do something with character */
                      }
                    </c-s>
                  </div>
                </t-b>
                <t-b>
                  Maps have the member function iter() that returns an iterator over
                  its key-value pairs:
                  <div class="indent pad5">
                    <c-s>
                      let mut m = std::collections::HashMap::<u8, String>
                        ::new();<br />
                        m.insert(0, String::from("zero"));<br />
                        m.insert(1, String::from("one"));<br />
                        ..<br />
                        let iter = m.iter();<br />
                        for item in iter { /* do something with item */ }
                    </c-s>
                  </div>
                </t-b>
                <t-b>
                  Iterators have an associated type, Item, and a number of member functions:
                  <table>
                    <tr>
                      <th>member function</th>
                      <th>operation</th>
                    </tr>
                    <tr>
                      <td>next(&mut self) -> Option&lt;Self::Item&gt;</td>
                      <td>Return next element in collection</td>
                    </tr>
                    <tr>
                      <td>count(self) -> usize</td>
                      <td>Consumes iterator, returning number of iterations</td>
                    </tr>
                    <tr>
                      <td>last(self) -> Option&lt;Self::Item&gt;</td>
                      <td>Consumes iterator, returning last item</td>
                    </tr>
                    <tr>
                      <td>nth(&mut self, n: usize) -> Option&lt;Self::Item&gt;</td>
                      <td>Consumes all preceding elements and nth which it returns</td>
                    </tr>
                    <tr>
                      <td>step-by(self, step: usize) ->StepBy&lt;Self&gt;</td>
                      <td>
                        Creates new iterator starting at same point, but
                        stepping by given amount at each iteration.
                      </td>
                    </tr>
                    <tr>
                      <td>map&lt;B, F&gt;(self, f: F) -> Map&lt;Self, F&gt;</td>
                      <td>
                        Takes a closure and creates an iterator that calls the closure
                        on each element
                      </td>
                    </tr>
                    <tr>
                      <td class="no-wrap">
                        filter&lt;P&gt;(self, predicate: P) - > Filter&lt;Self, P&gt;<br />
                        where P: FnMut(&Self::Item) -> bool
                      </td>
                      <td>
                        Creates an iterator which takes a closure to decide if element
                        should be included in result
                      </td>
                    </tr>
                    <tr>
                      <td>skip(self, n: usize) -> Skip&lt;Self&gt;</td>
                      <td>Creates an iterator that skips the first n elements</td>
                    </tr>
                    <tr>
                      <td>take(self, n:usize) -> Take&lt;Self&gt;</td>
                      <td>Creates an iterator that returns first n elements</td>
                    </tr>
                    <tr>
                      <td>by_ref(&mut self) -> &mut Self</td>
                      <td>
                        Supports using these adapters while retaining ownership
                        of the original iterator
                      </td>
                    </tr>
                    <tr>
                      <td>collect&lt;B&gt;(self) -> B</td>
                      <td>Transforms iterator into collection</td>
                    </tr>
                    <tr>
                      <td>More adapter functions ...</td>
                      <td><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">std::iter::Iterator</a></td>
                    </tr>
                  </table>
                </t-b>
                <t-b>
                  <div>
                    <details>
                      <summary class="darkItem">Examples: show_coll, show_fold</summary>
                      <s-halfEm></s-halfEm>
                      <defn-outerBlock>
                        <defn-block>
                          <defn-head>show_coll</defn-head>
                          <defn-code>
/*-------------------------------------------------------
  Display comma separated list of collection items
  - shows how to build function accepting iterable
  collections
  - returns Option::None if collection is empty
*/
fn show_coll&lt;C&gt;(c:&amp;C) -&gt; Option&lt;()&gt;
where C:IntoIterator + Clone + Debug, C::Item: Debug {

    let mut iter = c.clone().into_iter();
    /*-------------------------------------------
      returns Option if no next element using
      ? try operator
    */
    print!("\n  {:?}", iter.next()?);
    /*-- breaks when no next element --*/
    for item in iter {
        print!(", {:?}", &amp;item);
    }
    Some(())
}
                          </defn-code>
                        </defn-block>
                        <defn-block>
                          <defn-head>show_fold</defn-head>
                          <defn-code>
/*-------------------------------------------------
  Show slice as stack of rows with span elements
  in row
  - nice illustration of Iterator methods
*/
fn show_fold&lt;T:Debug&gt;(
    t:&amp;[T], span:usize, width:usize
) {
    let iter = t.iter();
    print!("\n  ");
    let mut count = 0;
    for bt in iter {
        count = count + 1;
        print!("{:wd$?}", bt, wd = width);
        if count == span {
            print!("\n  ");
            count = 0;
        }
    }
    //---------------------------------------------
    // alternate implementation
    //---------------------------------------------
    // let times = 1 + t.len()/span;
    // for _i in 0..times {
    //     for bt in iter.clone()
    //         .skip(_i * span).take(span) {
    //         print!("{:5?} ", bt);
    //     }
    //     if _i &lt; times - 1 {
    //         print!("\n  ");
    //     }
    // }
}
                          </defn-code>
                        </defn-block>
                      </defn-outerBlock>
                    </details>
                  </div>
                </t-b>
                <a id="str"></a>
                <s-halfEm></s-halfEm>
              </div>
              <h3>3. String, str</h3>
              <div class="indent">
                <t-b>
                  The std::string library provides the main Rust string.
                  <div class="indent pad5">
                    <c-s>let s = String::from("a string");</c-s>
                  </div>
                  The <c-s>"a string"</c-s> is a string slice of type <c-s>&str</c-s>.
                  It is a contiguous collection of UTF-8 characters, compiled into some
                  location in static memory with the code that uses it.
                  <s-halfEm></s-halfEm>
                  Each member of the <c-s>String</c-s> class consists of a control block in the stack 
                  holding a pointer to its string slice in the heap.  See
                  <a href="RustBites_Data.html">RustBites_Data</a> for a diagram of that. 
                </t-b>
                <t-b>
                  Strings have member functions:
                  <div style="width:calc(100vw-9em);">
                    <table style="max-width:calc(100vw-9em);">
                      <tr>
                        <th>member function</th><th>description</th>
                      </tr>
                      <tr>
                        <td>new() -> String</td>
                        <td>Create new empty String</td>
                      </tr>
                      <tr>
                        <td>from(s: &str) -> String</td>
                        <td>Creates string from string slice</td>
                      </tr>
                      <tr>
                        <td>as_str(&self) -> &str</td>
                        <td>Returns string slice</td>
                      </tr>
                      <tr>
                        <td>push_str(&mut self, s: &str)</td>
                        <td>Appends chars from s</td>
                      </tr>
                      <tr>
                        <td>push(&mut self, ch: char)</td>
                        <td>Appends ch</td>
                      </tr>
                      <tr>
                        <td>remove(&mut self, n: usize) -> char</td>
                        <td>Removes char at index n</td>
                      </tr>
                      <tr>
                        <td>insert(&mut self, n: usize, ch: char)</td>
                        <td>inserts ch at location n</td>
                      </tr>
                      <tr>
                        <td>insert_str(&mut self, n: usize, s: &str)</td>
                        <td>Inserts contents of s at location n</td>
                      </tr>
                      <tr>
                        <td>len(&self) -> usize</td>
                        <td>
                          Returns length of string in bytes, not chars!<br />
                          They are the same only for ASCII characters.
                        </td>
                      </tr>
                      <tr>
                        <td>is_empty(&self) -> bool</td>
                        <td>Returns true if len() == 0, else false</td>
                      </tr>
                      <tr>
                        <td>clear(&mut self)</td>
                        <td>Removes all bytes</td>
                      </tr>
                      <tr>
                        <td class="no-wrap">from_utf8(vec: Vec&lt;u8&gt; -> REsult&lt;String, FromUtf8Error&gt;</td>
                        <td>Converts vector of bytes to String.  Returns error if invalid UTF-8</td>
                      </tr>
                      <tr>
                        <td>into_bytes(self) -> Vec&lt;u8&gt;</td>
                        <td>Convert to Vec of bytes</td>
                      </tr>
                      <tr>
                        <td>as_bytes(&self) -> &[u8]</td>
                        <td>Returns byte slice</td>
                      </tr>
                      <tr>
                        <td>is_char_boundary(&self, n: usize) -> bool</td>
                        <td>Is this byte the start of a new UTF-8 character?</td>
                      </tr>
                      <tr>
                        <td>More methods ...</td>
                        <td><a href="https://doc.rust-lang.org/std/string/struct.String.html">std::string::String</a></td>
                      </tr>
                    </table>
                    </div>
                </t-b>
                <t-b>
                  <div>
                    <details>
                      <summary class="darkItem">String Examples:</summary>
                      <s-halfEm></s-halfEm>
                      <defn-outerBlock>
                        <defn-block>
                          <defn-head>demo_string</defn-head>
                          <defn-code>
  print!("\n  === demo_string ===");
  let s1 : String = String::from("a test string");
  show_type_value("s1", &s1);
  print!("\n  -- iterating through String characters --");
  let iter = s1.chars();
  print!("\n  ");
  for ch in iter {
      print!("{} ", ch);
  }
  print!("\n  -- extracting bytes --");
  let s1_bytes = s1.as_bytes();
  print!("\n  bytes are:");
  show_fold(&s1_bytes, 5, 5);
  // This works too, will wrap in []
  // print!("\n  bytes are: {:?}", b"a test string");
  
  print!("\n  -- extracting a slice --");
  let slc = &s1[0..6];
  show_type_value("&s1[0..6]", &slc);
                          </defn-code>
                        </defn-block>
                        <defn-block>
                          <defn-head>Output:</defn-head>
                          <defn-code>
  cargo run -q
  
  === demo_string ===
  value of s1 = "a test string"
  type is: &alloc::string::String
  -- iterating through String characters --
  a   t e s t   s t r i n g
  -- extracting bytes --
  bytes are:
     97   32  116  101  115
    116   32  115  116  114
    105  110  103
  -- extracting a slice --
  value of &s1[0..6] = "a test"
  type is: &&str
  
  That's all Folks!
                        </defn-code>
                        </defn-block>
                      </defn-outerBlock>
                    </details>
                  </div>
                </t-b>
                <a id="format"></a>
                <s-halfEm></s-halfEm>
              </div>
              </div>
              <h3>4. String Formats</h3>
              <div class="indent">
                <t-b>
                  Rust provides a useful set of formatting facilities for console display:  
                  <a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a>
                  and for building formatted strings, using the format! macro:
                  <a href="https://doc.rust-lang.org/std/macro.format.html">std::format</a>
                </t-b>
                <t-b>
                  There is a little language associated with the formatting process that 
                  is well described in the references given here.  Using that and an 
                  extensive set of attributes, also presented in the docs, you can provide
                  very well organized information on the console, instead of a lot of raw 
                  data.
                </t-b>
              </div>
              <a id="vec"></a>
              <s-halfEm></s-halfEm>
            <h3>5. Vec&lt;T&gt;</h3>
              <div class="indent">
              	<t-b>
              	  The Vec&lt;T&gt;, found in std::vec::Vec, is an expandable,
              	  indexable,  
              	  array-like container with elements, t:T, stored in contiguous
              	  memory in the heap.  It&apos;s structure is very like that of
              	  std::String. 
              	</t-b>
              	<t-b>
              	  Vec&lt;T&gt; has member functions:
              	  <div style="width:calc(100vw - 12em);">
              	    <table>
              	      <tr>
              	        <th>member functions</th><th>operations</th>
              	      </tr>
              	      <tr>
              	        <td>new() -> Vec&lt;T&gt;</td>
              	        <td>Returns a new empty vector.</td>
              	      </tr>
              	      <tr>
              	        <td>push(&mut self, value: T)</td>
              	        <td>Appends value to vector contents</td>
              	      </tr>
              	      <tr>
              	        <td>pop(&mut self) -> Option&lt;T&gt;</td>
              	        <td>
              	          Removes last element and returns Some(t:T).
              	          If vector is empty returns None.
              	        </td>
              	      </tr>
              	      <tr>
              	        <td>insert(&mut self, n: usize, elem: T)</td>
              	        <td>Inserts elem at position n.  Panics if out of bounds.</td>
              	      </tr>
              	      <tr>
              	        <td>remove(&mut self, n: usize) -> T</td>
              	        <td>
              	          Removes and returns element at position n.
              	          Panics if n is out of bounds.
              	        </td>
              	      </tr>
              	      <tr>
              	        <td>clear(&mut self)</td>
              	        <td>Removes all elements from vector</td>
              	      </tr>
              	      <tr>
              	        <td>len(&self) -> usize</td>
              	        <td>Returns number of elements in vector</td>
              	      </tr>
              	      <tr>
              	        <td>swap(&mut self, m: usize, n: usize)</td>
              	        <td>
              	          Swaps elements at positions m and n.
              	          Panics if either m or n are out of bounds.
              	        </td>
              	      <tr>
              	        <td>as_slice(&self) -> &[T]</td>
              	        <td>Returns slice containing all elements of vector</td>
              	      </tr>
              	      <tr>
              	        <td class="no-wrap">as_mut_slice(&mut self) -> &mut [T]</td>
              	        <td>Returns mutable slice with all elements of vector</td>
              	      </tr>
              	      </tr>
              	    </table>
              	    </div>
              	</t-b>
              	<t-b>
              	  <div>
              	    <details>
              	      <summary class="darkItem">Vec Examples:</summary>
              	      <s-halfEm></s-halfEm>
              	      <defn-outerBlock>
              	        <defn-block>
              	          <defn-head>demo_vec_int</defn-head>
              	          <defn-code>
print!("\n  === demo_vec_int ===");

let mut vec = vec![1, 2, 3, 4, 5];
show_coll(&vec);

print!("\n  -- assign vectors --");
vec = vec![5, 4, 3, 2, 1];
show_coll(&vec);

print!("\n  -- replace element --");
vec[1] = -4;
show_coll(&vec);

print!("\n  -- pop and push element --");
let _elem = vec.pop();
vec.push(42);
show_coll(&vec);

print!("\n  -- insert element --");
vec.insert(1, -42);
show_coll(&vec);

print!("\n  -- remove element --");
vec.remove(2);
show_coll(&vec);

print!("\n  -- extract full slice --");
let array = &vec[..];  // full slice
show_coll(&array);

print!("\n  -- extract partial slice --");
let array = &vec[1..4];  // partial slice
show_coll(&array);

print!("\n  -- build from string --");
let vec = Vec::from("a string");
show_coll(&vec);

print!("\n  -- iterate over vector --");
print!("\n  ");
for ch in vec {
    print!("{}", ch as char);
}
              	      </defn-code>
              	        </defn-block>
              	        <defn-block>
              	          <defn-head>Output:</defn-head>
              	          <defn-code>
cargo run -q

=== demo_vec_int ===
1, 2, 3, 4, 5
-- assign vectors --
5, 4, 3, 2, 1
-- replace element --
5, -4, 3, 2, 1
-- pop and push element --
5, -4, 3, 2, 42
-- insert element --
5, -42, -4, 3, 2, 42
-- remove element --
5, -42, 3, 2, 42
-- extract full slice --
5, -42, 3, 2, 42
-- extract partial slice --
-42, 3, 2
-- build from string --
97, 32, 115, 116, 114, 105, 110, 103
-- iterate over vector --
a string

That's all Folks!
              	        </defn-code>
              	        </defn-block>
              	      </defn-outerBlock>
              	    </details>
              	  </div>
              	</t-b>
              	<a id="map"></a>
              	<s-halfEm></s-halfEm>
              </div>
              <h3>6. HashMap&lt;K, V&gt;</h3>
              <div class="indent">
              	<t-b>
              	  The Map&lt;K, V&gt;, found in std::collections::HashMap, is a hash table structure,
              	  indexable by key:K, with associated value:V. Each HashMap item, { k:k, v:V } is stored in a 
              	  bucket - linked list in the heap - of items which all have the same hash value for k. If the table is not 
              	  densely populated the bucket list is short.  So retrieval is nearly constant time, the time 
              	  required to evaluate hash(k).
              	</t-b>
              	<t-b>
              	  HashMap&lt;K, V&gt; has member functions:
              	  <div style="width:calc(100vw - 12em);">
              	    <table class="fixed">
              	      <tr>
              	        <th style="width:40%;">member functions</th><th>operations</th>
              	      </tr>
              	      <tr>
              	        <td>new() -> HashMap&lt;K, V&gt;</td>
              	        <td style="white-space: normal;">Returns a new empty hash table.</td>
              	      </tr>
              	      <tr>
              	        <td>insert(&mut self, k: K, v: V) -> Option&lt;V&gt;</td>
              	        <td style="white-space: normal;">
              	          Inserts key-value pair into map.  If k already existed the old value is replaced by v and returns the old value,
              	          otherwise the pair is inserted into the hash table and returns None.
              	        </td>
              	      </tr>
              	      <tr>
              	        <td>remove(&mut self, k: &Q) -> Option&lt;V&gt;<br />where K: Borrow&lt;Q&gt;, Q: Hash + Eq</td>
              	        <td style="white-space: normal;">
              	          Removes key from map, returning value if key was in map.
              	          If vector is empty returns None.
              	        </td>
              	      </tr>
              	      <tr>
              	        <td>clear(&mut self)</td>
              	        <td style="white-space: normal;">Removes all key-value pairs, retains allocated table size</td>
              	      </tr>
              	      <tr>
              	        <td>contains_key&lt;Q: ?Sized&gt;(&self, k: &Q) -> bool</td>
              	        <td style="white-space: normal;">
              	          Returns true if map contains k.
              	        </td>
              	      </tr>
              	      <tr>
              	        <td>
              	          get_key_value&lt;Q: ?Sized&gt;(&mut self, k: &Q) -> Option&lt;(&K, &V)&gt;<br />
              	          where K: Borrow&lt;Q&gt;, Q: Hash + Eq
              	        </td>
              	        <td>Returns key-value pair for the supplied key.</td>
              	      </tr>
              	      <tr>
              	        <td>get&lt;Q: ?Sized&gt;(&self, k: &Q) -> Option&lt;&V&gt;</td>
              	        <td style="white-space: normal;">Returns reference to the value for k</td>
              	      </tr>
              	      <tr>
              	        <td>is_empty(&self) -> bool</td>
              	        <td style="white-space: normal;">Returns true if map contains no elements</td>
              	      <tr>
              	        <td>iter(&self) -> Iter&lt;K, V&gt;</td>
              	        <td style="white-space: normal;">Returns iterator that visits all elements in arbitrary order</td>
              	      </tr>
              	      <tr>
              	        <td>iter_mut(&mut self) -> IterMut&lt;K, V&gt;</td>
              	        <td style="white-space: normal;">
              	          Returns iterator that visits all elements in arbitrary order, returning mutable references.
              	        </td>
              	      </tr>
              	      <tr>
              	        <td>keys(&self) -> Keys&lt;K, V&gt;</td>
              	        <td style="white-space: normal;">Returns an iterator visiting all keys in arbitrary order</td>
              	      </tr>
              	      <tr>
              	        <td>values(&self) -> Values&lt;K, V&gt;</td>
              	        <td style="white-space: normal;">Returns an iterator visiting all values in arbitrary order</td>
              	      </tr>
              	      <tr>
              	        <td>values_mut(&mut self) -> ValuesMut&lt;K, V&gt;</td>
              	        <td style="white-space: normal;">Returns an iterator visiting all values mutably in arbitrary order</td>
              	      </tr>
              	      <tr>
              	        <td>More methods ...</td>
              	        <td style="white-space: normal;"><a href="https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html">HashMap</a></td>
              	      </tr>
              	    </table>
              	    </div>
              	</t-b>
              	<t-b>
              	  <div>
              	    <details>
              	      <summary class="darkItem">Map Examples:</summary>
              	      <s-halfEm></s-halfEm>
              	      <defn-outerBlock>
              	        <defn-block>
              	          <defn-head>collections::main.rs -> demo_map</defn-head>
              	          <defn-code>
#![allow(dead_code)]
use std::fmt::Debug;
use std::any::*;
/*-----------------------------------------------------------
    Display comma separated list of collection items
    - shows how to build function accepting iterable 
      collections
    - returns Option::None if collection is empty
*/
fn show_coll&lt;C&gt;(c:&amp;C) -&gt; Option&lt;()&gt; 
  where C:IntoIterator + Clone + Debug, C::Item: Debug {

    let mut iter = c.clone().into_iter();
    /*-------------------------------------------
      returns Option if no next element using 
      ? try operator
    */
    print!("\n  {:?}", iter.next()?);
    /*-- breaks when no next element --*/
    for item in iter {
        print!(", {:?}", &amp;item);
    }
    Some(())
}

// code elided

fn demo_map() {
    print!("\n  -- demo_map --");
    let mut m = std::collections::HashMap::&lt;u8, String&gt;::new();
    m.insert(0, String::from("zero"));
    m.insert(1, String::from("one"));
    m.insert(2, String::from("two"));
    m.insert(3, String::from("three"));

    print!("\n  Iterating through map:",);
    let iter = m.iter();
    print!("\n  {{ ");
    for item in iter {
        print!("{:?} ", item);
    }
    print!("}}");
    print!("\n  using show_coll(&amp;m):",);
    show_coll(&amp;m);
    print!("\n  displaying keys:",);
    let v:Vec&lt;&amp;u8&gt; = m.keys().collect();
    show_coll(&amp;v);
    print!("\n  displaying values:",);
    let v:Vec&lt;&amp;String&gt; = m.values().collect();
    show_coll(&amp;v);
    print!("\n  removing item with k == 2");
    m.remove(&amp;2);
    show_coll(&amp;m);
    print!("\n  value for k == 3 is {:?}",m[&amp;3]);
}

fn main() {

    // code elided

    demo_map();

    println!("\n\n  That's all Folks!\n\n");
}
              	          </defn-code>
              	        </defn-block>
              	        <defn-block>
              	          <defn-head>Output:</defn-head>
              	          <defn-code>
cargo run -q

  -- demo_map --
  Iterating through map:
  { (1, "one") (3, "three") (2, "two") (0, "zero") }
  using show_coll(&m):
  (1, "one"), (3, "three"), (2, "two"), (0, "zero")
  displaying keys:
  1, 3, 2, 0
  displaying values:
  "one", "three", "two", "zero"
  removing item with k == 2
  (1, "one"), (3, "three"), (0, "zero")
  value for k == 3 is "three"

  That's all Folks!
              	        </defn-code>
              	        </defn-block>
              	      </defn-outerBlock>
              	    </details>
              	  </div>
              	</t-b>
              	<t-b>
              	  Strings, Arrays, Vecs, and HashMaps are the most commonly used Rust containers, but there are other useful collections
              	  as well, listed below. 
              	  <a id="collect"></a>
              	  <s-halfEm></s-halfEm>
              	</t-b>
              </div>
              <h3>7. Other Collections:</h3>
              <t-b class="indent">
                  All documentations for the Rust collections are very well written - clear and accompanied by examples.
              </t-b>
              <t-b>
                <div>
                  <ul class="tight">
                    <li><a href="https://doc.rust-lang.org/beta/std/collections/">std::collections</a></li>
                    <li><a href="https://doc.rust-lang.org/beta/std/collections/struct.VecDeque.html">VecDeque</a></li>
                    <li><a href="https://doc.rust-lang.org/beta/std/collections/struct.LinkedList.html">LinkedList</a></li>
                    <li><a href="https://doc.rust-lang.org/beta/std/collections/struct.BTreeMap.html">BTreeMap</a></li>
                    <li><a href="https://doc.rust-lang.org/beta/std/collections/struct.HashSet.html">HashSet</a></li>
                    <li><a href="https://doc.rust-lang.org/beta/std/collections/struct.BTreeSet.html">BTreeSet</a></li>
                    <li><a href="https://doc.rust-lang.org/beta/std/collections/struct.BinaryHeap.html">BinaryHeap</a></li>
                  </ul>
                </div>
                <t-b class="indent">
                  You can easily view source code for all these collections (and all of the other libraries).  Just click
                  one of the links above, look for [src] and click.
                </t-b>
                <a id="exer"></a>
                <s-halfEm></s-halfEm>
              </t-b>
            </div>
            <div>
              <h3>8. Exercises</h3>
              <ol class="tight">
                <li>
                  Create an array of i32 elements and, using an iterator, display the odd numbers.
                </li>
                <li>
                  Create a String instance that contains some UTF-8 characters that are larger
                  than 1 byte and some that are larger than 2 bytes.  Now iterate over the string, 
                  displaying each character and  its byte count.
                  <div class="indent pad5">
                    You will probably need to do a little research on UTF-8 to find samples of
                    non-ASCII characters for this exercise.
                  </div>
                </li>
                <li>
                  In a Vec of tuples, record your immediate family members and their relationship
                  to you.  Display this collection.  Now, convert that to a HashMap and again 
                  display the collection.
                  <div class="indent pad5">
                    Use String formatting to make the displays well organized into fixed-width 
                    fields.
                  </div>
                </li>
              </ol>
            </div>
          </div>
        </div>
      </bb-55>
  </body>
</html>
