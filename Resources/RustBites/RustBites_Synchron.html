<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Synch</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <link rel="stylesheet" href="css/BiteTables.css" />
    <link rel="stylesheet" href="css/StylesWebComponents.css" />
    <script src="js/ScriptsWebComponents.js"></script>
    <script src="js/BiteScripts.js"></script>
    <script src="js/ScriptsKeyboard.js"></script>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <span class="top-center">Synchronization</span>
    </div>
    <next-prev>
      <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
      <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
      <a id="Prev" href="RustBites_Threads.html">prev</a> 
      <a id="Next" href="RustBites_Channels.html">next</a>
    </next-prev>

    <toc-b id="toc">
      <div id="bottom-menu" style="display:flex; flex-direction:row">
      </div>
        <up-b id="chaps">
        </up-b>
          <rt-b id="sects">
        <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#starting">Starting</a>, 
        <a href="#contents">Contents</a>, <a href="#refs">References</a>
      </rt-b>
    </toc-b>
    <div id="hlp" style="display:none;">
    </div>
   
    <h2>Rust Bite - Synchronization</h2>
    <t-b><hr /></t-b>
    <t-b>
      Synchronization is the process of ensuring that, in a multi-threaded program, each thread gets exclusive
      access to a shared resource, usually by locking with a synchronization type.  The common synchronization
      types are listed in Table 1., below.
    </t-b>
    <t-b>
      <h4>Table 1. - Common Synchronization Types</h4>
      <table>
        <tr>
          <th>Type</th><th>Description</th>
        </tr>
        <tr>
          <td>
            <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">Mutex&lt;T&gt;</a>
          </td>
          <td>
            A mutual exclusion primitive useful for protecting shared data.
          </td>
        </tr>
        <tr>
          <td>
            <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html">RwLock&lt;T&gt;</a>
          </td>
          <td>
            A reader-writer lock allowing multiple readers or at most one writer at any point in time.
          </td>
        </tr>
        <tr>
          <td>
            <a href="https://doc.rust-lang.org/std/sync/struct.Condvar.html">Condvar</a>
          </td>
          <td>
            A Condition Variable blocks threads waiting on an event to occur.
          </td>
        </tr>
        <tr>
          <td>
            <a href="https://doc.rust-lang.org/std/sync/atomic/">Atomic</a>
          </td>
          <td>
            Atomic types provide primitive shared-memory communication between threads.
          </td>
        </tr>
        <tr>
          <td>
            <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc&lt;T&gt;</a>
          </td>
          <td>
            A thread-safe reference-counting pointer. Arc is used to enable sharing of guarded resources
            in programs with multiple threads.
            <div style="height:0.25rem;"></div>
          </td>
        <tr>
          <td>
            <a href="https://doc.rust-lang.org/std/sync/struct.Barrier.html">Barrier</a>
          </td>
          <td>
            A barrier enables multiple threads to synchronize the beginning of some computation.
            <div style="height:0.25rem;"></div>
          </td>
        </tr>
        </tr>
      </table>
    </t-b>
    <div>
      <details>
        <summary class="darkItem">Mutex Example</summary>
        <defn-OuterBlock>
          <defn-block>
            <defn-head>Mutex Example</defn-head>
            <defn-code>
// Demonstrate threads sharing string resource 
#![allow(unused_imports)]
#![allow(dead_code)]

use std::thread;
use std::sync::{Mutex, RwLock, Condvar, Arc};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;

fn test_mutex() {
    /* define shared resource */
    let s = String::new();
    let share = Arc::new(Mutex::new(s));

    /* define reader processing */
    static RID:AtomicUsize = AtomicUsize::new(0usize);

    let rd_cls = |shared:Arc&lt;Mutex&lt;String&gt;&gt;| {
        /* fetch_add returns old value */
        let my_id = RID.fetch_add(1, Ordering::SeqCst) + 1;
        let dur = Duration::from_millis(2);
        for _i in 0..10 {
            if let Ok(temp) = shared.lock() {
                print!(
                    "\n  reader {} : str len = {}", 
                    my_id, temp.len()
                );
            }
            thread::sleep(dur);
        }
    };

    /* start readers */
    let shared = Arc::clone(&share);
    let handle1 = thread::spawn(move || { rd_cls(shared); });
    
    let shared = Arc::clone(&share);
    let handle2 = thread::spawn(move || { rd_cls(shared); });
    
    /* define writer processing */
    static WID:AtomicUsize = AtomicUsize::new(2usize);

    let wr_cls = |shared:Arc&lt;Mutex&lt;String&gt;&gt;| {
        /* fetch_add returns old value */
        let my_id = WID.fetch_add(1, Ordering::SeqCst) + 1;
        let dur = Duration::from_millis(2);
        for _i in 0..10 {
            if let Ok(mut temp) = shared.lock() {
                let digit = my_id.to_string();
                temp.push_str(digit.as_str());
                print!(
                    "\n  writer {} : str len = {}", 
                    my_id, temp.len()
                );
            }
            thread::sleep(dur);
        }
    };

    /* start writers */
    let shared = Arc::clone(&share);
    let handle3 = thread::spawn(move || { wr_cls(shared); });

    let shared = Arc::clone(&share);
    let handle4 = thread::spawn(move || { wr_cls(shared); });

    /* main thread waits for children to finish */
    let _ = handle1.join();
    let _ = handle2.join();
    let _ = handle3.join();
    let _ = handle4.join();

    /* lock will fail if thread holding lock panics */
    if let Ok(mod_str) = share.lock() {
        print!("\n  modified string: {:?}", mod_str);
    };  
    /* semicolon needed to ensure mod_str lives long enough */
}

fn main() {
    test_mutex();
}
              </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output</defn-head>
            <defn-code>
  reader 1 : str len = 0
  reader 1 : str len = 0
  reader 1 : str len = 0
  reader 1 : str len = 0
  writer 3 : str len = 1
  reader 2 : str len = 1
  writer 4 : str len = 2
  reader 1 : str len = 2
  writer 3 : str len = 3
  reader 1 : str len = 3
  writer 4 : str len = 4
  reader 2 : str len = 4
  writer 3 : str len = 5
  reader 1 : str len = 5
  writer 4 : str len = 6
  reader 2 : str len = 6
  writer 3 : str len = 7
  reader 1 : str len = 7
  writer 4 : str len = 8
  reader 2 : str len = 8
  reader 1 : str len = 8
  writer 3 : str len = 9
  writer 4 : str len = 10
  reader 2 : str len = 10
  reader 1 : str len = 10
  writer 4 : str len = 11
  reader 2 : str len = 11
  writer 4 : str len = 12
  reader 2 : str len = 12
  writer 3 : str len = 13
  writer 4 : str len = 14
  reader 2 : str len = 14
  writer 3 : str len = 15
  writer 4 : str len = 16
  reader 2 : str len = 16
  writer 3 : str len = 17
  writer 4 : str len = 18
  reader 2 : str len = 18
  writer 3 : str len = 19
  writer 3 : str len = 20
  modified string: 
      "34343434344434343433"  
            
            </defn-code>
          </defn-block>
        </defn-OuterBlock>
      </details>
    </div>
    <t-b>
      <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c295752fef36c089b16cc8ac0d7402fa">
        mutex demo in playground
      </a>
    </t-b>
  </body>
</html>
