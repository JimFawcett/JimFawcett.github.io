<!DOCTYPE html>
<html id="top">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Data</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <link rel="stylesheet" href="css/StylesWebComponents.css" />
    <script src="js/BiteScripts.js"></script>
    <script src="js/ScriptsWebComponents.js"></script>
    <style>
      th, td {
        padding:5px;
      }
    </style>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
      <span id="hctr">Consuming Rust Bite by Byte</span>
      <div style="position:relative; left:calc(100vw - 15rem);">
        <span class="top-center">Data</span>
        <!-- <a class="top-right" href="../../RustBiteByByte.html">RustBiteByByte.html</a> -->
      </div>
  </div>
  <next-prev>
    <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp;
    <a id="repo" href="../../RustBiteByByte.html">Repo</a> 
    <a id="prev" href="RustBites_UDB.html">prev</a> 
    <a id="next" href="RustBites_DataStr.html">next</a>
  </next-prev>

    <toc-b id="toc">
      <div style="display:flex; flex-direction:row">
        <a href="Javascript:;" onclick="storyMenu.sects()" style="color: #fefefa; ">Sects</a>&nbsp;
        <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
        <!-- <a href="../../RustBiteByByte.html" style="color:#fefefa;">Repo</a>&nbsp; -->
        <!-- <a href="../../index.html" style="color:#fefefa;">Home</a>&nbsp; -->
        <!-- <a href="Javascript:;" onclick="storyMenu.toggleTOC()" style="color:#fefefa;">esc</a>&nbsp; -->
        <!-- <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Close</a>&nbsp; -->
      </div>
    <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
      <up-b id="chaps">
        <a href="RustBites_Facts.html">Facts</a><br />
        <a href="RustBites_Intro.html">Introduction</a><br />
        <a href="RustBites_UDB.html">UndefBehavior</a><br />
        <a href="RustBites_Data.html">Data</a><br />
        <a href="RustBites_DataStr.html">DataStructs</a><br />
        <a href="RustBites_SmrtPtrs.html">SmartPtrs</a><br />
        <a href="RustBites_LifeCycle.html">LifeCycle</a><br />
        <a href="RustBites_Ownrs.html">Ownership</a><br />
        <a href="RustBites_Traits.html">Generics&Traits</a><br />
        <a href="RustBites_Functs.html">Functions</a><br />
        <a href="RustBites_Structs.html">Structs</a><br />
        <a href="RustBites_LifeTime.html">LifeTime</a><br />
        <a href="RustBites_Abstract.html">Abstractions</a><br />
        <a href="RustBites_ErrHnd.html">ErrHandling</a><br />
        <a href="RustBites_Collects.html">Collections</a><br />
        <a href="RustBites_Iterator.html">Iterators</a><br />
        <a href="RustBites_Threads.html">Threads</a><br />
        <a href="RustBites_Synchron.html">Synchronize</a><br />
        <a href="RustBites_Channels.html">Channels</a><br />
        <a href="RustBites_AsyncAwt.html">AsyncAwait</a><br />
        <a href="RustBites_Macros.html">Macros</a><br />
        <a href="RustBites_TipsAndTricks.html">Hacks and Helpers</a><br />
        <!-- <a href="RustBites_Generics.html">Generics</a><br /> -->
        <!-- <a href="RustBites_Intmut.html">InterMutat</a><br /> -->
        <a href="Javascript.;#"></a><br />
      </up-b>
    <rt-b id="sects">
        <a href="#top">Top</a>, <a href="#goal">goal</a>, <a href="#types">types</a>, <a href="#bind_val">bind val</a>,
        <a href="#bind_id">bind id</a>, <a href="#assign">assign</a>, 
        <a href="#copy_borrow">copy borrow</a>, <a href="#traits">traits</a>,
        <a href="#move_clone">move clone</a>, <a href="#mutate">mutate</a>, <a href="#summary">summary</a>, 
        <a href="#fmt">fmt</a>, <a href="#concl">Concl</a> <a href="#exer">exer</a>, <a href="#sln">sln_#1</a>
      </rt-b>
    </toc-b>
    <div id="hlp" style="display:none;">
      <table>
        <tr>
          <td style="padding-right:5px;">Esc</td>
          <td>toggle menus</td>
        </tr>
        <tr>
          <td>C</td>
          <td>close menus</td>
        </tr>
        <tr>
          <td>R</td><td>Refresh</td>
        </tr>
        <tr>
          <td>N</td><td>Next Bite</td>
        </tr>
        <tr>
          <td>P</td><td>Prev Bite</td>
        </tr>
      <tr>
          <td>T</td><td>scroll to top</td>
        </tr>
        <tr>
          <td>B</td><td>scroll to bottom</td>
        </tr>
        <tr>
          <td>H</td><td>Help</td>
        </tr>
      </table>
      </div>
  
      <bb-55>
        <h1>Rust Bite - Data</h1>
        <hr />
        <a id="goal"></a>
      <t-b>
        In this bite, we focus on basic data operations:
      </t-b>
      <t-b>
        <div>
          <div>
            <h3>1. Our goal is to understand the terms:</h3>
            <div class="indent">
              <table>
                <tr>
                  <td>-</td>
                  <td>Bind:</td>
                  <td>Associate an identifier with a value</td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>copy:</td>
                  <td>
                    Bind to a copy of the value of a blittable type, executed implicitly by compiler 
                    generated code, by copying bytes from source to destination location. Fast.
                  </td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>borrow:</td>
                  <td>
                    Create a named pointer to an identifier&apos;s location.  Pointers used for borrows must 
                    satisfy Rust&apos;s ownership rules, discussed in an upcoming Bite.  Borrows are the only
                    pointers that can be dereferenced in safe code.
                  </td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>Move:</td>
                  <td>
                    Transfer ownership of a type&apos;s resources, usually executed implicitly. 
                    Accomplished by creating, for the destination, a pointer to the source&apos;s 
                    resources (data allocated on the heap), and invalidating the source pointer.
                    Fast.
                  </td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>Clone:</td>
                  <td>Create a copy of a non-blittable type, invoked by program code. Slower.</td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>mutate:&nbsp;</td>
                  <td>Change the value associated with a mutable identifier.</td>
                </tr>
              </table>
              </div>
              <a id="types"></a>
              <s-1em></s-1em>
            </div>
          <div>
            <h3>2. Rust Types</h3>
            <div class="indent">
              <t-b>
                First, we need to say a few words about Rust types:
                <div class="indent pad10">
                  A type is set of allowed values and operations that are legal for the set.
                </div>
                The <strong>Rust language</strong> defines a rich set of primitive types:
                <div class="pad10">
                  <table>
                    <tr>
                      <td>-</td>
                      <td>bool</td>
                      <td></td>
                    </tr>
                    <tr>
                      <td>-</td>
                      <td>char (utf-8)</td>
                      <td></td>
                    </tr>
                    <tr>
                      <td>-</td>
                      <td>integers:</td>
                      <td>i8, i16, i32, i64, isize, u8, u16, u32, u64, usize</td>
                    </tr>
                    <tr>
                      <td>-</td>
                      <td>floats:</td>
                      <td>f32, f64</td>
                    </tr>
                    <tr>
                      <td>-</td>
                      <td>
                        aggregates:
                      </td>
                      <td>
                        array: [T;N], slice: [T], str: literal string "....", tuple: (T1, T2, ...),
                        struct { T1, T2, ... }
                      </td>
                    </tr>
                  </table>
                </div>
                <t-b class="top">
                  Assuming that T is a primitive type
                  these each occupy a contiguous block of memory.  The size of each depends on the type.
                  They all can be
                  copied by a memcpy operation, e.g., they are blittable, again, provided that T is primitive.
                  Rust uses the terms &quot;Copy trait&quot; for blittability. We say the Rust primitives are all <strong>Copy types</strong>.
                </t-b>
                <t-b>
                  The <strong>Rust Libraries</strong> define a large set of non-primitive types:
                  <table>
                    <tr>
                      <td>-</td>
                      <td>String</td>
                      <td>a stack-based object holding a collection of utf-8 chars in the heap</td>
                    </tr>
                    <tr>
                      <td>-</td>
                      <td>Vec&lt;T&gt;</td>
                      <td>very like a String, but holding a heap-based collection of an arbitrary type, T</td>
                    </tr>
                    <tr>
                      <td>-</td>
                      <td>VecDeque&lt;T&gt;</td>
                      <td>
                        stack-based object holding a heap-based collection of T objects with efficient access to both front and back
                      </td>
                    </tr>
                    <tr>
                      <td>-</td>
                      <td>Map&lt;K, V&gt;:</td>
                      <td>an associative container holding key-value pairs in the heap</td>
                    </tr>
                    <tr>
                      <td>-</td>
                      <td>...</td>
                      <td></td>
                    </tr>
                  </table>
                </t-b>
                <t-b>
                  These each occupy more than one contiguous block of memory and so cannot be blitted.  Rust uses the terms
                  &quot;Move trait&quot; for types that are not blittable.  They can be moved, but not copied.  We say they are
                  <strong>Move types</strong>.
                </t-b>
                <t-b>
                  User defined types may be either Copy or Move depending on whether they occupy one contiguous block of
                  memory or not.  No type can be both.
                </t-b>
              </t-b>
              <t-b>
                The Rust Story contains more details on Rust types with examples:
                <a href="https://JimFawcett.github.io/RustStory_Data.html">Rust types</a>
              </t-b>
              <a id="bind_val"></a>
              <s-1em></s-1em>
            </div>
          <div>
        </div>            
            <h3>3. Binding to a Value</h3>
            <div class="indent">
              Bind - associate an identifier with a memory location
              <ul class="tight">
                <li>
                  Remember, a type is a set of legal values with associated operations.
                </li>
                <li>
                  Every identifier has a type:
                  <div class="indent pad5">
                    <c-s>let k: i32 = 42;</c-s><br />
                  </div>
                  let signifies a binding is being created.
                  <c-s>i32</c-s> is the type of a 32 bit integer.
                  42 is a value placed in the memory location associated with k
                </li>
                <li>
                  Type inference:
                  <div class="indent pad5">
                    <c-s>let k = 42;</c-s><br />
                  </div>
                  This binding is legal and has the same meaning as the previous binding.
                  In lieu of other information, Rust will assign the type i32 to any unadorned
                  integral value that can be correctly written to a 32 bit location.
                </li>
              </ul>
              <a id="bind_id"></a>
              <s-1em></s-1em>
            </div>
          <div>
        </div>            
            <h3>4. Binding to an identifier</h3>
            <div class="indent">
              Binding to an identifier has several forms:
              <ul class="tight">
                <li>
                  <c-s>let j:i32 = k;    // makes copy for j because k is blittable</c-s>
                </li>
                <li>
                  <c-s>let l = &amp;k;&nbsp;&nbsp;&nbsp;&nbsp;// l makes a reference to k, called a borrow</c-s>
                </li>
                <li>
                  <c-s>let s:String = "a string".to_string();</c-s>
                </li>
                <li>
                  <c-s>
                    let t = s; &nbsp;&nbsp;&nbsp;&nbsp;// moves s into t, e.g., transfers ownership
                    as s is not blittable
                  </c-s>
                </li>
              </ul>
              <t-b>
                Both sides of a binding expression must be of the same type.  Rust will not implicitly convert
                types.
              </t-b>
              <a id="assign"></a>
              <s-1em></s-1em>
             <h3>5. Assignment</h3>
             <div class="indent">
              <t-b>
                As in many languages, assignment in Rust is an expression like:
                <ul>
                  <li><c-s>x = y; &nbsp;// copy if x and y are Copy types, y is valid after assignment</c-s></li>
                  <li><c-s>t = s; &nbsp;// move if s and t are Move types, s is invalid after assignment</c-s></li>
                </ul>
                <t-b>
                  Both sides of an assignment expression must be of the same type.
                </t-b>
              </t-b>
              <a id="copy_borrow"></a>
              <s-1em></s-1em>
            </div>
            <h3>6. Copy and Borrow</h3>
            <div class="indent">
              <t-b>
                Borrows are non-owning references pointing to an identifier.
              </t-b>
              <ul class="tight" style="margin-left:0em;">
                <li>
                  Copies happen implicitly when an identifier is bound to a Copy type:
                  <div class="indent pad5">
                    <c-s>let i = 3;  let j = i;  &nbsp;&nbsp;// copy</c-s>
                  </div>
                  or when one copy type is assigned to another:
                  <div class="indent pad5">
                    <c-s>j = i + 1;  &nbsp;&nbsp;// copy</c-s>
                  </div>
                </li>
                <li>
                  Borrows happen when binding references to other identifiers:
                  <div class="indent pad5">
                    <c-s>let r = &amp;i  &nbsp;&nbsp;// borrow;</c-s>
                  </div>
                  A reference, like <c-s>&amp;i</c-s>, is just a pointer to the memory location
                  bound to i.  It cannot be reset, and is subject to Rust ownership rules, which
                  we will discuss soon, in a later <a href="RustBites_Ownrs.html">Bite</a>.
                </li>
              </ul>
              <a id="traits"></a>
              <s-1em></s-1em>
            <div>
            <h3>7. Copy, Move, and Clone Traits</h3>
            <div class="indent">
              <div style="width:calc(100vw - 12rem);">
                <div class="right">
                  <photosizer-block src="../../Pictures/StringMove.jpg" width="400" class="photoSizerBlock" style="margin-top:0;">
                    <span style="
                  display: inline-block;
                  font-weight: bold;
                  font-family: 'Comic Sans MS, Tahoma';
                  background-color: #ddd;
                  width: 100%;
                  padding: 5px 0px;
                ">
                      Figure 1. String Move
                    </span>
                  </photosizer-block>
                  <!-- <div style="width:calc(100vw - 12rem);"> -->
                  <photosizer-block src="../../Pictures/StringClone.jpg" width="400" class="photoSizerBlock right" style="margin-top:0;">
                    <span style="
                  display: inline-block;
                  font-weight: bold;
                  font-family: 'Comic Sans MS, Tahoma';
                  background-color: #ddd;
                  width: 100%;
                  padding: 5px 0px;
                ">
                      Figure 2. String Clone
                    </span>
                  </photosizer-block>
                </div>
              </div>
              <t-b>
                Traits are like interface contracts.  They specify a behavior that a type must implement
                if it has that trait.
              </t-b>
              <t-b>
                Copy types are types that implement the Copy trait.
                <ul class="tight" style="margin-left:0em;">
                  <li>
                    To be elibible for the Copy trait
                    they must be blittable.
                  </li>
                </ul>
              </t-b>
              <t-b>
                Move types are types that don&apos;t implement the Copy trait.
                <ul class="tight" style="margin-left:0em;">
                  <li>
                    Move types are non-blittable, with one exception.
                  </li>
                  <li>
                    Adding the Drop trait makes a Move type, even if blittable.
                  </li>
                </ul>
              </t-b>
              <t-b>
                Clone types are types that implement the Clone trait.
                <ul class="tight" style="margin-left:0em;">
                  <li>
                    Data types with the Clone trait provide a clone() member function that creates
                    a new instance of the type that has the same structure and copies of any resources
                    held by the cloner.
                  </li>
                  <li>
                    Examples of Clone types are the collections, e.g., Strings, Vecs, VecDeques, Maps, ...
                  </li>
                </ul>
              </t-b>
              <a id="move_clone"></a>
              <s-halfEm></s-halfEm>
            </div>
            <h3>8. Move and Clone</h3>
            <ul>
              <li>
                A <strong>move</strong> transfers a Move type's heap resources to another instance of that type.
                <ul class="tight" style="margin-left:0em;">
                  <li>
                    The String, <s-s>s</s-s>, shown in Figure 1. is moved to <c-s>t</c-s>
                    with the statement:
                    <ul class="tight" style="margin-left:0em;">
                      <li><c-s>let t = s; &nbsp;&nbsp;// s is now invalid</c-s></li>
                    </ul>
                  </li>
                  <li>
                    Move transfers ownership of resources.
                  </li>
                </ul>
                <s-halfEm></s-halfEm>
              </li>
              <li>
                A <strong>clone</strong> copies a Move type&apos;s heap resources to a new instance of that type.
                <ul class="tight" style="margin-left:0em;">
                  <li>
                    The String, <s-s>s</s-s>, shown in Figure 2. is cloned with the statement:
                    <ul class="tight" style="margin-left:0em;">
                      <li><c-s>let t = s.clone(); &nbsp;&nbsp;// s is still valid</c-s></li>
                    </ul>
                  </li>
                  <li>
                    Clone operation copies resources to the target.
                  </li>
                </ul>
              </li>
            </ul>
            <a id="mutate"></a>
            <s-halfEm></s-halfEm>
          </div>
            <h3>9. Mutation</h3>
            <div class="indent">
              By default, Rust data is immutable - it can&apos;t be changed. Code has to opt in
              to mutation in order to change the value of an identifier.  We do that with the
              <c-s>mut</c-s> qualifier.
              <ul class="tight" style="margin-left:0em;">
                <li>
                  Immutable data:
                  <div class="indent pad5">
                    <c-s>
                      let i = 1;<br>
                      // i += 1;  won't compile
                    </c-s>
                  </div>
                </li>
                <li>
                  Mutable data:
                  <div class="indent pad5">
                    <c-s>
                      let mut j = 1;<br>
                      j += 1; // compiles since j is mutable
                    </c-s>
                  </div>
                </li>
              </ul>
              <t-b class="top">
                Mutability of data is an important part of Rust&apos;s
                <a href="RustBites_Ownrs.html">ownership</a> policies, designed to ensure memory safety.
                <a id="summary"></a>
                <s-halfEm></s-halfEm>
              </t-b>
            </div>
            <h3>10. Traits Preview:</h3>
            <div class="indent">
              <t-b>
                A trait specifies one or more function signatures that a type with that trait is obligated
                to implement.  Marker traits, like copy, are an exception, declaring no signature.  But they
                affect code generated by the compiler.
                Traits are used to constrain generic parameter types and to support
                dynamic dispatching in polymorphic designs.
              </t-b>
              <t-b>
                std::marker::Copy and std::clone::Clone are Traits defined by the standard library. There
                are many more, some of which we will meet in later Bites. Move is not one of them.
              </t-b>
              <t-b>
                I've included Move in this table because in some ways it acts like a trait.  The fact is
                that data is moved when constructing or assigning if and only if it is not Copy. So I
                think of Move as a trait even though you cannot use it to constrain generic types (more on
                that in the <a href="RustBites_Functs.html">Functs</a> Bite).
              </t-b>
              <div class="indents">
                <table border="1" style="padding:0px;">
                  <tr>
                    <th>Trait</th>
                    <th>Applies to:</th>
                    <th>Examples</th>
                    <th>Consequences</th>
                  </tr>
                  <tr>
                    <td>Copy</td>
                    <td>
                      Single contiguous memory block<br />
                      ==> blittable
                    </td>
                    <td>
                      ints, floats,
                      aggregates of Copy types
                    </td>
                    <td>
                      Copys value from one memory location to another.
                      <strong>Source valid after copy</strong>
                    </td>
                  </tr>
                  <tr>
                    <td>Move</td>
                    <td>
                      non-contiguous block<br />
                      ==> not blittable
                    </td>
                    <td>
                      Strings, Vecs, VecDeques, ...<br />
                      aggregates holding at least one Move type
                    </td>
                    <td>
                      Transfers data ownership to another identifier.
                      <strong>Source invalid after move</strong>
                    </td>
                  </tr>
                  <tr>
                    <td>Clone</td>
                    <td>most types</td>
                    <td>
                      ints, floats,
                      Structs, Strings, Vecs, VecDeques, ...
                    </td>
                    <td>
                      Makes copy of resources for another identifier.
                      <strong>Source valid after clone</strong>
                    </td>
                  </tr>
                </table>
              </div>
              <t-b class="bottom">
                <a id="fmt"></a>
                <s-halfEm></s-halfEm>
              </t-b>
            </div>
            <h3>11. Formatting Data</h3>
            <div class="indent">
              <t-b>
                Much of the data generated in Rust code will windup being formatted for display
                or for building strings.  We do that with print! and format! macros, that take
                format specifications like this:
              </t-b>
              <t-b>
                <defn-block>
                  <defn-head>Format Specifiers:</defn-head>
                  <defn-code style="font-size:0.9em;">
let arg1 = "abc";
let arg2 = 123
let s: String = format!("\n  {:?} and {}", arg1, arg2);
                  </defn-code>
                </defn-block>
              </t-b>
              <t-b>
                The last line contains a format operation using the format! macro. The &quot;<c-s>{xx}</c-s>&quot;
                are placeholders for format specifications.  The first, <c-s>{:?}</c-s> specifies the
                value of arg1 is to be formatted using the debug specifier, e.g., a relatively simple
                format known to most Rust library and user-defined types.  The second, <c-s>{}</c-s>
                specifies that a custom display format is to be used - because it doesn&apos;t hold a
                specifier.
              </t-b>
              <t-b>
                There are a lot of predefined specifiers and options described in
                <a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a> crate.  We will use these
                as needed in each of the remaining
                <a href="../../RustBiteByByte.html">Bites</a>
                without further clarification.
                <a id="concl"></a>
                <s-1em></s-1em>
              </t-b>
            </div>
            <h3>12. Conclusions:</h3>
            <div class="indent">
              <t-b>
                <div style="border:2px solid darkred; padding:0em 1.5em; width:max-content; max-width:55em;">
                  <t-b>
                    The notions of Move, Copy, Clone, Borrow, and Drop are central to the Rust memory model and Rust's guarantees
                    about memory and data race safety. We will see more about that in the <a href="RustBites_Ownrs.html">ownership</a>
                    Bite.
                  </t-b>
                  <t-b>
                    Binding and mutation provide Rust's interface to data values.  Combining all of these things allows Rust to
                    support a scope-based value model for data without the complexity of building user-defined assignment operators, and
                    destructors.
                  </t-b>
                </div>
                <a id="exer"></a>
                <s-1em></s-1em>
              </t-b>
            </div>
            <h3>13. Exercises:</h3>
            <div class="indent">
              <t-b>
                <strong>Note:</strong>
                <div class="pad5">
                  In order to build and run with cargo from the Visual Studio Code terminal you need to open
                  VS Code in the package folder for the code you want to build and run.  That's the folder where
                  the package cargo.toml file resides.
                </div>
              </t-b>
              <ol>
                <li>
                  Create an instance of a blittable type and show when it is copied.
                  <ul>
                    <li>Can you prove that it was copied?</li>
                  </ul>
                </li>
                <li>
                  Create an instance of a non-blittable type and show when it is moved.
                  <ul>
                    <li>Can you prove that it was moved?</li>
                    <li>Can you show that the moved-from is invalid?</li>
                  </ul>
                </li>
                <li>
                  Repeat the second exercise but clone the non-blittable type instead
                  of moving it.
                  <ul>
                    <li>Can you show that the cloner is still valid?</li>
                  </ul>
                  <!-- Hint: use the compiler messages. -->
                </li>
              </ol>
              <a id="sln"></a>
              <s-1em></s-1em>
            </div>
            <h3><a id="sln"></a>14. Solution for Exercise #1</h3>
            <div class="indent">
              <t-b class="indents">
                <details>
                  <summary>Solution</summary>
                  <s-halfEm></s-halfEm>
                  <div>
                    &nbsp;&nbsp;Addresses are different, values are the same => copy.  &nbsp;&nbsp;voila!
                    <table style="width:60%;">
                      <tr>
                        <td><img src="CodeSamples/bite_data_ex1/code.jpg" style="width:40em;"></td>
                        <td><img src="CodeSamples/bite_data_ex1/output.jpg" style="width:25em;"></td>
                      </tr>
                    </table>
                  </div>
                </details>
              </t-b>
              <t-b>
                Note that lines 5 and 6 are all you need to complete the main question.  The remaining
                lines address the &quot;Can you prove ...&quot; addendum.
              </t-b>
            </div>
      </t-b>
    </bb-55>
    <s-5em></s-5em>
  </body>
</html>
