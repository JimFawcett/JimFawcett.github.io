<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta name="keywords" content="Rust, Introduction" />
    <meta name="Author" content="Jim Fawcett" />
    <meta name="Author" content="James Fawcett" />
    <title>RustBites Data</title>
    <link rel="stylesheet" href="css/BiteStyles.css" />
    <link rel="stylesheet" href="css/StylesWebComponents.css" />
    <script src="js/BiteScripts.js"></script>
    <script src="js/ScriptsWebComponents.js"></script>
  </head>
  <body id="github" onload="initBites()">
    <div class="top-banner">
        <!-- <span id="hlft"><a href="RustBites_Intro.html">Intro</a></span> -->
        <span id="hctr">Consuming Rust Bite by Byte</span>
        <!-- <span id="hrgt"><a href="RustBites_UDB.html">UDB</a></span> -->
    </div>

    <toc-b id="toc">
      <div style="display:flex; flex-direction:row">
        <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Bites</a>&nbsp;
        <a href="Javascript:;" onclick="storyMenu.sects()" style="color:#fefefa;">Sects</a>&nbsp;
        <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">Esc/Close</a>&nbsp;
      </div>
      <!-- <up-b id="chaps" onmouseout="storyMenu.chaps()"> -->
      <up-b id="chaps">
        <a href="RustBites_Intro.html">Introdtn</a><br />
        <a href="RustBites_Data.html">Data</a><br />
        <a href="RustBites_UDB.html">UndefBhr</a><br />
        <a href="RustBites_Ownrs.html">Ownershp</a><br />
        <a href="RustBites_Intmut.html">IntrMut</a><br />
        <a href="RustBites_Functs.html">Functions</a><br />
        <a href="RustBites_ErrHnd.html">ErrHand</a><br />
        <a href="RustBites_Structs.html">Structs</a><br />
        <a href="RustBites_Traits.html">Traits</a><br />
        <a href="RustBites_Generics.html">Generics</a><br />
        <a href="RustBites_LifeTime.html">LifeTime</a><br />
        <a href="RustBites_Abstract.html">Abstract</a><br />
        <a href="RustBites_Collects.html">Collects</a><br />
        <a href="RustBites_Iterator.html">Iterator</a><br />
        <a href="RustBites_Threads.html">Threads</a><br />
        <a href="RustBites_Synchron.html">Synchron</a><br />
        <a href="RustBites_Channels.html">Channels</a><br />
        <a href="RustBites_AsyncAwt.html">AsyncAwt</a><br />
        <a href="RustBites_Macros.html">Macros</a><br />
        <a href="../../RustBiteByByte.html">Repos</a><br />
      </up-b>
      <rt-b id="sects">
        <a href="#top">Top</a>, <a href="#goal">goal</a>, <a href="#bind_val">bind val</a>,
        <a href="#bind_id">bind id</a>, <a href="#copy_borrow">copy borrow</a>, <a href="#traits">traits</a>,
        <a href="#move_clone">move clone</a>, <a href="#exer">exer</a>, <a href="#sln">sln_#1</a>
      </rt-b>
    </toc-b>
    <div id="hlp" style="display:none;">
      <table>
        <tr>
          <td style="padding-right:5px;">Esc</td>
          <td>toggle menus</td>
        </tr>
        <tr>
          <td>C</td>
          <td>close menus</td>
        </tr>
        <tr>
          <td>R</td><td>Refresh</td>
        </tr>
        <tr>
          <td>T</td><td>scroll to top</td>
        </tr>
        <tr>
          <td>B</td><td>scroll to bottom</td>
        </tr>
        <tr>
          <td>H</td><td>Help</td>
        </tr>
      </table>
      </div>
  
      <bb-55>
        <h1>Rust Bite - Data</h1>
        <hr />
        <a id="goal"></a>
      <t-b>
        In this bite, we focus on basic data operations:
      </t-b>
      <t-b>
        <ol class="tight">
          <li>
            <h3>Our goal is to understand the terms:</h3>
            <div class="indent">
              <table>
                <tr>
                  <td>-</td>
                  <td>Bind:</td>
                  <td>Associate an identifier with a value</td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>copy:</td>
                  <td>
                    Bind to a copy of the value of a blittable type, executed implicitly by compiler 
                    generated code, by copying bytes from source to destination location. Fast.
                  </td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>borrow:</td>
                  <td>
                    Create a named pointer to an identifier&apos;s location.  Pointers used for borrows must 
                    satisfy Rust&apos;s ownership rules, discussed in an upcoming Bite.  Borrows are the only
                    pointers that can be dereferenced in safe code.
                  </td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>Move:</td>
                  <td>
                    Transfer ownership of a type&apos;s resources, usually executed implicitly. 
                    Accomplished by creating, for the destination, a pointer to the source&apos;s 
                    resources (data allocated on the heap), and invalidating the source pointer.
                    Fast.
                  </td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>Clone:</td>
                  <td>Create a copy of a non-blittable type, invoked by program code. Slower.</td>
                </tr>
              </table>
              </div>
          </li>
          <li>
            <h3><a id="bind_val"></a>Binding to a Value</h3>
            <ul class="tight">
              <li>
                Bind - associate an identifier with a memory location
                <ul class="tight">
                  <li>
                    A type is a set of legal values with associated operations. 
                  </li>
                  <li>
                    Every identifier has a type:
                    <div class="indent pad5">
                      <c-s>let k: i32 = 42;</c-s><br /> 
                    </div>
                    let signifies a binding is being created.
                    <c-s>i32</c-s> is the type of a 32 bit integer.
                    42 is a value placed in the memory location associated with k
                  </li>
                  <li>
                    Type inference:
                    <div class="indent pad5">
                      <c-s>let k = 42;</c-s><br /> 
                    </div>
                    This binding is legal and has the same meaning as the previous binding.
                    In lieu of other information, Rust will assign the type i32 to any unadorned
                    integral value that can be correctly written to a 32 bit location.
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <h3><a id="bind_id"></a>Binding to an identifier</h3>
            <ul class="tight">
              <li>
                Binding to an identifier has several forms:
                <ul class="tight">
                  <li>
                    <c-s>let j:i32 = k;    // makes copy for j because k is blittable</c-s> 
                  </li>
                  <li>
                    <c-s>let l = &amp;k;&nbsp;&nbsp;&nbsp;&nbsp;// l makes a reference to k, called a borrow</c-s>
                  </li>
                  <li>
                    <c-s>let s:String = "a string".into_string();</c-s>
                  </li>
                  <li>
                    <c-s>let t = s; &nbsp;&nbsp;&nbsp;&nbsp;// moves s into t, e.g., transfers ownership
                    as s is not blittable</c-s>
                  </li>
                </ul>
              </li>
              <li>
                <strong>Blittable:</strong>
                <div class="indent pad5">
                  Values of the type reside in one contiguous block of 
                  memory and can be copied with a single memcpy.
                </div>  
                Blittable examples are all the integral types, floating 
                point types, and aggregates (arrays, tuples, and structs) containing only blittable types
                as members.    
              </li>
              <li>
                <strong>Non-Blittable:</strong>
                <div class="indent pad5">
                  Values of the type reside in more than one contiguous block of memory 
                  and cannot be copied with a single memcpy.
                </div>
                Non-blittable examples are all of the types that have data resources on the 
                heap, e.g., Strings, Vecs, VecDeques, Maps, ...    
              </li>
            </ul>
          </li>
          <li>
            <h3><a id="copy_borrow"></a>Copy and Borrow</h3>
            <ul class=tight>
              <li>
                Copies happen implicitly when an identifier is bound to a Copy type:
                <div class="indent pad5">
                  <c-s>let i = 3;  let j = i;  &nbsp;&nbsp;// copy</c-s>
                </div>
                or when one copy type is assigned to another:
                <div class="indent pad5">
                  <c-s>j = i + 1;  &nbsp;&nbsp;// copy</c-s>
                </div>
              </li>
              <li>
                Borrows happen when binding references to other identifiers:
                <div class="indent pad5">
                  <c-s>let r = &amp;i  &nbsp;&nbsp;// borrow;</c-s>
                </div>
                A reference, like <c-s>&amp;i</c-s>, is just a pointer to the memory location
                bound to i.  It cannot be reset, and is subject to Rust ownership rules, which
                we will discuss soon, in a later Bite. 
              </li>
            </ul>
          </li>
          <li>
            <h3><a id="traits"></a>Copy, Move, and Clone Traits</h3>
            <div style="width:calc(100vw - 12rem);">
              <div class="right">
              <photosizer-block src="../../Pictures/StringMove.jpg" width="500" class="photoSizerBlock" style="margin-top:0;">
                <span style="
                  display: inline-block;
                  font-weight: bold;
                  font-family: 'Comic Sans MS, Tahoma';
                  background-color: #ddd;
                  width: 100%;
                  padding: 5px 0px;
                ">
                  Figure 1. String Move
                </span>
              </photosizer-block>
             <!-- <div style="width:calc(100vw - 12rem);"> -->
              <photosizer-block src="../../Pictures/StringClone.jpg" width="500" class="photoSizerBlock right" style="margin-top:0;">
                <span style="
                  display: inline-block;
                  font-weight: bold;
                  font-family: 'Comic Sans MS, Tahoma';
                  background-color: #ddd;
                  width: 100%;
                  padding: 5px 0px;
                ">
                  Figure 2. String Clone
                </span>
              </photosizer-block>
            </div>
            </div>
            <t-b>
              Traits are like interface contracts.  They specify a behavior that a type must implement
              if it has that trait.
            </t-b>
            <t-b>
              Copy types are types that implement the Copy trait. 
              <ul class="tight">
                <li>
                  To be elibible for the Copy trait 
                  they must be blittable.
                </li>
              </ul>
            </t-b>
            <t-b>
              Move types are types that implement the Move trait. 
              <ul class="tight">
                <li>
                  Data types with the Move trait are non-blittable.
                </li>
              </ul>
            </t-b>
            <t-b>
              Clone types are types that implement the Clone trait. 
              <ul class="tight">
                <li>
                  Data types with the Clone trait provide a clone() member function that creates
                  a new instance of the type that has the same structure and copies of any resources 
                  held by the cloner.
                </li>
                <li>
                  Examples of Clone types are the collections, e.g., Strings, Vecs, VecDeques, Maps, ...    
                </li>
              </ul>
            </t-b>
          </li>
          <li>
            <h3><a id="move_clone"></a>Move and Clone</h3>
            <ul>
              <li>
                A <strong>move</strong> transfers a Move type's heap resources to another instance of that type.
                <ul class="tight">
                  <li>
                    The String, <s-s>s</s-s>, shown in Figure 1. is moved to <c-s>t</c-s>
                    with the statement:
                    <ul class="tight">
                      <li><c-s>let t = s; &nbsp;&nbsp;// s is now invalid</c-s></li>
                    </ul>
                  </li>
                  <li>
                    Move transfers ownership of resources.
                  </li>
                </ul>
                <s-halfEm></s-halfEm>
              </li>
              <li>
                A <strong>clone</strong> copies a Move type&apos;s heap resources to a new instance of that type.
                <ul class="tight">
                  <li>
                    The String, <s-s>s</s-s>, shown in Figure 2. is cloned with the statement:
                    <ul class="tight">
                      <li><c-s>let t = s.clone(); &nbsp;&nbsp;// s is still valid</c-s></li>
                    </ul>
                  </li>
                  <li>
                    Clone operation copies resources to target.
                  </li>
                </ul>
              </li>
            </ul>
            <div class="clear"></div>
          </li>
          <li>
            <h3><a id="exer"></a>Exercises:</h3>
            <ul>
              <li>
                Create an instance of a blittable type and show when it is copied.
                <ul>
                  <li>Can you prove that it was copied?</li>
                </ul>
              </li>
              <li>
                Create an instance of a non-blittable type and show when it is moved.
                <ul>
                  <li>Can you prove that it was moved?</li>
                </ul>
              </li>
              <li>
                Repeat the second exercise but clone the non-blittable type instead
                of moving it.
                <ul>
                  <li>Can you show that the cloner is still valid?</li>
                  <li>Can you show that the moved from is invalid?</li>
                </ul>
                <!-- Hint: use the compiler messages. -->
              </li>
            </ul>
          </li>
          <li>
            <h3><a id="sln"></a>Solution for Exercise #1</h3>
            <t-b class="indents">
              <details>
                <summary>Solution</summary>
                <s-halfEm></s-halfEm>
                <div>
                  &nbsp;&nbsp;Addresses are different, values are the same => copy.  &nbsp;&nbsp;voila!
                  <table style="width:60%;">
                    <tr>
                      <td><img src="CodeSamples/bite_data_ex1/code.jpg" style="width:40em;"></td>
                      <td><img src="CodeSamples/bite_data_ex1/output.jpg" style="width:25em;"></td>
                    </tr>
                  </table>
                </div>
              </details>
            </t-b>
          </li>
        </ol>
      </t-b>
    </bb-55>
    <s-5em></s-5em>
  </body>
</html>
