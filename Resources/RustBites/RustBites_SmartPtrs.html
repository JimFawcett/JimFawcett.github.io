<!DOCTYPE html>
<html>
<!--
  BasicBites_SmartPtrs.html
-->
<head>
  <title>RustBite SmartPtrs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeRust.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesRustTrack.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <style>
    #github table {
      max-width: 90%;
      border: 1px solid black;
      margin-top: 1em;
      margin-bottom: 1.0em;
    }

      #github table.invis {
        width: 90%;
        border: none;
      }

      #github table tr {
        border: 1px solid var(--dark);
      }

        #github table tr.invis {
          border: none;
        }

        #github table tr th {
          color: var(--dark);
          background-color: var(--menu);
        }

          #github table tr th.invis {
            border: none;
          }

        #github table tr td {
          color: var(--dark);
          background-color: var(--light);
        }

          #github table tr td.invis {
            border: none;
          }

      #github table a:link {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:visited {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:hover {
        color: var(--dark);
        background-color: transparent;
      }

      #github table a:active {
        color: var(--dark);
        background-color: transparent;
      }

    #github hr.dotted {
      border: none;
      border-top: 2px dashed var(--dark);
      color: var(--light);
      background-color: var(--light);
      height: 1px;
      width: 55em;
      margin-top: 0.5em;
      margin-bottom: 1.5em;
    }
  </style>
  <style>
    #github .topborder {
      border-top: 1px solid #363636;
    }

    #github th.num {
      width: 3em;
      text-align: right;
      padding-right: 1.0em;
    }

    #github td.num {
      width: 3em;
      text-align: right;
      padding-right: 1.0em;
    }

    #github th.elem {
      padding-right: 2.0em;
      white-space: nowrap;
    }

    #github td.elem {
      padding-right: 2.0em;
      white-space: nowrap;
    }

    t-b {
      display: block;
      margin-top: 0.75rem;
      margin-bottom: 0.75rem;
      max-width: 55rem;
    }

    #github td > hr {
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }
  </style>
<!--   <script>
    window.onmessage = function () {
      // alert('msg received');
      bottomMenu.sections();
    }
  </script>
 --></head>
<body id="github" onload="initialize()">

  <a id="Next" href="RustBites_LifeCycle.html">Next</a>
  <a id="Prev" href="RustBites_DataStr.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about" onclick="location.reload()">about</div>
      <div id="modified">03/15/2023</div>
      <div id="page">RustBites - SmartPtrs</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Consuming_Rust_bite_by_byte" style="margin:2.8em 1.0em; font-size:0.9em;">
            Rust Bites Code
          </a>
          <hgroup id="pagetitle" onclick="loadifrust()" style="cursor:pointer;">
            <h1>Rust Bite - SmartPtrs</h1>
            <h3 id="subtitle" class="indent">Box, Rc, Arc, RefCell, interior mutability, </h3>
          </hgroup>
        </header>
        <t-b>
          The Rust std library provides an interesting set of smart pointers.  The Box&lt;T&gt; pointer provides the only
          way to store and access data on the heap.
        </t-b>
        <t-b>
          Rc&lt;T&gt; and Arc&lt;T&gt; are reference counted pointers
          designed to support sharing of data for single threads and multiple threads, respectively.
        </t-b>
        <t-b>
          RefCell&lt;T&gt; supports deferring borrow checking for ownership from compile-time to
          run-time.  That is essential in some multi-threaded applications.
        </t-b>
        <t-b>
          This Bite is divided into sections for each of the pointers.  There we discuss each pointer&apos;s
          purpose and ways to create them and use their contents.
          <s-halfEm></s-halfEm>
        </t-b>
        <!--<div>-->
        <div>
          <a id="box"></a>
          <h2>1. std::boxed::Box&lt;T&gt;</h2>
          <t-b>
            std::Box&lt;T&gt; is a smart pointer to data in the heap.  Box manages allocation and deallocation
            of heap memory, and provides an interface to interact with that data.
          </t-b>
          <div class="indent pad5">
            <defn-block>
              <defn-head>Box - smart pointer to allocation on heap</defn-head>
              <defn-code style="font-size:0.9em;">
                let sp = Box::new(T::new());
                /*--------------------------------------------*/
                Box automatically derefernces to a T
                so you can call T methods on sp
                /*--------------------------------------------*/
                let vl = sp.getter();    // T method
                sp.setter(vl);           // T method
                let spc = sp.clone();    // Box method
                let t = *sp;  // move heap value to stack
                Box deallocates heap memory in its drop method
              </defn-code>
            </defn-block>
          </div>
          <bb-55>
            <t-b>
              An example of Box code is shown in the dropdown, below.
            </t-b>
          </bb-55>
          <div>
            <details>
              <summary class="darkItem">Example: Box&lt;T&gt;</summary>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>show_box::main.rs</defn-head>
                  <defn-code>
                    /////////////////////////////////////////////////////////////
                    // show_box::main.rs - demo Box&lt;T&gt; pointer to heap         //
                    //                                                         //
                    // Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
                    /////////////////////////////////////////////////////////////

                    #![allow(clippy::print_literal)]

                    use core::fmt::{ Debug };

                    /*-- same as print!("\n  sp = {:?}", sp) --*/
                    fn show&lt;T:Debug&gt;(name:&amp;str, t:&amp;T) {
                    print!("\n  {} = {:?}", name, t);
                    }

                    fn main() {

                    let putline = || print!("\n");

                    type TLC = test_type::TestLifeCycle;

                    print!("\n  -- create Box pointer to TLC on heap --");
                    let sp = Box::new(TLC::new());
                    show("sp", &amp;sp);
                    putline();

                    print!("\n  -- access member of TLC using Box --");
                    let v = sp.get_value();
                    show("v ", &amp;v);
                    putline();

                    print!("\n  -- clone Box pointer to TLC on heap --");
                    let mut spc = sp.clone();
                    show("spc", &amp;spc);
                    putline();

                    print!("\n  -- mutate TLC through Box --");
                    spc.set_value(42);
                    show("spc", &amp;spc);
                    show("v ", &amp;spc.get_value());
                    show("sp", &amp;sp);
                    putline();

                    print!("\n  -- create reference to Box pointer --");
                    let rspc = &amp;mut spc;
                    rspc.set_value(21);
                    show("rspc", &amp;rspc);    // holds new value
                    show("spc", &amp;spc);      // holds new value too
                    putline();

                    print!("\n  -- move contents of Box back to stack with deref --");
                    let tlc = *sp;  // move
                    show("tlc", &amp;tlc);

                    // statement below won't compile since sp has been moved
                    // show("sp", &amp;sp);

                    println!("\n\n  That's all Folks!");

                    }  /*-- drop Boxed item --*/
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Output:</defn-head>
                  <defn-code>
                    cargo run -q

                    -- create Box pointer to TLC on heap --
                    creating instance 0 of TestLifeCycle
                    sp = TestLifeCycle { count: 0 }

                    -- access member of TLC using Box --
                    v  = 0

                    -- clone Box pointer to TLC on heap --
                    TestLifeCycle instance 0 cloned
                    spc = TestLifeCycle { count: 0 }

                    -- mutate TLC through Box --
                    spc = TestLifeCycle { count: 42 }
                    v  = 42
                    sp = TestLifeCycle { count: 0 }

                    -- create reference to Box pointer --
                    rspc = TestLifeCycle { count: 21 }
                    spc = TestLifeCycle { count: 21 }

                    -- move contents of Box back to stack with deref --
                    tlc = TestLifeCycle { count: 0 }

                    That's all Folks!

                    TestLifeCycle instance 0 dropped
                    TestLifeCycle instance 21 dropped
                  </defn-code>
                </defn-block>
              </defn-outerBlock>
            </details>
          </div>
          <s-halfEm></s-halfEm>
        </div>
        <div>
          <a id="rc"></a>
          <h2>2. std::rc::Rc&lt;T&gt;</h2>
          <bb-55>
            <t-b>
              std::rc::Rc&lt;T&gt; is a reference counted pointer to an initialized value on the stack.
              Rc manages multiple references by dropping its inner value only when the last Rc pointer
              is dropped, e.g., there are no dangling references.
            </t-b>
            <t-b>
          </bb-55>
          <div class="indent pad5">
            <defn-block>
              <defn-head>Rc - reference counted pointer</defn-head>
              <defn-code style="font-size:0.9em;">
                let tlc = test_type::TestLifeCycle;
                let mut rc1 = Rc::new(tlc)
                /*------------------------------------------------*/
                std::rc::Rc is a reference counted pointer.
                - Rc::new(value) creates a pointer to value.
                - Rc::clone creates a new pointer to the same
                source inner value, adding 1 to ref count.
                - Rc automatically dereferences to a T, so you
                can call T methods on an Rc&lt;T&gt;.
                - Rc::drop decrements the ref count, dropping
                the inner value on zero.
                - Note, it does no harm to drop a stack value
                as long as there is no attempt to use after.
                /*------------------------------------------------*/
                let rc2 = rc1.clone();
                let rc3 = Rc::clone(&rc2);
                let opt = Rc::get_mut(&rc1);
                // where opt: Option&lt;Some(&mut tlc)&gt;
                /*------------------------------------------------*/
                get_mut returns an Option because the Rust
                ownership rules allow only one active mutable
                reference.
                If there is already an active mutable reference
                the option contains the enumeration value None.
                Otherwise it contains Some(&mut inner_value).
                /*------------------------------------------------*/
              </defn-code>
            </defn-block>
          </div>
          </t-b>
          <bb-55>
            <t-b>
              Example code for Rc is shown below.  Note that most of the code complexity results from processing an Option, returned
              by Rc::get_mut(&mut inner_value).  That&apos;s the way the cookie crumbles.
            </t-b>
          </bb-55>
          <div>
            <details>
              <summary class="darkItem">Example: Rc&lt;T&gt;</summary>
              <s-halfEm></s-halfEm>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>show_rc::main.rs</defn-head>
                  <defn-code>
                    /////////////////////////////////////////////////////////////
                    // show_rc::main.rs - demo Rc&lt;T&gt; ref counted ptr           //
                    //                                                         //
                    // Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
                    /////////////////////////////////////////////////////////////

                    use core::fmt::{ Debug };
                    use std::rc::Rc;

                    /*-- same as print!("\n  sp = {:?}", sp) --*/
                    #[allow(clippy::print_literal)]
                    fn show&lt;T:Debug&gt;(name:&amp;str, t:&amp;T) {
                    print!("\n  {} = {:?}", name, t);
                    }

                    struct SpaceAtEnd;
                    impl Drop for SpaceAtEnd {
                    fn drop(&amp;mut self) {
                    print!("\n\n");
                    }
                    }

                    fn main() {

                    let putline = || print!("\n");
                    let _cosmetic = SpaceAtEnd;

                    print!("\n  -- create instance of TestLifeCycle in stack --");
                    let tlc = test_type::TestLifeCycle::new();
                    putline();

                    print!("\n  -- create Rc ptr to value in stack --");
                    let mut rc1 = Rc::new(tlc);
                    show("rc1", &amp;rc1);
                    show("Rc strong count", &amp;Rc::strong_count(&amp;rc1));
                    show("rc1 inner value", &rc1.get_value());
                    putline();

                    print!("\n  -- attempt to mutate inst through Rc ptr --");
                    let opt_mut_rc1 = Rc::get_mut(&amp;mut rc1);
                    match opt_mut_rc1 {
                    Some(val) =&gt; {
                    /*-- make mutable reference --*/
                    let mut_rc1 = &amp;mut *val;
                    mut_rc1.set_value(42);
                    show("rc1", &amp;rc1);
                    },
                    None =&gt; {
                    print!(
                    "\n  can't have multiple mutable references"
                    );
                    }
                    }
                    putline();

                    print!("\n  -- create new Rc ptr to inst in stack --");
                    let mut rc2 = rc1.clone();
                    show("rc2", &amp;rc2);
                    show("Rc strong count", &amp;Rc::strong_count(&amp;rc2));
                    putline();

                    print!("\n  -- attempt to mutate inst through Rc ptr --");
                    let opt_mut_rc2 = Rc::get_mut(&amp;mut rc2);
                    match opt_mut_rc2 {
                    Some(val) =&gt; {
                    /*-- make mutable reference --*/
                    let mut_rc2 = &amp;mut *val;
                    mut_rc2.set_value(21);
                    show("rc2", &amp;rc2);
                    },
                    None =&gt; {
                    print!(
                    "\n  can't have multiple mutable references"
                    );
                    }
                    }
                    putline();

                    /*-- alternate clone syntax --*/
                    print!("\n  -- create another new Rc ptr to inst in stack --");
                    let mut rc3 = Rc::clone(&amp;rc1);
                    show("rc3", &amp;rc3);
                    show("Rc strong count", &amp;Rc::strong_count(&amp;rc1));
                    putline();

                    /*-- alternate matching syntax --*/
                    print!("\n  -- attempt to mutate inst through Rc ptr --");
                    let opt_mut_rc3 = Rc::get_mut(&amp;mut rc3);
                    if let Some(val) = opt_mut_rc3 {
                    /*-- make mutable reference --*/
                    let mut_rc3 = &amp;mut *val;
                    mut_rc3.set_value(21);
                    show("rc3", &amp;rc2);
                    }
                    else {
                    print!(
                    "\n  can't have multiple mutable references"
                    );
                    }
                    putline();

                    // print!("\n  dropping rc1");
                    // drop(rc1);
                    // print!("\n  dropping rc2");
                    // drop(rc2);
                    // print!("\n  dropping rc3");
                    // drop(rc3);
                    // putline();

                    /*-------------------------------------------------------
                    Help with Option processing, used above:
                    -----------------------------------------------------
                    The code below illustrates destructuring an option
                    with both if let and match constructs.
                    These will be discussed again in the Error Handling
                    Bite.
                    */
                    let maybe_cake = Some("this code is a piece of cake! :-)");
                    let not_cake = std::option::Option::&lt;&amp;str&gt;::None;
                    if let Some(cake) = maybe_cake {    // cake is a defined identifier
                    print!("\n  {}", cake);         // due to if let destructuring
                    }

                    let maybe_cake: Option&lt;&amp;str&gt; = not_cake;
                    match maybe_cake {
                    Some(cake) =&gt; print!("\n  {}", cake),
                    // now, cake is defined by
                    // match destructuring
                    None =&gt; print!("\n  this code is not a piece of cake!! :-(")
                    }

                    println!("\n\n  That's all Folks!");
                    }
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Output:</defn-head>
                  <defn-code>
                    cargo run -q

                    -- create instance of TestLifeCycle in stack --
                    creating instance 0 of TestLifeCycle

                    -- create Rc ptr to value in stack --
                    rc1 = TestLifeCycle { count: 0 }
                    Rc strong count = 1
                    rc1 inner value = 0

                    -- attempt to mutate inst through Rc ptr --
                    rc1 = TestLifeCycle { count: 42 }

                    -- create new Rc ptr to inst in stack --
                    rc2 = TestLifeCycle { count: 42 }
                    Rc strong count = 2

                    -- attempt to mutate inst through Rc ptr --
                    can't have multiple mutable references

                    -- create another new Rc ptr to inst in stack --
                    rc3 = TestLifeCycle { count: 42 }
                    Rc strong count = 3

                    -- attempt to mutate inst through Rc ptr --
                    can't have multiple mutable references

                    this code is a piece of cake! :-)
                    this code is not a piece of cake!! :-(

                    That's all Folks!

                    TestLifeCycle instance 42 dropped
                  </defn-code>
                </defn-block>
              </defn-outerBlock>
            </details>
            <bb-55>
              <t-b>
                Rc is used most often with RefCell to enable <a target="_blank" href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">Interior Mutability</a>.  You will see
                discussion and examples later in this <a target="_blank" href="#refcell">Bite</a>.
                <s-halfEm></s-halfEm>
              </t-b>
            </bb-55>
          </div>
        </div>
        <div>
          <a id="arc"></a>
          <h2>3. std::sync::Arc&lt;T&gt;</h2>
          <bb-55>
            <t-b>
              std::sync::Arc&lt;T&gt; is a thread-safe reference counted pointer to an initialized value on the stack.
              Arc manages multiple references by dropping its inner value only when the last Rc pointer
              is dropped, e.g., there are no dangling references. Arc is a thread-safe version of Rc.
            </t-b>
            <t-b>
          </bb-55>
          <div class="indent pad5">
            <defn-block>
              <defn-head>Arc - atomic reference counted pointer</defn-head>
              <defn-code style="font-size:0.9em;">
                let tlc = test_type::TestLifeCycle;
                let mut arc1 = Arc::new(tlc)
                /*------------------------------------------------*/
                std::sync::Arc is a thread-safe reference counted
                pointer, very like Rc, but using atomic ref count.
                - Arc::new(value) creates a pointer to value.
                - Arc::clone creates a new pointer to the same
                source inner value, adding 1 to ref count.
                - Arc::drop decrements the ref count, dropping
                the inner value on zero.
                - Note, it does no harm to drop a stack value
                as long as there is no attempt to use after.
                -
                /*------------------------------------------------*/
                let arc2 = arc1.clone();
                let arc3 = Arc::clone(&amp;arc2);
                let opt = Arc::get_mut(&amp;arc1);
                where opt: Option&lt;Some(&amp;mut tlc)&gt;
              </defn-code>
            </defn-block>
          </div>
          </t-b>
          <bb-55>
            <t-b>
              Example code for Arc is shown below.  Note that most of the code complexity results from processing an Option, returned
              by Arc::get_mut(&mut inner_value).  That&apos;s still the way cookies crumble.
            </t-b>
          </bb-55>
          <div>
            <details>
              <summary class="darkItem">Example: Arc&lt;T&gt;</summary>
              <s-halfEm></s-halfEm>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>show_arc::main.rs</defn-head>
                  <defn-code>
                    /////////////////////////////////////////////////////////////
                    // show_arc::main.rs - demo Arc&lt;T&gt; ref counted ptr         //
                    //                                                         //
                    // Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
                    /////////////////////////////////////////////////////////////

                    use core::fmt::{ Debug };
                    use std::sync::Arc;

                    /*-- same as print!("\n  sp = {:?}", sp) --*/
                    #[allow(clippy::print_literal)]
                    fn show&lt;T:Debug&gt;(name:&amp;str, t:&amp;T) {
                    print!("\n  {} = {:?}", name, t);
                    }

                    struct SpaceAtEnd;
                    impl Drop for SpaceAtEnd {
                    fn drop(&amp;mut self) {
                    print!("\n\n");
                    }
                    }

                    fn main() {

                    let putline = || print!("\n");
                    let _cosmetic = SpaceAtEnd;

                    print!("\n  -- create instance of TestLifeCycle in stack --");
                    let tlc = test_type::TestLifeCycle::new();
                    putline();

                    print!("\n  -- create Arc ptr to value in stack --");
                    let mut arc1 = Arc::new(tlc);
                    show("arc1", &amp;arc1);
                    show("Arc strong count", &amp;Arc::strong_count(&amp;arc1));
                    show("arc1 inner value", &amp;arc1.get_value());
                    putline();

                    print!("\n  -- attempt to mutate inst through Arc ptr --");
                    let opt_mut_arc1 = Arc::get_mut(&amp;mut arc1);
                    match opt_mut_arc1 {
                    Some(val) =&gt; {
                    /*-- make mutable reference --*/
                    let mut_arc1 = &amp;mut *val;
                    mut_arc1.set_value(42);
                    show("arc1", &amp;arc1);
                    },
                    None =&gt; {
                    print!(
                    "\n  can't have multiple mutable references"
                    );
                    }
                    }
                    putline();

                    print!("\n  -- create new Arc ptr to inst in stack --");
                    let mut arc2 = arc1.clone();
                    show("arc2", &amp;arc2);
                    show("Arc strong count", &amp;Arc::strong_count(&amp;arc2));
                    putline();

                    print!("\n  -- attempt to mutate inst through Arc ptr --");
                    let opt_mut_arc2 = Arc::get_mut(&amp;mut arc2);
                    match opt_mut_arc2 {
                    Some(val) =&gt; {
                    /*-- make mutable reference --*/
                    let mut_arc2 = &amp;mut *val;
                    mut_arc2.set_value(21);
                    show("arc2", &amp;arc2);
                    },
                    None =&gt; {
                    print!(
                    "\n  can't have multiple mutable references"
                    );
                    }
                    }
                    putline();

                    /*-- alternate clone syntax --*/
                    print!("\n  -- create another new Arc ptr to inst in stack --");
                    let mut arc3 = Arc::clone(&amp;arc1);
                    show("arc3", &amp;arc3);
                    show("Arc strong count", &amp;Arc::strong_count(&amp;arc1));
                    putline();

                    /*-- alternate matching syntax --*/
                    print!("\n  -- attempt to mutate inst through Arc ptr --");
                    let opt_mut_arc3 = Arc::get_mut(&amp;mut arc3);
                    if let Some(val) = opt_mut_arc3 {
                    /*-- make mutable reference --*/
                    let mut_arc3 = &amp;mut *val;
                    mut_arc3.set_value(21);
                    show("arc3", &amp;arc2);
                    }
                    else {
                    print!(
                    "\n  can't have multiple mutable references"
                    );
                    }
                    putline();

                    // print!("\n  dropping rc1");
                    // drop(rc1);
                    // print!("\n  dropping rc2");
                    // drop(rc2);
                    // print!("\n  dropping rc3");
                    // drop(rc3);
                    // putline();

                    println!("\n\n  That's all Folks!");
                    }
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Output:</defn-head>
                  <defn-code>
                    cargo run -q

                    -- create instance of TestLifeCycle in stack --
                    creating instance 0 of TestLifeCycle

                    -- create Arc ptr to value in stack --
                    arc1 = TestLifeCycle { count: 0 }
                    Arc strong count = 1
                    arc1 inner value = 0

                    -- attempt to mutate inst through Arc ptr --
                    arc1 = TestLifeCycle { count: 42 }

                    -- create new Arc ptr to inst in stack --
                    arc2 = TestLifeCycle { count: 42 }
                    Arc strong count = 2

                    -- attempt to mutate inst through Arc ptr --
                    can't have multiple mutable references

                    -- create another new Arc ptr to inst in stack --
                    arc3 = TestLifeCycle { count: 42 }
                    Arc strong count = 3

                    -- attempt to mutate inst through Arc ptr --
                    can't have multiple mutable references


                    That's all Folks!

                    TestLifeCycle instance 42 dropped
                  </defn-code>
                </defn-block>
              </defn-outerBlock>
            </details>
            <bb-55>
              <t-b>
                Arc is used most often with <a target="_blank" href="RustBites_Threads.html">Threading</a> applications.  You will see
                its use in examples for that Bite.
                <s-halfEm></s-halfEm>
              </t-b>
            </bb-55>
          </div>
        </div>
        <div>
          <a id="refcell"></a>
          <h2>4. std::cell::RefCell&lt;T&gt;</h2>
          <bb-55>
            <t-b>
              RefCell&lt;T&gt; is used to defer borrow checking until run-time.  We declare it
              as an immutable type, but are allowed to borrow a mutable reference.  If we
              already have an active borrow, the program will  panic, because the ownership
              rules have been violated.
            </t-b>
            <t-b>
              The point of all this is that there are certain conditions under which correct code
              will not compile because the compiler&apos;s static analysis can&apos;t guarantee
              that ownership rules haven&apos;t been violated.  RefCell&lt;T&gt; appears to the
              compiler to be immutable, but supports return of mutable references to its inner
              value.  This allows code to compile, and wait until run-time to verify that the
              ownership rules have or have not been satisfied.
            </t-b>
            <t-b>
              A common place where this occurs is in mult-threaded code.  We will see some
              examples when we look at the <a target="_blank" href="RustBites_Threads.html">Threads</a> Bite.
            </t-b>
            <t-b>
              When we borrow from a RefCell&lt;T&gt; we get a Ref&lt;T&gt; or a RefMut&lt;T&gt;,
              depending on the type of borrow.  These types are essentially transparent because
              they support automatic dereferencing to the RefCell&lt;T&gt; inner value.
            </t-b>
          </bb-55>
          <div class="indent pad5">
            <defn-block>
              <defn-head>RefCell, Ref, and RefMut</defn-head>
              <defn-code style="font-size:0.9em;">
                RefCell holds a mutable memory location with dynamically
                checked borrow rules.

                let sp = std::cell::RefCell::new(T::new());
                let r1 = sp.borrow()      // returns a Ref&lt;T&gt; which impl's Deref
                // panics if r1 was mutably borrowed
                // access inner with sp.borrow()
                //   due to auto dereferencing
                let r2 = sp.borrow_mut()  // returns a RefMut&lt;T&gt; which impl's Deref
                // panics if r2 was already borrowed
                // access inner with sp.borrow_mut()
                //   due to auto dereferencing
                let t = sp.into_inner()   // moves inner to t
                let t0 = sp.replace(t1)   // replaces original inner with new
                std::mem::drop(r1)        // drops inner t
              </defn-code>
            </defn-block>
          </div>
          <bb-55>
            <t-b>
              The example, below, illustrates the basic mechanics for using RefCell&lt;T&gt; and the
              wrappers Ref&lt;T&gt; and RefMut&lt;T&gt;.  It doens&apos;t give you much insight into
              how they are used in practice.  That will have to wait until we get to
              <a target="_blank" href="RustBites_Threads.html">Threads</a>.  There we will see that Mutex&lt;T&gt; and
              RwLock&lt;T&gt; need RefCell to implement their functionality.
            </t-b>
          </bb-55>
          <div>
            <details>
              <summary class="darkItem">Example: RefCell&lt;T&gt;</summary>
              <s-halfEm></s-halfEm>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>show_refcell::main.rs</defn-head>
                  <defn-code>
                    /////////////////////////////////////////////////////////////
                    // show_refcell::main.rs - demo RefCell<T>
                      smart pointer   //
                      //                                                         //
                      // Jim Fawcett, https://JimFawcett.github.io, 06 Jun 2020  //
                      /////////////////////////////////////////////////////////////

                      #![allow(clippy::print_literal)]
                      #![allow(unused_imports)]

                      use core::fmt::{ Debug };
                      use std::cell::{ RefCell, Ref, RefMut };
                      use std::any::type_name;

                      /*-- same as print!("\n  sp = {:?}", sp) --*/
                      fn show<T:Debug>
                        (name:&str, t:&T) {
                        print!("\n  {} = {:?}", name, t);
                        }

                        fn show_type<'a, T:Debug>(_t:T) -> &'a str where T:Debug {
                        type_name::<T>
                          ()
                          }

                          struct SpaceAtEnd;
                          impl Drop for SpaceAtEnd {
                          fn drop(&mut self) {
                          print!("\n\n");
                          }
                          }

                          fn main() {
                          /*-------------------------------------------------------
                          Note:
                          This program will panic if both Blk #1 and Blk #2
                          are uncommented.  That's because the borrowing
                          rules are violated.

                          If one is commented out - it doesn't matter which
                          one - the program completes successfully.

                          This illustrates that RefCell defers borrow checking
                          to run-time.
                          */

                          let putline = || print!("\n");
                          let _cosmetic = SpaceAtEnd;

                          let tlc = test_type::TestLifeCycle::new();

                          print!("\n  -- create RefCell pointer to tlc --");
                          /*-- note sp is statically immutable --*/
                          let sp = RefCell::new(tlc);
                          show("sp", &sp);
                          putline();

                          // Blk #1
                          // print!("\n  -- borrow inner TLC from RefCell --");
                          // let b = sp.borrow();
                          // show("b ", &b);
                          // let v = b.get_value();
                          // show("v ", &v);
                          // putline();

                          // Blk #2
                          print!("\n  -- attempt to mutably borrow inner TLC from RefCell --");
                          /*-------------------------------------------------------
                          - Even though sp is immutable, we can get a mutable
                          reference, b2.
                          - RefCell defers borrow checking to runtime.
                          - This succeeds only if there are no other current borrows.
                          You can see that by uncommenting the code in blk #1
                          */
                          let mut b2 = sp.borrow_mut();   // returns RefMut<T>
                            show("b2", &b2);
                            b2.set_value(42);               // automatically dereferenced
                            show("b2", &b2);
                            let v = b2.get_value();         // here too
                            show("v ", &v);
                            putline();

                            print!("\n  -- exploring borrowed type --");
                            type TLC = test_type::TestLifeCycle;
                            let sp2 = RefCell::new(TLC::new());
                            let r:Ref<TLC>
                              = sp2.borrow();
                              show("r:Ref<TLC>
                                ", &show_type(r));
                                putline();

                                print!("\n  -- exploring automatic dereferencing of Ref<T>
                                  --");
                                  /*-- r was moved in show_type(r) so get another --*/
                                  let r = sp2.borrow();
                                  let tlc = &*r;
                                  show("r:Ref<T>
                                    ", &r);
                                    show("tlc", &tlc);
                                    putline();

                                    print!("\n  -- exploring mutably borrowed type --");
                                    let sp2 = RefCell::new(TLC::new());
                                    let r:RefMut<TLC>
                                      = sp2.borrow_mut();
                                      show("r:RefMut<TLC>
                                        ", &show_type(r));
                                        putline();

                                        print!("\n  -- exploring automatic dereferencing of RefMut<T>
                                          --");
                                          /*-- r was moved in show_type(r) so get another --*/
                                          let r = sp2.borrow_mut();
                                          let tlc = &*r;
                                          show("r:RefMut<T>
                                            ", &r);
                                            show("tlc", &tlc);

                                            println!("\n\n  That's all Folks!");

                                            }
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Output:</defn-head>
                  <defn-code>
                    creating instance 0 of TestLifeCycle
                    -- create RefCell pointer to tlc --
                    sp = RefCell { value: TestLifeCycle { count: 0 } }

                    -- attempt to mutably borrow inner TLC from RefCell --
                    b2 = TestLifeCycle { count: 0 }
                    b2 = TestLifeCycle { count: 42 }
                    v  = 42

                    -- exploring borrowed type --
                    creating instance 0 of TestLifeCycle
                    r:Ref<TLC>
                      = "core::cell::Ref<test_type::TestLifeCycle>
                        "

                        -- exploring automatic dereferencing of Ref<T>
                          --
                          r:Ref<T>
                            = TestLifeCycle { count: 0 }
                            tlc = TestLifeCycle { count: 0 }

                            -- exploring mutably borrowed type --
                            creating instance 0 of TestLifeCycle
                            r:RefMut<TLC>
                              = "core::cell::RefMut<test_type::TestLifeCycle>
                                "

                                -- exploring automatic dereferencing of RefMut<T>
                                  --
                                  r:RefMut<T>
                                    = TestLifeCycle { count: 0 }
                                    tlc = TestLifeCycle { count: 0 }

                                    That's all Folks!

                                    TestLifeCycle instance 0 dropped
                                    TestLifeCycle instance 0 dropped
                                    TestLifeCycle instance 42 dropped
                  </defn-code>
                </defn-block>
              </defn-outerBlock>
            </details>
          </div>
          <bb-55>
            <t-b>
              If you look through the Rust documentation you will find other applications of
              RefCell&lt;T&gt; for building
              <a target="_blank" href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">Mock Objects</a> for
              testing and for initializing objects that have an immutable interface.
              <s-halfEm></s-halfEm>
            </t-b>
            <a id="intermut"></a>
            <h2>5. Interior Mutability</h2>
            <t-b>
              RefCell&lt;T&gt; was designed to support something called &quot;interior mutability&quot;.
              Its inner element can be mutated throught its member function borrow_mut().  That returns
              a reference that appears to the compiler to be immutable, but which supports mutating the
              inner element.
            </t-b>
            <t-b>
              That doesn&apos;t escape the Rust ownership rules.  It just defers their application to
              run-time. When borrow_mut() is invoked the borrow is recorded and, should another borrow
              occur before the first becomes inactive, then a panic results.  The advantage of this is
              that the compiler&apos;s borrow checker cannot always tell if a time sequence of borrows
              is safe, and so will fail to compile unless we use RefCell&lt;T&gt;.
              <s-halfEm></s-halfEm>
            </t-b>
        </div>
        <div>
          <a id="conclusions"></a>
          <h2>6. Conclusions:</h2>
          <t-b>
            <div style="border:2px solid darkred; padding:0em 1.5em; width:max-content; max-width:55em;">
              <t-b>
                For single-threaded applications, the most frequently used smart pointer is the Box&lt;T&gt;
                to access data stored heap.  All except
                Rc&lt;T&gt; are used extensively in multi-threaded applications.
              </t-b>
            </div>
            <s-1em></s-1em>
          </t-b>
        </div>
        <div>
          <a id="exercises"></a>
          <h2>7. Exercises:</h2>
          <div class="indent">
            <ol class="tight indent">
              <li>
                Store a string in the heap, and pass around access to several functions.  Why could that
                be useful?
              </li>
              <li>
                The smart pointers Rc and RefCell are often used together as Rc&lt;RefCell&lt;T&gt;&gt;.
                What is the purpose of this construct?
              </li>
              <li>
                We haven&apos;t mentioned weak pointers in these notes. Go to the std::rc::Rc documentation
                <a target="_blank" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#285-288">here</a> and map the
                relationships between Rc&lt;T&gt;, RcBox&lt;T: ?Sized&gt;, and Cell&lt;T&gt;.
                <ul class="tight">
                  <li>Read the comments in that documentation, then summarize in a few words.</li>
                  <li>Where are the reference counts kept?  Why are there two?</li>
                </ul>
                <s-halfEm></s-halfEm>
              </li>
            </ol>
          </div>
        </div>
        <div>
          <a id="other"></a>
          <h3>8. Other Interesting Problems</h3>
          <t-b>
            In this section we look at several exercises that are a bit more complicated.  I&apos;ve
            provided solutions for them because of that, but its worth your time to read them as they will
            help you understand the intended roles for each of these smart pointers.
          </t-b>
          <div>
            <ol class="tight">
              <li>
                <t-b>
                  Create an immutable array of double precision numbers and initialize each element with the time
                  at which each entry was filled, in microseconds.  You will find the std::time library useful.
                  <div class="indent pad5">
                    Try doing this with a static array.  In order to initialize an immutable collection you will
                    need to use std::cell::RefCell.
                  </div>
                </t-b>
                <t-b>
                  <div>
                    <details>
                      <summary class="darkItem">Solution for Problem #1</summary>
                      <s-halfEm></s-halfEm>
                      <defn-outerBlock>
                        <defn-block>
                          <defn-head>Problem #1</defn-head>
                          <defn-code>
                            fn solution_1() {

                            print!("\n  -- solution #1 --");

                            let t:Duration = Duration::from_micros(0);
                            let time_array : [Duration; 5] = [t; 5]; // not mutable

                            let mut t_init = RefCell::new(time_array);
                            let start = std::time::Instant::now();
                            for i in 0..5 {
                            let inner = t_init.get_mut();
                            inner[i] = start.elapsed();
                            }
                            let time_array = t_init.into_inner(); // still not mutable
                            print!("\n  time_array = {:?}", time_array);
                            print!("\n  type is {:?}\n",show_type(time_array));
                            }
                          </defn-code>
                        </defn-block>
                        <defn-block>
                          <defn-head>Output:</defn-head>
                          <defn-code>
                            -- solution #1 --
                            time_array = [1.3µs, 1.6µs, 1.8µs, 2µs, 2.1µs]
                            type is "[core::time::Duration; 5]"
                          </defn-code>
                        </defn-block>
                      </defn-outerBlock>
                    </details>
                  </div>
                </t-b>
                <t-b>
                  The brief code, above, shows in a simple way, how to initialize a non-mutable
                  array using a RefCell container.  It&apos;s also interesting to observe the
                  time needed to traverse a small loop.
                </t-b>
              </li>
              <li>
                Create an array of Strings on the heap, where the size of the array is defined at
                run-time.  Display the strings, then swap the first and last strings and display the
                results.  Did you have to copy any characters to swap the two strings?
                <div class="indent pad5">
                  This is a loaded question: arrays are static, with memory layout defined at compile time.
                  If we broaden our definition of array to &quot;indexable collection of items residing in a
                  contiguous memory block&quot; then we can indeed define the size at run-time using a
                  Vec&lt;T&gt;.
                </div>
                <div class="indent pad5">
                  Now, we can create an array, of size determined at run-time, by creating a full slice of
                  the Vec&lt;T&gt;  So we didn&apos;t need the broader definition, but did have to take
                  a circuitous path to provide an answer to the question, as asked.
                </div>
                <div class="indent pad5">
                  If you try to directly swap elements you will run afoul of Rust&apos;s ownership rules - you can't
                  have more than one mutable reference.  Instead, look at the Vec::swap function.  If you look at its
                  source code - it&apos;s simple (and available - just google for rust vec swap and press the
                  [src] button).  The same is true for swap for slices.   That will allow you to fully answer the question.
                </div>
                <div class="pad5">
                  <details>
                    <summary class="darkItem">Solution for Problem #2</summary>
                    <s-halfEm></s-halfEm>
                    <defn-outerBlock>
                      <defn-block>
                        <defn-head>Solution #2</defn-head>
                        <defn-code>
                          /////////////////////////////////////////////////////////////
                          // This is an exploration of creating and managing arrays.
                          // Almost always you should prefer to use std::Vec.

                          fn exercise_3() {

                          print!("\n  -- solution #2 --");
                          /*-- create static array in stack and swap --*/
                          let s1 = "one".to_string();
                          let s2 = "two".to_string();
                          let s3 = "three".to_string();
                          let s4 = "four".to_string();
                          let s5 = "five".to_string();

                          let mut stack_array =
                          [
                          s1.clone(),
                          s2.clone(),
                          s3.clone(),
                          s4.clone(),
                          s5.clone()
                          ];
                          print!("\n  stack_array = {:?}", stack_array);
                          stack_array.swap(0,4);
                          print!("\n  stack_array = {:?}", stack_array);

                          /*-- create static array in heap and swap --*/
                          let mut heap_array = Box::new([s1, s2, s3, s4, s5]);
                          print!("\n  heap_array = {:?}", heap_array);
                          heap_array.swap(0,4);
                          print!("\n  heap_array = {:?}", heap_array);

                          /*-- create dynamic vector in heap and swap --*/
                          let n = 5;
                          let mut v = Vec::&lt;String&gt;::new();
                          for i in 0..n {
                          v.push((i + 1).to_string());
                          }
                          let mut heap_vec = Box::new(v);
                          print!("\n  heap_vec = {:?}", heap_vec);
                          heap_vec.swap(0,4);
                          print!("\n  heap_vec = {:?}\n", heap_vec);

                          /*-- create array with run-time size and store in heap --*/
                          let n = 7;  // run-time size, could have been passed in by user
                          let mut vn = Vec::&lt;String&gt;::new();
                          for i in 0..n {
                          vn.push((2*i).to_string());
                          }
                          /*-- here's array, created as slice of vec --*/
                          let arr_n = &amp;mut vn[..];
                          show_type_value("arr_n", &amp;arr_n);

                          let heap_arr_n = Box::new(arr_n);
                          show_type_value("heap_arr_n", &amp;heap_arr_n);

                          heap_arr_n.swap(0,6);
                          show_type_value("heap_arr_n", &amp;heap_arr_n);

                          /*-- bring array back to stack, consuming src --*/
                          let arr_back = *heap_arr_n;
                          show_type_value("arr_back", &amp;arr_back);

                          /*-- curious things you can do with arrays --*/

                          /////////////////////////////////////////////
                          // Can copy string into array of Strings
                          arr_back[2] = "third element".to_string();

                          /////////////////////////////////////////////
                          // This sequence of statements copies chars
                          // to effect swap.  Uses clone because
                          // Strings can't be moved out of array.
                          let first: String = arr_back[0].clone();
                          let last: String = arr_back[6].clone();
                          arr_back[0] = last;
                          arr_back[6] = first;
                          /////////////////////////////////////////////
                          // This statment just swaps pointers
                          //-------------------------------------------
                          // arr_back.swap(0,6);

                          show_type_value("swapped arr_back", &amp;arr_back);

                          println!();
                          }
                        </defn-code>
                      </defn-block>
                      <defn-block>
                        <defn-head>Output:</defn-head>
                        <defn-code>
                          -- solution #2 --
                          stack_array = ["one", "two", "three", "four", "five"]
                          stack_array = ["five", "two", "three", "four", "one"]
                          heap_array = ["one", "two", "three", "four", "five"]
                          heap_array = ["five", "two", "three", "four", "one"]
                          heap_vec = ["1", "2", "3", "4", "5"]
                          heap_vec = ["5", "2", "3", "4", "1"]

                          arr_n = ["0", "2", "4", "6", "8", "10", "12"]
                          &&mut [alloc::string::String]
                          heap_arr_n = ["0", "2", "4", "6", "8", "10", "12"]
                          &alloc::boxed::Box&lt;&mut [alloc::string::String]&gt;
                          heap_arr_n = ["12", "2", "4", "6", "8", "10", "0"]
                          &alloc::boxed::Box&lt;&mut [alloc::string::String]&gt;
                          arr_back = ["12", "2", "4", "6", "8", "10", "0"]
                          &&mut [alloc::string::String]
                          swapped arr_back = ["0", "2", "third element", "6", "8", "10", "12"]
                          &&mut [alloc::string::String]
                        </defn-code>
                      </defn-block>
                    </defn-outerBlock>
                  </details>
                </div>
                <t-b class="top">
                  The solution, above, provides a lot of details about using heap memory,
                  working with vectors and with arrays.  You will see handled all of the issues cited
                  in the Exercise 3 statement with comments to help illustrate
                  what the code is trying to do.
                </t-b>
              </li>
              <li>
                Create a string that is simultaneously shared by two different identifiers. What do you have
                to do to modify the string?
                <s-halfEm></s-halfEm>
                <div class="indent pad5">
                  <div style="border:2px solid darkred; padding: 10px 15px;">
                    Shared mutation is not allowed in safe Rust as that can lead to undefined behavior
                    through unsafe memory access.
                  </div>
                  <t-b>
                    But, suppose that the shared mutations are staggered in
                    time so that they don't intereact?  Rust&apos;s borrow checker can often analyze
                    this case and allow it.  But sometimes the checker is just not strong enough to
                    detect this structure and a build fails for safe code.
                  </t-b>
                  <t-b>
                    This is exactly the primary use case for RefCell.  It defers some borrow checking
                    to run-time.  Then if the accesses are all truely staggered, the processing succeeds.
                  </t-b>
                </div>
                <div class="indent">
                  The answer I want to show you uses RefCell to defer borrow checking to run-time.
                </div>
                <s-halfEm></s-halfEm>
                <div class="pad5">
                  <details>
                    <summary class="darkItem">Solution for Problem #3</summary>
                    <s-halfEm></s-halfEm>
                    <defn-outerBlock>
                      <defn-block>
                        <defn-head>run_time_checking:main.rs</defn-head>
                        <defn-code>
                          /////////////////////////////////////////////////////////////
                          // run_time_checking::main.rs - demo RefCell               //
                          //                                                         //
                          // Jim Fawcett, https://JimFawcett.github.io, 08 Jun 2020  //
                          /////////////////////////////////////////////////////////////
                          /*
                          Demonstrate deferring ownership rule checking
                          to run-time by using RefCell.
                          */

                          #![allow(dead_code)]

                          use std::cell::RefCell;
                          use std::io::*;

                          fn putline() { println!(); }

                          /*-----------------------------------------------
                          This first function compiles.
                          Borrow checker flow analysis accepts it.
                          It has either immutable or mutable borrow,
                          but not both.  Borrow checker analyzed this!
                          */
                          fn test_checker1(p: bool) {
                          let mut s = String::from("this is a test");
                          let mut rs: &amp;String = &amp;"rs".to_string();
                          let mut mrs: &amp;mut String = &amp;mut "mrs".to_string();
                          if p {
                          rs = &amp;s;
                          print!("\n  rs = {:?}", rs);
                          }  // immutable borrow goes out of scope
                          else {
                          mrs = &amp;mut s;
                          print!("\n  mrs = {:?}", mrs);
                          }  // mutable borrow goes out of scope
                          print!("\n  mrs = {:?}", mrs);
                          print!("\n  rs = {:?}", rs);
                          putline();
                          }
                          /*-----------------------------------------------
                          Borrow checker flow analysis fails here even
                          if called with p1 != p2.  Borrow checker
                          can't tell without analyzing caller -
                          too complicated for compiler analysis.

                          Note: this function is same as test_checker1
                          except now has two predicates.
                          */
                          // fn test_checker2(p1: bool, p2: bool) {
                          //     let mut s = String::from("this is a test");
                          //     let mut rs: &amp;String = &amp;"rs".to_string();
                          //     let mut mrs: &amp;mut String = &amp;mut "mrs".to_string();
                          //     if p1 {
                          //         rs = &amp;s;
                          //     }
                          //     if p2 {
                          //         mrs = &amp;mut s;
                          //     }
                          //     print!("\n  mrs = {:?}", mrs);
                          //     print!("\n  rs = {:?}", rs);
                          // }
                          /*-----------------------------------------------
                          This function replicates functionality of
                          test_checker2.  It uses RefCell to defer
                          checking to run-time (hiding mutability),
                          So borrow checker accepts it.

                          I've added a new case using predicate p3
                          that doesn't satisfy ownership rules even
                          at run-time, and so panics.
                          */
                          fn test_checker3(p1: bool, p2: bool, p3:bool) {

                          print!(
                          "\n  -- test_checcker3({}, {}, {}) --",
                          p1, p2, p3
                          );
                          let s = String::from("this is a test");       // replacement
                          let sp1 = RefCell::new(s);
                          print!("\n  &amp;sp1 = {:?}", &amp;sp1.borrow());
                          let sp2 = RefCell::new("rsp2".to_string());   // initial val
                          let mut rsp2 = &amp;sp2;
                          let sp3 = RefCell::new("rsp3".to_string());   // initial val
                          let mut rsp3: &amp;RefCell&lt;String&gt; = &amp;sp3;

                          if p1 {
                          print!("\n  -- immutable borrow --");
                          rsp2 = &amp;sp1;
                          print!("\n  &amp;rsp2.borrow() = {:?}", &amp;rsp2.borrow());
                          }  // borrow goes out of scope

                          if p2 {
                          print!("\n  -- mutable borrow --");
                          let mut x = sp1.borrow_mut();
                          x.push_str(" and more");
                          rsp3 = &amp;sp1;
                          print!("\n  &amp;rsp3 = {:?}", &amp;rsp2);
                          }  // borrow goes out of scope

                          if p3 {  // panic if p3 true
                          print!("\n  -- immutable and mutable borrow --");
                          let _ = std::io::stdout().flush();
                          rsp2 = &amp;sp1;                    // immutable borrow
                          let mut x = sp1.borrow_mut();   // mutable borrow
                          x.push_str(" and more");        // mutates sp1 inner
                          /*-- looks like immutable borrow so compiles --*/
                          rsp3 = &amp;sp1;
                          print!("\n  &amp;rsp2.borrow() = {:?}", &amp;rsp2.borrow());
                          print!("\n  &amp;rsp3.borrow() = {:?}", &amp;rsp3.borrow());
                          }  // never get here - ownership rules violated

                          print!("\n  -- final results --");
                          print!("\n  &amp;rsp2.borrow() = {:?}", &amp;rsp2.borrow());
                          print!("\n  &amp;rsp3.borrow() = {:?}", &amp;rsp3.borrow());
                          putline();
                          }

                          fn main() {

                          // test_checker1(true);             // succeeds
                          // test_checker1(false);            // succeeds
                          test_checker3(true, true, false);   // succeeds
                          test_checker3(true, true, true);    // panics

                          println!("\n\n  That's all Folks!\n\n");
                          }
                        </defn-code>
                      </defn-block>
                      <defn-block>
                        <defn-head>Output:</defn-head>
                        <defn-code>
                          -- test_checcker3(true, true, false) --
                          &sp1 = "this is a test"
                          -- immutable borrow --
                          &rsp2.borrow() = "this is a test"
                          -- mutable borrow --
                          &rsp3 = RefCell { value: <borrowed>
                            }
                            -- final results --
                            &rsp2.borrow() = "this is a test and more"
                            &rsp3.borrow() = "this is a test and more"

                            -- test_checcker3(true, true, true) --
                            &sp1 = "this is a test"
                            -- immutable borrow --
                            &rsp2.borrow() = "this is a test"
                            -- mutable borrow --
                            &rsp3 = RefCell { value: <borrowed>
                              }
                              -- immutable and mutable borrow --
                              thread 'main' panicked at 'already mutably borrowed:
                              BorrowError', ...
                        </defn-code>
                      </defn-block>
                    </defn-outerBlock>
                  </details>
                </div>
                <t-b>
                  Deferring checking to run-time doesn't let you violate the ownership rules.
                  You use this technique when the compiler&apos;s static analysis can&apos;t tell if the
                  rules will be broken.  In this case, unless you do something like this, the build will
                  fail.
                </t-b>
                <t-b>
                  Using RefCell hides the mutability of a borrow, which
                  allows the code to compile, and then run-time processing will succeed or panic depending
                  on whether ownership rules are actually satisfied or not.
                </t-b>
                <t-b>
                  This turns out to be a very important technique for sharing between threads, as we will
                  see in the <a target="_blank" href="RustBites_Threads.html">Threads Bite</a>.
                </t-b>
              </li>
            </ol>
          </div>
        </div>
        <div>
          <a id="refs"></a>
          <h2>9. References:</h2>
          <div class="pad10 indent">
            <table style="border-collapse: collapse;">
              <tr>
                <th class="darkItem">Reference</th>
                <th class="darkItem">Description</th>
              </tr>
              <tr>
                <td class="lightItem"><a target="_blank" href="../RustBites/CodeSamples/SmartPtrs">Code for SmartPtrs</a></td>
                <td class="lightItem">Code for Examples of Box, Rc, Arc, RefCell</td>
              </tr>
              <tr>
                <td class="lightItem"><a target="_blank" href="https://www.youtube.com/watch?v=8O0Nt9qY_vo">Jon Gjengset</a></td>
                <td class="lightItem">Crust of Rust: SmartPtrs and interior mutability</td>
              </tr>
            </table>
          </div>
        </div>
        <div style="height:5rem;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <sec-elem style="width:0.0em">&nbsp;</sec-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#other">other</a></menu-elem>
        <menu-elem class="secElem"><a href="#exercises">exercises</a></menu-elem>
        <menu-elem class="secElem"><a href="#conclusions">conclusions</a></menu-elem>
        <menu-elem class="secElem"><a href="#intermut">intermut</a></menu-elem>
        <menu-elem class="secElem"><a href="#refcell">refcell</a></menu-elem>
        <menu-elem class="secElem"><a href="#arc">arc</a></menu-elem>
        <menu-elem class="secElem"><a href="#rc">rc</a></menu-elem>
        <menu-elem class="secElem"><a href="#box">box</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
        <div class='darkItem popupHeader' style="padding:0.25em 2.0em;" onclick="location.reload()">Sections</div>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
</body>
</html>

