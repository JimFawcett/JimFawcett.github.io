<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Prologue.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Rust Models</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="RustStory_Data.html">N</a>
  <a id="Prev" href="RustStory_Prologue.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 1. - Rust Models</h1>
      <h3 id="subtitle">Code Structure, Builds, Ownership, User-Defined Types and Traits</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#structure">Structure</a>, 
       <a href="#build">Build</a>, <a href="#ownership">Ownership</a>, <a href="#types">User-Defined Types</a>, 
       <a href="#refs">References</a>
     </rt-b>
   </toc-b>

  <bb-55 class="indent">
    <a id="prologue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.0</num-item1><num-item4>Prologue:</num-item4>
    </num-cont>
    <t-b>
      Rust is an interesting language, similar to C++, but with some unique differences:
      <indent-block class="pad10">
        <ol class="tight">
          <li>
            Rust&apos;s types are, by default, immutable. You have to opt-in to mutability with the
            mut keyword:
            <indent-block class="pad5">
              <c-s>let s = mut String::from("a string");</c-s>
            </indent-block>
          </li>
          <li>
            If a type is blittable, e.g., primitives, arrays, ... it is copyable:
            <indent-block class="pad5">
              <c-s>let a1 = [1, 2, 3];<br />let a2 = a1;&nbsp;&nbsp;&nbsp;// a copy</c-s>
            </indent-block>
          </li>
          <li>
            If not blittable, e.g., strings, a collection type, ... then it gets moved:
            <indent-block class="pad5">
              <c-s>let s1 = "a string".to_string();<br />let s2 = s1;&nbsp;&nbsp;&nbsp;// a move</c-s>
            </indent-block>
            In this example, s1 will not be usable after the move. Attempts to use a moved item are
            <n-s>compile</n-s> errors!
          </li>
          <li>
            All resource management is scope based.  When an item, holding resources, goes out of scope,
            its <n-s>drop</n-s> function (similar to a C++ destructor) is called.
          </li>
          <li>
            All heap allocations are referenced with a smart <c-s>Box&lt;T&gt;</c-s> pointer that drops its
            reference when it goes out of scope, similar to the C++ <c-s>std::unique_ptr&lt;T&gt;</c-s>.
          </li>
          <li>
            Rust has a module system, useful for refactoring local code, and packages that need not
            be local.
          </li>
          <li>
            It has a relatively complete <a href="https://doc.rust-lang.org/beta/std/">std library</a>
            with collections, threads, tcp socket wrappers, file system library, ...
          </li>
          <li>
            It has a very useful tool, <n-s>Cargo</n-s> which is a package manager, builder, and
            verifier, and will execute code, all with a simple command syntax.
          </li>
          <li>
            The Rust compiler analyzes code deeply and refuses to build code that has memory and
            reference problems.  Because of the structure of its types, this analysis is suprisingly
            fast.
          </li>
        </ol>
      </indent-block>
    </t-b>
  <a id="structure"></a>
  <hr class="spread" />
    <num-cont>
      <num-item1>1.1</num-item1><num-item4>Code Structure:</num-item4>
    </num-cont>
    <div style="width:calc(100vw - 6rem);">
      <photosizer-block src="Pictures/VscDemo.JPG" width="700" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 1. Demo_Crate Package directory in VS Code
        </span>
      </photosizer-block>
    </div>
    <t-b>
      Rust code structure is based on <n-s>crates</n-s> and <n-s>packages</n-s>:
      <indent-block class="pad10">
        <ul class="tight">
          <li>
            <strong>package:</strong>
            <div class="pad10">
              A package is a directory containing a <n-s>cargo.toml</n-s> file and a <n-s>scr</n-s> folder
              containing a collection of source files. Packages are built with cargo:
              <indent-block class="pad10">
                <c-s>cargo init [--bin | --lib] [package_name]</c-s><br />
                Default option is --bin and default package_name is the current directory name.
              </indent-block>
              The <c-s>cargo build</c-s> command creates a Target subdirectory, if it doesn&apos;t
              already exist, and runs rustc to create an executable or library in <c-s>Target/debug</c-s>.
            </div>
          </li>
          <li>
            <strong>crate:</strong>
            <div class="pad10">
              A crate is a Rust source file in a package src subdirectory named main.rs (binary), *.rs, or lib.rs (library).
              The main.rs file is expected to have a <c-s>fn main() {...}</c-s>.
            </div>
          </li>
        </ul>
      </indent-block>
    </t-b>
    <t-b>
      A <c-s>main.rs</c-s> may load a crate <c-s>helper.rs</c-s> from its own src directory with the 
      declaration <c-s>mod helper</c-s> and then use public functions from helper.
    </t-b>
    <t-b>
      The package for <c-s>main.rs</c-s> may also import a library <c-s>helper_lib</c-s> by including 
      the path to helper_lib in its
      <c-s>Cargo.toml</c-s> file&apos;s <c-s>[dependencies]</c-s> section.
      <indent-block class="pad10">
        <c-s>
          [dependencies]<br />
          helper_lib = { path = "../helper_lib"}
        </c-s>
      </indent-block>
    </t-b>
    <t-b>
      The main.rs file may then simply use <c-s>helper_lib::some_function()</c-s> or declare
      <c-s>use helper_lib::{ some_function }</c-s> at the top and then use some_function() in its 
      subsequent code.
    </t-b>
    <t-b>
      <details>
        <summary class="labelStyle darkItem">Structure Demo</summary>
        <t-b>
          The <c-s>main</c-s> function in <c-s>demo/src/main.rs</c-s> uses code from 
          <c-s>demo/src/helper.rs</c-s> and <c-s>demo_lib/src/lib.rs</c-s>. This shows how to
          factor code into maintainable pieces.
        </t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>demo/src/main.rs</defn-head>
            <defn-code>
mod helper;  // declares helper module
             // since there is no code block
             // helper.rs must be in local src and 
             // provide code for this module

use helper::{ say };

use demo_lib::{ libsay };  // only needed to qualify use of libsay

fn main() {
    helper::say();
    say();
    demo_lib::libsay();
    libsay();
    print!("\n  Hello, world!\n\n");
}
            </defn-code>
            <defn-head class="defnBorderTop">demo/src/helper.rs</defn-head>
            <defn-code>
pub fn say() {
    print!("\n  hello from helper");
}

// Including a main function is not a good idea
// but doesn't seem to do any harm, even if pub.
#[allow(dead_code)]
fn main() {
    print!("\n  hello world");
}
            </defn-code>
            <defn-head class="defnBorderTop">demo/Cargo.toml</defn-head>
            <defn-code>
[package]
name = "demo"
version = "0.1.0"
authors = ["James W. Fawcett &lt;jfawcett@twcny.rr.com&gt;"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
demo_lib = { path = "../demo_lib" }
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>demo_lib/src/lib.rs</defn-head>
            <defn-code>
pub fn libsay() {
    print!("\n  hello from demo_lib");
}
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
cargo -q run

  hello from helper
  hello from helper
  hello from demo_lib
  hello from demo_lib
  Hello, world!

            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </details>
    </t-b>
    <t-b style="margin-bottom:0px;">
      There is more to Rust <n-s>Code Structure</n-s>, e.g.:
    </t-b>
    <indent-block class="pad10">
      <ul class="tight">
        <li>
          <strong>Structs and Traits:</strong>
          <indent-block class="pad10">
            Roughly equivalent to C++ classes and interfaces.
          </indent-block>
        </li>
        <li>
          <strong>Enums and Matching:</strong>
          <indent-block class="pad10">
            Enums have much more functionality in Rust than in other languages.
          </indent-block>
        </li>
        <li>
          <strong>Modules:</strong>
          <indent-block class="pad10">
            Modules provide a way to factor code into smaller simpler parts in the same package.
          </indent-block>
        </li>
      </ul>
    </indent-block>
    Some of this we will discuss in <num-item1>1.4</num-item1><num-item4>User-Defined Types</num-item4>.
    The rest in <n-s>Chapter&nbsp;2&nbsp;-&nbsp;Data</n-s> and <n-s>chapter&nbsp;3&nbsp;-&nbsp;Operations</n-s>.
    <a id="build"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.2</num-item1><num-item4>Build Process:</num-item4>
    </num-cont>
    <t-b>
      All of this is built with a Rust tool called <n-s>Cargo</n-s>.  <n-s>Cargo</n-s> is a package manager,
      that can build, run, and clean a Rust <n-s>Package</n-s> as well as create a new <n-s>Package</n-s>
      and download crates from <a href="https://Crates.io">https://crates.io</a>.
    </t-b>
    <t-b>
      Figure 1. shows a newly created <n-s>Package</n-s>.  The process is simple.
      <indent-block class="pad10">
        <ol class="tight">
          <li>
            Open a Developer&apos;s command prompt
          </li>
          <li>
            Create a directory temp with <n-s>mkdir temp</n-s>
          </li>
          <li>
            Issue the command: <n-s>cargo new demo_crate</n-s>. That creates everything shown in Figure 1.
            <indent-block class="pad10">
              The image is a screen shot of Visual Studo Code with opened folder demo_crate.
            </indent-block>
            The <n-s>Cargo</n-s> tool is in your path after you install Rust.
          </li>
          <li>
            <n-s>main.rs</n-s> is a demonstration &quot;Hello World&quot; program.
          </li>
          <li>
            Build with the command <n-s>cargo build</n-s> and run with <n-s>cargo run</n-s>.
          </li>
          <li>
            Clean the crate with <n-s>cargo clean</n-s>.
          </li>
        </ol>
      </indent-block>
      <t-b>
        Using <a href="https://code.visualstudio.com/download">Visual Studio Code</a> makes this a fairly
        painless process.  If, using the command window, you navigate to the temp directory and type
        <c-s>code .</c-s>, assuming you&apos;ve installed VS Code, it will open showing the temp
        directory and its files an subdirectories, e.g., <c-s>Cargo.toml</c-s> and <c-s>temp/src</c-s>.
      </t-b>
      <t-b>
        You can open a teminal in VS Code, e.g., <n-s>top menu > Terminal > New Terminal</n-s>.  I usually move the terminal
        to the right side.  You can do that with <n-s>top menu > View > Appearance > Move Panel Right</n-s>.
        You can make your favored panel position the default in <n-s>top menu > View > Pallet [searh: user settings] >
        [search panel]</n-s>.
      </t-b>
      <t-b>
        Now, you can edit the package files, save, then, in the <n-s>terminal</n-s> type <c-s>cargo check</c-s>
        to test the build without running, and <c-s>cargo run</c-s> to build and run.  You will see the output
        in the terminal.  When you are done you can <c-s>cargo clean</c-s> to remove the target items including
        the <c-s>target</c-s> folder itself.
      </t-b>
      <t-b>
        A typical Rust program consists of a binary crate (one with a main.rs) and perhaps several
        library crates that implement all the functionality used by main.
      </t-b>
      <t-b>
        You create a library crate with the command <n-s>cargo new [library name] --lib</n-s>.  That builds
        the same structure as shown here except that in the folder <n-s>src</n-s> you find a file
        <n-s>lib.rs</n-s> that has functions that implement the library&apos;s operations and a test fixture
        for running a sequence of tests on the library.
      </t-b>
      <t-b>
        The binary crate must specify each of the libraries it uses with dependencies in its <n-s>Cargo.toml</n-s>
        file. All of this is illustrated by the code in the two details dropdowns, below.
      </t-b>
    </t-b>
    <num-cont>
      <num-item1>1.2.1</num-item1><num-item4>Display Library</num-item4>
    </num-cont>
    <t-b>
      This display library provides a set of display functions to help generate demonstration and
      debug io for Rust programs.  It contains functions:
      <indent-block class="pad10">
        <ol class="tight">
          <li>
            <n-s>show_type&lt;T&gt;(_value: &amp;T)</n-s> - 
            Displays type and size of input
          </li>
          <li>
            <n-s>log&lt;T&gt;(value: &amp;T)</n-s> - 
            Displays type and size of input, followed by its value.
          </li>
          <li>
            <n-s>title(msg: String)</n-s> - 
            Displays msg followed by an underline.
          </li>
          <li>
            <n-s>putline()</n-s> - Emits a newline.
          </li>
          <li>
            <n-s>putlinen(n: usize)</n-s> - Emits n newlines.
          </li>
        </ol>
      </indent-block>
      The code in <n-s>display_test</n-s> shows how it imports the library, <n-s>display</n-s>.
      Look at the dependencies in <n-s>display_test::Cargo.toml</n-s> and at the extern crate
      declaration at the top of the code in <n-s>display_test::main.rs</n-s>
    </t-b>
    <indent-blocks>
    <details>
      <summary class="labelStyle, darkItem">display_test</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>display_test::Cargo.toml</defn-head>
            <defn-code>
[package]
name = "test_display"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

[dependencies]
display = { path = "../display" }
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>

C:\github\JimFawcett\RustBasicDemos\display_test>
cargo -q run

 test types
------------
 TypeId: alloc::string::String, size: 12
 value:  String (8): a string
 TypeId: i8, size: 1
 value:  100
 TypeId: alloc::vec::Vec&lt;i32&gt;, size: 12
 value:  [-1, 0, 1]
 TypeId: test_display::main::Test, size: 1
 value:  Test1
 TypeId: test_display::main::Test, size: 1
 value:  Test2
 TypeId: test_display::Point, size: 24
 value:  Point { x: 1.0, y: 1.5, z: 2.0 }

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>display_test::main.rs</defn-head>
            <defn-code>
/////////////////////////////////////////////////////////////
// test_display::main.rs - test display library            //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 Feb 2020  //
/////////////////////////////////////////////////////////////
/*
  Usually you test a library using the library's built in
  test functions.  But those cannot write to the console
  because they are a compiled part of the library which
  has no console.

  So I've constructed this separate main that uses the
  library just like any other application.
*/

extern crate display;
use display::{ putline, title, log, putlinen };

#[derive(Debug)]
struct Point {
  x: f64,
  y: f64,
  z: f64,
}

fn main() {
  putline();
  title("test types".to_string());
  let mut str = String::new();
  str.push_str("a string");
  log(&amp;str);
  let an_i8: i8 = 100;
  log(&amp;an_i8);
  let mut vi : Vec&lt;i32&gt; = Vec::new();
  vi.push(-1);
  vi.push(0);
  vi.push(1);
  log(&amp;vi);
  #[derive(Debug)]
  enum Test { Test1, Test2, };
  log(&amp;Test::Test1);
  log(&amp;Test::Test2);
  let point = Point { x:1.0, y:1.5, z:2.0 };
  log(&amp;point);
  putlinen(1);
}
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
  </indent-blocks>
  <t-b>
    The code in <n-s>display</n-s> shows the structure of a lib crate. Note how the library
    imports Rust std library facilities with a series of use std::xxxx statements. These
    do essentially the same thing that #include &lt;xxxx&gt; declarations do in C++.
  </t-b>
  <indent-blocks>
    <details>
      <summary class="labelStyle, darkItem">display library</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>display::Cargo.toml</defn-head>
            <defn-code>
[package]
name = "display"
version = "0.1.0"
authors = ["James W. Fawcett &lt;jfawcett@twcny.rr.com&gt;"]
edition = "2018"

[dependencies]

            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
C:\github\JimFawcett\RustBasicDemos\display>
cargo test
Compiling display v0.1.0
(C:\github\JimFawcett\RustBasicDemos\display)
Finished test [unoptimized + debuginfo]
target(s) in 0.63s
Running target\debug\deps
\display-7c39a3f9b415f17e.exe

running 1 test
test tests::test_types ... ok

test result: ok.
1 passed; 0 failed; 0 ignored; 0 measured;
0 filtered out

Doc-tests display

running 0 tests

test result: ok.
0 passed; 0 failed; 0 ignored; 0 measured;
0 filtered out

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>display::lib.rs</defn-head>
            <defn-code>
///////////////////////////////////////////////////////////////
// display::main.rs tests - Demonstrate display types        //
//                                                           //
// Jim Fawcett, https://JimFawcett.github.io, 14 Feb 2020    //
///////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Debug)]
    struct Point {
        x: f64,
        y: f64,
        z: f64,
    }
    #[test]
    /*
       Library doesn't write to console, so all this tests is
       no panic occurred.  See test_display for useful tests.
    */
    fn test_types() {

        // test code elided

    }
}

/////////////////////////////////////////////////////////////
// display::main.rs - Demonstrate display types            //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 Feb 2020  //
/////////////////////////////////////////////////////////////
/*
   log and do_work are derived from:
   https://doc.rust-lang.org/beta/std/any/index.html

*/
use std::fmt::Debug;
use std::any::Any;
use std::any::type_name;
use std::mem::size_of;

/*---------------------------------------------------------
   show type name on console
   - expects T to implement Debug
   - see #[define(Debug)] attributes, above 
*/
pub fn show_type&lt;T: Any + Debug&gt;(_value: &amp;T) {
    let name = type_name::&lt;T&gt;();
    print!(
      "\n  TypeId: {}, size: {}", name, size_of::&lt;T&gt;()
    );
}

/*---------------------------------------------------------
   log type name and value to console
   - expects T to implement Debug
   - see #[define(Debug)] attributes, above 
*/
pub fn log&lt;T: Any + Debug&gt;(value: &amp;T) {
    let value_any = value as &amp;dyn Any;
    let name = type_name::&lt;T&gt;();
    print!(
      "\n  TypeId: {}, size: {}", name, size_of::&lt;T&gt;()
    );

    // Try to convert our value to a `String`. If successful, 
    // we want to output the String`'s length as well as its 
    // value. If not, it's a different type: just print it 
    // out unadorned.

    match value_any.downcast_ref::&lt;String&gt;() {
        Some(as_string) =&gt; {
            print!(
              "\n  value:  String ({}): {}", 
              as_string.len(), as_string
            );
        }
        None =&gt; {
            print!("\n  value:  {:?}", value);
        }
    }
}

/*---------------------------------------------------------
   Display underlined title on console
*/
pub fn title(msg: String) {
    print!("\n  {}", msg);
    let s = std::iter::repeat('-').take(msg.len() + 2)
            .collect::&lt;String&gt;();
    print!("\n {}", s);
}
/*-- push a single newline to console --*/

pub fn putline() {
    println!("\n");
}
/*-- pust n newlines to console --*/

pub fn putlinen(n: usize) {
    let s = std::iter::repeat('\n').take(n)
            .collect::&lt;String&gt;();
    println!("{}", s);
}

            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
    </indent-blocks>
    <t-b>
      Configuring packages and building them are traditionally done with <n-s>Cargo</n-s>.  Cargo is a 
      package manager, build manager (in some ways like a make file), checker, runner, and cleaner.
    </t-b>
    <t-b>
      One of the first things a developer new to Rust needs to learn is the naming conventions that 
      Cargo depends upon to do its business. It looks for directories named <n-s>src</n-s> to find
      code to build, its dependencies, described in <n-s>Cargo.toml</n-s>, have to be library packages
      that come from a local path or from <a href="https://crates.io">crates.io</a>, and it expects
      that modules are loaded from the local <n-s>src</n-s> directory.
    </t-b>
    <a id="ownership"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.3</num-item1><num-item4>Ownership:</num-item4>
    </num-cont>
    <t-b>
      Ownership is one of the most important features of the Rust programming language.  Rust fully
      supports value types, and manages to do that without help from the application designer.  There
      are no copy and move constructors, assignment operators, and destructors to write.
    </t-b>
    <t-b>
      Every name is bound to a value on the stack.  The value may have additional structure on the 
      heap which it manages without prompting by the designer. When the value goes out of scope, 
      it drops any heap resources it may own.
    </t-b>
    <t-b>
      When a new name binds to a declared value:
      <indent-block class="pad5">
        <c-s>let x = y;</c-s>
      </indent-block>
      That results in a copy if y&apos;s value is copyable, e.g., blittable. If not, then y&apos;s
      value is moved to x, passing ownership.  In that case, y is no longer usable.  If code attempts
      to use a moved instance that results in a <n-s>compile-time</n-s> error.
    </t-b>
    <t-b>
      Here&apos;s an example:
      <indent-block class="pad5">
        <defn-outerBlock>
          <defn-block>
            <defn-head>Example of copy and move:</defn-head>
            <defn-code>
let i = 3;        // i is blittable
let mut j = i;    // j gets copy of i
print!("\n  i = {}, j = {}", i, j);
// i is still usable

let s = String::from("String named s");  // s is not blitable
let mut t = s;                           // s is moved to t
t.push_str(" with more stuff");
print!("\n  t = {}", t);
// print!("\n  s = {}", s);              // can't use s, been moved

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output:</defn-head>
            <defn-code>


i = 3, j = 3





t = String named s with more stuff
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </indent-block>    </t-b>
    <t-b>
      Rust has references, which bind to, but don't own their &quot;borrowed&quot; values:
      <indent-block class="pad5">
        <c-s>let r = &amp;x;</c-s>
      </indent-block>
      A Rust program many have any number of non-mutating references to a given value.  However, it
      may only have at most one mutating reference, and in that case, no other references.
      <indent-block class="pad5">
        <c-s>let r = &amp;mut x;</c-s>
      </indent-block>
      Since references don&apos;t own the values to which they bind, nothing happens when they go out of
      scope.  Drops happen only for owned values.
    </t-b>
    <t-b>
      Example of references, using the code above:
      <indent-block class="pad5">
        <defn-outerBlock>
          <defn-block>
            <defn-head>Example reference:</defn-head>
            <defn-code>
let r = &mut j;   // r borrows j, e.g., reference, no copy
*r += 2;          // j is mutated
print!("\n  i = {}, j = {}", i, j);
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output:</defn-head>
            <defn-code>


i = 3, j = 5
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </indent-block>
    </t-b>
    <t-b>
      The next section focuses on user-defined structuring of code and data.
    </t-b>
    <a id="types"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.4</num-item1><num-item4>Rust Types and User-Defined Types and Traits:</num-item4>
    </num-cont>
    <t-b>
      Rust&apos;s <n-s><a href="https://doc.rust-lang.org/beta/std/index.html#primitives">type system</a></n-s> has:
      <indent-block class="pad5">
        <ul class="tight">
          <li>
            primitives, i32, f64, ... 
          </li>
          <li>
            array [i32, 4]
          </li>
          <li>
            tuple (i32, f64, String)
          </li>
          <li>
            struct { i:i32, f:f64, s:String }
          </li>
          <li>
            enum { BS(String), MS(String), PhD(String) }
          </li>
          <li>
            std collections:<br />
            Vec, VecDeque, LinkedList<br />
            HashMap, HashSet, BTreeMap, BTreeSet<br />
            BinaryHeap
          </li>
        </ul>
      </indent-block>
    </t-b>
    <t-b>
      The details dropdown, below, shows how to write type specifications for each of the non-collection
      types. Usually you don&apos;t need to supply the specs, but instead may rely on the compiler&apos;s
      strong type inference engine.
    </t-b>
    <t-b>
      Occasionally the Rust compiler needs help defining life time of references.  It is determined to
      ensure that a reference does not outlive the value to which it is bound. You can see an example
      of that for the S struct, in the dropdown, where we tell the compiler that a literal string is 
      static, e.g., it has the lifetime of the program.  The syntax is: <c-s>s:&'static str</c-s> where 
      the &apos;static says that the literal string has the same lifetime as the program.
    </t-b>
    <t-b>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Type Declarations:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Declaring Code:</defn-head>
              <defn-code>
/*-- fully specified --*/
let i:i32 = 5;
let f:f64 = 3.4;
let a:[f32; 5] = [1.0, 1.5, 2.0, 1.5, 1.0];
let t:(i32, f64, String) = (1, 2.0, "three".to_string());
#[derive(Debug)]
struct S{i:i32, s:&'static str, };
let s:S = S{i:15, s:"a literal string" };
#[derive(Debug)]
enum E {BS(String), MS(String), PhD(String),};
let e:E = E::MS("Computer Engineering".to_string());

print!("\n  -- fully specified types --\n");
print!("\n  i = {:?}", i);
print!("\n  f = {:?}", f);
print!("\n  a = {:?}", a);
print!("\n  t = {:?}", t);
print!("\n  s = {:?}", s);
print!("\n  e = {:?}", e);

/*-- using type deduction --*/
let i = 5;
let f = 3.4;
let a = [1.0, 1.5, 2.0, 1.5, 1.0];
let t = (1, 2.0, "three".to_string());
let s = S{i:15, s:"a literal string" };
let e = E::MS("Computer Engineering".to_string());

print!("\n\n  -- using type deduction --\n");
print!("\n  i = {:?}", i);
print!("\n  f = {:?}", f);
print!("\n  a = {:?}", a);
print!("\n  t = {:?}", t);
print!("\n  s = {:?}", s);
print!("\n  e = {:?}", e);
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
-- fully specified types --

i = 5
f = 3.4
a = [1.0, 1.5, 2.0, 1.5, 1.0]
t = (1, 2.0, "three")
s = S { i: 15, s: "a literal string" }
e = MS("Computer Engineering")

-- using type deduction --

i = 5
f = 3.4
a = [1.0, 1.5, 2.0, 1.5, 1.0]
t = (1, 2.0, "three")
s = S { i: 15, s: "a literal string" }
e = MS("Computer Engineering")

              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </t-b>
    </t-b>
    <t-b>
      Rust does not have classes or inheritance.  It does, however, have structs and traits.  A trait is
      similar to an interface or abstract class.  Here&apos;s an example, used in the details dropdown, 
      below:
      <t-b>
        <defn-block>
          <defn-head>Salutation Trait</defn-head>
          <defn-code>
trait Speaker {
    fn salutation(&self) -> String;
}
          </defn-code>
        </defn-block>
      </t-b>
      <t-b>
        The trait declares a salutation function that structs implement, like this:
      </t-b>
      <t-b>
        <defn-block>
          <defn-head>
            Implementing Saluation Trait
          </defn-head>
          <defn-code>
pub struct Presenter;
impl Speaker for Presenter {
    fn salutation(&self) -> String {
      "Hello, today we will discuss ...".to_string()
    }
} 
          </defn-code>
        </defn-block>
      </t-b>
    </t-b>
    <t->
      The code in the User-Defined Type dropdown illustrates how this can be used to implement
      polymorphic operations, e.g., function dispatching based on the type of value  bound to a reference,
      not on the type of the reference.
    </t->
    <t-b>
      That works because each trait has a virtual function pointer table used for function dispatching.
    </t-b>
    <t-b>
      <t-b>
        <details>
          <summary class="labelStyle darkItem">Example User-Defined Type:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Declaring Code:</defn-head>
              <defn-code>
///////////////////////////////////////////////////////////
// user-defined traits act like interfaces

trait Speaker {
    fn salutation(&self) -> String;
}

///////////////////////////////////////////////////////////
// The following structs act like classes that implement
// a Speaker interface

#[derive(Debug,Copy,Clone)]
pub struct Presenter;
impl Speaker for Presenter {
    fn salutation(&self) -> String {
      "Hello, today we will discuss ...".to_string()
    }
} 

#[derive(Debug)]
pub struct Friend {
    pub name : String,
}
impl Speaker for Friend {
    fn salutation(&self) -> String {
      let mut s = String::from("Hi good buddy, its me, ");
      let nm = self.name.as_str();
      s.push_str(nm);
      return s;
    }
}
impl Friend {
    #[allow(dead_code)]
    pub fn new(name : String) -> Self {
        Self {
            name,
        }  // note: no semicolon so Self is returned
    }
}
#[derive(Debug,Copy,Clone)]
pub struct TeamLead;
impl Speaker for TeamLead {
    fn salutation(&self) -> String {
      "Hi, I have a task for you ...".to_string()
    }
} 

              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
#[allow(dead_code)]
pub fn run() {
    
    print!("\n\n  {}","-- demo polymorphic struct instances --\n");
    let presenter : Presenter = Presenter;
    let joe : Friend = Friend::new("Joe".to_string());
    let sue : Friend = Friend::new("Sue".to_string());
    let team_lead : TeamLead = TeamLead;

    let mut v :Vec<&dyn Speaker> = Vec::new();
    v.push(&presenter);
    v.push(&joe);
    v.push(&sue);
    v.push(&team_lead);

    for speaker in v.iter() {
        print!("\n  {:?}",speaker.salutation());
    }
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
-- demo polymorphic struct instances --

"Hello, today we will discuss ..."
"Hi good buddy, its me, Joe"
"Hi good buddy, its me, Sue"
"Hi, I have a task for you ..."
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </t-b>
    </t-b>
    <t-b>
      The models we&apos;ve covered here: Code Structure, Build Process, Ownership, and User-Defined
      Types and Traits are what make Rust unique and interesting.  We will see more details for each
      of these in the coming chapters.
    </t-b>
    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.4</num-item1><num-item4>References:</num-item4>
    </num-cont>
    <table>
      <tr>
        <th class="darkItem">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html">A Gentle Introduction To Rust</a>
        </td>
        <td class="lightItem">
          First thing to read.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust by Example</a>
        </td>
        <td class="lightItem">
          Rust docs - walkthrough of syntax
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.twelve21.io/getting-started-with-rust-on-windows-and-visual-studio-code/">
            Getting Started with Rust on Windows and Visual Studio Code
          </a>
        </td>
        <td class="lightItem">
          Install Rust, Verify, Configure Visual Studio Code, Create Hello World, Create Build Task, 
          Configuring Unit Tests, Configure Debugging, 
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.rust-lang.org/">rust-lang.org home page</a>
        </td>
        <td class="lightItem">
          Links to download and documentation
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://cheats.rs/">rust cheat sheet</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.youtube.com/watch?v=zF34dRivLOw">(video) Rust - Crash Course | Rustlang</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.tutorialspoint.com/rust/index.htm">Tutorial - tutorialspoint.com</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <!--<tr>
        <td class="lightItem">
          <a href="https://www.javatpoint.com/rust-tutorial">Tutorial - javatpoint.com</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>-->
      <tr>
        <td class="lightItem">
          <a href="https://www.youtube.com/watch?v=zF34dRivLOw">(video) Rust - Crash Course | Rustlang</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
    </table>
  </bb-55>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>