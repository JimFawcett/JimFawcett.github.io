<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Prologue.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Rust Models</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="RustStory_Data.html">N</a>
  <a id="Prev" href="RustStory_Prologue.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 1. - Rust Models</h1>
      <h3 id="subtitle">Code Structure, Builds, Ownership, User-Defined Types and Traits</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#structure">Structure</a>, 
       <a href="#build">Build</a>, <a href="#ownership">Ownership</a>, <a href="#types">User-Defined Types</a>, 
       <a href="#refs">References</a>
     </rt-b>
   </toc-b>

  <bb-55 class="indent">
    <a id="prologue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.0</num-item1><num-item4>Prologue:</num-item4>
    </num-cont>

  <a id="structure"></a>
  <hr class="spread" />
    <num-cont>
      <num-item1>1.1</num-item1><num-item4>Code Structure:</num-item4>
    </num-cont>
    <div style="width:calc(100vw - 6rem);">
      <photosizer-block src="Pictures/Crate.JPG" width="700" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 1. Package directories in VS Code
        </span>
      </photosizer-block>
    </div>
    <t-b>
      Rust code structure is based on <n-s>crates</n-s> and <n-s>packages</n-s>:
      <indent-block class="pad10">
        <ul class="tight">
          <li>
            <strong>package:</strong>
            <div class="pad10">
              A package is a directory containing a <n-s>cargo.toml</n-s> file and a <n-s>scr</n-s> folder
              containing a collection of source files. Packages are built with cargo:
              <indent-block class="pad10">
                <c-s>cargo init [--bin | --lib] [package_name]</c-s><br />
                Default option is --bin and default package_name is the current directory name.
              </indent-block>
              The <c-s>cargo build</c-s> command creates a Target subdirectory, if it doesn&apos;t
              already exist, and runs rustc to create an executable or library in <c-s>Target/debug</c-s>.
            </div>
          </li>
          <li>
            <strong>crate:</strong>
            <div class="pad10">
              A crate is a Rust source file in a package src subdirectory named main.rs (binary), *.rs, or lib.rs (library).
              The main.rs file is expected to have a <c-s>fn main() {...}</c-s>.
            </div>
          </li>
        </ul>
      </indent-block>
    </t-b>
    <t-b>
      A <c-s>main.rs</c-s> may load a crate <c-s>helper.rs</c-s> from its own src directory with the 
      declaration <c-s>mod helper</c-s> and then use public functions from helper.
    </t-b>
    <t-b>
      The package for <c-s>main.rs</c-s> may also import a library <c-s>helper_lib</c-s> by including 
      the path to helper_lib in its
      <c-s>Cargo.toml</c-s> file&apos;s <c-s>[dependencies]</c-s> section.
      <indent-block class="pad10">
        <c-s>
          [dependencies]<br />
          helper_lib = { path = "../helper_lib"}
        </c-s>
      </indent-block>
    </t-b>
    <t-b>
      The main.rs file may then simply use <c-s>helper_lib::some_function()</c-s> or declare
      <c-s>use helper_lib::{ some_function }</c-s> at the top and then use some_function() in its 
      subsequent code.
    </t-b>
    <t-b>
      <details>
        <summary class="labelStyle darkItem">Structure Demo</summary>
        <t-b>
          The <c-s>main</c-s> function in <c-s>demo/src/main.rs</c-s> uses code from 
          <c-s>demo/src/helper.rs</c-s> and <c-s>demo_lib/src/lib.rs</c-s>. This shows how to
          factor code into maintainable pieces.
        </t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>demo/src/main.rs</defn-head>
            <defn-code>
mod helper;  // declares helper module
             // since there is no code block
             // helper.rs must be in local src and 
             // provide code for this module

use helper::{ say };

use demo_lib::{ libsay };  // only needed to qualify use of libsay

fn main() {
    helper::say();
    say();
    demo_lib::libsay();
    libsay();
    print!("\n  Hello, world!\n\n");
}
            </defn-code>
            <defn-head class="defnBorderTop">demo/src/helper.rs</defn-head>
            <defn-code>
pub fn say() {
    print!("\n  hello from helper");
}

// Including a main function is not a good idea
// but doesn't seem to do any harm, even if pub.
#[allow(dead_code)]
fn main() {
    print!("\n  hello world");
}
            </defn-code>
            <defn-head class="defnBorderTop">demo/Cargo.toml</defn-head>
            <defn-code>
[package]
name = "demo"
version = "0.1.0"
authors = ["James W. Fawcett &lt;jfawcett@twcny.rr.com&gt;"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
demo_lib = { path = "../demo_lib" }
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>demo_lib/src/lib.rs</defn-head>
            <defn-code>
pub fn libsay() {
    print!("\n  hello from demo_lib");
}
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
cargo -q run

  hello from helper
  hello from helper
  hello from demo_lib
  hello from demo_lib
  Hello, world!

            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </details>
    </t-b>
    <t-b style="margin-bottom:0px;">
      There is more to Rust <n-s>Code Structure</n-s>, e.g.:
    </t-b>
    <indent-block class="pad10">
      <ul class="tight">
        <li>
          <strong>Structs and Traits:</strong>
          <indent-block class="pad10">
            Roughly equivalent to C++ classes and interfaces.
          </indent-block>
        </li>
        <li>
          <strong>Enums and Matching:</strong>
          <indent-block class="pad10">
            Enums have much more functionality in Rust than in other languages.
          </indent-block>
        </li>
        <li>
          <strong>Modules:</strong>
          <indent-block class="pad10">
            Modules provide a way to factor code into smaller simpler parts in the same package.
          </indent-block>
        </li>
      </ul>
    </indent-block>
    Some of this we will discuss in <num-item1>1.4</num-item1><num-item4>User-Defined Types</num-item4>.
    The rest in <n-s>Chapter&nbsp;2&nbsp;-&nbsp;Data</n-s> and <n-s>chapter&nbsp;3&nbsp;-&nbsp;Operations</n-s>.
    <a id="build"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.2</num-item1><num-item4>Build Process:</num-item4>
    </num-cont>
    <t-b>
      All of this is built with a Rust tool called <n-s>Cargo</n-s>.  <n-s>Cargo</n-s> is a package manager,
      that can build, run, and clean a Rust <n-s>Package</n-s> as well as create a new <n-s>Package</n-s>
      and download crates from <a href="https://Crates.io">https://crates.io</a>.
    </t-b>
    <t-b>
      Figure 1. shows a newly created <n-s>Package</n-s>.  The process is simple.
      <indent-block class="pad10">
        <ol class="tight">
          <li>
            Open a Developer&apos;s command prompt
          </li>
          <li>
            Create a directory temp with <n-s>mkdir temp</n-s>
          </li>
          <li>
            Issue the command: <n-s>cargo new demo_crate</n-s>. That creates everything shown in Figure 1.
            <indent-block class="pad10">
              The image is a screen shot of Visual Studo Code with opened folder demo_crate.
            </indent-block>
            The <n-s>Cargo</n-s> tool is in your path after you install Rust.
          </li>
          <li>
            <n-s>main.rs</n-s> is a demonstration &quot;Hello World&quot; program.
          </li>
          <li>
            Build with the command <n-s>cargo build</n-s> and run with <n-s>cargo run</n-s>.
          </li>
          <li>
            Clean the crate with <n-s>cargo clean</n-s>.
          </li>
        </ol>
      </indent-block>
      <t-b>
        Using <a href="https://code.visualstudio.com/download">Visual Studio Code</a> makes this a fairly
        painless process.  If, using the command window, you navigate to the temp directory and type
        <c-s>code .</c-s>, assuming you&apos;ve installed VS Code, it will open showing the temp
        directory and its files an subdirectories, e.g., <c-s>Cargo.toml</c-s> and <c-s>temp/src</c-s>.
      </t-b>
      <t-b>
        You can open a teminal in VS Code, e.g., <n-s>top menu > Terminal > New Terminal</n-s>.  I usually move the terminal
        to the right side.  You can do that with <n-s>top menu > View > Appearance > Move Panel Right</n-s>.
      </t-b>
      <t-b>
        Now, you can edit the package files, save, then, in the <n-s>terminal</n-s> type <c-s>cargo check</c-s>
        to test the build without running, and <c-s>cargo run</c-s> to build and run.  You will see the output
        in the terminal.  When you are done you can <c-s>cargo clean</c-s> to remove the target items including
        the <c-s>target</c-s> folder itself.
      </t-b>
      <t-b>
        A typical Rust program consists of a binary crate (one with a main.rs) and perhaps several
        library crates that implement all the functionality used by main.
      </t-b>
      <t-b>
        You create a library crate with the command <n-s>cargo new [library name] --lib</n-s>.  That builds
        the same structure as shown here except that in the folder <n-s>src</n-s> you find a file
        <n-s>lib.rs</n-s> that has functions that implement the library&apos;s operations and a test fixture
        for running a sequence of tests on the library.
      </t-b>
      <t-b>
        The binary crate must specify each of the libraries it uses with dependencies in its <n-s>Cargo.toml</n-s>
        file. All of this is illustrated by the code in the two details dropdowns, below.
      </t-b>
    </t-b>
    <num-cont>
      <num-item1>1.2.1</num-item1><num-item4>Display Library</num-item4>
    </num-cont>
    <t-b>
      This display library provides a set of display functions to help generate demonstration and
      debug io for Rust programs.  It contains functions:
      <indent-block class="pad10">
        <ol class="tight">
          <li>
            <n-s>show_type&lt;T&gt;(_value: &amp;T)</n-s> - 
            Displays type and size of input
          </li>
          <li>
            <n-s>log&lt;T&gt;(value: &amp;T)</n-s> - 
            Displays type and size of input, followed by its value.
          </li>
          <li>
            <n-s>title(msg: String)</n-s> - 
            Displays msg followed by an underline.
          </li>
          <li>
            <n-s>putline()</n-s> - Emits a newline.
          </li>
          <li>
            <n-s>putlinen(n: usize)</n-s> - Emits n newlines.
          </li>
        </ol>
      </indent-block>
      The code in <n-s>display_test</n-s> shows how it imports the library, <n-s>display</n-s>.
      Look at the dependencies in <n-s>display_test::Cargo.toml</n-s> and at the extern crate
      declaration at the top of the code in <n-s>display_test::main.rs</n-s>
    </t-b>
    <indent-blocks>
    <details>
      <summary class="labelStyle, darkItem">display_test</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>display_test::Cargo.toml</defn-head>
            <defn-code>
[package]
name = "test_display"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

[dependencies]
display = { path = "../display" }
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>

C:\github\JimFawcett\RustBasicDemos\display_test>
cargo -q run

 test types
------------
 TypeId: alloc::string::String, size: 12
 value:  String (8): a string
 TypeId: i8, size: 1
 value:  100
 TypeId: alloc::vec::Vec&lt;i32&gt;, size: 12
 value:  [-1, 0, 1]
 TypeId: test_display::main::Test, size: 1
 value:  Test1
 TypeId: test_display::main::Test, size: 1
 value:  Test2
 TypeId: test_display::Point, size: 24
 value:  Point { x: 1.0, y: 1.5, z: 2.0 }

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>display_test::main.rs</defn-head>
            <defn-code>
/////////////////////////////////////////////////////////////
// test_display::main.rs - test display library            //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 Feb 2020  //
/////////////////////////////////////////////////////////////
/*
  Usually you test a library using the library's built in
  test functions.  But those cannot write to the console
  because they are a compiled part of the library which
  has no console.

  So I've constructed this separate main that uses the
  library just like any other application.
*/

extern crate display;
use display::{ putline, title, log, putlinen };

#[derive(Debug)]
struct Point {
  x: f64,
  y: f64,
  z: f64,
}

fn main() {
  putline();
  title("test types".to_string());
  let mut str = String::new();
  str.push_str("a string");
  log(&amp;str);
  let an_i8: i8 = 100;
  log(&amp;an_i8);
  let mut vi : Vec&lt;i32&gt; = Vec::new();
  vi.push(-1);
  vi.push(0);
  vi.push(1);
  log(&amp;vi);
  #[derive(Debug)]
  enum Test { Test1, Test2, };
  log(&amp;Test::Test1);
  log(&amp;Test::Test2);
  let point = Point { x:1.0, y:1.5, z:2.0 };
  log(&amp;point);
  putlinen(1);
}
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
  </indent-blocks>
  <t-b>
    The code in <n-s>display</n-s> shows the structure of a lib crate. Note how the library
    imports Rust std library facilities with a series of use std::xxxx statements. These
    do essentially the same thing that #include &lt;xxxx&gt; declarations do in C++.
  </t-b>
  <indent-blocks>
    <details>
      <summary class="labelStyle, darkItem">display library</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>display::Cargo.toml</defn-head>
            <defn-code>
[package]
name = "display"
version = "0.1.0"
authors = ["James W. Fawcett &lt;jfawcett@twcny.rr.com&gt;"]
edition = "2018"

[dependencies]

            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
C:\github\JimFawcett\RustBasicDemos\display>
cargo test
Compiling display v0.1.0
(C:\github\JimFawcett\RustBasicDemos\display)
Finished test [unoptimized + debuginfo]
target(s) in 0.63s
Running target\debug\deps
\display-7c39a3f9b415f17e.exe

running 1 test
test tests::test_types ... ok

test result: ok.
1 passed; 0 failed; 0 ignored; 0 measured;
0 filtered out

Doc-tests display

running 0 tests

test result: ok.
0 passed; 0 failed; 0 ignored; 0 measured;
0 filtered out

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>display::lib.rs</defn-head>
            <defn-code>
///////////////////////////////////////////////////////////////
// display::main.rs tests - Demonstrate display types        //
//                                                           //
// Jim Fawcett, https://JimFawcett.github.io, 14 Feb 2020    //
///////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Debug)]
    struct Point {
        x: f64,
        y: f64,
        z: f64,
    }
    #[test]
    /*
       Library doesn't write to console, so all this tests is
       no panic occurred.  See test_display for useful tests.
    */
    fn test_types() {

        // test code elided

    }
}

/////////////////////////////////////////////////////////////
// display::main.rs - Demonstrate display types            //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 Feb 2020  //
/////////////////////////////////////////////////////////////
/*
   log and do_work are derived from:
   https://doc.rust-lang.org/beta/std/any/index.html

*/
use std::fmt::Debug;
use std::any::Any;
use std::any::type_name;
use std::mem::size_of;

/*---------------------------------------------------------
   show type name on console
   - expects T to implement Debug
   - see #[define(Debug)] attributes, above 
*/
pub fn show_type&lt;T: Any + Debug&gt;(_value: &amp;T) {
    let name = type_name::&lt;T&gt;();
    print!(
      "\n  TypeId: {}, size: {}", name, size_of::&lt;T&gt;()
    );
}

/*---------------------------------------------------------
   log type name and value to console
   - expects T to implement Debug
   - see #[define(Debug)] attributes, above 
*/
pub fn log&lt;T: Any + Debug&gt;(value: &amp;T) {
    let value_any = value as &amp;dyn Any;
    let name = type_name::&lt;T&gt;();
    print!(
      "\n  TypeId: {}, size: {}", name, size_of::&lt;T&gt;()
    );

    // Try to convert our value to a `String`. If successful, 
    // we want to output the String`'s length as well as its 
    // value. If not, it's a different type: just print it 
    // out unadorned.

    match value_any.downcast_ref::&lt;String&gt;() {
        Some(as_string) =&gt; {
            print!(
              "\n  value:  String ({}): {}", 
              as_string.len(), as_string
            );
        }
        None =&gt; {
            print!("\n  value:  {:?}", value);
        }
    }
}

/*---------------------------------------------------------
   Display underlined title on console
*/
pub fn title(msg: String) {
    print!("\n  {}", msg);
    let s = std::iter::repeat('-').take(msg.len() + 2)
            .collect::&lt;String&gt;();
    print!("\n {}", s);
}
/*-- push a single newline to console --*/

pub fn putline() {
    println!("\n");
}
/*-- pust n newlines to console --*/

pub fn putlinen(n: usize) {
    let s = std::iter::repeat('\n').take(n)
            .collect::&lt;String&gt;();
    println!("{}", s);
}

            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
    </indent-blocks>
    <t-b>
      Configuring packages and building them are traditionally done with <n-s>Cargo</n-s>.  Cargo is a 
      package manager, build manager (in some ways like a make file), checker, runner, and cleaner.
    </t-b>
    <t-b>
      One of the first things a developer new to Rust needs to learn is the naming conventions that 
      Cargo depends upon to do its business. It looks for directories named <n-s>src</n-s> to find
      code to build, its dependencies, described in <n-s>Cargo.toml</n-s>, have to be library packages
      that come from a local path or from <a href="https://crates.io">crates.io</a>, and it expects
      that modules are loaded from the local <n-s>src</n-s> directory.
    </t-b>
    <a id="ownership"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.3</num-item1><num-item4>Ownership:</num-item4>
    </num-cont>
    <a id="types"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.4</num-item1><num-item4>User-Defined Types:</num-item4>
    </num-cont>
    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.4</num-item1><num-item4>References:</num-item4>
    </num-cont>
    <table>
      <tr>
        <th class="darkItem">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html">A Gentle Introduction To Rust</a>
        </td>
        <td class="lightItem">
          First thing to read.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust by Example</a>
        </td>
        <td class="lightItem">
          Rust docs - walkthrough of syntax
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.twelve21.io/getting-started-with-rust-on-windows-and-visual-studio-code/">
            Getting Started with Rust on Windows and Visual Studio Code
          </a>
        </td>
        <td class="lightItem">
          Install Rust, Verify, Configure Visual Studio Code, Create Hello World, Create Build Task, 
          Configuring Unit Tests, Configure Debugging, 
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.rust-lang.org/">rust-lang.org home page</a>
        </td>
        <td class="lightItem">
          Links to download and documentation
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://cheats.rs/">rust cheat sheet</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.youtube.com/watch?v=zF34dRivLOw">(video) Rust - Crash Course | Rustlang</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.tutorialspoint.com/rust/index.htm">Tutorial - tutorialspoint.com</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <!--<tr>
        <td class="lightItem">
          <a href="https://www.javatpoint.com/rust-tutorial">Tutorial - javatpoint.com</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>-->
      <tr>
        <td class="lightItem">
          <a href="https://www.youtube.com/watch?v=zF34dRivLOw">(video) Rust - Crash Course | Rustlang</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
    </table>
  </bb-55>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>