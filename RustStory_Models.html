<!DOCTYPE html>
<html>
<!--
  index.html
    Site home page
-->
<head>
  <title>Rust Story Models</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--<link rel="stylesheet" href="css/StylesTemplate.css" />-->
  <!--<link rel="stylesheet" href="css/StylesDefault.css" />-->
  <!--<link rel="stylesheet" href="css/StylesBrownTheme.css" />-->
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeRust.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <!--<script src="js/ScriptsPageFrameDefaults.js"></script>-->
  <script src="js/ScriptsPageFrameRustStory.js"></script>
  <script src="js/ScriptsPageFramePagesRustStory.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <!-- No need for Pages script for pages with no next or prev pages -->
  <!--<script src="js/ScriptsPageFramePages.js"></script>-->
  <link rel="stylesheet" href="css/Styles_BitsContent.css" />
  <script src="js/Scripts_BitsContent.js"></script>
  <link rel="stylesheet" href="css/StylesSplitterBar.css" />
  <script src="js/ScriptsSplitterBar.js"></script>
  <link rel="stylesheet" href="css/prism.css" />
  <script src="js/prism.js"></script>
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding: 0.75em 1.5em;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width: 50em;
    }

    #github h2 {
      margin-top: 0.75em;
    }

    #github ol.tight li {
      margin-top: 0.15em;
      margin-bottom: 0.15em;
    }

    #github header h3 {
      margin-top: 0em;
      margin-left: 1em;
    }
  </style>
  <script>
      function loadifrust() {
        var loc = window.location.href;
          if (window.self === window.top) {
      /*alert('top');*/
        window.location.href = 'TOCRust.html?src=' + loc;
    }
    else {
            /*alert('not top');*/
          /*window.top.location.href = loc;*/
            window.top.location.href = loc;
                  }
          }
  </script>
  <script>


    function getHelp() {
      alert('help for Rust Models');
        }
  </script>
  <!--   <script>
      window.onmessage = function () {
        // alert('msg received');
        bottomMenu.sections();
      }
    </script>
   -->
  <style>
    #github .separator {
      margin:1.25em;
      border-top:1px var(--dark);
      border-style:solid;
    }
  </style>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="RustStory_Data.html">Next</a>
  <a id="Prev" href="RustStory_Prologue.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main id="main">
      <div id="about" onclick="this.style.display = 'none'">about</div>
      <div id="page">RustStory Models</div>
      <div id="modified">6/8/2022</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <header>
          <!-- <a class="repoLink" style="margin-right:9em;" href="RustStoryRepo.html">Rust Story Repo</a> -->
          <a target="_blank" class="repoLink" style="margin:2.0em 1.0em; font-size:0.9em;" href="https://github.com/JimFawcett/RustStory">Rust Story Code</a>
          <hgroup id="pagetitle" onclick="loadifrust()" style="cursor:pointer;">
            <h1 id="title">Chapter 1. - Rust Models</h1>
            <h3 id="subtitle">Code Structure, Builds, Ownership, User-Defined Types and Traits, Generics</h3>
          </hgroup>
        </header>

        <t-b>
          <a id="prologue"></a>
          <h2>1.0&nbsp;&nbspPrologue</h2>
          <t-b>
            <details>
              <summary class="labelStyle darkItem">Hello World in Rust</summary>
              <hr class="separator" />
              <t-b>
                Uses only <n-s>Cargo</n-s>, after installing Rust, and the x64 Native Tools Command Prompt for Visual Studio Code.
              </t-b>
              <div class="blockSingle" style="padding:0em; width:100%; width:calc(100vw - 9em);">
                <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>Create Project</strong></div>
                <div style="float:right; margin-right:0.75em; padding:0.25em 0em;"><strong>main.rs</strong></div>
                <splitter-container id="container" class="clear">
                  <first-item id="hello-first" style="width:60%;">
                    <div class="codewrap" onclick="cbubbleup('hello-first')">
                      <pre style="width:200em;"><code class="language-term">C:\github\JimFawcett\RustStory\Chap_1_Models
> cargo new hello_world
    Creating binary (application) `hello_world` package
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
C:\github\JimFawcett\RustStory\Chap_1_Models
> cd hello_world
C:\github\JimFawcett\RustStory\Chap_1_Models\hello_world
> dir

Directory: C:\github\JimFawcett\RustStory\Chap_1_Models\hello_world

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----         8/22/2024  12:13 PM                src
-a----         8/22/2024  12:13 PM             82 Cargo.toml

C:\github\JimFawcett\RustStory\Chap_1_Models\hello_world
></code></pre>
                    </div>
                  </first-item>
                  <splitter-bar id="hello-seperator"></splitter-bar>
                  <second-item id="hello-second" style="width:40em;">
                    <div class="codewrap" onclick="obubbleup('hello-first')">
                      <pre style="width:200em;"><code class="language-shell">fn main() {
    println!("Hello, world!");
}
</code></pre>
                    </div>
                  </second-item>
                </splitter-container>
              </div>
              <div style="height:1em;"></div>

              <div class="blockSingle" style="padding:0em; width:100%; width:calc(100vw - 9em);">
                <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>Build and Run</strong></div>
                <div style="float:right; margin-right:0.75em; padding:0.25em 0em;"><strong>Cargo.toml Contents</strong></div>
                <splitter-container id="container" class="clear">
                  <first-item id="hello2-first" style="width:60%;">
                    <div class="codewrap" onclick="cbubbleup('hello2-first')">
                      <pre style="width:200em;"><code class="language-term">> cargo run
Compiling hello_world v0.1.0 (C:\github\JimFawcett\RustStory\Chap_1_Models\hello_world)
Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.36s
Running `target\debug\hello_world.exe`
Hello, world!
</code></pre>
                    </div>
                  </first-item>
                  <splitter-bar id="hello2-seperator"></splitter-bar>
                  <second-item id="hello2-second" style="width:40em;">
                    <div class="codewrap" onclick="obubbleup('hello2-first')">
                      <pre style="width:200em;"><code class="language-term">[package]
name = "hello"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

</code></pre>
                    </div>
                  </second-item>
                </splitter-container>
              </div>
              <div style="height:1em;"></div>
              <hr class="separator" />
            </details>
          </t-b>
          <t-b>
            Rust is an interesting language, similar to C++, but with some unique differences.  To  understand those, let&apos;s
            start with a couple of definitions:
          </t-b>
          <div class="pad5">
            <defn-block style="width: calc(100vw - 6em); max-width:max-content;">
              <defn-head>Type Safety</defn-head>
              <defn-body>
                <ul class="tight" style="font-size:medium;">
                  <li>
                    A program is well defined if no execution can exhibit undefined behavior.
                  </li>
                  <li>
                    A language is type safe if its type system ensures that every program is well defined.
                  </li>
                </ul>
                <s-halfEm></s-halfEm>
              </defn-body>
            </defn-block>
            <s-halfEm></s-halfEm>
          </div>
          A non-type safe language may introduce undefined behavior with:
          <indent-block class="pad5">
            <ul class="tight">
              <li>mutation of data with active aliases</li>
              <li>memory access after buffer overflow</li>
              <li>integer overflow</li>
              <li>use after free</li>
              <li>double free</li>
              <li>race conditions</li>
            </ul>
          </indent-block>
        </t-b>
        <t-b>
          Rust&apos;s type system was designed to prevent these behaviors.
        </t-b>
        <t-b>
          <t-b>
            <defn-block style="width: calc(100vw - 6em); max-width:max-content;">
              <defn-head>Rust Principles:</defn-head>
              <defn-body style="width:auto;">
                <ol class="tight">
                  <li>
                    <div>
                      Rust provides memory safety by:
                      <indent-block class="pad5">
                        <n-s>Compiler</n-s> checked Ownership + Borrowing rules,<br />
                        <n-s>compiler</n-s> checked indexing where possible, else run-time panic (no reads/writes of unowned memory)
                      </indent-block>
                      These prevent simultaneous aliasing + mutation and avoids accessing out-of-bounds indexed memory.
                    </div>
                  </li>
                  <li>
                    In debug builds signed and unsigned intergers are checked for overflow.
                  </li>
                  <li>
                    All access to heap resources occurs through Box&lt;T&gt;, a smart pointer
                    that releases resources when it goes out of scope.
                  </li>
                  <li>
                    Rust provides data race safety using two concurrency models:
                    <indent-block class="pad5">
                      Model #1 - Thread communication through messaging passing that transfers ownership of messages
                      <indent-block>
                        Prevents simultaneous aliasing and mutation
                      </indent-block>
                      Model #2 - Guarded locks bound to mutated data
                      <indent-block>
                        prevent mutation without ordering
                      </indent-block>
                    </indent-block>
                    These models are <n-s>compiler</n-s> checked.
                  </li>
                </ol>
              </defn-body>
            </defn-block>
          </t-b>
          <div class="pad10">
            <ol class="tights">
              <li>
                Rust&apos;s <n-s>types are, by default, immutable</n-s>. You have to opt-in to mutability with the
                mut keyword:
                <indent-block class="pad5">
                  <c-s>let mut s = String::from("a string");</c-s>
                </indent-block>
              </li>
              <li>
                <n-s>Ownership</n-s>:
                <div class="pad5">
                  In Rust there is only one owner of a value:
                </div>
                <ul class="tight" style="list-style-type:lower-alpha;">
                  <li>
                    If a type is blittable<sup>1</sup>, e.g., primitives, arrays, ... it is copyable:
                    <indent-block class="pad5">
                      <c-s>let a1 = [1, 2, 3];<br />let a2 = a1;&nbsp;&nbsp;&nbsp;// a copy</c-s>
                    </indent-block>
                  </li>
                  <li>
                    If not blittable, e.g., strings, a collection type, ... then it gets moved (transfers ownership):
                    <indent-block class="pad5">
                      <c-s>
                        let s1 = "a string".to_string();<br />
                        let s2 = s1;&nbsp;&nbsp;&nbsp;// a move<br />
                        let s3 = s2.clone();&nbsp;&nbsp;&nbsp;// an explicit copy so no move
                      </c-s>
                    </indent-block>
                    In this example, s1 will not be usable after the move. Attempts to use a moved item are
                    <n-s>compile</n-s> errors! S3 owns a <n-s>copy</n-s> of s2&apos;s resource, so s2 is usable
                    after the clone operation.
                  </li>
                  <li>
                    References support <n-s>borrowing</n-s> of ownership:
                    <indent-block class="pad5">
                      <c-s>let mut s = String::from("another string);&nbsp;&nbsp;&nbsp;// s owns string</c-s><br />
                      <c-s>let rs = &mut s;&nbsp;&nbsp;&nbsp;// rs borrows ownership from s</c-s>
                    </indent-block>
                  </li>
                  <li>
                    References must satisfy <n-s>compiler-checked</n-s> rules:
                    <div>
                      <ul class="tight">
                        <li>
                          Only one mutable reference is allowed
                        </li>
                        <li>
                          Any number of un-mutable references are allowed
                        </li>
                        <li>
                          Original owner must not mutate while references are active.
                          References become inactive when they go out of scope or are dropped<sup>2</sup>.
                        </li>
                      </ul>
                    </div>
                  </li>
                </ul>
                <hr class="indent" />
                <div class="footnote indent">
                  <ol class="tight pad5">
                    <li>
                      Data that can be copied with a block transfer, e.g., using memcpy.
                    </li>
                    <li>
                      let x = String::from("will be dropped"); drop(x);
                    </li>
                  </ol>
                </div>
              </li>
              <li>
                All <n-s>resource management is scope based</n-s>.  When an item, holding resources, goes out of scope,
                its <n-s>drop</n-s> function (similar to a C++ destructor) is called.
              </li>
              <li>
                All <n-s>heap allocations are referenced with a smart <c-s>Box&lt;T&gt;</c-s> pointer</n-s> that drops its
                reference when it goes out of scope, similar to the C++ <c-s>std::unique_ptr&lt;T&gt;</c-s>.
              </li>
              <li>
                Rust has a <n-s>module system</n-s>, useful for refactoring local code, and packages that need not
                be local.
              </li>
              <li>
                It has a relatively complete <a href="https://doc.rust-lang.org/beta/std/"><n-s>std library</n-s></a>
                with collections, threads, tcp socket wrappers, file system library, ...
              </li>
              <li>
                The good news is, in Rust, it is relatively simple to <n-s>interface to C code</n-s>. The bad news is
                it is relatively simple to interface to C code.
              </li>
              <li>
                Rust has a very useful tool, <n-s>Cargo</n-s>, which is a package manager, builder, and
                verifier, and will execute code, all with a simple command syntax.
              </li>
              <li>
                The Rust <n-s>compiler analyzes code deeply</n-s> and refuses to build code that has memory and
                reference problems.  Because of the structure of its types and its caching strategies, this
                analysis is faster than you might expect.
                Compiler error messages are <n-s>usually</n-s> clear, simple, and provide advice for fixing
                the error.  If the error is grievous enough, the messages can get confusing, even complaining
                about correct code.
              </li>
              <li>
                Rust code layout is more flexible than that of C++, where definitions must come before use.
                In Rust, an <n-s>identifier may be used at any place in the code</n-s> provided only that it has been
                defined somewhere in the translation unit (similar to Java and C#).
              </li>
              <li>
                As of now, there is <n-s>no debugger</n-s> as part of the Rust tool chain. That isn&apos;t as big an issue
                as you might think.  <del>Many</del> most errors are compile-time and the compiler helps with those.
                Since Rust eliminates many errors by construction, logging works for the small remainder.  The Visual
                Studio Code IDE does have Rust pluggins which support graphical debugging, although the data visualizers
                aren&apos;t as complete as in IDEs like Visual Studio.
              </li>
              <li>
                Rust uses structs for creating types.  Structs can only inherit from traits, a form of
                abstract type similar to an interface.  Traits can, but often do not, implement
                the methods they declare.  This is not full inheritance of implementation because traits
                do not have data members.
              </li>
              <li>
                <n-s>Rust does not implement function overloading</n-s>.
              </li>
              <li>
                <n-s>Rust does not have exceptions</n-s> - uses panics (controlled shutdown)
              </li>
              <li>
                <n-s>Rust generics are like Java and C# generics rather than C++ Templates</n-s>.
                <ul class="tight pad5" style="margin-left:1em;">
                  <li>
                    C++ template classes can be specialized and template functions can be overloaded.
                    That enlarges the set of types that the template function or class can be successfully
                    instantiated with. Any types that don&apos;t work correctly with the generic template
                    can be specialized with code that works for that type.
                  </li>
                  <li>
                    Rust generics can be constrained by the use of trait specifications. That diminishes the
                    set of types that will compile for the generic function or struct. Any type that doesn&apos;t
                    implement the trait will not compile when used to instantiate the generic function or struct.
                  </li>
                  <li>
                    Rust generics do not support creation of variadic functions and variatic type lists for
                    generic structs. To create a variatic function you need to use macros. Rust macros seem
                    to be well engineered, so that may not be as inconvenient as it would otherwise be.
                  </li>
                </ul>
              </li>
            </ol>
          </div>
          <t-b style="margin-top:0px;">
            This seems like a daunting list of things to learn. It is, but the Rust compiler makes that a lot
            easier than you might think.  Every time your code doesn&apos;t follow the rules it fails to
            compile with usually very clear error messages that help you fix the error(s).
          </t-b>
          <a id="compare"></a>
          <h3>1.1&nbsp;&nbsp;Comparing to C++</h3>
          <t-b>
            Modern C++ provides lots of tools to promote safe design:
            <indent-block>
              <ol class="tight">
                <li>
                  Scope-based resource management via constructors and destructors
                </li>
                <li>
                  Smart pointers: std::unique_ptr&lt;T&gt;, std::shared_ptr&lt;T&gt;
                </li>
                <li>
                  Range-based for loops and begin and end iterators nearly eliminate out-of-bound
                  indexing.
                </li>
                <li>
                  Encapsulation of state in instances of classes
                </li>
                <li>move constructors and assignment</li>
                <li>exception handling, STL container at(i) method</li>
                <li>...</li>
              </ol>
            </indent-block>
          </t-b>
          <t-b>
            These are used effectively by experienced C++ developers to write safe code. But not all
            C++ developers have enough experience to do that consistently.  C++ is safe by convention,
            but the conventions have to be followed.
          </t-b>
          <t-b>
            Rust indentifies safety vulnerabilities and avoids them with compiler enforced rules.
          </t-b>
          <t-b>
            <indent-block>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>Modern C++</defn-head>
                  <defn-body>Safe by convention</defn-body>
                </defn-block>
                <defn-block>
                  <defn-head>Rust</defn-head>
                  <defn-body>Safe by construction</defn-body>
                </defn-block>
              </defn-outerBlock>
            </indent-block>
          </t-b>
          <t-b>
            This isn&apos;t as one-sided as it seems.  Rust has two back doors that could re-introduce
            vulnerabilities:
            <indent-block>
              <ol class="tight">
                <li>
                  <n-s><strong>unsafe blocks</strong></n-s>:<br />
                  There are a few places in library code where the rules may need to be suspended.
                  The application of the compiler&apos;s rules may not be precise enough to allow
                  a library designer to build what is needed.
                </li>
                <li>
                  Rust provides an <n-s><strong>interface to C code</strong></n-s> through its std::ffi
                  (foreign function interface) crate.  This can be used to bind to
                  existing code resources written in C or C++.  The Rust interface can only talk
                  directly to C style code, but that code can call into C++ code that uses more advanced
                  features.  That imports any vulnerabilities suffered by the foreign code.
                </li>
              </ol>
            </indent-block>
          </t-b>
          <t-b>
            Assuming we use only unsafe blocks, its easy to identify them in code and, if they are
            small, fairly easy to build safe wrappers around them.  Note however, that there is some
            controversy in the Rust community about promiscuous use of unsafe code by some open-source
            developers.
          </t-b>
          <a id="unique"></a>
          <h3>1.2&nbsp;&nbsp;Features Unique to Rust</h3>
          <t-b>
            <div class="indent">
              <ol class="tight">
                <li>
                  <strong>Memory and Concurrency safety</strong>
                  <div pad5>
                    Ownership rules, combined with panics, provide memory safety.  Ownership rules, combined with
                    required Mutex and Convar locking and signaling, provide safe concurrency.
                  </div>
                </li>
                <li>
                  <strong>Ownership Rules</strong>
                  <div pad5>
                    Data in Rust can have only one owner.  That ownership can be borrowed or transferred, allowing
                    any number of readers if there are no writers, but only one writer with no readers.
                  </div>
                </li>
                <li>
                  <strong>Error Handling</strong>
                  <div pad5>
                    Rust provides <c-s>Result&lt;T, E&gt;</c-s> types that are returned by any function that can
                    fail.  Code has to explicitly opt out of handling these, and usually should not.
                  </div>
                </li>
                <li>
                  <strong>Value behavior without need for copy and move constructors</strong>
                  <div pad5>
                    Rust will implicitly copy only blittable types, e.g, i32, f64, ...&nbsp;&nbsp;Non blittable types,
                    e.g., Strings, Vecs, ... are implicitly moved, and may implement the Clone Trait, but
                    clone() must be called explicitly.
                  </div>
                </li>
                <li>
                  <strong>Extrodinarily effective tool chain</strong>
                  <div pad5>
                    Rust provides the cargo package manager that wraps rustc, rustfmt, rustdoc, and rust-clippy
                    to handle most of the common developer tasks other than writing code.  Cargo is simple to use,
                    quick, and effective.
                  </div>
                </li>
              </ol>
            </div>
          </t-b>      <t-b style="margin-top:0px;">
            There is a lot to like about Rust, but there are still strong use-cases for C++ and other languages.
            I expect to write a lot of Rust code, but think I will continue to use C++ frequently for things I build.
          </t-b>
          <div style="height:0.15em;"></div>
          <a id="first"></a>
          <h3>1.2&nbsp;&nbsp;Things to Read First</h3>
          <t-b>
            Important references for this chapter:
            <s-1em></s-1em>
            <table style="width:calc(100vw - 12em);">
              <tr>
                <th class="darkItem">Link</th>
                <th class="darkItem">Description</th>
              </tr>
              <tr>
                <td class="lightItem">
                  <a href="https://www.youtube.com/watch?v=DnT-LUQgc7s">Considering&nbsp;Rust&nbsp;-&nbsp;Feb&nbsp;2020&nbsp;-&nbsp;Jon&nbsp;Gjengset</a>
                </td>
                <td class="lightItem">
                  Great what-is-it video, with code snippets and a lot of mind setting conversation by a very
                  knowledgeable presenter.
                </td>
              </tr>
              <tr>
                <td class="lightItem"><a href="Resources/RustModels.pdf">RustModels.pdf</a></td>
                <td class="lightItem">
                  Discussion of principle ideas on which Rust is based.
                </td>
              </tr>
              <tr>
                <td class="lightItem"><a href="https://doc.rust-lang.org/std/index.html">Rust std</a></td>
                <td class="lightItem">
                  Very clear documentation for the Rust std facilities, e.g., types, modules, macros, and
                  keywords.
                </td>
              </tr>
              <tr>
                <td class="lightItem">
                  <a href="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/">A half-hour to learn Rust</a>
                </td>
                <td class="lightItem">
                  Code fragments with commentary that cover most of the Rust ideas.
                </td>
              </tr>
              <tr>
                <td class="lightItem"><a href="https://cheats.rs/">Rust&nbsp;Cheat&nbsp;Sheet</a></td>
                <td class="lightItem">
                  Very broad reference to the Rust language, its libraries, and idioms.
                </td>
              </tr>
              <tr>
                <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
                <td class="lightItem">
                  Container diagrams
                </td>
              </tr>
              <tr>
                <td class="lightItem"><a href="https://hacks.mozilla.org/2015/05/diving-into-rust-for-the-first-time/">Diving into Rust</a></td>
                <td class="lightItem">
                  Contains an excellent video you <n-s>should</n-s> watch. Discusses <n-s>ownership</n-s>, with
                  copies and moves, and thread models.
                </td>
              </tr>
              <tr>
                <td class="lightItem"><a href="RustBasicDemos.html">Rust&nbsp;Basic&nbsp;Code&nbsp;Demos</a></td>
                <td class="lightItem">
                  Small code examples that probe how Rust functions
                </td>
              </tr>
              <!--<tr>
                <td class="lightItem"><a href="https://wiki.mozilla.org/Matrix">Matrix open discussion platform</a></td>
                <td class="lightItem">

                </td>
              </tr>-->
            </table>
          </t-b>
          <t-b>
            <details>
              <summary class="labelStyle darkItem">Places to visit later</summary>
              <table style="width:calc(100vw - 12em);">
                <tr>
                  <td class="darkItem">Places to visit later</td>
                  <td class="darkItem">
                    Description
                  </td>
                </tr>
                <tr>
                  <td class="lightItem">
                    <a href="https://docs.rs/dtolnay/0.0.8/dtolnay/macro._02__reference_types.html">
                      Shared&nbsp;reference&nbsp;&amp;T&nbsp;and&nbsp;exclusive&nbsp;reference&nbsp;&amp;mut&nbsp;T
                    </a>
                  </td>
                  <td class="lightItem">
                    More accurate description than immutable reference and mutable reference
                  </td>
                </tr>
                <tr>
                  <td class="lightItem"><a href="https://deterministic.space/elegant-apis-in-rust.html">Elegant APIs in Rust</a></td>
                  <td class="lightItem">
                    Things to consider when writing Rust functions and packages
                  </td>
                </tr>
                <!--<tr>
                  <td class="lightItem"><a href="https://rustacean.net/">Rustaceans</a></td>
                  <td class="lightItem">
                    Open Source images
                  </td>
                </tr>-->
                <!--<tr>
                  <td class="lightItem"><a href="https://blog.rust-lang.org/">Rust Blog</a></td>
                  <td class="lightItem">
                    Open Source images
                  </td>
                </tr>-->
                <!--<tr>
                  <td class="lightItem"><a href="https://raphlinus.github.io/">Ralph Levien's blog</a></td>
                  <td class="lightItem">
                    Developer and Philosopher
                  </td>
                </tr>-->
                <tr>
                  <td class="lightItem"><a href="https://raphlinus.github.io/rust/2020/01/18/soundness-pledge.html">Soundness Pledge</a></td>
                  <td class="lightItem">
                    Commentary about Rust programming goals and ideals - how not to subvert safety goals.
                  </td>
                </tr>
                <!--<tr>
                  <td class="lightItem"><a href="https://words.steveklabnik.com/a-sad-day-for-rust">Sad day for Rust</a></td>
                  <td class="lightItem">
                    Commentary about some issues with Rust community.
                  </td>
                </tr>-->
              </table>
            </details>
          </t-b>
        </t-b>
        <div style="height:0.5em;"></div>
        <a id="codestructure"></a>
        <h3>2.0&nbsp;&nbsp;Code Structure</h3>
        <div style="width:calc(100vw - 9em);">
          <photosizer-block src="Pictures/VscDemo.JPG" width="500" class="photoSizerBlock right" style="margin-top:0;">
            <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS', Tahoma;
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
              Figure 1. Demo_Crate Package in VS Code
            </span>
          </photosizer-block>
        </div>
        <t-b class="mbz">
          Rust code structure is based on <n-s>crates</n-s> and <n-s>packages</n-s>:
          <indent-block class="pad10 mbz">
            <ul class="tight mbz">
              <li>
                <strong>Package:</strong>
                <div class="pad10">
                  A Package is a directory containing a <c-s>cargo.toml</c-s> file and a <c-s>/src</c-s> folder
                  containing a collection of source files. Packages are built with cargo:
                  <indent-block class="pad10">
                    <c-s>cargo init [--bin | --lib] [package_name]</c-s><br />
                    Default option is --bin and default package_name is the current directory name.
                  </indent-block>
                  The <c-s>cargo build</c-s> command creates a Target subdirectory, if it doesn&apos;t
                  already exist, and runs rustc to create an executable or library in <c-s>Target/debug</c-s>.
                </div>
              </li>
              <li>
                <strong>Crate:</strong>
                <div class="pad10 mbz">
                  The source form of a crate has:
                  <indent-block class="pad5">
                    <ol class="tight mbz">
                      <li>
                        A crate root file with the name main.rs or lib.rs, residing in the /src folder.
                        main.rs has a main function. lib.rs has a test configuration section with one or more tests.
                      </li>
                      <li>
                        Zero or more supporting source files, *.rs, in <c-s>/src</c-s>, called modules, that are imported into the
                        crate root with the keyword mod followed by the module name without extension.
                        Each module may import other lower-level module files that reside in <c-s>/src</c-s>.
                      </li>
                      <li>
                        The crate may depend on other libraries in some local folder, in crates.io, or in a github
                        repository. These are all identified in the <c-s>[dependencies]</c-s> section of the
                        <c-s>cargo.toml</c-s> file.
                      </li>
                      <li>
                        Crates compile into a single file.  A binary crate has a main.rs root and compiles to
                        a single executable file, [package_name].exe on windows.  A library crate has a lib.rs root
                        and compiles to a
                        single library file, lib[package_name].rlib.
                      </li>
                    </ol>
                  </indent-block>
                </div>
              </li>
            </ul>
          </indent-block>
        </t-b>
        <t-b class="mtz">
          All this is illustrated in the &quot;Structure Demo&quot;, below.
        </t-b>
        <t-b class="mtz">
          The Structure Demo <c-s>main.rs</c-s> loads a module, <c-s>helper.rs</c-s>, from its own src directory with the
          declaration <c-s>mod helper</c-s> and then declares use of a public function, say, from helper.
        </t-b>
        <t-b>
          The package for <c-s>main.rs</c-s> also imports a library <c-s>demo_lib</c-s> by including
          the path to demo_lib in its
          <c-s>Cargo.toml</c-s> file&apos;s <c-s>[dependencies]</c-s> section.
          <indent-block class="pad10">
            <c-s>
              [dependencies]<br />
              demo_lib = { path = "../demo_lib"}
            </c-s>
          </indent-block>
        </t-b>
        <t-b>
          If the Cargo.toml file contains an identifier without a path in its [dependencies] section then
          Cargo looks for a library in <a href="https://crates.io">https://Crates.io</a>.
          <indent-block class="pad10">
            <c-s>
              [dependencies]<br />
              demo_lib = { path = "../demo_lib"}<br />
              serde = "1.0.104"
            </c-s>
          </indent-block>
          The <a href="https://crates.io/crates/serde">serde crate</a> provides serialization and deserialization
          of Rust types.
        </t-b>
        <t-b>
          The main.rs file may then simply use <c-s>demo_lib::say()</c-s> or declare
          <c-s>use helper_lib::{ say }</c-s> at the top and then use say() in its
          subsequent code.
        </t-b>
        <div style="height:0.25em;"></div>
        <t-b>
          <details>
            <summary class="labelStyle darkItem">Structure Demo</summary>
            <hr class="separator" />
            <t-b>
              This Structure Demo illustrates how to build a binary crate root, helper module, and a demo library.
              It has almost no functionality; just serves to illustrate how code is structured from modules and
              libraries.
            </t-b>
            <t-b>
              The <c-s>main</c-s> function in <c-s>demo/src/main.rs</c-s> uses code from
              <c-s>demo/src/helper.rs</c-s> and <c-s>demo_lib/src/lib.rs</c-s>. This shows how to
              factor code into maintainable pieces.
            </t-b>
            <div class="blockSingle" style="padding:0em; width:100%;">
              <!-- calc(100vw - 9em) -->
              <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>demo/src/main.rs</strong></div>
              <div style="float:right; margin-right:0.75em; padding:0.25em 0em;"><strong>demo/src/helper.rs</strong></div>
              <splitter-container id="container" class="clear">
                <first-item id="demo1-first" style="width:52%;">
                  <div class="codewrap" onclick="cbubbleup('demo1-first')">
                    <pre style="width:200em;"><code class="language-rust">mod helper; // declares helper module

use helper::{ say };
use demo_lib::{ libsay };

fn main() {
  helper::say();
  say();
  demo_lib::libsay();
  libsay();
  print!("\n Hello, world!\n\n");
}
</code></pre>
                  </div>
                </first-item>
                <splitter-bar id="demo1-seperator"></splitter-bar>
                <second-item id="demo1-second" style="width:40em;">
                  <div class="codewrap" onclick="obubbleup('demo1-first')">
                    <pre style="width:200em;"><code class="language-rust">pub fn say() {
  print!("\n  hello from helper");
}
</code></pre>
                  </div>
                </second-item>
              </splitter-container>
            </div>
            <div style="height:1em;"></div>

            <div class="blockSingle" style="padding:0em; width:100%;">
              <!-- calc(100vw - 9em) -->
              <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>demo_lib/src/lib.rs</strong></div>
              <div style="float:right; margin-right:0.75em; padding:0.25em 0em;"><strong>Output</strong></div>
              <splitter-container id="container" class="clear">
                <first-item id="demo2-first" style="width:52%;">
                  <div class="codewrap" onclick="cbubbleup('demo2-first')">
                    <pre style="width:200em;"><code class="language-rust">pub fn libsay() {
  print!("\n  hello from demo_lib");
}
#[cfg(test)]
mod tests {
  #[test]
  fn it_works() {
    assert_eq!(2 + 2, 4);
  }
}
</code></pre>
                  </div>
                </first-item>
                <splitter-bar id="demo2-seperator"></splitter-bar>
                <second-item id="demo2-second" style="width:40em;">
                  <div class="codewrap" onclick="obubbleup('demo2-first')">
                    <pre style="width:200em;"><code class="language-term">cargo -q run

hello from helper
hello from helper
hello from demo_lib
hello from demo_lib
Hello, world!
</code></pre>
                  </div>
                </second-item>
              </splitter-container>
            </div>
            <div style="height:1em;"></div>

            <div class="blockSingle" style="padding:0em; width:max-content;">
              <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>Cargo.toml</strong></div>
              <div style="padding:0.25em;">
                <div class="codewrap clear" style="padding:0.25em; overflow-x:auto; width:max-content;">
                  <pre style="width:35em;"><code class="language-term">[package]
name = "demo"
version = "0.1.0"
authors = ["James W. Fawcett &lt;jfawcett@twcny.rr.com&gt;"]
edition = "2018"

[dependencies]
demo_lib = { path = "../demo_lib" }
</code></pre>
                </div>
              </div>
            </div>
            <hr class="separator" />
            <div style="height:0.25em;"></div>
          </details>
        </t-b>
        <t-b>
          Most Rust code starts with a package structure built with the Rust tool <n-s>Cargo</n-s>.
          <n-s>Cargo</n-s> is a package manager,
          that can build, run, and clean a Rust <n-s>Package</n-s> as well as create a new <n-s>Package</n-s>
          and download crates from <a href="https://Crates.io">https://crates.io</a>.
        </t-b>
        <t-b>
          Figure 1., above, shows a newly created <n-s>Package</n-s>.  The process is simple.
          <indent-block class="pad10">
            <ol class="tight">
              <li>
                Open a Developer&apos;s command prompt
              </li>
              <li>
                Create a directory temp with <n-s>mkdir temp</n-s>
              </li>
              <li>
                Issue the command: <n-s>cargo new demo_crate</n-s>. That creates everything shown in Figure 1.
                <indent-block class="pad10">
                  The image is a screen shot of Visual Studo Code with opened folder demo_crate.
                </indent-block>
                The <n-s>Cargo</n-s> tool is in your path after you install Rust.
              </li>
              <li>
                <n-s>main.rs</n-s> is a demonstration &quot;Hello World&quot; program.
              </li>
              <li>
                Build with the command <n-s>cargo build</n-s> and run with <n-s>cargo run</n-s>.
              </li>
              <li>
                Clean the crate with <n-s>cargo clean</n-s>.
              </li>
            </ol>
          </indent-block>
          <t-b>
            Using <a href="https://code.visualstudio.com/download">Visual Studio Code</a> makes this a fairly
            painless process.  If, using the command window, you navigate to the temp directory and type
            <c-s>code .</c-s>, assuming you&apos;ve installed VS Code, it will open showing the temp
            directory and its files and subdirectories, e.g., <c-s>Cargo.toml</c-s> and <c-s>temp/src</c-s>.
          </t-b>
          <t-b>
            You can open a teminal in VS Code, e.g., <c-s>top menu > Terminal > New Terminal</c-s>.  I usually move the terminal
            to the right side.  You can do that with <c-s>top menu > View > Appearance > Move Panel Right</c-s>.
            You can make your favored panel position the default in <c-s>
              top menu > View > Pallet [searh: user settings] >
              [search panel]
            </c-s>.
          </t-b>
          <t-b>
            Now, you can edit the package files, save, then, in the <n-ss>terminal</n-ss> type <c-s>cargo check</c-s>
            to test the build without running, and <c-s>cargo run</c-s> to build and run.  You will see the output
            in the terminal.  When you are done you can <c-s>cargo clean</c-s> to remove the target items including
            the <c-s>target</c-s> folder itself.
          </t-b>
          <t-b>
            A typical Rust program consists of a binary crate (one with a main.rs) and perhaps several
            library crates that implement all the functionality used by main.
          </t-b>
          <t-b>
            You create a library crate with the command <c-s>cargo new [library name] --lib</c-s>.  That builds
            the same structure as shown here except that in the folder <c-s>src</c-s> you find a file
            <c-s>lib.rs</c-s> that has functions that implement the library&apos;s operations and a test fixture
            for running a sequence of tests on the library.
          </t-b>
          <t-b>
            The binary crate must specify each of the libraries it uses with dependencies in its <c-s>Cargo.toml</c-s>
            file. All of this is illustrated by the code in the two details dropdowns, below.
          </t-b>
        </t-b>
        <div style="height:0.5em;"></div>
        <a id="example"></a>
        <h3>2.1&nbsp;&nbsp;Display Library Example:</h3>
        <t-b>
          This <a href="RustBasicDemos.html">display library</a> provides a set of functions to help generate demonstration and
          debug io for Rust programs.  It contains functions:
          <indent-block class="pad10">
            <ol class="tight">
              <li>
                <c-s>show_type&lt;T&gt;(_value: &amp;T)</c-s> -
                Displays type and size of input
              </li>
              <li>
                <c-s>log&lt;T&gt;(value: &amp;T)</c-s> -
                Displays type and size of input, followed by its value.
              </li>
              <li>
                <c-s>main_title(msg: String)</c-s> and <c-s>sub_title(msg: String</c-s> -
                Displays msg followed by an underline.
              </li>
              <li>
                <c-s>putline()</c-s> - Emits a newline.
              </li>
              <li>
                <c-s>putlinen(n: usize)</c-s> - Emits n newlines.
              </li>
              <li>
                ...
              </li>
            </ol>
          </indent-block>
        </t-b>
        <t-b>
          The code in <c-s>display library</c-s> shows the structure of a lib crate. Note how the library
          imports Rust std library facilities with a series of use std::xxxx statements. These
          do essentially the same thing that #include &lt;xxxx&gt; declarations do in C++.
        </t-b>
        <indent-blocks>
          <details>
            <summary class="labelStyle, darkItem">display library</summary>
            <t-b>
              <div class="blockSingle" style="padding:0em; width:100%; width:calc(100vw - 9em);">
                <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>display::lib.rs</strong></div>
                <div style="float:right; margin-right:0.75em; padding:0.25em 0em;"><strong>examples/demo_display.rs</strong></div>
                <splitter-container id="container" class="clear">
                  <first-item id="hello3-first" style="width:52%;">
                    <div class="codewrap" onclick="cbubbleup('hello3-first')">
                      <div style="display:flex; flex-direction:column;">
                        <pre style="width:200em;"><code class="language-cpp">/////////////////////////////////////////////////////////////
// display::lib.rs - Demonstrate display types             //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 25 Mar 2020  //
/////////////////////////////////////////////////////////////
/*
   log and do_work are derived from:
   https://doc.rust-lang.org/beta/std/any/index.html

*/
use std::any::type_name;
use std::any::Any;
use std::fmt::Debug;
use std::mem::size_of;

/*-----------------------------------------------
   Accepts either String or str
   - no automatic newline
*/
pub fn shows&lt;S: Into&lt;String&gt;&gt;(s: S) {
    print!(&quot;{}&quot;, s.into());
}
/*-------------------------------------------------------------
   Display message and value
   - no automatic newline
*/
pub fn show&lt;T: Debug&gt;(msg: &str, t: &T) {
    print!(&quot;{}{:?}&quot;, msg, t);
}
pub fn str_show&lt;T: Debug&gt;(msg: &str, t: &T) -&gt; String {
    format!(&quot;{}{:?}&quot;, msg, t)
}
/*-------------------------------------------------------------
   show value
   - expects T to implement Debug
*/
pub fn show_value&lt;T: Debug&gt;(value: &T) {
    print!(&quot;&#92;n  value: {:?}&quot;, value);
}
pub fn str_show_value&lt;T: Debug&gt;(value: &T) -&gt; String {
    format!(&quot;&#92;n  value: {:?}&quot;, value)
}
/*-------------------------------------------------------------
   show type name
*/
pub fn show_type&lt;T&gt;(_value: &T) {
    let name = std::any::type_name::&lt;T&gt;();
    print!(&quot;&#92;n  TypeId: {}, size: {}&quot;, name, size_of::&lt;T&gt;());
}
pub fn str_show_type&lt;T&gt;(_value: &T) -&gt; String {
    let name = std::any::type_name::&lt;T&gt;();
    format!(&quot;&#92;n  TypeId: {}, size: {}&quot;, name, size_of::&lt;T&gt;())
}
/*-------------------------------------------------------------
   show type name and value
   - expects T to implement Debug
   - see #[define(Debug)] attributes, above
*/
pub fn log&lt;T: Debug&gt;(value: &T) {
    let name = type_name::&lt;T&gt;();
    print!(&quot;&#92;n  TypeId: {}, size: {}&quot;, name, size_of::&lt;T&gt;());
    print!(&quot;&#92;n  value:  {:?}&quot;, value);
}
pub fn str_log&lt;T: Debug&gt;(value: &T) -&gt; String {
    let name = type_name::&lt;T&gt;();
    let mut st = format!(&quot;&#92;n  TypeId: {}, size: {}&quot;, name, size_of::&lt;T&gt;());
    let st1 = format!(&quot;&#92;n  value:  {:?}&quot;, value);
    st.push_str(&st1);
    st.clone()
}

/*-------------------------------------------------------------
   log type name and value
   - expects T to implement Debug

   This function is deprecated.  Its here to avoid breaking
   older code.
*/
pub fn slog&lt;T: Any + Debug&gt;(value: &T) {
    let value_any = value as &dyn Any;
    let name = type_name::&lt;T&gt;();
    print!(&quot;&#92;n  TypeId: {}, size: {}&quot;, name, size_of::&lt;T&gt;());

    // Try to convert our value to a `String`. If successful, we want to
    // output the String`'s length as well as its value. If not, it's a
    // different type: just print it out unadorned.
    match value_any.downcast_ref::&lt;String&gt;() {
        Some(as_string) =&gt; {
            print!(&quot;&#92;n  value:  String ({}): {}&quot;, as_string.len(), as_string);
        }
        None =&gt; {
            print!(&quot;&#92;n  value:  {:?}&quot;, value);
        }
    }
}
/*-------------------------------------------------------------
   Display underlined main title on console
*/
pub fn main_title(msg: &str) {
    print!(&quot;&#92;n  {}&quot;, msg);
    let s = &quot;=&quot;.repeat(msg.len() + 2);
    print!(&quot;&#92;n {}&quot;, s);
}
/*-------------------------------------------------------------
   Display underlined sub title on console
*/
pub fn sub_title(msg: &str) {
    print!(&quot;&#92;n  {}&quot;, msg);
    let s = &quot;-&quot;.repeat(msg.len() + 2);
    print!(&quot;&#92;n {}&quot;, s);
}
/*-------------------------------------------------------------
   show line with len hyphens
*/
pub fn separator(len: u8) {
    let mut s = String::new();
    for _i in 1..len + 2 {
        s.push('-');
    }
    print!(&quot;&#92;n {}&quot;, s);
}
/*-------------------------------------------------------------
   push a single newline to console
*/
pub fn putline() {
    println!();
}
/*-------------------------------------------------------------
   pust n newlines to console
*/
pub fn putlinen(n: usize) {
    let s = &quot;&#92;n&quot;.repeat(n);
    print!(&quot;{}&quot;, s);
}

///////////////////////////////////////////////////////////////
// display::main.rs tests - Demonstrate display types        //
//                                                           //
// Jim Fawcett, https://JimFawcett.github.io, 25 Mar 2020    //
///////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Debug)]
    #[allow(dead_code)]
    struct Point {
        x: f64,
        y: f64,
        z: f64,
    }
    #[test]
    /*
       Library doesn't write to console, so all this tests is that
       no panic occurred.  See test_display for useful tests.
    */
    fn test_show_type() {
        let mut str = String::new();
        str.push_str(&quot;a string&quot;);
        assert_eq!(str_show_type(&str).contains(&quot;TypeId:&quot;), true);
    }
    #[test]
    fn test_show_value() {
        let mut str = String::new();
        str.push_str(&quot;a string&quot;);
        assert_eq!(str_show_value(&str).contains(&quot;value:&quot;), true);
    }
    #[test]
    fn test_log() {
        let an_i8: i8 = 100;
        assert_eq!(str_log(&an_i8).contains(&quot;100&quot;), true);
        let mut vi: Vec&lt;i32&gt; = Vec::new();
        vi.push(-1);
        vi.push(0);
        vi.push(1);
        assert_eq!(str_log(&vi).contains(&quot;1]&quot;), true);
        #[derive(Debug)]
        enum Test {
            Test1,
            Test2,
        }
        log(&Test::Test1);
        log(&Test::Test2);
        let point = Point {
            x: 1.0,
            y: 1.5,
            z: 2.0,
        };
        log(&point);
        assert_eq!(str_log(&point).contains(&quot;2.0 }&quot;), true);
        sub_title(&quot;that's all folks!&quot;);
    }
}

</code></pre>
                        <!-- <div class="split left">New Section</div>
                        <pre style="width:200em;"><code class="language-cpp">
> cargo run

                  </code></pre> -->
                      </div>
                    </div>
                  </first-item>
                  <splitter-bar id="hello3-seperator"></splitter-bar>
                  <second-item id="hello3-second" style="width:40em;">
                    <div class="codewrap" onclick="obubbleup('hello3-first')">
                      <div style="display:flex; flex-direction:column;">
                        <pre style="width:200em;"><code class="language-cpp">/* run using: cargo --example demo_displays */

extern crate display;
use display::*;

#[allow(dead_code)] /*-- fields are not explicitly read -*/
#[derive(Debug)]
pub struct Point {
    x: f64,
    y: f64,
    z: f64,
}

fn test_displays() {
    main_title(&quot;demo display&quot;);
    sub_title(&quot;--  shows  --&quot;);
    putline();

    sub_title(&quot;--  show_type and show_value  --&quot;);
    let mut str = String::new();
    str.push_str(&quot;a string&quot;);
    show_type(&str);
    show_value(&str);
    putline();

    sub_title(&quot;--  log  --&quot;);
    let an_i8: i8 = 100;
    log(&an_i8);
    let mut vi: Vec&lt;i32&gt; = Vec::new();
    vi.push(-1);
    vi.push(0);
    vi.push(1);
    log(&vi);
    #[derive(Debug)]
    enum Test {
        Test1,
        Test2,
    }
    log(&Test::Test1);
    log(&Test::Test2);
    let point = Point {
        x: 1.0,
        y: 1.5,
        z: 2.0,
    };
    log(&point);
    print!(&quot;&#92;n  {:?}&quot;, point);
    putline();

    sub_title(&quot;--  show --&quot;);
    show(&quot;&#92;n  this is a Point structure&#92;n  &quot;, &point);
    putline();
    sub_title(&quot;that's all folks!&quot;);
    putline();
}

fn main() {
    test_displays();
}
</code></pre>
                        <div class="split"><div class="right">Output</div></div>
                        <pre style="width:200em;"><code class="language-cpp">  demo display
 ==============
  --  shows  --
 ---------------

  --  show_type and show_value  --
 ----------------------------------
  TypeId: alloc::string::String, size: 24
  value: &quot;a string&quot;

  --  log  --
 -------------
  TypeId: i8, size: 1
  value:  100
  TypeId: alloc::vec::Vec&lt;i32&gt;, size: 24
  value:  [-1, 0, 1]
  TypeId: demo_display::test_displays::Test, size: 1
  value:  Test1
  TypeId: demo_display::test_displays::Test, size: 1
  value:  Test2
  TypeId: demo_display::Point, size: 24
  value:  Point { x: 1.0, y: 1.5, z: 2.0 }
  Point { x: 1.0, y: 1.5, z: 2.0 }

  --  show --
 -------------
  this is a Point structure
  Point { x: 1.0, y: 1.5, z: 2.0 }

  that's all folks!
 -------------------
</code></pre>
                      </div>
                    </div>
                  </second-item>
                </splitter-container>
              </div>
              <div style="height:1em;"></div>
            </t-b>
            <s-halfEm></s-halfEm>
          </details>
        </indent-blocks>
        <t-b>
          Configuring packages and building them are traditionally done with <n-s>Cargo</n-s>.  Cargo is a
          package manager, build manager (in some ways like a make file), checker, runner, and cleaner.
        </t-b>
        <t-b>
          One of the first things a developer new to Rust needs to learn is the naming conventions that
          Cargo depends upon to do its business. It looks for directories named <n-s>src</n-s> to find
          code to build, its dependencies, described in <n-s>Cargo.toml</n-s>, have to be library packages
          that come from a local path or from <a href="https://crates.io">crates.io</a>, and it expects
          that modules are loaded from the local <n-s>src</n-s> directory.
        </t-b>
        <div style="height:0.5em;"></div>
        <a id="build"></a>
        <h2>3.0&nbsp;&nbsp;Build Process:</h2>
        <div style="width:calc(100vw - 9em);">
          <photosizer-block src="Pictures/build.jpg" width="500" class="photoSizerBlock right" style="margin-top:0;">
            <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
              Figure 2. Build Process
            </span>
          </photosizer-block>
        </div>
        <t-b>
          The Rust build process for a crate starts with code in the <c-s>[crate]/src</c-s> folder, provided that
          its <c-s>[crate]/target</c-s> folder does not exist or contains items that are out of date.
        </t-b>
        <t-b>
          Rust builds are transitive.  The command <c-s>cargo build</c-s> issued in a terminal opened in
          the root of a crate, i.e., the directory holding the crate&apos;s cargo.toml file:
          <indent-block class="pad5">
            <ol class="tight">
              <li>
                Builds each dependency cited in it&apos;s cargo.toml file, if its build target is not cached
                or retrieved from the load, by traversing this list from the top.
                <indent-block class="pad5">
                  <ul class="tight">
                    <li>
                      loads and builds each local library identified by:
                      <div style="font-size:1em; padding:5px 25px 5px 25px; margin:0px;">
                        <c-s>
                          [dependencies]<br />
                          lib_name = { path = "[path to lib root]" }
                        </c-s>
                      </div>
                    </li>
                    <li>
                      loads and builds each crate from <a href="https://crates.io">crates.io</a> specified by:
                      <div style="font-size:1em; padding:5px 25px 5px 25px; margin:0px;">
                        <c-s>
                          [dependencies]<br />
                          crate_name = "[version number]"
                        </c-s>
                      </div>
                    </li>
                    <li>
                      loads and builds each crate from <a href="https://github.com">github.com</a> specified by:
                      <div style="font-size:1em; padding:5px 25px 5px 25px; margin:0px;">
                        <c-s>
                          [dependencies]<br />
                          crate_name = { git = "https://github.com/[crate_repo]" }
                        </c-s>
                      </div>
                    </li>
                  </ul>
                </indent-block>
                Each of the build statements in the three items above implement all the same steps.  So when
                a dependency is loaded and no target is available, the build process examines its cargo.toml file and builds its dependencies.
                <s-halfEm></s-halfEm>
              </li>
              <li>
                Loads the crate root source file, e.g., <c-s>main.rs</c-s> (binary) or <c-s>lib.rs</c-s> (library)
                located in the <c-s>/src</c-s> folder.
                <indent-block class="pad5">
                  <ul class="tight">
                    <li>
                      Loads and compiles each local module, identified by the keyword <c-s>mod [filename]</c-s>
                      in the crate root source file.
                      Modules are files, <c-s>*.rs</c-s>, other than the root file, found in the local <c-s>/src</c-s> folder.
                    </li>
                    <li>
                      Then compiles the source of the crate root file.
                    </li>
                  </ul>
                </indent-block>
                Each compilation checks code syntax and checks that ownership rules have not been violated.
              </li>
            </ol>
          </indent-block>
        </t-b>
        <t-b>
          Cargo will also build documentation.  That is covered in the Structures chapter in more detail than we
          have space for here. Note that the cargo generated documentation gives you a source listing for all your
          code and all the code you depend upon, other than the std libraries, which are documented
          <a href="https://doc.rust-lang.org/beta/std/">here</a>.
        </t-b>
        <div style="height:0.5em;"></div>
        <a id="execution"></a>
        <h2>4.0&nbsp;&nbsp;Execution:</h2>
        <t-b>
          The cargo execution model consists of three modes:
          <indent-block class="pad5">
            <ol class="tight">
              <li>
                <n-s>Execution of binaries:</n-s>
                <t-b>
                  If the crate root file is a binary, <c-s>main.rs</c-s>, the command &quot;<c-s>cargo run</c-s>&quot; will
                  run its main function.
                </t-b>
              </li>
              <li>
                <n-s>Testing libraries:</n-s>
                <div>
                  <t-b>
                    If the crate root file is a library, <c-s>lib.rs</c-s>, the command &quot;<c-s>cargo test</c-s>&quot; will
                    run any tests configured at the end of the library.  When cargo builds a library it creates a
                    single configured test at the end of the library that simply asserts that <c-s>2 + 2 == 4</c-s>,
                    to show you how to build tests.  Tests succeed if and only if they do not assert, so you use
                    assertions to check test invariants and operation results.
                  </t-b>
                  <t-b>
                    When running tests, an assertion failure does not cause a panic shutdown.  Instead, the test
                    environment traps the panic and returns an error message.
                  </t-b>
                </div>
              </li>
              <li>
                <n-s>Running Examples</n-s>
                <div>
                  <t-b>
                    For library crates, if you create an <c-s>/examples</c-s> folder and put source files, each
                    with a main function, then the command &quot;<c-s>cargo run --example [file_name]</c-s>&quot;, without the
                    <c-s>rs</c-s> extension, will execute that main, using the library as needed.
                  </t-b>
                  <t-b>
                    This is a great way to help users understand how to use your library.  You might provide several
                    example files for users with different levels of expertise, for example.
                  </t-b>
                </div>
              </li>
            </ol>
          </indent-block>
          Finally, when <c-s>cargo</c-s> builds a binary, you will find the execution image in <c-s>/target/debug</c-s> and
          can execute that by navigating to that folder with the command prompt and typing the command [file_name].exe or
          ./[file_name].exe depending on your platform.
        </t-b>
        <t-b>
          You will find a more detailed discussion of these execution processes in the Structures chapter.
        </t-b>
        <div style="height:0.5em;"></div>
        <a id="ownership"></a>
        <h2>5.0&nbsp;&nbsp;Ownership</h2>
        <t-b>
          Ownership is one of the most important features of the Rust programming language.  Rust fully
          supports value types, and manages to do that without help from the application designer.  There
          are no copy and move constructors, assignment operators, or destructors to write.
        </t-b>
        <t-b>
          Every name is bound to a value on the stack.  The value may have additional structure on the
          heap which it manages without prompting by the designer. The String and Vec types are examples.
          When a variable bound to some type goes out of scope,
          it drops (deallocates) any heap resources it may own.
        </t-b>
        <t-b>
          When a new name, x, binds to an existing variable y:
          <indent-block class="pad5">
            <c-s>let x = y;</c-s>
          </indent-block>
          That results in a copy if y&apos;s value is copyable, e.g., blittable. If not, then y&apos;s
          value is moved to x, passing ownership.  In that case, y is no longer usable.  If code attempts
          to use a moved instance that results in a <n-s>compile-time</n-s> error.
        </t-b>
        <t-b>

        <div class="blockSingle" style="padding:0em; width:100%; width:calc(100vw - 9em);">
          <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>Copy and Move</strong></div>
          <div style="float:right; margin-right:0.75em; padding:0.25em 0em;"><strong>Output</strong></div>
          <splitter-container id="container" class="clear">
            <first-item id="cam-first" style="width:60%;">
              <div class="codewrap" onclick="cbubbleup('cam-first')">
                <pre style="width:200em;"><code class="language-cpp">
let i = 3;        // i is blittable
let mut j = i;    // j gets copy of i
print!("\n  i = {}, j = {}", i, j);
// i is still usable

let s = String::from("String named s");  // s is not blitable
let mut t = s;                           // s is moved to t
t.push_str(" with more stuff");
print!("\n  t = {}", t);
// print!("\n  s = {}", s);              // can't use s, been moved

</code></pre>
              </div>
            </first-item>
            <splitter-bar id="cam-seperator"></splitter-bar>
            <second-item id="cam-second" style="width:40em;">
              <div class="codewrap" onclick="obubbleup('cam-first')">
                <pre style="width:200em;"><code class="language-cpp">

  i = 3, j = 3





  t = String named s with more stuff
</code></pre>
              </div>
            </second-item>
          </splitter-container>
        </div>
        <div style="height:1em;"></div>

        </t-b>
        <t-b>
          Rust has references, which bind to, and borrow but don't own their &quot;borrowed&quot; values:
          <indent-block class="pad5">
            <c-s>let r = &amp;x;</c-s>
          </indent-block>
          A Rust program many have any number of non-mutating references to a given value.  However, it
          may have at most one mutating reference, and in that case, no other references.
          <indent-block class="pad5">
            <c-s>let r = &amp;mut x;</c-s>
          </indent-block>
          Since references don&apos;t own the values to which they bind, nothing happens to the values when
          they go out of scope.  Drops happen only for an owned value when the owner, o, goes out of scope
          or are dropped with a move or call to drop(o).
        </t-b>
        <t-b>
          When a value has been borrowed by a reference, e.g., <c-s>r</c-s> mutably borrowing
          <c-s>x</c-s>&apos;s value, the original owner, <c-s>x</c-s>, can not mutate the value, because
          <c-s>r</c-s> has borrowed the ability to mutate.  That restriction continues until the reference, <c-s>r</c-s>
          goes out of scope or is dropped with a call to <c-s>drop(r)</c-s>.
        </t-b>
        <t-b>
          When a non-mutable reference to a value is declared, that creates a view of the value which should not
          change until the reference is dropped, so, again, the original owner can not mutate its value until
          all references go out of scope. Note that dropping a reference does not drop the
          referred value since the reference does not own the value.
        </t-b>
        <t-b>
          The most common use of references is to pass an argument to a function by reference.  When the function
          returns, the reference goes out of scope and the original owner may mutate its value.
        </t-b>
        <t-b>

          <div class="blockSingle" style="padding:0em; width:100%; width:calc(100vw - 9em);">
            <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>Mutable References</strong></div>
            <div style="float:right; margin-right:0.75em; padding:0.25em 0em;"><strong>Output</strong></div>
            <splitter-container id="container" class="clear">
              <first-item id="mutref-first" style="width:60%;">
                <div class="codewrap" onclick="cbubbleup('mutref-first')">
                  <pre style="width:200em;"><code class="language-cpp">
  let i = 3;
  let mut j = i;    // copy of i
  let r = &mut j;   // mutable ref to j
  *r += 2;          // mutating j thru r

  ///////////////////////////////////////////////////////
  // won&apos;t compile:
  // print!("\n  i = {}, j = {}, r = {}", i, j, r);
  // print! takes its arguments by reference
  // so can't pass r, as that would make a second
  // reference where the first is mutable - not allowed

  let z = *r;       // copy r's referent value
  print!("\n  i = {}, j = {}, z = {}", i, j, z);
</code></pre>
                </div>
              </first-item>
              <splitter-bar id="mutref-seperator"></splitter-bar>
              <second-item id="mutref-second" style="width:40em;">
                <div class="codewrap" onclick="obubbleup('mutref-first')">
                  <pre style="width:200em;"><code class="language-cpp">













  i = 3, j = 5, z = 5
</code></pre>
                </div>
              </second-item>
            </splitter-container>
          </div>
          <div style="height:1em;"></div>

        </t-b>
        <t-b>
          You will find a more detailed presentation of Rust&apos;s ownership model by following links in the table, below.
        </t-b>
        <t-b>
          <table>
            <tr>
              <th class="darkItem">Ownership Details</th>
              <th class="darkItem"></th>
            </tr>
            <tr>
              <td class="lightItem">
                <a href="Resources/RustModels.pdf#page=18">RustModels.pdf</a><br />
                <a href="RustModels.html">RustModels&nbsp;code&nbsp;demos</a>
              </td>
              <td class="lightItem">
                Discussion of RwLock ownership, Copies, Moves, Clones, reference borrowing, mutability with code
                examples
              </td>
            </tr>
            <tr>
              <td class="lightItem"><a href="RustBasicDemos.html">RustBasicDemos.html</a></td>
              <td class="lightItem">Large collection of demos, several for ownership</td>
            </tr>
          </table>
        </t-b>
        <t-b>
          The next section focuses on user-defined structuring of code and data.
        </t-b>
        <div style="height:0.5em;"></div>
        <a id="types"></a>
        <h2>6.0&nbsp;&nbsp;Rust Types</h2>
        <t-b>
          Rust&apos;s <n-s><a href="https://doc.rust-lang.org/beta/std/index.html#primitives">type system</a></n-s> has:
          <div class="pad5">
            <ul class="tight">
              <li>
                primitives, i32, f64, ...
              </li>
              <li>
                array [i32, 4]
              </li>
              <li>
                tuple (i32, f64, String)
              </li>
              <li>
                struct { i:i32, f:f64, s:String }
              </li>
              <li>
                enum { BS(String), MS(String), PhD(String) }
              </li>
              <li>
                std collections:<br />
                Vec, VecDeque, LinkedList<br />
                HashMap, HashSet, BTreeMap, BTreeSet<br />
                BinaryHeap
              </li>
            </ul>
          </div>
        </t-b>
        <t-b>
          The details dropdown, below, shows how to write type specifications for each of the non-collection
          types. Usually you don&apos;t need to supply the specs, but instead may rely on the compiler&apos;s
          strong type inference engine.
        </t-b>
        <t-b>
          <t-b>
            <details>
              <summary class="labelStyle darkItem">Type Declarations:</summary>

              <div class="blockSingle" style="padding:0em; width:100%; width:calc(100vw - 9em);">
                <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>Type Declarations</strong></div>
                <div style="float:right; margin-right:0.75em; padding:0.25em 0em;"><strong>Output</strong></div>
                <splitter-container id="container" class="clear">
                  <first-item id="tdecl-first" style="width:60%;">
                    <div class="codewrap" onclick="cbubbleup('tdecl-first')">
                      <pre style="width:200em;"><code class="language-cpp">/*-- fully specified --*/
let i:i32 = 5;
let f:f64 = 3.4;
let a:[f32; 5] = [1.0, 1.5, 2.0, 1.5, 1.0];
let t:(i32, f64, String) = (1, 2.0, "three".to_string());
#[derive(Debug)]
struct S<'a>{i:i32, s:&'a str, };
let s:S = S{i:15, s:"a literal string" };
#[derive(Debug)]
enum E {BS(String), MS(String), PhD(String),};
let e:E = E::MS("Computer Engineering".to_string());

print!("\n  -- fully specified types --\n");
print!("\n  i = {:?}", i);
print!("\n  f = {:?}", f);
print!("\n  a = {:?}", a);
print!("\n  t = {:?}", t);
print!("\n  s = {:?}", s);
print!("\n  e = {:?}", e);

/*-- using type deduction --*/
let i = 5;
let f = 3.4;
let a = [1.0, 1.5, 2.0, 1.5, 1.0];
let t = (1, 2.0, "three".to_string());
let s = S{i:15, s:"a literal string" };
let e = E::MS("Computer Engineering".to_string());

print!("\n\n  -- using type deduction --\n");
print!("\n  i = {:?}", i);
print!("\n  f = {:?}", f);
print!("\n  a = {:?}", a);
print!("\n  t = {:?}", t);
print!("\n  s = {:?}", s);
print!("\n  e = {:?}", e);
</code></pre>
                    </div>
                  </first-item>
                  <splitter-bar id="tdecl-seperator"></splitter-bar>
                  <second-item id="tdecl-second" style="width:40em;">
                    <div class="codewrap" onclick="obubbleup('tdecl-first')">
                      <pre style="width:200em;"><code class="language-cpp">-- fully specified types --

i = 5
f = 3.4
a = [1.0, 1.5, 2.0, 1.5, 1.0]
t = (1, 2.0, "three")
s = S { i: 15, s: "a literal string" }
e = MS("Computer Engineering")

-- using type deduction --

i = 5
f = 3.4
a = [1.0, 1.5, 2.0, 1.5, 1.0]
t = (1, 2.0, "three")
s = S { i: 15, s: "a literal string" }
e = MS("Computer Engineering")

</code></pre>
                    </div>
                  </second-item>
                </splitter-container>
              </div>
              <div style="height:1em;"></div>

            </details>
          </t-b>
        </t-b>
        <t-b>
          Occasionally the Rust compiler needs help defining life time of references.  It wants to
          ensure that a reference does not outlive the value to which it is bound. You can see an example
          of that help for the S struct, in the dropdown, where we tell the compiler that a literal string
          member must have the lifetime of the struct.  The member declaration syntax is:
          <c-s>s:&amp;&apos;a str</c-s> where
          the <c-s>&apos;a</c-s> says that the literal string has the same lifetime as the struct.
          <indent-block class="pad5">
            <c-s>struct S&lt;&apos;a&gt;{i:i32, s:&amp;&apos;a str, };</c-s>
          </indent-block>
          Where the notation <c-s>S&lt;&apos;a&gt;</c-s> identifies &quot;a&quot; as the lifetime of S.
          <a id="user-defined"></a>
        </t-b>
        <div style="height:0.5em;"></div>
        <a id="objmodel"></a>
        <h2>7.0&nbsp;&nbsp;Rust Object Model</h2>
        <t-b>
          Rust does not have classes but structs are used in a way similar to the way classes are used in C++.
          Structs have:
          <div class="pad5">
            <ul class="tight">
              <li>
                <div>Composed members:</div>
                <div class="indent">
                  May be instances of language or user defined types.
                </div>
              </li>
              <li>
                <div>Aggregated members:</div>
                <div class="indent">
                  Uses the <n-s>Box&lt;T&gt;</n-s> construct.
                  Box&lt;T&gt; is composed, but points to an instance of T in the native heap.
                  Box&lt;T&gt; acts like the std::unique_ptr&lt;T&gt; in C++.  That is, it provides
                  a reference to data on the heap, but deallocates that data when it goes out of scope.
                </div>
              </li>
              <li>
                <div>Methods: both <n-s>static</n-s> and <n-s>non-static</n-s></div>
                <div class="indent">
                  A non-static method is declared with a first argument of &amp;self, analogous to the
                  &quot;this&quot; pointer in C++. When invoked the compiler generates code to pass
                  a reference to the invoking instance so the user does not supply that argument.
                  Static methods do not have the &amp;self argument, and so are unable to access member
                  data.
                </div>
              </li>
              <li>
                <div>Traits:</div>
                <div class="indent">
                  Traits, implemented by the struct, declare method signatures that must be defined for types that implement them.
                  A trait may provide default method implementations but often does not. Traits are used
                  like Java or C# interfaces and also provide type constraints for generic functions and
                  types.
                </div>
              </li>
              <li>
                <div>Access control: using the <n-s>pub</n-s> keyword</div>
                <div class="indent">
                  A typical struct will be declared public with <n-s>pub</n-s>.  Some of its methods will
                  also be declared public, but we usually don&apos;t make the struct&apos;s member data public.
                </div>
              </li>
            </ul>
          </div>
        </t-b>
        <t-b>
          It is interesting to note that traits can be applied to existing types, including those provided by
          the language, to add new methods for the type, much like C# extension methods, but easier to use.
        </t-b>
        <t-b>
          Here is an example of a user defined type:
        </t-b>
        <t-b>
          <div id="traits">
            <details>
              <summary class="labelStyle darkItem">User Defined Type with Traits:</summary>
              <div class="blockSingle" style="padding:0em; width:100%; width:calc(100vw - 9em);">
                <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>Traits Definition</strong></div>
                <div style="float:right; margin-right:0.75em; padding:0.25em 0em;"><strong>Test Demo Code</strong></div>
                <splitter-container id="container" class="clear">
                  <first-item id="traits-first" style="width:52%;">
                    <div class="codewrap" onclick="cbubbleup('traits-first')">
                      <div style="display:flex; flex-direction:column;">
                        <pre style="width:200em;"><code class="language-rust">/////////////////////////////////////////////////////////////
// probe_traits.rs - demo user defined traits              //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 22 Mar 2020  //
/////////////////////////////////////////////////////////////

use std::fmt::{Debug};
use display::{*};
/*-----------------------------------------------
   Note that all trait functions are public
*/

/*-----------------------------------------------
   Show trait needs Super trait Debug
   - provides default method implementation
*/
trait Show : Debug {
    fn show(&self) {
        print!(&quot;&#92;n  {:?}&quot;, &self);
    }
}
/*-----------------------------------------------
   Stucts that use Size must implement fn size
   - no default impl provided
*/
trait Size {
    fn size(&self) -&gt; usize;
}

#[derive(Debug, Copy, Clone)]
pub struct Test { // public type
    x:i32, y:f64, // private data
}
/*-----------------------------------------------
   Implementing traits
*/
impl Show for Test {}  // using default impl
impl Size for Test {   // must provide impl
    fn size(&self) -&gt; usize {
        std::mem::size_of::&lt;Test&gt;()
    }
}
/*-----------------------------------------------
   Implementing methods
*/
impl Test {
    pub fn new() -&gt; Self {
        Self {
            x:42,
            y:1.5,
        }
    }
    pub fn get_x(&self) -&gt; i32 {
        self.x
    }
    pub fn set_x(&mut self, v:i32) {
        self.x = v;
    }
    pub fn get_y(&self) -&gt; f64 {
        self.y
    }
    pub fn set_y(&mut self, v:f64) {
        self.y = v;
    }
}

</code></pre>
                      </div>
                    </div>
                  </first-item>
                  <splitter-bar id="traits-seperator"></splitter-bar>
                  <second-item id="traits-second" style="width:40em;">
                    <div class="codewrap" onclick="obubbleup('traits-first')">
                      <div style="display:flex; flex-direction:column;">
                        <pre style="width:200em;"><code class="language-rust">#[allow(dead_code)]
pub fn run () {
    main_title(&quot;Demonstrating probe_traits&quot;);
    putline();

    sub_title(&quot;using Show trait&quot;);
    let mut t = Test::new();
    t.show();
    putline();

    sub_title(&quot;using getters and setters&quot;);
    t.set_x(3);
    t.set_y(-3.5);
    print!(&quot;&#92;n  x = {}, y = {}&quot;, t.get_x(), t.get_y());
    putline();

    sub_title(&quot;using Size trait&quot;);
    print!(&quot;&#92;n  size = Test instance t = {}&quot;, t.size());

    /*-------------------------------------------
       Implementing Size for built in types!
    */
    impl Size for i32 {
        fn size(&self) -&gt; usize {
            std::mem::size_of::&lt;i32&gt;() as usize
        }
    }
    impl Size for f64 {
        fn size(&self) -&gt; usize {
            std::mem::size_of::&lt;f64&gt;() as usize
        }
    }

    let sx = t.x.size();
    let sy = t.y.size();
    print!(&quot;&#92;n  size of x = {}, size of y = {}&quot;, sx, sy);
    print!(&quot;&#92;n  remaining 4 bytes is padding for alignment&quot;);
    putline();

    sub_title(&quot;exploring struct layout with safe pointers&quot;);
    let mut t = Test::new();
    t.show();
    shows(&quot;&#92;n  Note: Test implements traits:&quot;);
    shows(&quot;&#92;n        Show, Size, Debug, Copy, Clone&quot;);
    shows(&quot;&#92;n        Missing 4 bytes is padding for alignment.&#92;n&quot;);
    let rt = &t as *const Test;
    let rx = &t.x as *const i32;
    let ry = &mut t.y as *mut f64;
    let st = std::mem::size_of::&lt;Test&gt;();
    let sx = std::mem::size_of::&lt;i32&gt;();
    let sy = std::mem::size_of::&lt;f64&gt;();
    print!(&quot;&#92;n  address of t   = {:?}&quot;, rt as i32);
    print!(&quot;&#92;n  address of t.x = {:?}&quot;, rx as i32);
    print!(&quot;&#92;n  address of t.y = {:?}&quot;, ry as i32);
    print!(&quot;&#92;n  size of t      = {:?}&quot;, st);
    print!(&quot;&#92;n  size of x      = {:?}&quot;, sx);
    print!(&quot;&#92;n  size of y      = {:?}&quot;, sy);
    print!(&quot;&#92;n  address of t + st = {:?}&quot;, rt as i32 + st as i32);
    putline();
}</code></pre>
                      </div>
                    </div>
                  </second-item>
                </splitter-container>
              </div>
              <div style="height:1em;"></div>

              <div class="blockSingle" style="padding:0em; width:max-content;">
                <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>Test Demo Output</strong></div>
                <div style="padding:0.25em;">
                  <div class="codewrap clear" style="padding:0.25em; overflow-x:auto; width:max-content;">
                    <pre style="width:35em;"><code class="language-term">  demo display
 ==============
  --  shows  --
 ---------------

  --  show_type and show_value  --
 ----------------------------------
  TypeId: alloc::string::String, size: 24
  value: "a string"

  --  log  --
 -------------
  TypeId: i8, size: 1
  value:  100
  TypeId: alloc::vec::Vec<i32>, size: 24
  value:  [-1, 0, 1]
  TypeId: demo_display::test_displays::Test, size: 1
  value:  Test1
  TypeId: demo_display::test_displays::Test, size: 1
  value:  Test2
  TypeId: demo_display::Point, size: 24
  value:  Point { x: 1.0, y: 1.5, z: 2.0 }
  Point { x: 1.0, y: 1.5, z: 2.0 }

  --  show --
 -------------
  this is a Point structure
  Point { x: 1.0, y: 1.5, z: 2.0 }

  that's all folks!
 -------------------
</code></pre>
                  </div>
                </div>
              </div>

              <div style="height:1em;"></div>

            </details>
          </div>
        </t-b>
        <div style="width:calc(100vw - 9em);">
          <photosizer-block src="Pictures/RustStaticBinding.jpg" width="600" class="photoSizerBlock right" style="margin-top:0;">
            <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS', Tahoma;
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
              Figure 3. Trait Method Binding
            </span>
          </photosizer-block>
        </div>
        <t-b>
          Any type with a trait has an associated virtual function pointer table (Vtbl), as shown in Figure 3.
          If you looked at the &quot;User Defined Type with Traits&quot; details dropdown, above, you saw that the layout
          of a struct can be analyzed using safe pointers<sup>1</sup>.  The results of that analysis are shown in
          Table 1., below.
        </t-b>
        <t-b>
          Rust traits are very similar to Java and C# interfaces.  Rust does not support any form of inheritance of implementation,
          but does support inheriting traits, which can have no member data.
        </t-b>
        <div class="clear"></div>
        <div style="width:calc(100vw - 9em);">
          <div class="clear right" style="padding-left:1.5em; margin-right:1em;">
            <table>
              <tr>
                <th colspan="3" class="darkItem fw_norm">
                  Table 1. Test Struct Memory Layout
                </th>
              </tr>
              <tr>
                <th class="darkItem fw_norm">Component</th>
                <th class="darkItem fw_norm">Address</th>
                <th class="darkItem fw_norm">Size - bytes</th>
              </tr>
              <tr>
                <th class="lightItem fw_norm" style="text-align:right;">Test Struct</th>
                <th class="lightItem fw_norm">8190584</th>
                <th class="lightItem fw_norm" style="text-align:right;">16</th>
              </tr>
              <tr>
                <th class="lightItem fw_norm" style="text-align:right;">y:f64</th>
                <th class="lightItem fw_norm">8190584</th>
                <th class="lightItem fw_norm" style="text-align:right;">8</th>
              </tr>
              <tr>
                <th class="lightItem fw_norm" style="text-align:right;">x:i32</th>
                <th class="lightItem fw_norm">8190592</th>
                <th class="lightItem fw_norm" style="text-align:right;">4</th>
              </tr>
              <tr>
                <th class="lightItem fw_norm" style="text-align:right;">padding</th>
                <th class="lightItem fw_norm">8190596</th>
                <th class="lightItem fw_norm" style="text-align:right;">4</th>
              </tr>
            </table>
          </div>
          <t-b>
            We see from the table that each field associated with a struct lies within the memory footprint of
            the struct, and if the
            struct has any traits<sup>2</sup> there will be an embedded pointer to a Vtbl as well.
            There is only one Vtbl for each type, so the pointer address value is invariant.
          </t-b>
          <t-b>
            Because of this layout strategy, a copy<sup>3</sup>, is simply a memcopy of the entire struct
            to the destination. For structs that contain no-copy (non-blittable) fields, only moves are
            allowed, but they work the same way, doing a mem-copy to the destination.  The only difference
            is that for copies the source remains valid, while for moves, the source becomes invalid.
          </t-b>
        </div>
        <div style="width:calc(100vw - 9em);" class="clear">
          <photosizer-block src="Pictures/RustVtbl.jpg" width="600" class="photoSizerBlock right" style="margin-top:0;">
            <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS', Tahoma;
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
              Figure 4. Trait Virtual Dispatching
            </span>
          </photosizer-block>
        </div>
        <t-b>
          Rust structs support polymorphism through virtual dispatching, as illustrated in Figure 4.  Suppose we
          implement a function:
          <s-halfEm></s-halfEm>
          <indent-block class="pad5">
            <defn-block>
              <defn-head>Function accepting trait object</defn-head>
              <defn-code>
fn size_is(o:&dyn Size) ->usize {
  o.size()  // Size::size()
}

              </defn-code>
            </defn-block>
          </indent-block>
          We can pass any type to <c-s>size_is</c-s> as long as the type implements the Size trait. Each type that
          implements traits has an associated virtual method table (vtble).  Rust uses type inference to associate an input
          instance, <c-s>o</c-s> for <c-s>size_is(o:&dyn Size)</c-s> with its vtble and calls the size method implemented
          for that type.
        </t-b>
        <t-b>
          That means that we can write one function like <c-s>size_is</c-s> that will work for an open-ended number of
          types - they just need to implement the Size trait.  And, that function implementation doesn&apos;t need to
          know anything about the incoming types.  It just uses the trait methods. That is a big deal!
        </t-b>
        <div class="clear"></div>
        <t-b>
          <hr class="spreadup" />
          <ol class="footnote">
            <li>
              You can create pointers and display their addresses in safe code, which is what we have
              done for this analysis.  You can only dereference pointers in unsafe blocks, but we did
              not need to do that.
            </li>
            <li>
              Almost every struct has traits, at least Debug, and if copyable, Copy and Clone. Adding
              custom traits can be very useful, as shown in this and the next example.
            </li>
            <li>
              Stucts with all blittable fields can implement the Copy trait.  Those with non-blittable
              fields cannot.
            </li>
          </ol>
        </t-b>
        <div class="clear"></div>
        <div style="height:0.5em;"></div>
        <a id="userdeftypes"></a>
        <h2>8.0&nbsp;&nbsp;User-Defined Types:</h2>
        <t-b>
          <t-b>
            Rust does not have classes or inheritance of implementation.  It does, however, have structs and traits.  A trait is
            similar to an interface or abstract class.  Structs have public and private members and can implement
            traits as well as other functions.
          </t-b>
          <t-b>
            Here&apos;s an example, used in the details dropdown,
            below:
          </t-b>



          <t-b>

          </t-b>
          <t-b>
            <defn-block>
              <defn-head>Salutation Trait</defn-head>
              <defn-code>
trait Speaker {
  fn salutation(&self) -> String;
}
              </defn-code>
            </defn-block>
          </t-b>
          <t-b>
            The trait declares a salutation function that structs implement, like this:
          </t-b>
          <t-b>
            <defn-block>
              <defn-head>
                Implementing Saluation Trait
              </defn-head>
              <defn-code>
pub struct Presenter;
impl Speaker for Presenter {
    fn salutation(&self) -> String {
  "Hello, today we will discuss ...".to_string()
  }
}
              </defn-code>
            </defn-block>
          </t-b>
        </t-b>
        <t->
          The code in the User-Defined Type dropdown illustrates how this can be used to implement
          polymorphic operations, e.g., function dispatching based on the type of value  bound to a reference,
          not on the type of the reference.
        </t->
        <t-b>
          That works because each trait has a virtual function pointer table used for function dispatching.
        </t-b>
        <t-b>
          <t-b>
            <details>
              <summary class="labelStyle darkItem">Example User-Defined Type:</summary>
              <div class="blockSingle" style="padding:0em; width:100%; width:calc(100vw - 9em);">
                <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>Trait Defs and Impl : userdef.rs</strong></div>
                <div style="float:right; margin-right:0.75em; padding:0.25em 0em;"><strong>Demo Code : main.rs</strong></div>
                <splitter-container id="container" class="clear">
                  <first-item id="userdef-first" style="width:52%;">
                    <div class="codewrap" onclick="cbubbleup('userdef-first')">
                      <div style="display:flex; flex-direction:column;">
                        <pre style="width:200em;"><code class="language-rust">///////////////////////////////////////////////////////////
// user-defined traits act like interfaces               //
// userdef.rs                                            //
///////////////////////////////////////////////////////////

pub trait Speaker {
  fn salutation(&self) -&gt; String;
}

///////////////////////////////////////////////////////////
// The following structs act like classes that implement
// a Speaker interface

#[derive(Debug,Copy,Clone)]
pub struct Presenter;
impl Speaker for Presenter {
  fn salutation(&self) -&gt; String {
    &quot;Presenter: Hello, today we will discuss ...&quot;.to_string()
  }
}

#[derive(Debug)]
pub struct Friend {
  pub name : String,
}
impl Speaker for Friend {
  fn salutation(&self) -&gt; String {
    let mut s = String::from(&quot;Friend:    Hi good buddy, its me, &quot;);
    let nm = self.name.as_str();
    s.push_str(nm);
    return s;
  }
}
impl Friend {
  #[allow(dead_code)]
  pub fn new(name : String) -&gt; Self {
    Self {
      name,
    }  // note: no semicolon so Self is returned
  }
}
#[derive(Debug,Copy,Clone)]
pub struct TeamLead;
impl Speaker for TeamLead {
  fn salutation(&self) -&gt; String {
    &quot;TeamLead:  Hi, I have a task for you ...&quot;.to_string()
  }
}

</code></pre>
                      </div>
                    </div>
                  </first-item>
                  <splitter-bar id="userdef-seperator"></splitter-bar>
                  <second-item id="userdef-second" style="width:40em;">
                    <div class="codewrap" onclick="obubbleup('userdef-first')">
                      <div style="display:flex; flex-direction:column;">
                        <pre style="width:200em;"><code class="language-rust">///////////////////////////////////////////////////////////
// Demonstrate polymorphic operations using Rust Traits  //
// user_def::main.rs                                     //
///////////////////////////////////////////////////////////

mod userdef;
use userdef::*;

#[allow(dead_code)]
pub fn run() {

  print!(
    &quot;&#92;n&#92;n  {}&quot;,
    &quot;-- demo polymorphic struct instances --&#92;n&quot;
  );
  let presenter : Presenter = Presenter;
  let joe : Friend = Friend::new(&quot;Joe&quot;.to_string());
  let sue : Friend = Friend::new(&quot;Sue&quot;.to_string());
  let team_lead : TeamLead = TeamLead;

  let mut v :Vec&lt;&dyn Speaker&gt; = Vec::new();
  v.push(&presenter);
  v.push(&joe);
  v.push(&sue);
  v.push(&team_lead);

  /*
    Presenters, Friends, and TeamLeads are all Speakers, i.e.,
    they implement the Speaker trait, so they all can be
    treated uniformily, as speakers.
   */
  for speaker in v.iter() {
    print!(&quot;&#92;n  {:?}&quot;,speaker.salutation());
  }
}

fn main() {
  run();
}
</code></pre>
                      </div>
                    </div>
                  </second-item>
                </splitter-container>
              </div>
              <div style="height:1em;"></div>

              <div class="blockSingle" style="padding:0em; width:max-content;">
                <div style="float:left; margin-left:0.75em; padding:0.25em 0em;"><strong>Demo Output</strong></div>
                <div style="padding:0.25em;">
                  <div class="codewrap clear" style="padding:0.25em; overflow-x:auto; width:max-content;">
                    <pre style="width:35em;"><code class="language-term">-- demo polymorphic struct instances --

  "Presenter: Hello, today we will discuss ..."
  "Friend:    Hi good buddy, its me, Joe"
  "Friend:    Hi good buddy, its me, Sue"
  "TeamLead:  Hi, I have a task for you ..."
</code></pre>
                  </div>
                </div>
              </div>

              <div style="height:1em;"></div>

            </details>
          </t-b>
        </t-b>
        <t-b>
          In the next section we discuss Rust generics.  They provide a way of deferring definition of specific
          types used as function arguments and struct data members.
        </t-b>
        <div style="height:0.5em;"></div>
        <a id="generics"></a>
        <h2>9.0&nbsp;&nbsp;Generics:</h2>
        <t-b>
          Rust supports generics for functions and structs:
        </t-b>
        <t-b>
          <div>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Generic Function:</defn-head>
                <defn-code>
fn demo_ref&lt;T&gt;(t:&amp;T) where T:Debug  {
  show_type(t);
  show_value(t);
}
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Generic Struct:</defn-head>
                <defn-code>
#[derive(Debug)]
struct Point&lt;T&gt; { x:T, y:T, z:T, }
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </div>
        </t-b>
        <t-b>
          Rust generics are similar to C# and Java Generics.  They don&apos;t support specialization to
          broaded the number of types accepted, like C++.  They do define constraints to narrow the number
          of types that compile, like C# and Java. In the function example, above, we&apos;ve used a constraint
          to allow only those types with a Debug trait to compile.
        </t-b>
        <t-b>
          In the details dropdown, below, we&apos;ve added a another example for both functions and structs, and
          shown using code and output as well.
        </t-b>
        <t-b>
          <indent-blocks>
            <details>
              <summary class="labelStyle darkItem">Generics Examples:</summary>
              <defn-outerBlock>
                <defn-block>
                  <defn-head>Generic Functions</defn-head>
                  <defn-code>
                    /*-----------------------------------------
                    No-copy arguments will be moved
                    */
                    fn demo&lt;T:Debug&gt;(t:T) {
                    show_type(&amp;t);
                    show_value(&amp;t);
                    }

                    /*-----------------------------------------
                    refs so arguments will not be moved
                    */
                    fn demo_ref&lt;T&gt;(t:&amp;T) where T:Debug  {
                    show_type(t);
                    show_value(t);
                    }

                  </defn-code>
                  <defn-head class="defnBorderTop">Using Code:</defn-head>
                  <defn-code>
                    let mut s = String::from("this is a test");

                    sub_title("demo_ref");
                    demo_ref(&amp;s);
                    let pi = 3.1415927;
                    demo_ref(&amp;pi);
                    s.push('Z');
                    putline();

                    sub_title("demo");
                    demo(s);
                    demo(pi);
                    // statement below won't compile - s moved
                    // s.push('Z');
                    putline();

                  </defn-code>
                  <defn-head class="defnBorderTop">Output:</defn-head>
                  <defn-code>
                    demo_ref
                    ----------
                    TypeId: alloc::string::String, size: 12
                    value: "this is a test"
                    TypeId: f64, size: 8
                    value: 3.1415927

                    demo
                    ------
                    TypeId: alloc::string::String, size: 12
                    value: "this is a testZ"
                    TypeId: f64, size: 8
                    value: 3.1415927
                  </defn-code>
                </defn-block>
                <defn-block>
                  <defn-head>Generic Structs</defn-head>
                  <defn-code>
                    #[derive(Debug)]
                    struct Point&lt;T&gt; { x:T, y:T, z:T, }

                    // Copy trait works because blittable, provided
                    // that T is blittable
                    #[derive(Debug, Copy, Clone)]
                    struct BetterPoint&lt;T&gt; { x:T, y:T, z:T, }

                  </defn-code>
                  <defn-head class="defnBorderTop">Using Code:</defn-head>
                  <defn-code>
                    sub_title("demo_ref and demo with struct");
                    let mut pt = Point { x:1.0, y:-1.5, z:2.3 };
                    demo_ref(&amp;pt);
                    pt.x = 3.2;
                    demo(pt);
                    // statement below won't compile - pt moved for demo
                    // pt.x = 3.2;
                    putline();

                    sub_title("demo_ref and demo with copy-able struct");
                    let mut bpt = BetterPoint { x:1.0, y:-1.5, z:2.3 };
                    demo_ref(&amp;bpt);
                    bpt.x = 3.2;
                    demo(bpt);
                    // statement ok - pt copied for demo
                    bpt.x = 3.2;
                    putline();

                    sub_title("demo_ref and demo with copy-able struct");
                    let mut bpt = BetterPoint { x:"one", y:"two", z:"three" };
                    demo_ref(&amp;bpt);
                    bpt.x = "1";
                    demo(bpt);
                    // statement ok - pt copied for demo
                    bpt.x = "one";
                    putline();

                    sub_title("demo_ref and demo with non copy-able struct");
                    let mut bpt = BetterPoint {
                    x:"one".to_string(),
                    y:"two".to_string(),
                    z:"three".to_string()
                    };
                    demo_ref(&amp;bpt);
                    bpt.x = "four".to_string();
                    demo(bpt);
                    // won't compile - bpt not blittable so it was moved
                    // bpt.x = "one".to_string();

                    putlinen(2);
                  </defn-code>
                  <defn-head class="defnBorderTop">Output:</defn-head>
                  <defn-code>
                    demo_ref and demo with struct
                    -------------------------------
                    TypeId: generics_probes::Point<f64>
                      , size: 24
                      value: Point { x: 1.0, y: -1.5, z: 2.3 }
                      TypeId: generics_probes::Point<f64>
                        , size: 24
                        value: Point { x: 3.2, y: -1.5, z: 2.3 }

                        demo_ref and demo with copy-able struct
                        -----------------------------------------
                        TypeId: generics_probes::BetterPoint<f64>
                          , size: 24
                          value: BetterPoint { x: 1.0, y: -1.5, z: 2.3 }
                          TypeId: generics_probes::BetterPoint<f64>
                            , size: 24
                            value: BetterPoint { x: 3.2, y: -1.5, z: 2.3 }

                            demo_ref and demo with copy-able struct
                            -----------------------------------------
                            TypeId: generics_probes::BetterPoint<&str>
                              , size: 24
                              value: BetterPoint { x: "one", y: "two", z: "three" }
                              TypeId: generics_probes::BetterPoint<&str>
                                , size: 24
                                value: BetterPoint { x: "1", y: "two", z: "three" }

                                demo_ref and demo with non copy-able struct
                                ---------------------------------------------
                                TypeId: generics_probes::BetterPoint<alloc::string::String>
                                  , size: 36
                                  value: BetterPoint { x: "one", y: "two", z: "three" }
                                  TypeId: generics_probes::BetterPoint<alloc::string::String>
                                    , size: 36
                                    value: BetterPoint { x: "four", y: "two", z: "three" }

                  </defn-code>
                </defn-block>
              </defn-outerBlock>
            </details>
          </indent-blocks>
        </t-b>
        <t-b>
          This chapter has focused on the main features and models of Rust.  You will find more details in
          succeeding chapters.
        </t-b>
        <div style="height:0.5em;"></div>
        <a id="epilogue"></a>
        <h2>10.0&nbsp;&nbsp;Epilogue:</h2>
        <t-b>
          The models we&apos;ve covered here: Code Structure, Build Process, Ownership, and User-Defined
          Types and Traits are what make Rust unique and interesting.  We will see more details for each
          of these in the coming chapters.
        </t-b>
        <t-b>
          Rust is interesting, worth spending effort to gain a working knowledge of the language
          and its uses.  To help you do that, I&apos;m providing a set of exercises for you to begin that process.
          I won&apos;t be providing answers, but you will find code in <a href="RustBasicDemos.html">RustBasicDemos</a>
          very similar to code for the completed exercises.
        </t-b>
        <a id="exercises"></a>
        <hr class="spread" />
        <h3>10.1&nbsp;&nbsp;Exercises:</h3>
        <t-b class="indent" style="margin-bottom:2em;">
          <ol class="tight">
            <li>
              Write code that intentionally attempts to violate each of the ownership rules.  Observe when they
              fail to compile, comment out the offending code with commentary about why the code failed to
              compile.
            </li>
            <li>
              Declare an array of some primitive type, and visit each element, printing out its value. Now repeat
              for a Vec holding the same primitive type.
            </li>
            <li>
              Declare a struct that defines a three dimensional point.  Define two points with different values
              and print out the differences between each of the three coordinates for the two points.
            </li>
            <li>
              Repeat the previous exercise using tuples instead of structs.
            </li>
          </ol>
        </t-b>
        <div style="height:0.5em;"></div>
        <hr class="spread" />
        <a id="refs"></a>
        <h2>11.0&nbsp;&nbsp;References:</h2>
        <t-b>
          I&apos;ve ordered these references with the most elementary or briefest expositions coming first.  Later
          references you will use heavily later.
        </t-b>
        <t-b>
          There are a lot of references here. I don&apos;t recommend cover-to-cover reading; just browse, stopping at
          points of interest, and, after that, use them as reference materials.
        </t-b>

        <table style="width:calc(100vw - 12em);">
          <tr>
            <th class="darkItem">Reference Link</th>
            <th class="darkItem">Description</th>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://www.oreilly.com/programming/free/files/why-rust.pdf">Why Rust? - Jim Blandy</a>
            </td>
            <td class="lightItem">
              Monograph on why Rust is important
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://users.rust-lang.org/">Rust users forum</a>
            </td>
            <td class="lightItem">
              Answers to a broad range of questions from beginner to advanced.
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/">A half-hour to learn Rust</a>
            </td>
            <td class="lightItem">
              Code fragments with commentary that cover most of the Rust ideas.
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust by Example</a>
            </td>
            <td class="lightItem">
              Rust docs - walkthrough of syntax
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://rust-lang-nursery.github.io/rust-cookbook/intro.html">Rust Cookbook</a>
            </td>
            <td class="lightItem">
              Rust docs - a collection of example projects using the Rust libraries and external crates
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html">A Gentle Introduction To Rust</a>
            </td>
            <td class="lightItem">
              Read early in your Rust travels.
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://doc.rust-lang.org/book/">The Rust Book</a>
            </td>
            <td class="lightItem">
              Rust docs - walkthrough of syntax
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://cheats.rs/">Rust cheat sheet</a>
            </td>
            <td class="lightItem">
              Quite extensive list of cheats and helpers.
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
            <td class="lightItem">
              Container diagrams
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://doc.rust-lang.org/reference/">The Rust Reference Book</a>
            </td>
            <td class="lightItem">
              Rust&apos;s approximation of a language standard. Clear and well written, with a glossary at the end.
              Its <a href="https://github.com/rust-lang/reference">github site</a> shows that changes are still being
              actively incorporated.
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">RIP Tutorial on Rust</a></td>
            <td class="lightItem">
              Comprehensive coverage from RIP, the stackoverflow archive
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">Learning Rust ebook</a></td>
            <td class="lightItem">
              Comprehensive coverage from RIP, stackoverflow archive
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://riptutorial.com/rust/awesome-learning/book">Rust - Awesome Book</a></td>
            <td class="lightItem">
              lots of interesting discussions from RIP, the Stackoverflow Archive
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://docs.rs/dtolnay/0.0.8/dtolnay/macro._02__reference_types.html">
                Shared&nbsp;reference&nbsp;&amp;T&nbsp;and&nbsp;exclusive&nbsp;reference&nbsp;&amp;mut&nbsp;T
              </a>
            </td>
            <td class="lightItem">
              More accurate description than immutable reference and mutable reference
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://www.twelve21.io/getting-started-with-rust-on-windows-and-visual-studio-code/">
                Getting Started with Rust on Windows and Visual Studio Code
              </a>
            </td>
            <td class="lightItem">
              Install Rust, Verify, Configure Visual Studio Code, Create Hello World, Create Build Task,
              Configuring Unit Tests, Configure Debugging,
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://www.rust-lang.org/">rust-lang.org home page</a>
            </td>
            <td class="lightItem">
              Links to download and documentation
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://www.youtube.com/watch?v=zF34dRivLOw">(video) Rust - Crash Course | Rustlang</a>
            </td>
            <td class="lightItem">
              Code demo using basic types.
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://www.tutorialspoint.com/rust/index.htm">Tutorial - tutorialspoint.com</a>
            </td>
            <td class="lightItem">
              Tutorials for most of the Rust parts with code examples.
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://deterministic.space/">Blog - Pascal's Scribbles</a>
            </td>
            <td class="lightItem">
              Pascal Hertleif - Rust contributor
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://blog.mgattozzi.dev/">Blog - Barely Functional</a>
            </td>
            <td class="lightItem">
              Michael Gattozzi - Rust contributor
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://www.snoyman.com/blog/2020/05/no-mutable-parameters-in-rust">Blog - S.Noyberg</a>
            </td>
            <td class="lightItem">
              Examples of aysnc/await, tokio, lifetime, ...
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="http://kmcallister.github.io/talks/rust/2015-contributing-to-rust/slides.html">Compilation details</a>
            </td>
            <td class="lightItem">
              kmcallister.github.io
            </td>
          </tr>
          <tr>
            <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
            <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
          </tr>
          <!--<tr>
            <td class="lightItem">
              <a href="https://www.javatpoint.com/rust-tutorial">Tutorial - javatpoint.com</a>
            </td>
            <td class="lightItem">
              Quite extensive list of cheats and helpers.
            </td>
          </tr>-->
        </table>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#exercises">exercises</a></menu-elem>
        <menu-elem class="secElem"><a href="#epilogue">epilogue</a></menu-elem>
        <menu-elem class="secElem"><a href="#generics">generics</a></menu-elem>
        <menu-elem class="secElem"><a href="#userdeftypes">userdeftypes</a></menu-elem>
        <menu-elem class="secElem"><a href="#traits">traits</a></menu-elem>
        <menu-elem class="secElem"><a href="#objmodel">objmodel</a></menu-elem>
        <menu-elem class="secElem"><a href="#types">types</a></menu-elem>
        <menu-elem class="secElem"><a href="#ownership">ownership</a></menu-elem>
        <menu-elem class="secElem"><a href="#execution">execution</a></menu-elem>
        <menu-elem class="secElem"><a href="#build">build</a></menu-elem>
        <menu-elem class="secElem"><a href="#codestructure">codestructure</a></menu-elem>
        <menu-elem class="secElem"><a href="#compare">compare</a></menu-elem>
        <menu-elem class="secElem"><a href="#prologue">prologue</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
        <div class='darkItem popupHeader' style="padding:0.25em 2.0em;" onclick="this.parentElement.style.display='none'">Sections</div>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:5em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn;
  </script>
  <script>
    onLoadSplitter("hello");
    onLoadSplitter("hello2");
    onLoadSplitter("hello3");
    // onLoadSplitter("demo1");
    // onLoadSplitter("demo2");
    // onLoadSplitter("dlib1");
    // onLoadSplitter("dlib2");
    // onLoadSplitter("dlib3");
    // onLoadSplitter("dlib4");
    onLoadSplitter("cam");
    onLoadSplitter("mutref");
    onLoadSplitter("tdecl");
    onLoadSplitter("traits");
    onLoadSplitter("userdef");
  </script>
</body>
</html>