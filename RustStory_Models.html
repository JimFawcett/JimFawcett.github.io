<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Prologue.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Rust Models</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="RustStory_Data.html">N</a>
  <a id="Prev" href="RustStory_Prologue.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 1. - Rust Models</h1>
      <h3 id="subtitle">Code Structure, Builds, Ownership, User-Defined Types and Traits, Generics</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_Libraries.html">Libraries</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#structure">Structure</a>, 
       <a href="#build">Build</a>, <a href="#ownership">Ownership</a>, <a href="#types">Types</a>, 
       <a href="#user-defined">User-defined Types</a>, <a href="#generics">Generics</a>, 
       <a href="#refs">References</a>
     </rt-b>
   </toc-b>

  <bb-55 class="indent">
    <a id="prologue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.0</num-item1><num-item4>Prologue:</num-item4>
    </num-cont>
    <t-b>
      <details>
        <summary class="labelStyle lightItem">Hello World in Rust</summary>
        <t-b>
          Uses only <n-s>Cargo</n-s>, after installing Rust, and the x64 Native Tools Command Prompt for Visual Studio 2019.
        </t-b>
      <defn-outerBlock>
        <defn-block>
          <defn-head>Create hello_demo Package with Cargo</defn-head>
          <defn-code>
c:\su\temp>
cargo init hello_demo
     Created binary (application) package

c:\su\temp>
cd hello_demo

c:\su\temp\hello_demo>
dir
 Volume in drive C is OS
 Volume Serial Number is 765A-DAD5

 Directory of c:\su\temp\hello_demo

02/23/2020  10:15 AM    &lt;DIR&gt;          .
02/23/2020  10:15 AM    &lt;DIR&gt;          ..
02/23/2020  10:15 AM                 8 .gitignore
02/23/2020  10:15 AM               234 Cargo.toml
02/23/2020  10:13 AM    &lt;DIR&gt;          src
               2 File(s)            242 bytes
               3 Dir(s)  644,435,443,712 bytes free

c:\su\temp\hello_demo>
dir .\src
 Volume in drive C is OS
 Volume Serial Number is 765A-DAD5

 Directory of c:\su\temp\hello_demo\src

02/23/2020  10:13 AM    &lt;DIR&gt;          .
02/23/2020  10:13 AM    &lt;DIR&gt;          ..
02/23/2020  10:13 AM                45 main.rs
               1 File(s)             45 bytes
               2 Dir(s)  644,435,443,712 bytes free
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>main.rs</defn-head>
          <defn-code>
c:\su\temp\hello_demo>
cd src

c:\su\temp\hello_demo\src>
type main.rs
fn main() {
    println!("Hello, world!");
}
          </defn-code>
          <defn-head class="defnBorderTop">run main.rs</defn-head>
          <defn-code>
c:\su\temp\hello_demo\src>
cd..

c:\su\temp\hello_demo>
cargo run
   Compiling hello_demo v0.1.0 (C:\su\temp\hello_demo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.84s
     Running `target\debug\hello_demo.exe`
Hello, world!
          </defn-code>
          <defn-head class="defnBorderTop">Cargo.toml</defn-head>
          <defn-code>
c:\su\temp\hello_demo>
type cargo.toml
[package]
name = "hello_demo"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at // remainder elided

[dependencies]

          </defn-code>
        </defn-block>
      </defn-outerBlock>
      </details>
    </t-b>
    <t-b>
      Rust is an interesting language, similar to C++, but with some unique differences.
      <t-b>
        <defn-block>
          <defn-head>Rust Principles:</defn-head>
          <defn-body>
            <ol class="tight">
              <li>
                <n-b>Memory unsafety <==> <n-s>aliasing + mutation</n-s> or <n-s>out-of-bounds indexing</n-s></n-b>
                <div>
                  Rust provides memory safety by:
                  <indent-block class="pad5">
                    <n-s>Compiler</n-s> checked Ownership + Borrowing rules,<br />
                    <n-s>compiler</n-s> checked indexing where possible, else run-time panic (no reads/writes of unowned memory)
                  </indent-block>
                  These prevent simultaneous aliasing + mutation and avoids accessing out-of-bounds indexed memory.
                </div>
              </li>
              <li>
                <n-b>Data races <==> <n-s>aliasing + mutation + no ordering</n-s></n-b>
                Rust provides race safety using two concurrency models:
                <indent-block class="pad5">
                  Model #1 - Thread communication through messaging transfers ownership of message
                  <indent-block>
                    Prevents simultaneous aliasing and mutation
                  </indent-block>
                  Model #2 - Guarded locks
                  <indent-block>
                    prevent mutation without ordering
                  </indent-block>
                </indent-block>
                These models are <n-s>compiler</n-s> checked.
              </li>
            </ol>
          </defn-body>
        </defn-block>
      </t-b>
      <indent-block class="pad10">
        <ol class="tights">
          <li>
            Rust&apos;s <n-s>types are, by default, immutable</n-s>. You have to opt-in to mutability with the
            mut keyword:
            <indent-block class="pad5">
              <c-s>let s = mut String::from("a string");</c-s>
            </indent-block>
          </li>
          <li>
            <n-s>Ownership</n-s>:&nbsp;&nbsp;memory unsafety using resources <==> aliasing + mutation
            <div class="pad5">
              In Rust there is only one owner of a value:
            </div>
            <ul class="tight" style="list-style-type:lower-alpha;">
              <li>
                If a type is blittable<sup>1</sup>, e.g., primitives, arrays, ... it is copyable:
                <indent-block class="pad5">
                  <c-s>let a1 = [1, 2, 3];<br />let a2 = a1;&nbsp;&nbsp;&nbsp;// a copy</c-s>
                </indent-block>
              </li>
              <li>
                If not blittable, e.g., strings, a collection type, ... then it gets moved (transfers ownership):
                <indent-block class="pad5">
                  <c-s>let s1 = "a string".to_string();<br />
                  let s2 = s1;&nbsp;&nbsp;&nbsp;// a move<br />
                  let s3 = s2.clone();&nbsp;&nbsp;&nbsp;// an explicit copy so no move</c-s>
                </indent-block>
                In this example, s1 will not be usable after the move. Attempts to use a moved item are
                <n-s>compile</n-s> errors! S3 owns a <n-s>copy</n-s> of s2&apos;s resource, so s2 is usable
                after the clone operation.
              </li>
              <li>
                References support <n-s>borrowing</n-s>:
                <indent-block class="pad5">
                  <c-s>let mut s = String::from("another string);</c-s><br />
                  <c-s>let rs = &mut s;</c-s>
                </indent-block>
              </li>
              <li>
                References must satisfy <n-s>compiler-checked</n-s> rules:
                <div>
                  <ul class="tight">
                    <li>
                      Only one mutable reference is allowed
                    </li>
                    <li>
                      Any number of un-mutable references are allowed
                    </li>
                    <li>
                      Owner must not mutate while references are active.
                      References become inactive when they go out of scope or are dropped<sup>2</sup>.
                    </li>
                  </ul>
                </div>
              </li>
            </ul>
            <hr class="spreadup" />
            <div class="footnote">
              <ol class="tight">
                <li>
                  Data that can be copied with a block transfer, e.g., using memcpy.
                </li>
                <li>
                  let x = String::from("will be dropped"); drop(x);
                </li>
              </ol>
            </div>
          </li>
          <li>
            All <n-s>resource management is scope based</n-s>.  When an item, holding resources, goes out of scope,
            its <n-s>drop</n-s> function (similar to a C++ destructor) is called.
          </li>
          <li>
            All <n-s>heap allocations are referenced with a smart <c-s>Box&lt;T&gt;</c-s> pointer</n-s> that drops its
            reference when it goes out of scope, similar to the C++ <c-s>std::unique_ptr&lt;T&gt;</c-s>.
          </li>
          <li>
            Rust has a <n-s>module system</n-s>, useful for refactoring local code, and packages that need not
            be local.
          </li>
          <li>
            It has a relatively complete <a href="https://doc.rust-lang.org/beta/std/"><n-s>std library</n-s></a>
            with collections, threads, tcp socket wrappers, file system library, ...
          </li>
          <li>
            The good news is, in Rust, it is relatively simple to <n-s>interface to C code</n-s>. The bad news is
            it is relatively simple to interface to C code.
          </li>
          <li>
            Rust has a very useful tool, <n-s>Cargo</n-s>, which is a package manager, builder, and
            verifier, and will execute code, all with a simple command syntax.
          </li>
          <li>
            The Rust <n-s>compiler analyzes code deeply</n-s> and refuses to build code that has memory and
            reference problems.  Because of the structure of its types, this analysis is suprisingly
            fast. Compiler error messages are <n-s>usually</n-s> clear, simple, and provide advice for fixing
            the error.  If the error is grievous enough, the messages can get confusing, even complaining
            about correct code.
          </li>
          <li>
            Rust code layout is more flexible than that of C++, where definitions must come before use.
            In Rust, an <n-s>identifier may be used at any place in the code</n-s> provided only that it has been
            defined somewhere in the translation unit (similar to Java and C#).
          </li>
          <li>
            As of now, there is <n-s>no debugger</n-s> as part of the Rust tool chain. That isn&apos;t as big an issue
            as you might think.  <del>Many</del> most errors are compile-time and the compiler helps with those. 
            Since Rust eliminates many errors by construction, logging works for the small remainder.
          </li>
          <li>
            Rust uses structs for creating types.  Structs can only inherit from traits, a form of
            abstract type similar to an interface.  Traits can, but often do not, implement
            the methods they declare.
          </li>
          <li>
            <n-s>Rust does not implement function overloading</n-s>.
          </li>
          <li>
            <n-s>Rust does not have exceptions</n-s> - uses panics (controlled shutdown)
          </li>
          <li>
            <n-s>Rust generics are like Java and C# generics rather than C++ Templates</n-s>. 
            <ul class="tight">
              <li>
                C++ template classes can be specialized and template functions can be overloaded. 
                That enlarges the set of types that the template function or class can be successfully
                instantiated with. Any types that don&apos;t work correctly with the generic template
                can be specialized with code that works for that type.
              </li>
              <li>
                Rust generics can be constrained by the use of trait specifications. That diminishes the
                set of types that will compile for the generic function or struct. Any type that doesn&apos;t
                implement the trait will not compile when used to instantiate the generic function or struct.
              </li>
              <li>
                Rust generics do not support creation of variadic functions and variatic type lists for
                generic structs. To create a variatic function you need to use macros. Rust macros seem
                to be well engineered, so that may not be as inconvenient as it would otherwise be.
              </li>
            </ul>
          </li>
        </ol>
      </indent-block>
      <t-b style="margin-top:0px;">
        This seems like a daunting list of things to learn. It is, but the Rust compiler makes that a lot
        easier than you might think.  Every time your code doesn&apos;t follow the rules it fails to
        compile with usually very clear error messages that help you fix the error(s).
      </t-b>
      <num-cont>
        <num-item1>1.0.1</num-item1><num-item4>Comparing to C++</num-item4>
      </num-cont>
      <t-b>
        Modern C++ provides lots of tools to promote safe design:
        <indent-block>
          <ol class="tight">
            <li>
              Scope-based resource management via constructors and destructors
            </li>
            <li>
              Smart pointers: std::unique_ptr&lt;T&gt;, std::shared_ptr&lt;T&gt;
            </li>
            <li>
              Range-based for loops and begin and end iterators nearly eliminate out-of-bound
              indexing.
            </li>
            <li>
              Encapsulation of state in instances of classes
            </li>
            <li>move constructors and assignment</li>
            <li>exception handling, STL container at(i) method</li>
            <li>...</li>
          </ol>
        </indent-block>
      </t-b>
      <t-b>
        These are used effectively by experienced C++ developers to write safe code. But not all
        C++ developers have enough experience to do that consistently.  C++ is safe by convention, 
        but the conventions have to be followed.
      </t-b>
      <t-b>
        Rust indentifies safety vulnerabilities and avoids them with compiler enforced rules.
      </t-b>
      <t-b>
        <indent-block>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Modern C++</defn-head>
              <defn-body>Safe by convention</defn-body>
            </defn-block>
            <defn-block>
              <defn-head>Rust</defn-head>
              <defn-body>Safe by construction</defn-body>
            </defn-block>
          </defn-outerBlock>
        </indent-block>
      </t-b>
      <t-b>
        This isn&apos;t as one-sided as it seems.  Rust has two back doors that could reintroduce 
        vulnerabilities:
        <indent-block>
          <ol class="tight">
            <li>
              <n-s><strong>unsafe blocks</strong></n-s>:<br />
              There are a few places in library code where the rules may need to be suspended. 
              The application of the compiler&apos;s rules may not be precise enough to allow 
              a library designer to build what is needed.
            </li>
            <li>
              Rust provides an <n-s><strong>interface to C code</strong></n-s> through libc.  This can be used to bind to
              existing code resources written in C or C++.  The Rust interface can only talk
              directly to C code for reasons of code layout, but that code can call into C++
              code.  That imports any vulnerabilities suffered by the foreign code.
            </li>
          </ol>
        </indent-block>
      </t-b>
      <t-b>
        Assuming we use only unsafe blocks, its easy to identify them in code and, if they are
        small, fairly easy to build safe wrappers around them.  Note however, that there is some
        controversy in the Rust community about promiscuous use of unsafe code by some open-source
        developers.
      </t-b>
      <t-b style="margin-top:0px;">
        There is a lot to like about Rust, but there are still strong use-cases for C++ and other languages.
        I expect to write a lot of Rust code, but I think C++ will continue to be my favorite language for
        most of the things I do.
      </t-b>
      <num-cont>
        <num-item1>1.0.2</num-item1><num-item4>Things to Read First</num-item4>
      </num-cont>
      <t-b>
        Important references for this chapter:
        <s-1em></s-1em>
        <table style="width:calc(100vw - 12rem);">
          <tr>
            <th class="darkItem">Link</th><th class="darkItem">Description</th>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://doc.rust-lang.org/std/index.html">Rust std</a></td>
            <td class="lightItem">
              Very clear documentation for the Rust std facilities, e.g., types, modules, macros, and
              keywords.
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://www.youtube.com/watch?v=DnT-LUQgc7s">Considering&nbsp;Rust&nbsp;-&nbsp;Feb&nbsp;2020&nbsp;-&nbsp;Jon&nbsp;Gjengset</a>
            </td>
            <td class="lightItem">
              Great what-is-it video, with code snippets and a lot of mind setting conversation by a very
              knowledgeable presenter.
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/">A half-hour to learn Rust</a>
            </td>
            <td class="lightItem">
              Code fragments with commentary that cover most of the Rust ideas.
            </td>
          </tr>
         <tr>
            <td class="lightItem"><a href="https://cheats.rs/">Rust&nbsp;Cheat&nbsp;Sheet</a></td>
            <td class="lightItem">
              Very broad reference to the Rust language, its libraries, and idioms.
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
            <td class="lightItem">
              Container diagrams
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://hacks.mozilla.org/2015/05/diving-into-rust-for-the-first-time/">Diving into Rust</a></td>
            <td class="lightItem">
              Contains an excellent video you <n-s>should</n-s> watch. Discusses <n-s>ownership</n-s>, with
              copies and moves, and thread models.
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="RustBasicDemos.html">Rust&nbsp;Basic&nbsp;Code&nbsp;Demos</a></td>
            <td class="lightItem">
              Small code examples that probe how Rust functions
            </td>
          </tr>
          <!--<tr>
            <td class="lightItem"><a href="https://wiki.mozilla.org/Matrix">Matrix open discussion platform</a></td>
            <td class="lightItem">
              
            </td>
          </tr>-->
        </table>
      </t-b>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Places to visit later</summary>
          <table style="width:calc(100vw - 12rem);">
          <tr>
            <td class="darkItem">Places to visit later</td>
            <td class="darkItem">
              Description
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://docs.rs/dtolnay/0.0.8/dtolnay/macro._02__reference_types.html">
                Shared&nbsp;reference&nbsp;&amp;T&nbsp;and&nbsp;exclusive&nbsp;reference&nbsp;&amp;mut&nbsp;T
              </a>
            </td>
            <td class="lightItem">
              More accurate description than immutable reference and mutable reference
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://deterministic.space/elegant-apis-in-rust.html">Elegant APIs in Rust</a></td>
            <td class="lightItem">
              Things to consider when writing Rust functions and packages
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://rustacean.net/">Rustaceans</a></td>
            <td class="lightItem">
              Open Source images
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://blog.rust-lang.org/">Rust Blog</a></td>
            <td class="lightItem">
              Open Source images
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://raphlinus.github.io/">Ralph Levien's blog</a></td>
            <td class="lightItem">
              Developer and Philosopher
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://raphlinus.github.io/rust/2020/01/18/soundness-pledge.html">Soundness Pledge</a></td>
            <td class="lightItem">
              Commentary about Rust programming goals and ideals - how not to subvert safety goals.
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://words.steveklabnik.com/a-sad-day-for-rust">Sad day for Rust</a></td>
            <td class="lightItem">
              Commentary about some issues with Rust community.
            </td>
          </tr>
          </table>
        </details>
      </t-b>
      <s-halfEm></s-halfEm>
    </t-b>
  <a id="structure"></a>
  <hr class="spread" />
    <num-cont>
      <num-item1>1.1</num-item1><num-item4>Code Structure:</num-item4>
    </num-cont>
    <div style="width:calc(100vw - 6rem);">
      <photosizer-block src="Pictures/VscDemo.JPG" width="700" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 1. Demo_Crate Package directory in VS Code
        </span>
      </photosizer-block>
    </div>
    <t-b>
      Rust code structure is based on <n-s>crates</n-s> and <n-s>packages</n-s>:
      <indent-block class="pad10">
        <ul class="tight">
          <li>
            <strong>crate:</strong>
            <div class="pad10">
              A crate is a directory containing a <n-s>cargo.toml</n-s> file and a <n-s>scr</n-s> folder
              containing a collection of source files. Crates are built with cargo:
              <indent-block class="pad10">
                <c-s>cargo init [--bin | --lib] [crate_name]</c-s><br />
                Default option is --bin and default crate_name is the current directory name.
              </indent-block>
              The <c-s>cargo build</c-s> command creates a Target subdirectory, if it doesn&apos;t
              already exist, and runs rustc to create an executable or library in <c-s>Target/debug</c-s>.
            </div>
          </li>
          <li>
            <strong>Package:</strong>
            <div class="pad10">
              A package is one or more linked crates that focus on a specific functionality.  Links
              are described in the Cargo.toml [dependencies] section.
            </div>
          </li>
        </ul>
      </indent-block>
    </t-b>
    <t-b>
      A <c-s>main.rs</c-s> may load a crate <c-s>helper.rs</c-s> from its own src directory with the 
      declaration <c-s>mod helper</c-s> and then use public functions from helper.
    </t-b>
    <t-b>
      The package for <c-s>main.rs</c-s> may also import a library <c-s>helper_lib</c-s> by including 
      the path to helper_lib in its
      <c-s>Cargo.toml</c-s> file&apos;s <c-s>[dependencies]</c-s> section.
      <indent-block class="pad10">
        <c-s>
          [dependencies]<br />
          helper_lib = { path = "../helper_lib"}
        </c-s>
      </indent-block>
    </t-b>
    <t-b>
      If the Cargo.toml file contains an identifier without a path in its [dependencies] section then
      Cargo looks for a library in <a href="https://crates.io">https://Crates.io</a>.
      <indent-block class="pad10">
        <c-s>
          [dependencies]<br />
          serde = "1.0.104"
        </c-s>
      </indent-block>
      The <a href="https://crates.io/crates/serde">serde crate</a> provides serialization and deserialization 
      of Rust types.
    </t-b>
    <t-b>
      The main.rs file may then simply use <c-s>helper_lib::some_function()</c-s> or declare
      <c-s>use helper_lib::{ some_function }</c-s> at the top and then use some_function() in its 
      subsequent code.
    </t-b>
    <t-b>
      <details>
        <summary class="labelStyle darkItem">Structure Demo</summary>
        <t-b>
          The <c-s>main</c-s> function in <c-s>demo/src/main.rs</c-s> uses code from 
          <c-s>demo/src/helper.rs</c-s> and <c-s>demo_lib/src/lib.rs</c-s>. This shows how to
          factor code into maintainable pieces.
        </t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>demo/src/main.rs</defn-head>
            <defn-code>
mod helper;  // declares helper module
             // since there is no code block
             // helper.rs must be in local src and 
             // provide code for this module

use helper::{ say };

use demo_lib::{ libsay };  // only needed to qualify use of libsay

fn main() {
    helper::say();
    say();
    demo_lib::libsay();
    libsay();
    print!("\n  Hello, world!\n\n");
}
            </defn-code>
            <defn-head class="defnBorderTop">demo/src/helper.rs</defn-head>
            <defn-code>
pub fn say() {
    print!("\n  hello from helper");
}

// Including a main function is not a good idea
// but doesn't seem to do any harm, even if pub.
#[allow(dead_code)]
fn main() {
    print!("\n  hello world");
}
            </defn-code>
            <defn-head class="defnBorderTop">demo/Cargo.toml</defn-head>
            <defn-code>
[package]
name = "demo"
version = "0.1.0"
authors = ["James W. Fawcett &lt;jfawcett@twcny.rr.com&gt;"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
demo_lib = { path = "../demo_lib" }
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>demo_lib/src/lib.rs</defn-head>
            <defn-code>
pub fn libsay() {
    print!("\n  hello from demo_lib");
}
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
cargo -q run

  hello from helper
  hello from helper
  hello from demo_lib
  hello from demo_lib
  Hello, world!

            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </details>
    </t-b>
    <t-b style="margin-bottom:0px;">
      There is more to Rust <n-s>Code Structure</n-s>, e.g.:
    </t-b>
    <indent-block class="pad10">
      <ul class="tight">
        <li>
          <strong>Structs and Traits:</strong>
          <indent-block class="pad10">
            Roughly equivalent to C++ classes and interfaces.
          </indent-block>
        </li>
        <li>
          <strong>Enums and Matching:</strong>
          <indent-block class="pad10">
            Enums have much more functionality in Rust than in other languages.
          </indent-block>
        </li>
        <li>
          <strong>Modules:</strong>
          <indent-block class="pad10">
            Modules provide a way to factor code into smaller simpler parts in the same crate.
          </indent-block>
        </li>
      </ul>
    </indent-block>
    <t-b style="margin-top:0px;">
      Some of this we will discuss in <num-item1>1.4</num-item1><num-item4>User-Defined Types</num-item4>.
      The rest in <n-s>Chapter&nbsp;2&nbsp;-&nbsp;Data</n-s> and <n-s>chapter&nbsp;3&nbsp;-&nbsp;Operations</n-s>.
    </t-b>
    <t-b>
      You might consider looking at some of the Rust std library source code for good examples of
      how to write Rust code.
      <s-halfEm></s-halfEm>
      <defn-block class="indent">
        <defn-head>Library Source Code: <nt-s>you can find that here (on Windows)</nt-s>:</defn-head>
        <defn-body>
          C:\Users\[UserName]\.rustup\toolchains\stable-i686-pc-windows-msvc\lib\rustlib\src\rust\src\libstd
        </defn-body>
      </defn-block>
    </t-b>
    <s-halfEm></s-halfEm>
    <a id="build"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.2</num-item1><num-item4>Build Process:</num-item4>
    </num-cont>
    <t-b>
      Most Rust code starts with a package structure built with the Rust tool <n-s>Cargo</n-s>.  
      <n-s>Cargo</n-s> is a package manager,
      that can build, run, and clean a Rust <n-s>Package</n-s> as well as create a new <n-s>Package</n-s>
      and download crates from <a href="https://Crates.io">https://crates.io</a>.
    </t-b>
    <t-b>
      Figure 1. shows a newly created <n-s>Package</n-s>.  The process is simple.
      <indent-block class="pad10">
        <ol class="tight">
          <li>
            Open a Developer&apos;s command prompt
          </li>
          <li>
            Create a directory temp with <n-s>mkdir temp</n-s>
          </li>
          <li>
            Issue the command: <n-s>cargo new demo_crate</n-s>. That creates everything shown in Figure 1.
            <indent-block class="pad10">
              The image is a screen shot of Visual Studo Code with opened folder demo_crate.
            </indent-block>
            The <n-s>Cargo</n-s> tool is in your path after you install Rust.
          </li>
          <li>
            <n-s>main.rs</n-s> is a demonstration &quot;Hello World&quot; program.
          </li>
          <li>
            Build with the command <n-s>cargo build</n-s> and run with <n-s>cargo run</n-s>.
          </li>
          <li>
            Clean the crate with <n-s>cargo clean</n-s>.
          </li>
        </ol>
      </indent-block>
      <t-b>
        Using <a href="https://code.visualstudio.com/download">Visual Studio Code</a> makes this a fairly
        painless process.  If, using the command window, you navigate to the temp directory and type
        <c-s>code .</c-s>, assuming you&apos;ve installed VS Code, it will open showing the temp
        directory and its files an subdirectories, e.g., <c-s>Cargo.toml</c-s> and <c-s>temp/src</c-s>.
      </t-b>
      <t-b>
        You can open a teminal in VS Code, e.g., <n-s>top menu > Terminal > New Terminal</n-s>.  I usually move the terminal
        to the right side.  You can do that with <n-s>top menu > View > Appearance > Move Panel Right</n-s>.
        You can make your favored panel position the default in <n-s>top menu > View > Pallet [searh: user settings] >
        [search panel]</n-s>.
      </t-b>
      <t-b>
        Now, you can edit the package files, save, then, in the <n-s>terminal</n-s> type <c-s>cargo check</c-s>
        to test the build without running, and <c-s>cargo run</c-s> to build and run.  You will see the output
        in the terminal.  When you are done you can <c-s>cargo clean</c-s> to remove the target items including
        the <c-s>target</c-s> folder itself.
      </t-b>
      <t-b>
        A typical Rust program consists of a binary crate (one with a main.rs) and perhaps several
        library crates that implement all the functionality used by main.
      </t-b>
      <t-b>
        You create a library crate with the command <n-s>cargo new [library name] --lib</n-s>.  That builds
        the same structure as shown here except that in the folder <n-s>src</n-s> you find a file
        <n-s>lib.rs</n-s> that has functions that implement the library&apos;s operations and a test fixture
        for running a sequence of tests on the library.
      </t-b>
      <t-b>
        The binary crate must specify each of the libraries it uses with dependencies in its <n-s>Cargo.toml</n-s>
        file. All of this is illustrated by the code in the two details dropdowns, below.
      </t-b>
    </t-b>
    <num-cont>
      <num-item1>1.2.1</num-item1><num-item4>Display Library Example:</num-item4>
    </num-cont>
    <t-b>
      This <a href="RustBasicDemos.html">display library</a> provides a set of display functions to help generate demonstration and
      debug io for Rust programs.  It contains functions:
      <indent-block class="pad10">
        <ol class="tight">
          <li>
            <n-s>show_type&lt;T&gt;(_value: &amp;T)</n-s> - 
            Displays type and size of input
          </li>
          <li>
            <n-s>log&lt;T&gt;(value: &amp;T)</n-s> - 
            Displays type and size of input, followed by its value.
          </li>
          <li>
            <n-s>main_title(msg: String)</n-s> and <n-s>sub_title(msg: String</n-s> - 
            Displays msg followed by an underline.
          </li>
          <li>
            <n-s>putline()</n-s> - Emits a newline.
          </li>
          <li>
            <n-s>putlinen(n: usize)</n-s> - Emits n newlines.
          </li>
          <li>
            ...
          </li>
        </ol>
      </indent-block>
      The code in <n-s>display_test</n-s> shows how it imports the library, <n-s>display</n-s>.
      Look at the dependencies in <n-s>display_test::Cargo.toml</n-s> and at the <c-s>use display</c-s>
      declaration near the top of the code in <n-s>display_test::main.rs</n-s>
    </t-b>
    <indent-blocks>
    <details>
      <summary class="labelStyle, darkItem">display_test</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>display_test::Cargo.toml</defn-head>
            <defn-code>
[package]
name = "test_display"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

[dependencies]
display = { path = "../display" }
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
C:\github\JimFawcett\RustBasicDemos\display_test>
cargo -q run

  test types
 ============
  TypeId: alloc::string::String, size: 12
  value:  "a string"
  TypeId: alloc::string::String, size: 12
  value: "a string"
  TypeId: i8, size: 1
  value:  100
  TypeId: alloc::vec::Vec<i32>, size: 12
  value:  [-1, 0, 1]
  TypeId: test_display::main::Test, size: 1
  value:  Test1
  TypeId: test_display::main::Test, size: 1
  value:  Test2
  TypeId: test_display::Point, size: 24
  value:  Point { x: 1.0, y: 1.5, z: 2.0 }

  That's all folks!
 -------------------

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>display_test::main.rs</defn-head>
            <defn-code>
/////////////////////////////////////////////////////////////
// display_test::main.rs - test display library            //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 Feb 2020  //
/////////////////////////////////////////////////////////////
/*
  Usually you test a library using the library's built in
  test functions.  But those cannot write to the console
  because they are a compiled part of the library which
  has no console.

  So I've constructed this separate main that uses the
  library just like any other application.
*/

#[allow(unused_imports)]
use display::{ 
  putline, main_title, sub_title, 
  log, show_type, show_value, putlinen 
};

#[derive(Debug)]
struct Point {
    x: f64,
    y: f64,
    z: f64,
}
/* Need more tests for added functions */

fn main() {
    main_title("test types");
    let mut str = String::new();
    str.push_str("a string");
    log(&amp;str);
    show_type(&amp;str);
    show_value(&amp;str);
    let an_i8: i8 = 100;
    log(&amp;an_i8);
    let mut vi : Vec&lt;i32&gt; = Vec::new();
    vi.push(-1);
    vi.push(0);
    vi.push(1);
    log(&amp;vi);
    #[derive(Debug)]
    enum Test { Test1, Test2, };
    log(&amp;Test::Test1);
    log(&amp;Test::Test2);
    let point = Point { x:1.0, y:1.5, z:2.0 };
    log(&amp;point);
    putline();
    sub_title("That's all folks!");
    putlinen(2);
}
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
  </indent-blocks>
  <t-b>
    The code in <n-s>display</n-s> shows the structure of a lib crate. Note how the library
    imports Rust std library facilities with a series of use std::xxxx statements. These
    do essentially the same thing that #include &lt;xxxx&gt; declarations do in C++.
  </t-b>
  <indent-blocks>
    <details>
      <summary class="labelStyle, darkItem">display library</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>display::Cargo.toml</defn-head>
            <defn-code>
[package]
name = "display"
version = "0.1.0"
authors = ["James W. Fawcett"]
edition = "2018"

[dependencies]

            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
C:\github\JimFawcett\RustBasicDemos\display>
cargo test
Compiling display v0.1.0
(C:\github\JimFawcett\RustBasicDemos\display)
Finished test [unoptimized + debuginfo]
target(s) in 0.63s
Running target\debug\deps
\display-7c39a3f9b415f17e.exe

running 1 test
test tests::test_types ... ok

test result: ok.
1 passed; 0 failed; 0 ignored; 0 measured;
0 filtered out

Doc-tests display

running 0 tests

test result: ok.
0 passed; 0 failed; 0 ignored; 0 measured;
0 filtered out

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>display::lib.rs</defn-head>
            <defn-code>
/////////////////////////////////////////////////////////////
// display::lib.rs - Demonstrate display types             //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 Feb 2020  //
/////////////////////////////////////////////////////////////
/*
   log and do_work are derived from:
   https://doc.rust-lang.org/beta/std/any/index.html

*/
use std::fmt::Debug;
use std::any::Any;
use std::any::type_name;
use std::mem::size_of;

/*-----------------------------------------------------------
   Display message and value on console
*/
pub fn show&lt;T: Debug&gt;(msg:&amp;str, t:&amp;T) {
    print!("\n  {}{:?}", msg, t);
}
/*-----------------------------------------------------------
   show value on console
   - expects T to implement Debug
   - see #[define(Debug)] attributes, above 
*/
pub fn show_value&lt;T: Debug&gt;(value: &amp;T) {
    print!("\n  value: {:?}", value);
}
/*----------------------------------------------------------- 
   show type name on console
   - expects T to implement Debug
   - see #[define(Debug)] attributes, above 
*/
pub fn show_type&lt;T: Debug&gt;(_value: &amp;T) {
    let name = type_name::&lt;T&gt;();
    print!(
      "\n  TypeId: {}, size: {}", name, size_of::&lt;T&gt;()
    );
}
  /*-----------------------------------------------------------
   show type name and value on console
   - expects T to implement Debug
   - see #[define(Debug)] attributes, above 
*/
pub fn log&lt;T: Debug&gt;(value: &amp;T) {
    let name = type_name::&lt;T&gt;();
    print!(
      "\n  TypeId: {}, size: {}", name, size_of::&lt;T&gt;()
    );
    print!("\n  value:  {:?}", value);
  }
/*-------------------------------------------------------------
   Display underlined main title on console
*/
pub fn main_title(msg: &amp;str) {
    print!("\n  {}", msg);
    let s = std::iter::repeat('=')
              .take(msg.len() + 2)
              .collect::&lt;String&gt;();
    print!("\n {}", s);
}
/*-------------------------------------------------------------
   Display underlined sub title on console
*/
pub fn sub_title(msg: &amp;str) {
    print!("\n  {}", msg);
    let s = std::iter::repeat('-')
              .take(msg.len() + 2)
              .collect::&lt;String&gt;();
    print!("\n {}", s);
}
/*-----------------------------------------------------------
   show line with len hyphens
*/
pub fn separator(len:u8) {
    let mut s = String::new();
    for _i in 1..len+2 { s.push('-');}
    print!("\n {}",s);
}

/*-- push a single newline to console --*/

pub fn putline() {
    print!("\n");
}
/*-- pust n newlines to console --*/

pub fn putlinen(n: usize) {
    let s = std::iter::repeat('\n')
              .take(n)
              .collect::&lt;String&gt;();
    print!("{}", s);
}
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
    </indent-blocks>
    <t-b>
      Configuring packages and building them are traditionally done with <n-s>Cargo</n-s>.  Cargo is a 
      package manager, build manager (in some ways like a make file), checker, runner, and cleaner.
    </t-b>
    <t-b>
      One of the first things a developer new to Rust needs to learn is the naming conventions that 
      Cargo depends upon to do its business. It looks for directories named <n-s>src</n-s> to find
      code to build, its dependencies, described in <n-s>Cargo.toml</n-s>, have to be library packages
      that come from a local path or from <a href="https://crates.io">crates.io</a>, and it expects
      that modules are loaded from the local <n-s>src</n-s> directory.
    </t-b>
    <a id="ownership"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.3</num-item1><num-item4>Ownership:</num-item4>
    </num-cont>
    <t-b>
      Ownership is one of the most important features of the Rust programming language.  Rust fully
      supports value types, and manages to do that without help from the application designer.  There
      are no copy and move constructors, assignment operators, and destructors to write.
    </t-b>
    <t-b>
      Every name is bound to a value on the stack.  The value may have additional structure on the 
      heap which it manages without prompting by the designer. The String type and std::collections
      types are examples.  When the value goes out of scope, 
      it drops any heap resources it may own.
    </t-b>
    <t-b>
      When a new name binds to a declared value:
      <indent-block class="pad5">
        <c-s>let x = y;</c-s>
      </indent-block>
      That results in a copy if y&apos;s value is copyable, e.g., blittable. If not, then y&apos;s
      value is moved to x, passing ownership.  In that case, y is no longer usable.  If code attempts
      to use a moved instance that results in a <n-s>compile-time</n-s> error.
    </t-b>
    <t-b>
      Here&apos;s an example:
      <indent-block class="pad5">
        <defn-outerBlock>
          <defn-block>
            <defn-head>Example of copy and move:</defn-head>
            <defn-code>
let i = 3;        // i is blittable
let mut j = i;    // j gets copy of i
print!("\n  i = {}, j = {}", i, j);
// i is still usable

let s = String::from("String named s");  // s is not blitable
let mut t = s;                           // s is moved to t
t.push_str(" with more stuff");
print!("\n  t = {}", t);
// print!("\n  s = {}", s);              // can't use s, been moved

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output:</defn-head>
            <defn-code>


i = 3, j = 3





t = String named s with more stuff
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </indent-block>    </t-b>
    <t-b>
      Rust has references, which bind to, and borrow but don't own their &quot;borrowed&quot; values:
      <indent-block class="pad5">
        <c-s>let r = &amp;x;</c-s>
      </indent-block>
      A Rust program many have any number of non-mutating references to a given value.  However, it
      may have at most one mutating reference, and in that case, no other references.
      <indent-block class="pad5">
        <c-s>let r = &amp;mut x;</c-s>
      </indent-block>
      Since references don&apos;t own the values to which they bind, nothing happens when they go out of
      scope.  Drops happen only for owned values.
    </t-b>
    <t-b>
      Example of references, using the code above:
      <indent-block class="pad5">
        <defn-outerBlock>
          <defn-block>
            <defn-head>Example reference:</defn-head>
            <defn-code>
let i = 3;        // i32 so copyable
let mut j = i;    // copy of i
let r = &mut j;   // r borrows j, e.g., reference, no copy
*r += 2;          // j is mutated
print!("\n  i = {}, j = {}", i, j);
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output:</defn-head>
            <defn-code>


i = 3, j = 5
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </indent-block>
    </t-b>
    <t-b>
      The next section focuses on user-defined structuring of code and data.
    </t-b>
    <a id="types"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.4</num-item1><num-item4>Rust Types and User-Defined Types and Traits:</num-item4>
    </num-cont>
    <t-b>
      Rust&apos;s <n-s><a href="https://doc.rust-lang.org/beta/std/index.html#primitives">type system</a></n-s> has:
      <indent-block class="pad5">
        <ul class="tight">
          <li>
            primitives, i32, f64, ... 
          </li>
          <li>
            array [i32, 4]
          </li>
          <li>
            tuple (i32, f64, String)
          </li>
          <li>
            struct { i:i32, f:f64, s:String }
          </li>
          <li>
            enum { BS(String), MS(String), PhD(String) }
          </li>
          <li>
            std collections:<br />
            Vec, VecDeque, LinkedList<br />
            HashMap, HashSet, BTreeMap, BTreeSet<br />
            BinaryHeap
          </li>
        </ul>
      </indent-block>
    </t-b>
    <t-b>
      The details dropdown, below, shows how to write type specifications for each of the non-collection
      types. Usually you don&apos;t need to supply the specs, but instead may rely on the compiler&apos;s
      strong type inference engine.
    </t-b>
    <t-b>
      <t-b>
        <details>
          <summary class="labelStyle darkItem">Type Declarations:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Declaring Code:</defn-head>
              <defn-code>
/*-- fully specified --*/
let i:i32 = 5;
let f:f64 = 3.4;
let a:[f32; 5] = [1.0, 1.5, 2.0, 1.5, 1.0];
let t:(i32, f64, String) = (1, 2.0, "three".to_string());
#[derive(Debug)]
struct S{i:i32, s:&'static str, };
let s:S = S{i:15, s:"a literal string" };
#[derive(Debug)]
enum E {BS(String), MS(String), PhD(String),};
let e:E = E::MS("Computer Engineering".to_string());

print!("\n  -- fully specified types --\n");
print!("\n  i = {:?}", i);
print!("\n  f = {:?}", f);
print!("\n  a = {:?}", a);
print!("\n  t = {:?}", t);
print!("\n  s = {:?}", s);
print!("\n  e = {:?}", e);

/*-- using type deduction --*/
let i = 5;
let f = 3.4;
let a = [1.0, 1.5, 2.0, 1.5, 1.0];
let t = (1, 2.0, "three".to_string());
let s = S{i:15, s:"a literal string" };
let e = E::MS("Computer Engineering".to_string());

print!("\n\n  -- using type deduction --\n");
print!("\n  i = {:?}", i);
print!("\n  f = {:?}", f);
print!("\n  a = {:?}", a);
print!("\n  t = {:?}", t);
print!("\n  s = {:?}", s);
print!("\n  e = {:?}", e);
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
-- fully specified types --

i = 5
f = 3.4
a = [1.0, 1.5, 2.0, 1.5, 1.0]
t = (1, 2.0, "three")
s = S { i: 15, s: "a literal string" }
e = MS("Computer Engineering")

-- using type deduction --

i = 5
f = 3.4
a = [1.0, 1.5, 2.0, 1.5, 1.0]
t = (1, 2.0, "three")
s = S { i: 15, s: "a literal string" }
e = MS("Computer Engineering")

              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </t-b>
    </t-b>
    <t-b>
      Occasionally the Rust compiler needs help defining life time of references.  It wants to
      ensure that a reference does not outlive the value to which it is bound. You can see an example
      of that help for the S struct, in the dropdown, where we tell the compiler that a literal string is 
      static, e.g., it has the lifetime of the program.  The syntax is: <c-s>s:&'static str</c-s> where 
      the <c-s>&apos;static</c-s> says that the literal string has the same lifetime as the program.
      <a id="user-defined"></a>
    </t-b>
    <num-cont>
      <num-item1>1.4.1</num-item1><num-item4>User-Defined Types:</num-item4>
    </num-cont>
    <t-b>
      <t-b>
        Rust does not have classes or inheritance.  It does, however, have structs and traits.  A trait is
        similar to an interface or abstract class.  Structs have public and private members and can implement
        traits as well as other functions.
      </t-b>
      <t-b>
        Here&apos;s an example, used in the details dropdown,
        below:
      </t-b>
      <t-b>
        <defn-block>
          <defn-head>Salutation Trait</defn-head>
          <defn-code>
trait Speaker {
    fn salutation(&self) -> String;
}
          </defn-code>
        </defn-block>
      </t-b>
      <t-b>
        The trait declares a salutation function that structs implement, like this:
      </t-b>
      <t-b>
        <defn-block>
          <defn-head>
            Implementing Saluation Trait
          </defn-head>
          <defn-code>
pub struct Presenter;
impl Speaker for Presenter {
    fn salutation(&self) -> String {
      "Hello, today we will discuss ...".to_string()
    }
} 
          </defn-code>
        </defn-block>
      </t-b>
    </t-b>
    <t->
      The code in the User-Defined Type dropdown illustrates how this can be used to implement
      polymorphic operations, e.g., function dispatching based on the type of value  bound to a reference,
      not on the type of the reference.
    </t->
    <t-b>
      That works because each trait has a virtual function pointer table used for function dispatching.
    </t-b>
    <t-b>
      <t-b>
        <details>
          <summary class="labelStyle darkItem">Example User-Defined Type:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Declaring Code:</defn-head>
              <defn-code>
///////////////////////////////////////////////////////////
// user-defined traits act like interfaces

trait Speaker {
    fn salutation(&self) -> String;
}

///////////////////////////////////////////////////////////
// The following structs act like classes that implement
// a Speaker interface

#[derive(Debug,Copy,Clone)]
pub struct Presenter;
impl Speaker for Presenter {
    fn salutation(&self) -> String {
      "Hello, today we will discuss ...".to_string()
    }
} 

#[derive(Debug)]
pub struct Friend {
    pub name : String,
}
impl Speaker for Friend {
    fn salutation(&self) -> String {
      let mut s = String::from("Hi good buddy, its me, ");
      let nm = self.name.as_str();
      s.push_str(nm);
      return s;
    }
}
impl Friend {
    #[allow(dead_code)]
    pub fn new(name : String) -> Self {
        Self {
            name,
        }  // note: no semicolon so Self is returned
    }
}
#[derive(Debug,Copy,Clone)]
pub struct TeamLead;
impl Speaker for TeamLead {
    fn salutation(&self) -> String {
      "Hi, I have a task for you ...".to_string()
    }
} 

              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
#[allow(dead_code)]
pub fn run() {
    
    print!("\n\n  {}","-- demo polymorphic struct instances --\n");
    let presenter : Presenter = Presenter;
    let joe : Friend = Friend::new("Joe".to_string());
    let sue : Friend = Friend::new("Sue".to_string());
    let team_lead : TeamLead = TeamLead;

    let mut v :Vec<&dyn Speaker> = Vec::new();
    v.push(&presenter);
    v.push(&joe);
    v.push(&sue);
    v.push(&team_lead);

    for speaker in v.iter() {
        print!("\n  {:?}",speaker.salutation());
    }
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
-- demo polymorphic struct instances --

"Hello, today we will discuss ..."
"Hi good buddy, its me, Joe"
"Hi good buddy, its me, Sue"
"Hi, I have a task for you ..."
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </t-b>
    </t-b>
    <t-b>
      The models we&apos;ve covered here: Code Structure, Build Process, Ownership, and User-Defined
      Types and Traits are what make Rust unique and interesting.  We will see more details for each
      of these in the coming chapters.
    </t-b>

    <a id="generics"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.5</num-item1><num-item4>Generics:</num-item4>
    </num-cont>
    <t-b>
      Rust supports generics for functions and structs:
    </t-b>
    <t-b>
      <div>
        <defn-outerBlock>
          <defn-block>
            <defn-head>Generic Function:</defn-head>
            <defn-code>
fn demo_ref&lt;T&gt;(t:&amp;T) where T:Debug  {
  show_type(t);
  show_value(t);
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Generic Struct:</defn-head>
            <defn-code>
#[derive(Debug)]
struct Point&lt;T&gt; { x:T, y:T, z:T, }

            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </div>
    </t-b>
    <t-b>
      Rust generics are similar to C# and Java Generics.  They don&apos;t support specialization to
      broaded the number of types accepted, like C++.  They do define constraints to narrow the number
      of types that compile, like C# and Java. In the function example, above, we&apos;ve used a constraint
      to allow only those types with a Debug trait to compile.
    </t-b>
    <t-b>
      In the details dropdown, below, we&apos;ve added a another example for both functions and structs, and
      shown using code and output as well.
    </t-b>
    <t-b>
      <indent-blocks>
        <details>
          <summary class="labelStyle darkItem">Generics Examples:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Generic Functions</defn-head>
              <defn-code>
/*-----------------------------------------
No-copy arguments will be moved
*/
fn demo&lt;T:Debug&gt;(t:T) {
  show_type(&amp;t);
  show_value(&amp;t);
}

/*-----------------------------------------
refs so arguments will not be moved
*/
fn demo_ref&lt;T&gt;(t:&amp;T) where T:Debug  {
  show_type(t);
  show_value(t);
}

</defn-code>
<defn-head class="defnBorderTop">Using Code:</defn-head>
<defn-code>
let mut s = String::from("this is a test");

sub_title("demo_ref");
demo_ref(&amp;s);
let pi = 3.1415927;
demo_ref(&amp;pi);
s.push('Z');
putline();

sub_title("demo");
demo(s);
demo(pi);
// statement below won't compile - s moved
// s.push('Z');
putline();

</defn-code>
<defn-head class="defnBorderTop">Output:</defn-head>
<defn-code>
 demo_ref
----------
TypeId: alloc::string::String, size: 12
value: "this is a test"
TypeId: f64, size: 8
value: 3.1415927

demo
------
TypeId: alloc::string::String, size: 12
value: "this is a testZ"
TypeId: f64, size: 8
value: 3.1415927
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Generic Structs</defn-head>
              <defn-code>
#[derive(Debug)]
struct Point&lt;T&gt; { x:T, y:T, z:T, }

// Copy trait works because blittable, provided
// that T is blittable
#[derive(Debug, Copy, Clone)]
struct BetterPoint&lt;T&gt; { x:T, y:T, z:T, }

              </defn-code>
              <defn-head class="defnBorderTop">Using Code:</defn-head>
              <defn-code>
sub_title("demo_ref and demo with struct");
let mut pt = Point { x:1.0, y:-1.5, z:2.3 };
demo_ref(&amp;pt);
pt.x = 3.2;
demo(pt);
// statement below won't compile - pt moved for demo
// pt.x = 3.2;
putline();

sub_title("demo_ref and demo with copy-able struct");
let mut bpt = BetterPoint { x:1.0, y:-1.5, z:2.3 };
demo_ref(&amp;bpt);
bpt.x = 3.2;
demo(bpt);
// statement ok - pt copied for demo
bpt.x = 3.2;
putline();

sub_title("demo_ref and demo with copy-able struct");
let mut bpt = BetterPoint { x:"one", y:"two", z:"three" };
demo_ref(&amp;bpt);
bpt.x = "1";
demo(bpt);
// statement ok - pt copied for demo
bpt.x = "one";
putline();

sub_title("demo_ref and demo with non copy-able struct");
let mut bpt = BetterPoint {
  x:"one".to_string(),
  y:"two".to_string(),
  z:"three".to_string()
};
demo_ref(&amp;bpt);
bpt.x = "four".to_string();
demo(bpt);
// won't compile - bpt not blittable so it was moved
// bpt.x = "one".to_string();

putlinen(2);
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
 demo_ref and demo with struct
-------------------------------
TypeId: generics_probes::Point<f64>
, size: 24
value: Point { x: 1.0, y: -1.5, z: 2.3 }
TypeId: generics_probes::Point<f64>
, size: 24
value: Point { x: 3.2, y: -1.5, z: 2.3 }

 demo_ref and demo with copy-able struct
-----------------------------------------
TypeId: generics_probes::BetterPoint<f64>
, size: 24
value: BetterPoint { x: 1.0, y: -1.5, z: 2.3 }
TypeId: generics_probes::BetterPoint<f64>
, size: 24
value: BetterPoint { x: 3.2, y: -1.5, z: 2.3 }

 demo_ref and demo with copy-able struct
-----------------------------------------
TypeId: generics_probes::BetterPoint<&str>
, size: 24
value: BetterPoint { x: "one", y: "two", z: "three" }
TypeId: generics_probes::BetterPoint<&str>
, size: 24
value: BetterPoint { x: "1", y: "two", z: "three" }

 demo_ref and demo with non copy-able struct
---------------------------------------------
TypeId: generics_probes::BetterPoint<alloc::string::String>
, size: 36
value: BetterPoint { x: "one", y: "two", z: "three" }
TypeId: generics_probes::BetterPoint<alloc::string::String>
  , size: 36
value: BetterPoint { x: "four", y: "two", z: "three" }

              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </indent-blocks>
    </t-b>
    <t-b>
      This chapter has focused on the main features and models of Rust.  You will find more details in
      succeeding chapters.
    </t-b>
    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.6</num-item1><num-item4>References:</num-item4>
    </num-cont>
    <table style="width:calc(100vw - 12rem);">
      <tr>
        <th class="darkItem">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/">A half-hour to learn Rust</a>
        </td>
        <td class="lightItem">
          Code fragments with commentary that cover most of the Rust ideas.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html">A Gentle Introduction To Rust</a>
        </td>
        <td class="lightItem">
          First thing to read.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust by Example</a>
        </td>
        <td class="lightItem">
          Rust docs - walkthrough of syntax
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://cheats.rs/">Rust cheat sheet</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
        <td class="lightItem">
          Container diagrams
        </td>
        </tr>
        <tr>
          <td class="lightItem">
            <a href="https://docs.rs/dtolnay/0.0.8/dtolnay/macro._02__reference_types.html">
              Shared&nbsp;reference&nbsp;&amp;T&nbsp;and&nbsp;exclusive&nbsp;reference&nbsp;&amp;mut&nbsp;T
            </a>
          </td>
          <td class="lightItem">
            More accurate description than immutable reference and mutable reference
          </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.twelve21.io/getting-started-with-rust-on-windows-and-visual-studio-code/">
            Getting Started with Rust on Windows and Visual Studio Code
          </a>
        </td>
        <td class="lightItem">
          Install Rust, Verify, Configure Visual Studio Code, Create Hello World, Create Build Task, 
          Configuring Unit Tests, Configure Debugging, 
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.rust-lang.org/">rust-lang.org home page</a>
        </td>
        <td class="lightItem">
          Links to download and documentation
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.youtube.com/watch?v=zF34dRivLOw">(video) Rust - Crash Course | Rustlang</a>
        </td>
        <td class="lightItem">
          Code demo using basic types.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.tutorialspoint.com/rust/index.htm">Tutorial - tutorialspoint.com</a>
        </td>
        <td class="lightItem">
          Tutorials for most of the Rust parts with code examples.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://deterministic.space/">Blog - Pascal's Scribbles</a>
        </td>
        <td class="lightItem">
          Pascal Hertleif - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://deterministic.space/">Blog - Deterministic Space</a>
        </td>
        <td class="lightItem">
          Michael Gattozzi - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
        <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
      </tr>
      <!--<tr>
        <td class="lightItem">
          <a href="https://www.javatpoint.com/rust-tutorial">Tutorial - javatpoint.com</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>-->
    </table>
  </bb-55>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>