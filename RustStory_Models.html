<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Prologue.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Rust Models</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
    #github .fw_norm {
      font-weight:normal;
    }
    #github th.darkItem, td.lightItem {
      padding:5px 15px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="RustStory_Data.html">N</a>
  <a id="Prev" href="RustStory_Prologue.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 1. - Rust Models</h1>
      <h3 id="subtitle">Code Structure, Builds, Ownership, User-Defined Types and Traits, Generics</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:#fefefa;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:#fefefa;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:#fefefa;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_Libraries.html">Libraries</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">Top</a>, <a href="#prologue">Prolg</a>, <a href="#structure">CodeStr</a>, 
       <a href="#build">Bld</a>, <a href="#execution">Exec</a>, 
       <a href="#ownership">Ownrshp</a>, <a href="#types">Types</a>, <a href="#objmodel">ObjMod</a>
       <a href="#userdeftypes">UserDefTyps</a>, <a href="#generics">Genrcs</a>, 
       <a href="#epilogue">Epilg</a>, <a href="#exercises">Exers</a>, <a href="#refs">Refs</a>
     </rt-b>
   </toc-b>

  <bb-55 class="indent">
    <a id="prologue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.0</num-item1><num-item4>Prologue:</num-item4>
    </num-cont>
    <t-b>
      <details>
        <summary class="labelStyle lightItem">Hello World in Rust</summary>
        <t-b>
          Uses only <n-s>Cargo</n-s>, after installing Rust, and the x64 Native Tools Command Prompt for Visual Studio 2019.
        </t-b>
      <defn-outerBlock>
        <defn-block>
          <defn-head>Create hello_demo Package with Cargo</defn-head>
          <defn-code>
c:\su\temp>
cargo init hello_demo
     Created binary (application) package

c:\su\temp>
cd hello_demo

c:\su\temp\hello_demo>
dir
 Volume in drive C is OS
 Volume Serial Number is 765A-DAD5

 Directory of c:\su\temp\hello_demo

02/23/2020  10:15 AM    &lt;DIR&gt;          .
02/23/2020  10:15 AM    &lt;DIR&gt;          ..
02/23/2020  10:15 AM                 8 .gitignore
02/23/2020  10:15 AM               234 Cargo.toml
02/23/2020  10:13 AM    &lt;DIR&gt;          src
               2 File(s)            242 bytes
               3 Dir(s)  644,435,443,712 bytes free

c:\su\temp\hello_demo>
dir .\src
 Volume in drive C is OS
 Volume Serial Number is 765A-DAD5

 Directory of c:\su\temp\hello_demo\src

02/23/2020  10:13 AM    &lt;DIR&gt;          .
02/23/2020  10:13 AM    &lt;DIR&gt;          ..
02/23/2020  10:13 AM                45 main.rs
               1 File(s)             45 bytes
               2 Dir(s)  644,435,443,712 bytes free
          </defn-code>
        </defn-block>
        <defn-block>
          <defn-head>main.rs</defn-head>
          <defn-code>
c:\su\temp\hello_demo>
cd src

c:\su\temp\hello_demo\src>
type main.rs
fn main() {
    println!("Hello, world!");
}
          </defn-code>
          <defn-head class="defnBorderTop">run main.rs</defn-head>
          <defn-code>
c:\su\temp\hello_demo\src>
cd..

c:\su\temp\hello_demo>
cargo run
   Compiling hello_demo v0.1.0 (C:\su\temp\hello_demo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.84s
     Running `target\debug\hello_demo.exe`
Hello, world!
          </defn-code>
          <defn-head class="defnBorderTop">Cargo.toml</defn-head>
          <defn-code>
c:\su\temp\hello_demo>
type cargo.toml
[package]
name = "hello_demo"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

# See more keys and their definitions at // remainder elided

[dependencies]

          </defn-code>
        </defn-block>
      </defn-outerBlock>
      </details>
    </t-b>
    <t-b>
      Rust is an interesting language, similar to C++, but with some unique differences.  To  understand those, let&apos;s 
      start with a couple of definitions:
    <t-b>
      <div class="pad5">
        <defn-block>
          <defn-head>Type Safety</defn-head>
          <defn-body>
            <ul class="tight">
              <li>
                A program is well defined if no execution can exhibit undefined behavior.
              </li>
              <li>
                A language is type safe if its type system ensures that every program is well defined.
              </li>
            </ul>
            <s-halfEm></s-halfEm>
          </defn-body>
        </defn-block>
        <s-halfEm></s-halfEm>
      </div>
      A non-type safe language may introduce undefined behavior with:
      <indent-block class="pad5">
        <ul class="tight">
          <li>mutation of data with active aliases</li>
          <li>memory access after buffer overflow</li>
          <li>integer overflow</li>
          <li>use after free</li>
          <li>double free</li>
          <li>race conditions</li>
        </ul>
      </indent-block>
    </t-b>
    <t-b>
      Rust&apos;s type system was designed to prevent these behaviors.
    </t-b>
    <t-b>
      <t-b>
        <defn-block>
          <defn-head>Rust Principles:</defn-head>
          <defn-body>
            <ol class="tight">
              <li>
                <div>
                  Rust provides memory safety by:
                  <indent-block class="pad5">
                    <n-s>Compiler</n-s> checked Ownership + Borrowing rules,<br />
                    <n-s>compiler</n-s> checked indexing where possible, else run-time panic (no reads/writes of unowned memory)
                  </indent-block>
                  These prevent simultaneous aliasing + mutation and avoids accessing out-of-bounds indexed memory.
                </div>
              </li>
              <li>
                In debug builds signed and unsigned intergers are checked for overflow.
              </li>
              <li>
                All access to heap resources occurs through Box&lt;T&gt;, a smart pointer
                that releases resources when it goes out of scope.
              </li>
              <li>
                Rust provides data race safety using two concurrency models:
                <indent-block class="pad5">
                  Model #1 - Thread communication through messaging passing that transfers ownership of messages
                  <indent-block>
                    Prevents simultaneous aliasing and mutation
                  </indent-block>
                  Model #2 - Guarded locks bound to mutated data
                  <indent-block>
                    prevent mutation without ordering
                  </indent-block>
                </indent-block>
                These models are <n-s>compiler</n-s> checked.
              </li>
            </ol>
          </defn-body>
        </defn-block>
      </t-b>
      <indent-block class="pad10">
        <ol class="tights">
          <li>
            Rust&apos;s <n-s>types are, by default, immutable</n-s>. You have to opt-in to mutability with the
            mut keyword:
            <indent-block class="pad5">
              <c-s>let s = mut String::from("a string");</c-s>
            </indent-block>
          </li>
          <li>
            <n-s>Ownership</n-s>:
            <div class="pad5">
              In Rust there is only one owner of a value:
            </div>
            <ul class="tight" style="list-style-type:lower-alpha;">
              <li>
                If a type is blittable<sup>1</sup>, e.g., primitives, arrays, ... it is copyable:
                <indent-block class="pad5">
                  <c-s>let a1 = [1, 2, 3];<br />let a2 = a1;&nbsp;&nbsp;&nbsp;// a copy</c-s>
                </indent-block>
              </li>
              <li>
                If not blittable, e.g., strings, a collection type, ... then it gets moved (transfers ownership):
                <indent-block class="pad5">
                  <c-s>let s1 = "a string".to_string();<br />
                  let s2 = s1;&nbsp;&nbsp;&nbsp;// a move<br />
                  let s3 = s2.clone();&nbsp;&nbsp;&nbsp;// an explicit copy so no move</c-s>
                </indent-block>
                In this example, s1 will not be usable after the move. Attempts to use a moved item are
                <n-s>compile</n-s> errors! S3 owns a <n-s>copy</n-s> of s2&apos;s resource, so s2 is usable
                after the clone operation.
              </li>
              <li>
                References support <n-s>borrowing</n-s> of ownership:
                <indent-block class="pad5">
                  <c-s>let mut s = String::from("another string);&nbsp;&nbsp;&nbsp;// s owns string</c-s><br />
                  <c-s>let rs = &mut s;&nbsp;&nbsp;&nbsp;// rs borrows ownership from s</c-s>
                </indent-block>
              </li>
              <li>
                References must satisfy <n-s>compiler-checked</n-s> rules:
                <div>
                  <ul class="tight">
                    <li>
                      Only one mutable reference is allowed
                    </li>
                    <li>
                      Any number of un-mutable references are allowed
                    </li>
                    <li>
                      Original owner must not mutate while references are active.
                      References become inactive when they go out of scope or are dropped<sup>2</sup>.
                    </li>
                  </ul>
                </div>
              </li>
            </ul>
            <hr class="spreadup" />
            <div class="footnote">
              <ol class="tight">
                <li>
                  Data that can be copied with a block transfer, e.g., using memcpy.
                </li>
                <li>
                  let x = String::from("will be dropped"); drop(x);
                </li>
              </ol>
            </div>
          </li>
          <li>
            All <n-s>resource management is scope based</n-s>.  When an item, holding resources, goes out of scope,
            its <n-s>drop</n-s> function (similar to a C++ destructor) is called.
          </li>
          <li>
            All <n-s>heap allocations are referenced with a smart <c-s>Box&lt;T&gt;</c-s> pointer</n-s> that drops its
            reference when it goes out of scope, similar to the C++ <c-s>std::unique_ptr&lt;T&gt;</c-s>.
          </li>
          <li>
            Rust has a <n-s>module system</n-s>, useful for refactoring local code, and packages that need not
            be local.
          </li>
          <li>
            It has a relatively complete <a href="https://doc.rust-lang.org/beta/std/"><n-s>std library</n-s></a>
            with collections, threads, tcp socket wrappers, file system library, ...
          </li>
          <li>
            The good news is, in Rust, it is relatively simple to <n-s>interface to C code</n-s>. The bad news is
            it is relatively simple to interface to C code.
          </li>
          <li>
            Rust has a very useful tool, <n-s>Cargo</n-s>, which is a package manager, builder, and
            verifier, and will execute code, all with a simple command syntax.
          </li>
          <li>
            The Rust <n-s>compiler analyzes code deeply</n-s> and refuses to build code that has memory and
            reference problems.  Because of the structure of its types and its caching strategies, this 
            analysis is faster than you might expect.
            Compiler error messages are <n-s>usually</n-s> clear, simple, and provide advice for fixing
            the error.  If the error is grievous enough, the messages can get confusing, even complaining
            about correct code.
          </li>
          <li>
            Rust code layout is more flexible than that of C++, where definitions must come before use.
            In Rust, an <n-s>identifier may be used at any place in the code</n-s> provided only that it has been
            defined somewhere in the translation unit (similar to Java and C#).
          </li>
          <li>
            As of now, there is <n-s>no debugger</n-s> as part of the Rust tool chain. That isn&apos;t as big an issue
            as you might think.  <del>Many</del> most errors are compile-time and the compiler helps with those. 
            Since Rust eliminates many errors by construction, logging works for the small remainder.
          </li>
          <li>
            Rust uses structs for creating types.  Structs can only inherit from traits, a form of
            abstract type similar to an interface.  Traits can, but often do not, implement
            the methods they declare.
          </li>
          <li>
            <n-s>Rust does not implement function overloading</n-s>.
          </li>
          <li>
            <n-s>Rust does not have exceptions</n-s> - uses panics (controlled shutdown)
          </li>
          <li>
            <n-s>Rust generics are like Java and C# generics rather than C++ Templates</n-s>. 
            <ul class="tight">
              <li>
                C++ template classes can be specialized and template functions can be overloaded. 
                That enlarges the set of types that the template function or class can be successfully
                instantiated with. Any types that don&apos;t work correctly with the generic template
                can be specialized with code that works for that type.
              </li>
              <li>
                Rust generics can be constrained by the use of trait specifications. That diminishes the
                set of types that will compile for the generic function or struct. Any type that doesn&apos;t
                implement the trait will not compile when used to instantiate the generic function or struct.
              </li>
              <li>
                Rust generics do not support creation of variadic functions and variatic type lists for
                generic structs. To create a variatic function you need to use macros. Rust macros seem
                to be well engineered, so that may not be as inconvenient as it would otherwise be.
              </li>
            </ul>
          </li>
        </ol>
      </indent-block>
      <t-b style="margin-top:0px;">
        This seems like a daunting list of things to learn. It is, but the Rust compiler makes that a lot
        easier than you might think.  Every time your code doesn&apos;t follow the rules it fails to
        compile with usually very clear error messages that help you fix the error(s).
      </t-b>
      <num-cont>
        <num-item1>1.0.1</num-item1><num-item4>Comparing to C++</num-item4>
      </num-cont>
      <t-b>
        Modern C++ provides lots of tools to promote safe design:
        <indent-block>
          <ol class="tight">
            <li>
              Scope-based resource management via constructors and destructors
            </li>
            <li>
              Smart pointers: std::unique_ptr&lt;T&gt;, std::shared_ptr&lt;T&gt;
            </li>
            <li>
              Range-based for loops and begin and end iterators nearly eliminate out-of-bound
              indexing.
            </li>
            <li>
              Encapsulation of state in instances of classes
            </li>
            <li>move constructors and assignment</li>
            <li>exception handling, STL container at(i) method</li>
            <li>...</li>
          </ol>
        </indent-block>
      </t-b>
      <t-b>
        These are used effectively by experienced C++ developers to write safe code. But not all
        C++ developers have enough experience to do that consistently.  C++ is safe by convention, 
        but the conventions have to be followed.
      </t-b>
      <t-b>
        Rust indentifies safety vulnerabilities and avoids them with compiler enforced rules.
      </t-b>
      <t-b>
        <indent-block>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Modern C++</defn-head>
              <defn-body>Safe by convention</defn-body>
            </defn-block>
            <defn-block>
              <defn-head>Rust</defn-head>
              <defn-body>Safe by construction</defn-body>
            </defn-block>
          </defn-outerBlock>
        </indent-block>
      </t-b>
      <t-b>
        This isn&apos;t as one-sided as it seems.  Rust has two back doors that could re-introduce 
        vulnerabilities:
        <indent-block>
          <ol class="tight">
            <li>
              <n-s><strong>unsafe blocks</strong></n-s>:<br />
              There are a few places in library code where the rules may need to be suspended. 
              The application of the compiler&apos;s rules may not be precise enough to allow 
              a library designer to build what is needed.
            </li>
            <li>
              Rust provides an <n-s><strong>interface to C code</strong></n-s> through its std::ffi 
              (foreign function interface) crate.  This can be used to bind to
              existing code resources written in C or C++.  The Rust interface can only talk
              directly to C style code, but that code can call into C++ code that uses more advanced
              features.  That imports any vulnerabilities suffered by the foreign code.
            </li>
          </ol>
        </indent-block>
      </t-b>
      <t-b>
        Assuming we use only unsafe blocks, its easy to identify them in code and, if they are
        small, fairly easy to build safe wrappers around them.  Note however, that there is some
        controversy in the Rust community about promiscuous use of unsafe code by some open-source
        developers.
      </t-b>
      <t-b style="margin-top:0px;">
        There is a lot to like about Rust, but there are still strong use-cases for C++ and other languages.
        I expect to write a lot of Rust code, but I think C++ will continue to be my favorite language for
        most of the things I do.
      </t-b>
      <num-cont>
        <num-item1>1.0.2</num-item1><num-item4>Things to Read First</num-item4>
      </num-cont>
      <t-b>
        Important references for this chapter:
        <s-1em></s-1em>
        <table style="width:calc(100vw - 12rem);">
          <tr>
            <th class="darkItem">Link</th><th class="darkItem">Description</th>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://www.youtube.com/watch?v=DnT-LUQgc7s">Considering&nbsp;Rust&nbsp;-&nbsp;Feb&nbsp;2020&nbsp;-&nbsp;Jon&nbsp;Gjengset</a>
            </td>
            <td class="lightItem">
              Great what-is-it video, with code snippets and a lot of mind setting conversation by a very
              knowledgeable presenter.
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="Resources/RustModels.pdf">RustModels.pdf</a></td>
            <td class="lightItem">
              Discussion of principle ideas on which Rust is based.
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://doc.rust-lang.org/std/index.html">Rust std</a></td>
            <td class="lightItem">
              Very clear documentation for the Rust std facilities, e.g., types, modules, macros, and
              keywords.
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/">A half-hour to learn Rust</a>
            </td>
            <td class="lightItem">
              Code fragments with commentary that cover most of the Rust ideas.
            </td>
          </tr>
         <tr>
            <td class="lightItem"><a href="https://cheats.rs/">Rust&nbsp;Cheat&nbsp;Sheet</a></td>
            <td class="lightItem">
              Very broad reference to the Rust language, its libraries, and idioms.
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
            <td class="lightItem">
              Container diagrams
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://hacks.mozilla.org/2015/05/diving-into-rust-for-the-first-time/">Diving into Rust</a></td>
            <td class="lightItem">
              Contains an excellent video you <n-s>should</n-s> watch. Discusses <n-s>ownership</n-s>, with
              copies and moves, and thread models.
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="RustBasicDemos.html">Rust&nbsp;Basic&nbsp;Code&nbsp;Demos</a></td>
            <td class="lightItem">
              Small code examples that probe how Rust functions
            </td>
          </tr>
          <!--<tr>
            <td class="lightItem"><a href="https://wiki.mozilla.org/Matrix">Matrix open discussion platform</a></td>
            <td class="lightItem">
              
            </td>
          </tr>-->
        </table>
      </t-b>
      <t-b>
        <details>
          <summary class="labelStyle lightItem">Places to visit later</summary>
          <table style="width:calc(100vw - 12rem);">
          <tr>
            <td class="darkItem">Places to visit later</td>
            <td class="darkItem">
              Description
            </td>
          </tr>
          <tr>
            <td class="lightItem">
              <a href="https://docs.rs/dtolnay/0.0.8/dtolnay/macro._02__reference_types.html">
                Shared&nbsp;reference&nbsp;&amp;T&nbsp;and&nbsp;exclusive&nbsp;reference&nbsp;&amp;mut&nbsp;T
              </a>
            </td>
            <td class="lightItem">
              More accurate description than immutable reference and mutable reference
            </td>
          </tr>
          <tr>
            <td class="lightItem"><a href="https://deterministic.space/elegant-apis-in-rust.html">Elegant APIs in Rust</a></td>
            <td class="lightItem">
              Things to consider when writing Rust functions and packages
            </td>
          </tr>
          <!--<tr>
            <td class="lightItem"><a href="https://rustacean.net/">Rustaceans</a></td>
            <td class="lightItem">
              Open Source images
            </td>
          </tr>-->
          <!--<tr>
            <td class="lightItem"><a href="https://blog.rust-lang.org/">Rust Blog</a></td>
            <td class="lightItem">
              Open Source images
            </td>
          </tr>-->
          <!--<tr>
            <td class="lightItem"><a href="https://raphlinus.github.io/">Ralph Levien's blog</a></td>
            <td class="lightItem">
              Developer and Philosopher
            </td>
          </tr>-->
          <tr>
            <td class="lightItem"><a href="https://raphlinus.github.io/rust/2020/01/18/soundness-pledge.html">Soundness Pledge</a></td>
            <td class="lightItem">
              Commentary about Rust programming goals and ideals - how not to subvert safety goals.
            </td>
          </tr>
          <!--<tr>
            <td class="lightItem"><a href="https://words.steveklabnik.com/a-sad-day-for-rust">Sad day for Rust</a></td>
            <td class="lightItem">
              Commentary about some issues with Rust community.
            </td>
          </tr>-->
          </table>
        </details>
      </t-b>
      <s-halfEm></s-halfEm>
    </t-b>
  <a id="structure"></a>
  <hr class="spread" />
    <num-cont>
      <num-item1>1.1</num-item1><num-item4>Code Structure:</num-item4>
    </num-cont>
    <div style="width:calc(100vw - 9rem);">
      <photosizer-block src="Pictures/VscDemo.JPG" width="700" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 1. Demo_Crate Package directory in VS Code
        </span>
      </photosizer-block>
    </div>
    <t-b class="mbz">
      Rust code structure is based on <n-s>crates</n-s> and <n-s>packages</n-s>:
      <indent-block class="pad10 mbz">
        <ul class="tight mbz">
          <li>
            <strong>Package:</strong>
            <div class="pad10">
              A Package is a directory containing a <c-s>cargo.toml</c-s> file and a <c-s>/src</c-s> folder
              containing a collection of source files. Packages are built with cargo:
              <indent-block class="pad10">
                <c-s>cargo init [--bin | --lib] [package_name]</c-s><br />
                Default option is --bin and default package_name is the current directory name.
              </indent-block>
              The <c-s>cargo build</c-s> command creates a Target subdirectory, if it doesn&apos;t
              already exist, and runs rustc to create an executable or library in <c-s>Target/debug</c-s>.
            </div>
          </li>
          <li>
            <strong>Crate:</strong>
            <div class="pad10 mbz">
              The source form of a crate has:
              <indent-block class="pad5">
                <ol class="tight mbz">
                  <li>
                    A crate root file with the name main.rs or lib.rs, residing in the /src folder.  
                    main.rs has a main function. lib.rs has a test configuration section with one or more tests.
                  </li>
                  <li>
                    Zero or more supporting source files, *.rs, in <c-s>/src</c-s>, called modules, that are imported into the
                    crate root with the keyword mod followed by the module name without extension.
                    Each module may import other lower-level module files that reside in <c-s>/src</c-s>.
                  </li>
                  <li>
                    The crate may depend on other libraries in some local folder, in crates.io, or in a github
                    repository. These are all identified in the <c-s>[dependencies]</c-s> section of the 
                    <c-s>cargo.toml</c-s> file.
                  </li>
                  <li>
                    Crates compile into a single file.  A binary crate has a main.rs root and compiles to
                    a single executable file, [package_name].exe on windows.  A library crate has a lib.rs root
                    and compiles to a
                    single library file, lib[package_name].rlib.
                  </li>
                </ol>
              </indent-block>
            </div>
          </li>
        </ul>
      </indent-block>
    </t-b>
    <t-b class="mtz">
      All this is illustrated in the &quot;Structure Demo&quot;, below.
    </t-b>
    <t-b class="mtz">
      The Structure Demo <c-s>main.rs</c-s> loads a module, <c-s>helper.rs</c-s>, from its own src directory with the 
      declaration <c-s>mod helper</c-s> and then declares use of a public function, say, from helper.
    </t-b>
    <t-b>
      The package for <c-s>main.rs</c-s> also imports a library <c-s>demo_lib</c-s> by including 
      the path to demo_lib in its
      <c-s>Cargo.toml</c-s> file&apos;s <c-s>[dependencies]</c-s> section.
      <indent-block class="pad10">
        <c-s>
          [dependencies]<br />
          demo_lib = { path = "../demo_lib"}
        </c-s>
      </indent-block>
    </t-b>
    <t-b>
      If the Cargo.toml file contains an identifier without a path in its [dependencies] section then
      Cargo looks for a library in <a href="https://crates.io">https://Crates.io</a>.
      <indent-block class="pad10">
        <c-s>
          [dependencies]<br />
          demo_lib = { path = "../demo_lib"}<br />
          serde = "1.0.104"
        </c-s>
      </indent-block>
      The <a href="https://crates.io/crates/serde">serde crate</a> provides serialization and deserialization 
      of Rust types.
    </t-b>
    <t-b>
      The main.rs file may then simply use <c-s>demo_lib::say()</c-s> or declare
      <c-s>use helper_lib::{ say }</c-s> at the top and then use say() in its 
      subsequent code.
    </t-b>
    <t-b>
      <defn-block>
        <defn-body>
          This Structure Demo illustrates how to build a binary crate root, helper module, and a demo library.
          It has almost no functionality; just serves to illustrate how code is structured from modules and
          libraries.
        </defn-body>
      </defn-block>
    </t-b>
    <t-b>
      <details>
        <summary class="labelStyle darkItem">Structure Demo</summary>
        <t-b>
          The <c-s>main</c-s> function in <c-s>demo/src/main.rs</c-s> uses code from 
          <c-s>demo/src/helper.rs</c-s> and <c-s>demo_lib/src/lib.rs</c-s>. This shows how to
          factor code into maintainable pieces.
        </t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>demo/src/main.rs</defn-head>
            <defn-code>
mod helper;  // declares helper module
             // since there is no code block
             // helper.rs must be in local src and 
             // provide code for this module

use helper::{ say };

use demo_lib::{ libsay };

fn main() {
    helper::say();
    say();
    demo_lib::libsay();
    libsay();
    print!("\n  Hello, world!\n\n");
}
            </defn-code>
            <defn-head class="defnBorderTop">demo/src/helper.rs</defn-head>
            <defn-code>
pub fn say() {
    print!("\n  hello from helper");
}

// Including a main function is not a good idea
// but doesn't seem to do any harm, even if pub.
#[allow(dead_code)]
fn main() {
    print!("\n  hello world");
}
            </defn-code>
            <defn-head class="defnBorderTop">demo/Cargo.toml</defn-head>
            <defn-code>
[package]
name = "demo"
version = "0.1.0"
authors = ["James W. Fawcett &lt;jfawcett@twcny.rr.com&gt;"]
edition = "2018"

[dependencies]
demo_lib = { path = "../demo_lib" }
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>demo_lib/src/lib.rs</defn-head>
            <defn-code>
pub fn libsay() {
    print!("\n  hello from demo_lib");
}
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
cargo -q run

  hello from helper
  hello from helper
  hello from demo_lib
  hello from demo_lib
  Hello, world!

            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </details>
    </t-b>
    <t-b>
      Most Rust code starts with a package structure built with the Rust tool <n-s>Cargo</n-s>.  
      <n-s>Cargo</n-s> is a package manager,
      that can build, run, and clean a Rust <n-s>Package</n-s> as well as create a new <n-s>Package</n-s>
      and download crates from <a href="https://Crates.io">https://crates.io</a>.
    </t-b>
    <t-b>
      Figure 1. shows a newly created <n-s>Package</n-s>.  The process is simple.
      <indent-block class="pad10">
        <ol class="tight">
          <li>
            Open a Developer&apos;s command prompt
          </li>
          <li>
            Create a directory temp with <n-s>mkdir temp</n-s>
          </li>
          <li>
            Issue the command: <n-s>cargo new demo_crate</n-s>. That creates everything shown in Figure 1.
            <indent-block class="pad10">
              The image is a screen shot of Visual Studo Code with opened folder demo_crate.
            </indent-block>
            The <n-s>Cargo</n-s> tool is in your path after you install Rust.
          </li>
          <li>
            <n-s>main.rs</n-s> is a demonstration &quot;Hello World&quot; program.
          </li>
          <li>
            Build with the command <n-s>cargo build</n-s> and run with <n-s>cargo run</n-s>.
          </li>
          <li>
            Clean the crate with <n-s>cargo clean</n-s>.
          </li>
        </ol>
      </indent-block>
      <t-b>
        Using <a href="https://code.visualstudio.com/download">Visual Studio Code</a> makes this a fairly
        painless process.  If, using the command window, you navigate to the temp directory and type
        <c-s>code .</c-s>, assuming you&apos;ve installed VS Code, it will open showing the temp
        directory and its files and subdirectories, e.g., <c-s>Cargo.toml</c-s> and <c-s>temp/src</c-s>.
      </t-b>
      <t-b>
        You can open a teminal in VS Code, e.g., <c-s>top menu > Terminal > New Terminal</c-s>.  I usually move the terminal
        to the right side.  You can do that with <c-s>top menu > View > Appearance > Move Panel Right</c-s>.
        You can make your favored panel position the default in <c-s>top menu > View > Pallet [searh: user settings] >
        [search panel]</c-s>.
      </t-b>
      <t-b>
        Now, you can edit the package files, save, then, in the <n-ss>terminal</n-ss> type <c-s>cargo check</c-s>
        to test the build without running, and <c-s>cargo run</c-s> to build and run.  You will see the output
        in the terminal.  When you are done you can <c-s>cargo clean</c-s> to remove the target items including
        the <c-s>target</c-s> folder itself.
      </t-b>
      <t-b>
        A typical Rust program consists of a binary crate (one with a main.rs) and perhaps several
        library crates that implement all the functionality used by main.
      </t-b>
      <t-b>
        You create a library crate with the command <c-s>cargo new [library name] --lib</c-s>.  That builds
        the same structure as shown here except that in the folder <c-s>src</c-s> you find a file
        <c-s>lib.rs</c-s> that has functions that implement the library&apos;s operations and a test fixture
        for running a sequence of tests on the library.
      </t-b>
      <t-b>
        The binary crate must specify each of the libraries it uses with dependencies in its <c-s>Cargo.toml</c-s>
        file. All of this is illustrated by the code in the two details dropdowns, below.
      </t-b>
    </t-b>
    <num-cont>
      <num-item1>1.1.1</num-item1><num-item4>Display Library Example:</num-item4>
    </num-cont>
    <t-b>
      This <a href="RustBasicDemos.html">display library</a> provides a set of display functions to help generate demonstration and
      debug io for Rust programs.  It contains functions:
      <indent-block class="pad10">
        <ol class="tight">
          <li>
            <c-s>show_type&lt;T&gt;(_value: &amp;T)</c-s> - 
            Displays type and size of input
          </li>
          <li>
            <c-s>log&lt;T&gt;(value: &amp;T)</c-s> - 
            Displays type and size of input, followed by its value.
          </li>
          <li>
            <c-s>main_title(msg: String)</c-s> and <c-s>sub_title(msg: String</c-s> - 
            Displays msg followed by an underline.
          </li>
          <li>
            <c-s>putline()</c-s> - Emits a newline.
          </li>
          <li>
            <c-s>putlinen(n: usize)</c-s> - Emits n newlines.
          </li>
          <li>
            ...
          </li>
        </ol>
      </indent-block>
    </t-b>
  <t-b>
    The code in <c-s>display library</c-s> shows the structure of a lib crate. Note how the library
    imports Rust std library facilities with a series of use std::xxxx statements. These
    do essentially the same thing that #include &lt;xxxx&gt; declarations do in C++.
  </t-b>
  <indent-blocks>
    <details>
      <summary class="labelStyle, darkItem">display library</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>display::Cargo.toml</defn-head>
            <defn-code>
[package]
name = "display"
version = "0.1.1"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

[lib]
doctest = false

[dependencies]

            </defn-code>
            <defn-head class="defnBorderTop">examples/demo_display.rs</defn-head>
            <defn-code>
use display::{*};

#[derive(Debug)]
struct Point {
    x: f64,
    y: f64,
    z: f64,
}

fn test_displays() {
    main_title("demo display");
    sub_title("--  shows  --");
    shows("\n  showing type and value:");
    putline();
    sub_title("--  show_type and show_value  --");
    let mut str = String::new();
    str.push_str("a string");
    show_value(&amp;str);
    putline();
    sub_title("--  log  --");
    let an_i8: i8 = 100;
    log(&amp;an_i8);
    let mut vi : Vec&lt;i32&gt; = Vec::new();
    vi.push(-1);
    vi.push(0);
    vi.push(1);
    log(&amp;vi);
    #[derive(Debug)]
    enum Test { Test1, Test2, };
    log(&amp;Test::Test1);
    log(&amp;Test::Test2);
    let point = Point { x:1.0, y:1.5, z:2.0 };
    log(&amp;point);
    putline();
    sub_title("--  show --");
    show("\n  this is a Point structure\n  ", &amp;point);
    putline();
    sub_title("that's all folks!");
    putline();
}

fn main() {
    test_displays();
}
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
  demo display
 ==============
  --  shows  --
 ---------------
  showing type and value:

  --  show_type and show_value  --
 ----------------------------------
  value: "a string"

  --  log  --
 -------------
  TypeId: i8, size: 1
  value:  100
  TypeId: alloc::vec::Vec<i32>, size: 12
  value:  [-1, 0, 1]
  TypeId: demo_display::test_displays::Test, size: 1
  value:  Test1
  TypeId: demo_display::test_displays::Test, size: 1
  value:  Test2
  TypeId: demo_display::Point, size: 24
  value:  Point { x: 1.0, y: 1.5, z: 2.0 }

  --  show --
 -------------
  this is a Point structure
  Point { x: 1.0, y: 1.5, z: 2.0 }

  that's all folks!
 -------------------

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>display::lib.rs</defn-head>
            <defn-code>
/////////////////////////////////////////////////
// lib.rs - Demonstrate display types          //
//                                             //
// Jim Fawcett, https://JimFawcett.github.io   //
/////////////////////////////////////////////////
/*
   log and do_work are derived from:
   https://doc.rust-lang.org/beta/std/any/index.html

*/
use std::fmt::Debug;
use std::any::Any;
use std::any::type_name;
use std::mem::size_of;

/*-----------------------------------------------
   Accepts either String or str
   - no automatic newline
*/
pub fn shows&lt;S: Into&lt;String&gt;&gt;(s:S) {
    print!("{}",s.into());
}
/*-----------------------------------------------
   Display message and value
   - no automatic newline
*/
pub fn show&lt;T: Debug&gt;(
    msg:&amp;str, t:&amp;T
    ) {
    print!("{}{:?}", msg, t);
}
pub fn str_show&lt;T: Debug&gt;(
      msg:&amp;str, t:&amp;T
    ) -&gt; String {
        format!("{}{:?}", msg, t)
}
/*-----------------------------------------------
   show value
   - expects T to implement Debug
*/
pub fn show_value&lt;T: Debug&gt;(value: &amp;T) {
    print!("\n  value: {:?}", value);
}
pub fn str_show_value&lt;T: Debug&gt;(value: &amp;T)
         -&gt; String {
    format!("\n  value: {:?}", value)
}
/*-----------------------------------------------
   show type name
*/
pub fn show_type&lt;T&gt;(_value: &amp;T) {
    let name = std::any::type_name::&lt;T&gt;();
    print!(
      "\n  TypeId: {}, size: {}", 
      name, size_of::&lt;T&gt;()
    );
}
pub fn str_show_type&lt;T&gt;(_value: &amp;T)
          -&gt; String {
    let name = std::any::type_name::&lt;T&gt;();
    format!(
      "\n  TypeId: {}, size: {}", 
      name, size_of::&lt;T&gt;()
    )
}
  /*---------------------------------------------
   show type name and value
   - expects T to implement Debug
   - see #[define(Debug)] attributes, above 
*/
pub fn log&lt;T: Debug&gt;(value: &amp;T) {
    let name = type_name::&lt;T&gt;();
    print!(
      "\n  TypeId: {}, size: {}", 
      name, size_of::&lt;T&gt;()
    );
    print!("\n  value:  {:?}", value);
  }
  pub fn str_log&lt;T: Debug&gt;(value: &amp;T)
           -&gt; String {
    let name = type_name::&lt;T&gt;();
    let mut st = format!(
      "\n  TypeId: {}, size: {}", 
      name, size_of::&lt;T&gt;()
    );
    let st1 = 
      format!("\n  value:  {:?}", value);
    st.push_str(&amp;st1);
    st.clone()
  }
  
/*-----------------------------------------------
   Display underlined main title on console
*/
pub fn main_title(msg: &amp;str) {
    print!("\n  {}", msg);
    let s = std::iter::repeat('=')
          .take(msg.len() + 2)
          .collect::&lt;String&gt;();
    print!("\n {}", s);
}
/*-----------------------------------------------
   Display underlined sub title on console
*/
pub fn sub_title(msg: &amp;str) {
    print!("\n  {}", msg);
    let s = std::iter::repeat('-')
           .take(msg.len() + 2)
           .collect::&lt;String&gt;();
    print!("\n {}", s);
}
/*-----------------------------------------------
   show line with len hyphens
*/
pub fn separator(len:u8) {
    let mut s = String::new();
    for _i in 1..len+2 { s.push('-');}
    print!("\n {}",s);
}
/*-----------------------------------------------
   push a single newline to console
*/
pub fn putline() {
    print!("\n");
}
/*-----------------------------------------------
   pust n newlines to console
*/
pub fn putlinen(n: usize) {
    let s = std::iter::repeat('\n')
            .take(n).collect::&lt;String&gt;();
    print!("{}", s);
}

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>lib.rs tests</defn-head>
            <defn-code>
/////////////////////////////////////////////////
// display::main.rs tests - Demo display types //
//                                             //
// Jim Fawcett, https://JimFawcett.github.io   //
/////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Debug)]
    struct Point {
        x: f64,
        y: f64,
        z: f64,
    }
    #[test]
    fn test_show_type() {
        let mut str = String::new();
        str.push_str("a string");
        assert_eq!(
          str_show_type(&amp;str).contains("TypeId:"), 
          true
        );
    }
    #[test]
    fn test_show_value() {
        let mut str = String::new();
        str.push_str("a string");
        assert_eq!(
          str_show_value(&amp;str).contains("value:"),
          true
        );
    }
    #[test]
    fn test_log() {
        let an_i8: i8 = 100;
        assert_eq!(
          str_log(&amp;an_i8).contains("100"),
          true
        );
        let mut vi : Vec&lt;i32&gt; = Vec::new();
        vi.push(-1);
        vi.push(0);
        vi.push(1);
        assert_eq!(
          str_log(&amp;vi).contains("1]"),
          true
        );
        #[derive(Debug)]
        enum Test { Test1, Test2, };
        log(&amp;Test::Test1);
        log(&amp;Test::Test2);
        let point = Point { x:1.0, y:1.5, z:2.0 };
        log(&amp;point);
        assert_eq!(
          str_log(&amp;point).contains("2.0 }"),
          true
        );
        sub_title("that's all folks!");
    }
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>lib.rs test output</defn-head>
            <defn-code>
C:\github\JimFawcett\RustBasicDemos\display>
cargo test
    Finished test [unoptimized + debuginfo] 
      target(s) in 0.02s
    Running target\debug\deps
      \display-26eaf9b270500dad.exe   

running 3 tests
test tests::test_show_type ... ok
test tests::test_log ... ok
test tests::test_show_value ... ok

test result: ok. 
  3 passed; 
  0 failed; 
  0 ignored; 
  0 measured; 
  0 filtered out

            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
      <s-halfEm></s-halfEm>
    </details>
    </indent-blocks>
    <t-b>
      Configuring packages and building them are traditionally done with <n-s>Cargo</n-s>.  Cargo is a 
      package manager, build manager (in some ways like a make file), checker, runner, and cleaner.
    </t-b>
    <t-b>
      One of the first things a developer new to Rust needs to learn is the naming conventions that 
      Cargo depends upon to do its business. It looks for directories named <n-s>src</n-s> to find
      code to build, its dependencies, described in <n-s>Cargo.toml</n-s>, have to be library packages
      that come from a local path or from <a href="https://crates.io">crates.io</a>, and it expects
      that modules are loaded from the local <n-s>src</n-s> directory.
    </t-b>
    <a id="build"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.2</num-item1><num-item4>Build Process:</num-item4>
    </num-cont>
    <div style="width:calc(100vw - 9rem);">
      <photosizer-block src="Pictures/build.jpg" width="500" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 2. Build Process
        </span>
      </photosizer-block>
    </div>
    <t-b>
      The Rust build process for a crate starts with code in the <c-s>[crate]/src</c-s> folder, provided that 
      its <c-s>[crate]/target</c-s> folder does not exist or contains items that are out of date.
    </t-b>
    <t-b>
      Rust builds are transitive.  The command <c-s>cargo build</c-s> issued in a terminal opened in
      the root of a crate, i.e., the directory holding the crate&apos;s cargo.toml file:
      <indent-block class="pad5">
        <ol class="tight">
          <li>
            Builds each dependency cited in it&apos;s cargo.toml file, if its build target is not cached
            or retrieved from the load, by traversing this list from the top.
            <indent-block class="pad5">
              <ul class="tight">
                <li>
                  loads and builds each local library identified by:
                  <div style="font-size:1em; padding:5px 25px 5px 25px; margin:0px;">
                    <c-s>
                      [dependencies]<br />
                      lib_name = { path = "[path to lib root]" }
                    </c-s>
                  </div>
                </li>
                <li>
                  loads and builds each crate from <a href="https://crates.io">crates.io</a> specified by:
                  <div style="font-size:1em; padding:5px 25px 5px 25px; margin:0px;">
                    <c-s>
                      [dependencies]<br />
                      crate_name = "[version number]"
                    </c-s>
                  </div>
                </li>
                <li>
                  loads and builds each crate from <a href="https://github.com">github.com</a> specified by:
                  <div style="font-size:1em; padding:5px 25px 5px 25px; margin:0px;">
                    <c-s>
                      [dependencies]<br />
                      crate_name = { git = "https://github.com/[crate_repo]" }
                    </c-s>
                  </div>
                </li>
              </ul>
            </indent-block>
            Each of the build statements in the three items above implement all the same steps.  So when
            a dependency is loaded and no target is available, the build process examines its cargo.toml file and builds its dependencies.
            <s-halfEm></s-halfEm>
          </li>
          <li>
            Loads the crate root source file, e.g., <c-s>main.rs</c-s> (binary) or <c-s>lib.rs</c-s> (library)
            located in the <c-s>/src</c-s> folder.
            <indent-block class="pad5">
              <ul class="tight">
                <li>
                  Loads and compiles each local module, identified by the keyword <c-s>mod [filename]</c-s>
                  in the crate root source file. 
                  Modules are files, <c-s>*.rs</c-s>, other than the root file, found in the local <c-s>/src</c-s> folder.
                </li>
                <li>
                  Then compiles the source of the crate root file.
                </li>
              </ul>
            </indent-block>
            Each compilation checks code syntax and checks that ownership rules have not been violated.
          </li>
        </ol>
      </indent-block>
    </t-b>
    <t-b>
      Cargo will also build documentation.  That is covered in the Structures chapter in more detail than we
      have space for here. Note that the cargo generated documentation gives you a source listing for all your
      code and all the code you depend upon, other than the std libraries, which are documented
      <a href="https://doc.rust-lang.org/beta/std/">here</a>.
    </t-b>

    <a id="execution"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.3</num-item1><num-item4>Execution:</num-item4>
    </num-cont>
    <t-b>
      The cargo execution model consists of three modes:
      <indent-block class="pad5">
        <ol class="tight">
          <li>
            <n-s>Execution of binaries:</n-s>
            <t-b>
              If the crate root file is a binary, <c-s>main.rs</c-s>, the command &quot;<c-s>cargo run</c-s>&quot; will 
              run its main function.
            </t-b>
          </li>
          <li>
            <n-s>Testing libraries:</n-s>
            <div>
              <t-b>
                If the crate root file is a library, <c-s>lib.rs</c-s>, the command &quot;<c-s>cargo test</c-s>&quot; will
                run any tests configured at the end of the library.  When cargo builds a library it creates a
                single configured test at the end of the library that simply asserts that <c-s>2 + 2 == 4</c-s>,
                to show you how to build tests.  Tests succeed if and only if they do not assert, so you use
                assertions to check test invariants and operation results.
              </t-b>
              <t-b>
                When running tests, an assertion failure does not cause a panic shutdown.  Instead, the test
                environment traps the panic and returns an error message.
              </t-b>
            </div>
          </li>
          <li>
            <n-s>Running Examples</n-s>
            <div>
              <t-b>
                For library crates, if you create an <c-s>/examples</c-s> folder and put source files, each
                with a main function, then the command &quot;<c-s>cargo run --example [file_name]</c-s>&quot;, without the
                <c-s>rs</c-s> extension, will execute that main, using the library as needed.
              </t-b>
              <t-b>
                This is a great way to help users understand how to use your library.  You might provide several
                example files for users with different levels of expertise, for example.
              </t-b>
            </div>
          </li>
        </ol>
      </indent-block>
      Finally, when <c-s>cargo</c-s> builds a binary, you will find the execution image in <c-s>/target/debug</c-s> and
      can execute that by navigating to that folder with the command prompt and typing the command [file_name].exe or
      ./[file_name].exe depending on your platform.
    </t-b>
    <t-b>
      You will find a more detailed discussion of these execution processes in the Structures chapter.
    </t-b>
    <a id="ownership"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.4</num-item1><num-item4>Ownership:</num-item4>
    </num-cont>
    <t-b>
      Ownership is one of the most important features of the Rust programming language.  Rust fully
      supports value types, and manages to do that without help from the application designer.  There
      are no copy and move constructors, assignment operators, or destructors to write.
    </t-b>
    <t-b>
      Every name is bound to a value on the stack.  The value may have additional structure on the 
      heap which it manages without prompting by the designer. The String and Vec types are examples.  
      When a variable bound to some type goes out of scope, 
      it drops (deallocates) any heap resources it may own.
    </t-b>
    <t-b>
      When a new name, x, binds to an existing variable y:
      <indent-block class="pad5">
        <c-s>let x = y;</c-s>
      </indent-block>
      That results in a copy if y&apos;s value is copyable, e.g., blittable. If not, then y&apos;s
      value is moved to x, passing ownership.  In that case, y is no longer usable.  If code attempts
      to use a moved instance that results in a <n-s>compile-time</n-s> error.
    </t-b>
    <t-b>
      <div class="pad5">
        <defn-outerBlock>
          <defn-block>
            <defn-head>Example of copy and move:</defn-head>
            <defn-code>
let i = 3;        // i is blittable
let mut j = i;    // j gets copy of i
print!("\n  i = {}, j = {}", i, j);
// i is still usable

let s = String::from("String named s");  // s is not blitable
let mut t = s;                           // s is moved to t
t.push_str(" with more stuff");
print!("\n  t = {}", t);
// print!("\n  s = {}", s);              // can't use s, been moved

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output:</defn-head>
            <defn-code>


i = 3, j = 3





t = String named s with more stuff
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </div>    </t-b>
    <t-b>
      Rust has references, which bind to, and borrow but don't own their &quot;borrowed&quot; values:
      <indent-block class="pad5">
        <c-s>let r = &amp;x;</c-s>
      </indent-block>
      A Rust program many have any number of non-mutating references to a given value.  However, it
      may have at most one mutating reference, and in that case, no other references.
      <indent-block class="pad5">
        <c-s>let r = &amp;mut x;</c-s>
      </indent-block>
      Since references don&apos;t own the values to which they bind, nothing happens to the values when 
      they go out of scope.  Drops happen only for an owned value when the owner, o, goes out of scope
      or are dropped with a move or call to drop(o).
    </t-b>
    <t-b>
      When a value has been borrowed by a reference, e.g., <c-s>r</c-s> mutably borrowing 
      <c-s>x</c-s>&apos;s value, the original owner, <c-s>x</c-s>, can not mutate the value, because
      <c-s>r</c-s> has borrowed the ability to mutate.  That restriction continues until the reference, <c-s>r</c-s> 
      goes out of scope or is dropped with a call to <c-s>drop(r)</c-s>.
    </t-b>
    <t-b>
      When a non-mutable reference to a value is declared, that creates a view of the value which should not
      change until the reference is dropped, so, again, the original owner can not mutate its value until
      all references have been dropped or go out of scope. Note that dropping a reference does not drop the
      referred value since the reference does not own the value.
    </t-b>
    <t-b>
      The most common use of references is to pass an argument to a function by reference.  When the function
      returns, the reference goes out of scope and the original owner may mutate its value.
    </t-b>
    <t-b>
      <div class="pad5">
        <defn-outerBlock>
          <defn-block>
            <defn-head>Example of references:</defn-head>
            <defn-code>
let i = 3;
let mut j = i;    // copy of i
let r = &mut j;   // mutable ref to j
*r += 2;          // mutating j thru r
 
///////////////////////////////////////////////////////
// won&apos;t compile:
// print!("\n  i = {}, j = {}, r = {}", i, j, r);
// print! takes its arguments by reference
// so can't pass r, as that would make a second
// reference where the first is mutable - not allowed

let z = *r;       // copy r's referent value
print!("\n  i = {}, j = {}, z = {}", i, j, z);
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Output:</defn-head>
            <defn-code>













i = 3, j = 5, z = 5
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </div>
    </t-b>
    <t-b>
      You will find a more detailed presentation of Rust&apos;s ownership model by following links in the table, below.
    </t-b>
    <t-b>
      <table>
        <tr>
          <th class="darkItem">Ownership Details</th>
          <th class="darkItem"></th>
        </tr>
        <tr>
          <td class="lightItem">
            <a href="Resources/RustModels.pdf#page=18">RustModels.pdf</a><br />
            <a href="RustModels.html">RustModels&nbsp;code&nbsp;demos</a>
          </td>
          <td class="lightItem">
            Discussion of RwLock ownership, Copies, Moves, Clones, reference borrowing, mutability with code
            examples
          </td>
        </tr>
        <tr>
          <td class="lightItem"><a href="RustBasicDemos.html">RustBasicDemos.html</a></td>
          <td class="lightItem">Large collection of demos, several for ownership</td>
        </tr>
      </table>
    </t-b>
    <t-b>
      The next section focuses on user-defined structuring of code and data.
    </t-b>
    <a id="types"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.5</num-item1><num-item4>Rust Types</num-item4>
    </num-cont>
    <t-b>
      Rust&apos;s <n-s><a href="https://doc.rust-lang.org/beta/std/index.html#primitives">type system</a></n-s> has:
      <indent-block class="pad5">
        <ul class="tight">
          <li>
            primitives, i32, f64, ... 
          </li>
          <li>
            array [i32, 4]
          </li>
          <li>
            tuple (i32, f64, String)
          </li>
          <li>
            struct { i:i32, f:f64, s:String }
          </li>
          <li>
            enum { BS(String), MS(String), PhD(String) }
          </li>
          <li>
            std collections:<br />
            Vec, VecDeque, LinkedList<br />
            HashMap, HashSet, BTreeMap, BTreeSet<br />
            BinaryHeap
          </li>
        </ul>
      </indent-block>
    </t-b>
    <t-b>
      The details dropdown, below, shows how to write type specifications for each of the non-collection
      types. Usually you don&apos;t need to supply the specs, but instead may rely on the compiler&apos;s
      strong type inference engine.
    </t-b>
    <t-b>
      <t-b>
        <details>
          <summary class="labelStyle darkItem">Type Declarations:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Declaring Code:</defn-head>
              <defn-code>
/*-- fully specified --*/
let i:i32 = 5;
let f:f64 = 3.4;
let a:[f32; 5] = [1.0, 1.5, 2.0, 1.5, 1.0];
let t:(i32, f64, String) = (1, 2.0, "three".to_string());
#[derive(Debug)]
struct S<'a>{i:i32, s:&'a str, };
let s:S = S{i:15, s:"a literal string" };
#[derive(Debug)]
enum E {BS(String), MS(String), PhD(String),};
let e:E = E::MS("Computer Engineering".to_string());

print!("\n  -- fully specified types --\n");
print!("\n  i = {:?}", i);
print!("\n  f = {:?}", f);
print!("\n  a = {:?}", a);
print!("\n  t = {:?}", t);
print!("\n  s = {:?}", s);
print!("\n  e = {:?}", e);

/*-- using type deduction --*/
let i = 5;
let f = 3.4;
let a = [1.0, 1.5, 2.0, 1.5, 1.0];
let t = (1, 2.0, "three".to_string());
let s = S{i:15, s:"a literal string" };
let e = E::MS("Computer Engineering".to_string());

print!("\n\n  -- using type deduction --\n");
print!("\n  i = {:?}", i);
print!("\n  f = {:?}", f);
print!("\n  a = {:?}", a);
print!("\n  t = {:?}", t);
print!("\n  s = {:?}", s);
print!("\n  e = {:?}", e);
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output:</defn-head>
              <defn-code>
-- fully specified types --

i = 5
f = 3.4
a = [1.0, 1.5, 2.0, 1.5, 1.0]
t = (1, 2.0, "three")
s = S { i: 15, s: "a literal string" }
e = MS("Computer Engineering")

-- using type deduction --

i = 5
f = 3.4
a = [1.0, 1.5, 2.0, 1.5, 1.0]
t = (1, 2.0, "three")
s = S { i: 15, s: "a literal string" }
e = MS("Computer Engineering")

              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </t-b>
    </t-b>
    <t-b>
      Occasionally the Rust compiler needs help defining life time of references.  It wants to
      ensure that a reference does not outlive the value to which it is bound. You can see an example
      of that help for the S struct, in the dropdown, where we tell the compiler that a literal string
      member must have the lifetime of the struct.  The member declaration syntax is: 
      <c-s>s:&amp;&apos;a str</c-s> where 
      the <c-s>&apos;a</c-s> says that the literal string has the same lifetime as the struct.
      <indent-block class="pad5">
        <c-s>struct S&lt;&apos;a&gt;{i:i32, s:&amp;&apos;a str, };</c-s>
      </indent-block>
      Where the notation <c-s>S&lt;&apos;a&gt;</c-s> identifies &quot;a&quot; as the lifetime of S.
      <a id="user-defined"></a>
    </t-b>
    <!--<num-cont>
      <num-item1>1.5.1</num-item1><num-item4>User-Defined Types:</num-item4>
    </num-cont>
    <t-b>
      <t-b>
        Rust does not have classes or inheritance.  It does, however, have structs and traits.  A trait is
        similar to an interface or abstract class.  Structs have public and private members and can implement
        traits as well as other functions.
      </t-b>
      <t-b>
        Here&apos;s an example, used in the details dropdown,
        below:
      </t-b>
      <t-b>
        <defn-block>
          <defn-head>Salutation Trait</defn-head>
          <defn-code>
trait Speaker {
    fn salutation(&self) -> String;
}
          </defn-code>
        </defn-block>
      </t-b>
      <t-b>
        The trait declares a salutation function that structs implement, like this:
      </t-b>
      <t-b>
        <defn-block>
          <defn-head>
            Implementing Saluation Trait
          </defn-head>
          <defn-code>
pub struct Presenter;
impl Speaker for Presenter {
    fn salutation(&self) -> String {
      "Hello, today we will discuss ...".to_string()
    }
} 
          </defn-code>
        </defn-block>
      </t-b>
    </t-b>
    <t->
      The code in the User-Defined Type dropdown illustrates how this can be used to implement
      polymorphic operations, e.g., function dispatching based on the type of value  bound to a reference,
      not on the type of the reference.
    </t->
    <t-b>
      That works because each trait has a virtual function pointer table used for function dispatching.
    </t-b>
    <t-b>
      <t-b>
        <details>
          <summary class="labelStyle darkItem">Example User-Defined Type:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Declaring Code:</defn-head>
              <defn-code>
///////////////////////////////////////////////////////////
// user-defined traits act like interfaces

trait Speaker {
    fn salutation(&self) -> String;
}

///////////////////////////////////////////////////////////
// The following structs act like classes that implement
// a Speaker interface

#[derive(Debug,Copy,Clone)]
pub struct Presenter;
impl Speaker for Presenter {
    fn salutation(&self) -> String {
      "Hello, today we will discuss ...".to_string()
    }
} 

#[derive(Debug)]
pub struct Friend {
    pub name : String,
}
impl Speaker for Friend {
    fn salutation(&self) -> String {
      let mut s = String::from("Hi good buddy, its me, ");
      let nm = self.name.as_str();
      s.push_str(nm);
      return s;
    }
}
impl Friend {
    #[allow(dead_code)]
    pub fn new(name : String) -> Self {
        Self {
            name,
        }  // note: no semicolon so Self is returned
    }
}
#[derive(Debug,Copy,Clone)]
pub struct TeamLead;
impl Speaker for TeamLead {
    fn salutation(&self) -> String {
      "Hi, I have a task for you ...".to_string()
    }
} 

              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
#[allow(dead_code)]
pub fn run() {
    
    print!("\n\n  {}","-- demo polymorphic struct instances --\n");
    let presenter : Presenter = Presenter;
    let joe : Friend = Friend::new("Joe".to_string());
    let sue : Friend = Friend::new("Sue".to_string());
    let team_lead : TeamLead = TeamLead;

    let mut v :Vec<&dyn Speaker> = Vec::new();
    v.push(&presenter);
    v.push(&joe);
    v.push(&sue);
    v.push(&team_lead);

    for speaker in v.iter() {
        print!("\n  {:?}",speaker.salutation());
    }
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
-- demo polymorphic struct instances --

"Hello, today we will discuss ..."
"Hi good buddy, its me, Joe"
"Hi good buddy, its me, Sue"
"Hi, I have a task for you ..."
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </t-b>
    </t-b>
    <t-b>
      In the next section we discuss Rust generics.  They provide a way of deferring definition of specific
      types used as function arguments and struct data members. 
    </t-b>-->

    <a id="objmodel"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.6</num-item1><num-item4>Rust Object Model:</num-item4>
    </num-cont>
    <t-b>
      Rust does not have classes but structs are used in a way very similar to the way classes are used in C++.
      Structs have:
      <indent-block class="pad5">
        <ul class="tight">
          <li>
            <strong>Composed members:</strong>
            <div>
              May be instances of language or user defined types.
            </div>
          </li>
          <li>
            <strong>Aggregated members:</strong> using the <n-s>Box&lt;T&gt;</n-s> construct
            <div>
              Box&lt;T&gt; is composed, but points to an instance of T in the native heap. 
              Box&lt;T&gt; acts like the std::unique_ptr&lt;T&gt; in C++.  That is, it provides
              a reference to data on the heap, but deallocates that data when it goes out of scope.
            </div>
          </li>
          <li>
            <strong>Methods:</strong>, both <n-s>static</n-s> and <n-s>non-static</n-s>
            <div>
              A non-static method is declared with a first argument of &amp;self, analogous to the
              &quot;this&quot; pointer in C++. When invoked the compiler generates code to pass
              a reference to the invoking instance so the user does not supply that argument.
              Static methods do not have the &amp;self argument, and so are unable to access member
              data.
            </div>
          </li>
          <li>
            <strong>Traits:</strong> implemented by the struct
            <div>
              Traits declare method signatures that must be defined for types that implement them.
              A trait may provide default method implementations but often does not. Traits are used
              like Java or C# interfaces and also provide type constraints for generic functions and
              types.
            </div>
          </li>
          <li>
            <strong>Access control:</strong> using the <n-s>pub</n-s> keyword
            <div>
              A typical struct will be declared public with <n-s>pub</n-s>.  Some of its methods will
              also be declared public, but we usually don&apos;t make the struct&apos;s member data public.
            </div>
          </li>
        </ul>
      </indent-block>
    </t-b>
    <t-b>
      It is interesting to note that traits can be applied to existing types, including those provided by
      the language, to add new methods for the type, much like C# extension methods, but easier to use.
    </t-b>
    <t-b>
      Here is an example of a user defined type:
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">User Defined Type with Traits:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Type Definition:</defn-head>
              <defn-code>
/////////////////////////////////////////////////
// probe_traits.rs - demo user defined traits

use std::fmt::{Debug};
use display::{*};
/*-----------------------------------------------
   Note that all trait functions are public
*/

/*-----------------------------------------------
   Show trait needs Super trait Debug 
   - provides default method implementation
*/
trait Show : Debug {
    fn show(&amp;self) {
        print!("\n  {:?}", &amp;self);
    }
}
/*-----------------------------------------------
   Stucts that use Size must implement fn size
   - no default impl provided
*/
trait Size {
    fn size(&amp;self) -&gt; usize;
}

#[derive(Debug, Copy, Clone)]
pub struct Test { // public type 
    x:i32, y:f64, // private data
}
/*-----------------------------------------------
   Implementing traits
*/
impl Show for Test {}  // using default impl
impl Size for Test {   // must provide impl
    fn size(&amp;self) -&gt; usize {
        use std::mem;
        mem::size_of::&lt;Test&gt;()
    }
}
/*-----------------------------------------------
   Implementing methods
*/
impl Test {
    pub fn new() -&gt; Self {
        Self {
            x:42,
            y:1.5,
        }
    }
    pub fn get_x(&amp;self) -&gt; i32 {
        self.x
    }
    pub fn set_x(&amp;mut self, v:i32) {
        self.x = v;
    }
    pub fn get_y(&amp;self) -&gt; f64 {
        self.y
    }
    pub fn set_y(&amp;mut self, v:f64) {
        self.y = v;
    }
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
pub fn run () {
    main_title("Demonstrating probe_traits");
    putline();

    sub_title("using Show trait");
    let mut t = Test::new();
    t.show();
    putline();

    sub_title("using getters and setters");
    t.set_x(3);
    t.set_y(-3.5);
    print!("\n  x = {}, y = {}", t.get_x(), t.get_y());
    putline();

    sub_title("using Size trait");
    print!("\n  size = Test instance t = {}", t.size());

    /*-------------------------------------------
       Implementing Size for built in types!
    */
    impl Size for i32 {
        fn size(&self) -> usize {
            std::mem::size_of::<i32>() as usize
        }
    }
    impl Size for f64 {
        fn size(&self) -> usize {
            std::mem::size_of::<f64>() as usize
        }
    }

    let sx = t.x.size();
    let sy = t.y.size();
    print!("\n  size of x = {}, size of y = {}", sx, sy);
    print!(
      "\n  4 bytes is size of pointer to trait vtable"
    );
    putline();

    sub_title("exploring struct layout with safe pointers");
    let mut t = Test::new();
    t.show();
    shows("\n  Note: Test implements traits:");
    shows("\n        Show, Size, Debug, Copy, Clone");
    shows(
      "\n        Missing 4 bytes is ptr to traits vtable.\n"
    );
    let rt = &t as *const Test;
    let rx = &t.x as *const i32;
    let ry = &mut t.y as *mut f64;
    let st = std::mem::size_of::<Test>();
    let sx = std::mem::size_of::<i32>();
    let sy = std::mem::size_of::<f64>();
    print!("\n  address of t   = {:?}", rt as i32);
    print!("\n  address of t.x = {:?}", rx as i32);
    print!("\n  address of t.y = {:?}", ry as i32);
    print!("\n  size of t      = {:?}", st);
    print!("\n  size of x      = {:?}", sx);
    print!("\n  size of y      = {:?}", sy);
    print!(
      "\n  address of t + st = {:?}", rt as i32 + st as i32
    );
    putline();
}              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
  Demonstrating probe_traits
 ============================

  using Show trait
 ------------------
  Test { x: 42, y: 1.5 }

  using getters and setters
 ---------------------------
  x = 3, y = -3.5

  using Size trait
 ------------------
  size = Test instance t = 16
  size of x = 4, size of y = 8
  4 bytes is size of pointer to trait vtable

  exploring struct layout with safe pointers
 --------------------------------------------
  Test { x: 42, y: 1.5 }
  Note: Test implements traits:
        Show, Size, Debug, Copy, Clone
        Missing 4 bytes is ptr to traits vtable.

  address of t   = 8190584
  address of t.x = 8190592
  address of t.y = 8190584
  size of t      = 16
  size of x      = 4
  size of y      = 8
  address of t + st = 8190600

              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <div style="width:calc(100vw - 9rem);">
      <photosizer-block src="Pictures/RustStaticBinding.jpg" width="600" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 3. Trait Method Binding
        </span>
      </photosizer-block>
    </div>
    <t-b>
      Any type with a trait has an associated virtual function pointer table (Vtbl), as shown in Figure 3.
      If you looked at the &quot;User Defined Type with Traits&quot; details dropdown, above, you saw that the layout
      of a struct can be analyzed using safe pointers<sup>1</sup>.  The results of that analysis are shown in 
      Table 1., below.
    </t-b>
    <t-b>
      <div>
        <table>
          <tr>
            <th colspan="3" class="darkItem fw_norm">
              Table 1. Test Struct Memory Layout
            </th>
          </tr>
          <tr>
            <th class="darkItem fw_norm">Component</th>
            <th class="darkItem fw_norm">Address</th>
            <th class="darkItem fw_norm">Size - bytes</th>
          </tr>
          <tr>
            <th class="lightItem fw_norm" style="text-align:right;">Test Struct</th>
            <th class="lightItem fw_norm">8190584</th>
            <th class="lightItem fw_norm" style="text-align:right;">16</th>
          </tr>
          <tr>
            <th class="lightItem fw_norm" style="text-align:right;">y:f64</th>
            <th class="lightItem fw_norm">8190584</th>
            <th class="lightItem fw_norm" style="text-align:right;">8</th>
          </tr>
          <tr>
            <th class="lightItem fw_norm" style="text-align:right;">x:i32</th>
            <th class="lightItem fw_norm">8190592</th>
            <th class="lightItem fw_norm" style="text-align:right;">4</th>
          </tr>
          <tr>
            <th class="lightItem fw_norm" style="text-align:right;">padding</th>
            <th class="lightItem fw_norm">8190596</th>
            <th class="lightItem fw_norm" style="text-align:right;">4</th>
          </tr>
        </table>
      </div>
    </t-b>
    <t-b>
      We see from the table that each field associated with a struct lies within the memory footprint of 
      the struct, and if the
      struct has any traits<sup>2</sup> there will be an embedded pointer to a Vtbl as well.
      There is only one Vtbl for each type, so the pointer address value is invariant.
    </t-b>
    <t-b>
      Because of this layout strategy, a copy<sup>3</sup>, is simply a memcopy of the entire struct
      to the destination. For structs that contain no-copy (non-blittable) fields, only moves are
      allowed, but they work the same way, doing a mem-copy to the destination.  The only difference
      is that for copies the source remains valid, while for moves, the source becomes invalid.
    </t-b>
    <div style="width:calc(100vw - 9rem);">
      <photosizer-block src="Pictures/RustVtbl.jpg" width="600" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 3. Trait Virtual Dispatching
        </span>
      </photosizer-block>
    </div>
    <t-b>
      Rust structs support polymorphism through virtual dispatching, as illustrated in Figure 4.  Suppose we
      implement a function:
      <s-halfEm></s-halfEm>
      <indent-block class="pad5">
        <defn-block>
          <defn-head>Function accepting trait object</defn-head>
          <defn-code>
fn size_is(o:&dyn Size) ->usize {
  o.size()  // Size::size()
}

          </defn-code>
        </defn-block>
      </indent-block>
      We can pass any type to <c-s>size_is</c-s> as long as the type implements the Size trait. Each type that
      implements traits has an associated virtual method table (vtble).  Rust uses type inference to associate an input
      instance, <c-s>o</c-s> for <c-s>size_is(o:&dyn Size)</c-s> with its vtble and calls the size method implemented
      for that type.
    </t-b>
    <t-b>
      That means that we can write one function like <c-s>size_is</c-s> that will work for an open-ended number of
      types - they just need to implement the Size trait.  And, that function implementation doesn&apos;t need to 
      know anything about the incoming types.  It just uses the trait methods. That is a big deal! 
    </t-b>
    <div class="clear"></div>
    <t-b>
      <hr class="spreadup" />
      <ol class="footnote">
        <li>
          You can create pointers and display their addresses in safe code, which is what we have
          done for this analysis.  You can only dereference pointers in unsafe blocks, but we did
          not need to do that.
        </li>
        <li>
          Almost every struct has traits, at least Debug, and if copyable, Copy and Clone. Adding
          custom traits can be very useful, as shown in this and the next example.
        </li>
        <li>
          Stucts with all blittable fields can implement the Copy trait.  Those with non-blittable
          fields cannot.
        </li>
      </ol>
    </t-b>
    <div class="clear"></div>
    <a id="userdeftypes"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.7</num-item1><num-item4>User-Defined Types:</num-item4>
    </num-cont>
    <t-b>
      <t-b>
        Rust does not have classes or inheritance.  It does, however, have structs and traits.  A trait is
        similar to an interface or abstract class.  Structs have public and private members and can implement
        traits as well as other functions.
      </t-b>
      <t-b>
        Here&apos;s an example, used in the details dropdown,
        below:
      </t-b>
      <t-b>
        <defn-block>
          <defn-head>Salutation Trait</defn-head>
          <defn-code>
trait Speaker {
    fn salutation(&self) -> String;
}
          </defn-code>
        </defn-block>
      </t-b>
      <t-b>
        The trait declares a salutation function that structs implement, like this:
      </t-b>
      <t-b>
        <defn-block>
          <defn-head>
            Implementing Saluation Trait
          </defn-head>
          <defn-code>
pub struct Presenter;
impl Speaker for Presenter {
    fn salutation(&self) -> String {
      "Hello, today we will discuss ...".to_string()
    }
} 
          </defn-code>
        </defn-block>
      </t-b>
    </t-b>
    <t->
      The code in the User-Defined Type dropdown illustrates how this can be used to implement
      polymorphic operations, e.g., function dispatching based on the type of value  bound to a reference,
      not on the type of the reference.
    </t->
    <t-b>
      That works because each trait has a virtual function pointer table used for function dispatching.
    </t-b>
    <t-b>
      <t-b>
        <details>
          <summary class="labelStyle darkItem">Example User-Defined Type:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Declaring Code:</defn-head>
              <defn-code>
///////////////////////////////////////////////////////////
// user-defined traits act like interfaces

trait Speaker {
    fn salutation(&self) -> String;
}

///////////////////////////////////////////////////////////
// The following structs act like classes that implement
// a Speaker interface

#[derive(Debug,Copy,Clone)]
pub struct Presenter;
impl Speaker for Presenter {
    fn salutation(&self) -> String {
      "Hello, today we will discuss ...".to_string()
    }
} 

#[derive(Debug)]
pub struct Friend {
    pub name : String,
}
impl Speaker for Friend {
    fn salutation(&self) -> String {
      let mut s = String::from("Hi good buddy, its me, ");
      let nm = self.name.as_str();
      s.push_str(nm);
      return s;
    }
}
impl Friend {
    #[allow(dead_code)]
    pub fn new(name : String) -> Self {
        Self {
            name,
        }  // note: no semicolon so Self is returned
    }
}
#[derive(Debug,Copy,Clone)]
pub struct TeamLead;
impl Speaker for TeamLead {
    fn salutation(&self) -> String {
      "Hi, I have a task for you ...".to_string()
    }
} 

              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Using Code:</defn-head>
              <defn-code>
#[allow(dead_code)]
pub fn run() {
    
    print!(
      "\n\n  {}",
      "-- demo polymorphic struct instances --\n"
    );
    let presenter : Presenter = Presenter;
    let joe : Friend = Friend::new("Joe".to_string());
    let sue : Friend = Friend::new("Sue".to_string());
    let team_lead : TeamLead = TeamLead;

    let mut v :Vec<&dyn Speaker> = Vec::new();
    v.push(&presenter);
    v.push(&joe);
    v.push(&sue);
    v.push(&team_lead);

    for speaker in v.iter() {
        print!("\n  {:?}",speaker.salutation());
    }
}
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
-- demo polymorphic struct instances --

"Hello, today we will discuss ..."
"Hi good buddy, its me, Joe"
"Hi good buddy, its me, Sue"
"Hi, I have a task for you ..."
              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </t-b>
    </t-b>
    <t-b>
      In the next section we discuss Rust generics.  They provide a way of deferring definition of specific
      types used as function arguments and struct data members. 
    </t-b>

    <a id="generics"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.8</num-item1><num-item4>Generics:</num-item4>
    </num-cont>
    <t-b>
      Rust supports generics for functions and structs:
    </t-b>
    <t-b>
      <div>
        <defn-outerBlock>
          <defn-block>
            <defn-head>Generic Function:</defn-head>
            <defn-code>
fn demo_ref&lt;T&gt;(t:&amp;T) where T:Debug  {
  show_type(t);
  show_value(t);
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Generic Struct:</defn-head>
            <defn-code>
#[derive(Debug)]
struct Point&lt;T&gt; { x:T, y:T, z:T, }

            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </div>
    </t-b>
    <t-b>
      Rust generics are similar to C# and Java Generics.  They don&apos;t support specialization to
      broaded the number of types accepted, like C++.  They do define constraints to narrow the number
      of types that compile, like C# and Java. In the function example, above, we&apos;ve used a constraint
      to allow only those types with a Debug trait to compile.
    </t-b>
    <t-b>
      In the details dropdown, below, we&apos;ve added a another example for both functions and structs, and
      shown using code and output as well.
    </t-b>
    <t-b>
      <indent-blocks>
        <details>
          <summary class="labelStyle darkItem">Generics Examples:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>Generic Functions</defn-head>
              <defn-code>
/*-----------------------------------------
No-copy arguments will be moved
*/
fn demo&lt;T:Debug&gt;(t:T) {
  show_type(&amp;t);
  show_value(&amp;t);
}

/*-----------------------------------------
refs so arguments will not be moved
*/
fn demo_ref&lt;T&gt;(t:&amp;T) where T:Debug  {
  show_type(t);
  show_value(t);
}

</defn-code>
<defn-head class="defnBorderTop">Using Code:</defn-head>
<defn-code>
let mut s = String::from("this is a test");

sub_title("demo_ref");
demo_ref(&amp;s);
let pi = 3.1415927;
demo_ref(&amp;pi);
s.push('Z');
putline();

sub_title("demo");
demo(s);
demo(pi);
// statement below won't compile - s moved
// s.push('Z');
putline();

</defn-code>
<defn-head class="defnBorderTop">Output:</defn-head>
<defn-code>
 demo_ref
----------
TypeId: alloc::string::String, size: 12
value: "this is a test"
TypeId: f64, size: 8
value: 3.1415927

demo
------
TypeId: alloc::string::String, size: 12
value: "this is a testZ"
TypeId: f64, size: 8
value: 3.1415927
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Generic Structs</defn-head>
              <defn-code>
#[derive(Debug)]
struct Point&lt;T&gt; { x:T, y:T, z:T, }

// Copy trait works because blittable, provided
// that T is blittable
#[derive(Debug, Copy, Clone)]
struct BetterPoint&lt;T&gt; { x:T, y:T, z:T, }

              </defn-code>
              <defn-head class="defnBorderTop">Using Code:</defn-head>
              <defn-code>
sub_title("demo_ref and demo with struct");
let mut pt = Point { x:1.0, y:-1.5, z:2.3 };
demo_ref(&amp;pt);
pt.x = 3.2;
demo(pt);
// statement below won't compile - pt moved for demo
// pt.x = 3.2;
putline();

sub_title("demo_ref and demo with copy-able struct");
let mut bpt = BetterPoint { x:1.0, y:-1.5, z:2.3 };
demo_ref(&amp;bpt);
bpt.x = 3.2;
demo(bpt);
// statement ok - pt copied for demo
bpt.x = 3.2;
putline();

sub_title("demo_ref and demo with copy-able struct");
let mut bpt = BetterPoint { x:"one", y:"two", z:"three" };
demo_ref(&amp;bpt);
bpt.x = "1";
demo(bpt);
// statement ok - pt copied for demo
bpt.x = "one";
putline();

sub_title("demo_ref and demo with non copy-able struct");
let mut bpt = BetterPoint {
  x:"one".to_string(),
  y:"two".to_string(),
  z:"three".to_string()
};
demo_ref(&amp;bpt);
bpt.x = "four".to_string();
demo(bpt);
// won't compile - bpt not blittable so it was moved
// bpt.x = "one".to_string();

putlinen(2);
              </defn-code>
              <defn-head class="defnBorderTop">Output:</defn-head>
              <defn-code>
 demo_ref and demo with struct
-------------------------------
TypeId: generics_probes::Point<f64>
, size: 24
value: Point { x: 1.0, y: -1.5, z: 2.3 }
TypeId: generics_probes::Point<f64>
, size: 24
value: Point { x: 3.2, y: -1.5, z: 2.3 }

 demo_ref and demo with copy-able struct
-----------------------------------------
TypeId: generics_probes::BetterPoint<f64>
, size: 24
value: BetterPoint { x: 1.0, y: -1.5, z: 2.3 }
TypeId: generics_probes::BetterPoint<f64>
, size: 24
value: BetterPoint { x: 3.2, y: -1.5, z: 2.3 }

 demo_ref and demo with copy-able struct
-----------------------------------------
TypeId: generics_probes::BetterPoint<&str>
, size: 24
value: BetterPoint { x: "one", y: "two", z: "three" }
TypeId: generics_probes::BetterPoint<&str>
, size: 24
value: BetterPoint { x: "1", y: "two", z: "three" }

 demo_ref and demo with non copy-able struct
---------------------------------------------
TypeId: generics_probes::BetterPoint<alloc::string::String>
, size: 36
value: BetterPoint { x: "one", y: "two", z: "three" }
TypeId: generics_probes::BetterPoint<alloc::string::String>
  , size: 36
value: BetterPoint { x: "four", y: "two", z: "three" }

              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </indent-blocks>
    </t-b>
    <t-b>
      This chapter has focused on the main features and models of Rust.  You will find more details in
      succeeding chapters.
    </t-b>
    <a id="epilogue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.9</num-item1><num-item4>Epilogue:</num-item4>
    </num-cont>
    <t-b>
      The models we&apos;ve covered here: Code Structure, Build Process, Ownership, and User-Defined
      Types and Traits are what make Rust unique and interesting.  We will see more details for each
      of these in the coming chapters.
    </t-b>
    <t-d>
      Rust is interesting, worth spending effort to gain a working knowledge of the language
      and its uses.  To help you do that, I&apos;m providing a set of exercises for you to begin that process.
      I won&apos;t be providing answers, but you will find code in <a href="RustBasicDemos.html">RustBasicDemos</a>
      very similar to code for the completed exercises.
    </t-d>

    <a id="exercises"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.10</num-item1><num-item4>Exercises:</num-item4>
    </num-cont>
    <t-b class="indent" style="margin-bottom:2em;">
      <ol class="tight">
        <li>
          Write code that intentionally attempts to violate each of the ownership rules.  Observe when they
          fail to compile, comment out the offending code with commentary about why the code failed to 
          compile.
        </li>
        <li>
          Declare an array of some primitive type, and visit each element, printing out its value. Now repeat
          for a Vec holding the same primitive type.
        </li>
        <li>
          Declare a struct that defines a three dimensional point.  Define two points with different values
          and print out the differences between each of the three coordinates for the two points.
        </li>
        <li>
          Repeat the previous exercise using tuples instead of structs.
        </li>
      </ol>
    </t-b>

    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>1.11</num-item1><num-item4>References:</num-item4>
    </num-cont>
    <table style="width:calc(100vw - 12rem);">
      <tr>
        <th class="darkItem">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.oreilly.com/programming/free/files/why-rust.pdf">Why Rust? - Jim Blandy</a>
        </td>
        <td class="lightItem">
          Monograph on why Rust is important
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://users.rust-lang.org/">Rust users forum</a>
        </td>
        <td class="lightItem">
          Answers to a broad range of questions from beginner to advanced.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/">A half-hour to learn Rust</a>
        </td>
        <td class="lightItem">
          Code fragments with commentary that cover most of the Rust ideas.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a>
        </td>
        <td class="lightItem">
          First thing to read.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://stevedonovan.github.io/rust-gentle-intro/readme.html">A Gentle Introduction To Rust</a>
        </td>
        <td class="lightItem">
          First thing to read.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/book/">The Rust Book</a>
        </td>
        <td class="lightItem">
          Rust docs - walkthrough of syntax
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://cheats.rs/">Rust cheat sheet</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
        <td class="lightItem">
          Container diagrams
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/reference/">The Rust Reference Book</a>
        </td>
        <td class="lightItem">
          Rust&apos;s approximation of a language standard. Clear and well written, with a glossary at the end.
          Its <a href="https://github.com/rust-lang/reference">github site</a> shows that changes are still being
          actively incorporated.
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">RIP Tutorial on Rust</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, the stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/ebook/rust">Learning Rust ebook</a></td>
        <td class="lightItem">
          Comprehensive coverage from RIP, stackoverflow archive
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://riptutorial.com/rust/awesome-learning/book">Rust - Awesome Book</a></td>
        <td class="lightItem">
          lots of interesting discussions from RIP, the Stackoverflow Archive
        </td>
      </tr>
        <tr>
          <td class="lightItem">
            <a href="https://docs.rs/dtolnay/0.0.8/dtolnay/macro._02__reference_types.html">
              Shared&nbsp;reference&nbsp;&amp;T&nbsp;and&nbsp;exclusive&nbsp;reference&nbsp;&amp;mut&nbsp;T
            </a>
          </td>
          <td class="lightItem">
            More accurate description than immutable reference and mutable reference
          </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.twelve21.io/getting-started-with-rust-on-windows-and-visual-studio-code/">
            Getting Started with Rust on Windows and Visual Studio Code
          </a>
        </td>
        <td class="lightItem">
          Install Rust, Verify, Configure Visual Studio Code, Create Hello World, Create Build Task, 
          Configuring Unit Tests, Configure Debugging, 
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.rust-lang.org/">rust-lang.org home page</a>
        </td>
        <td class="lightItem">
          Links to download and documentation
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.youtube.com/watch?v=zF34dRivLOw">(video) Rust - Crash Course | Rustlang</a>
        </td>
        <td class="lightItem">
          Code demo using basic types.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.tutorialspoint.com/rust/index.htm">Tutorial - tutorialspoint.com</a>
        </td>
        <td class="lightItem">
          Tutorials for most of the Rust parts with code examples.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://deterministic.space/">Blog - Pascal's Scribbles</a>
        </td>
        <td class="lightItem">
          Pascal Hertleif - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://blog.mgattozzi.dev/">Blog - Barely Functional</a>
        </td>
        <td class="lightItem">
          Michael Gattozzi - Rust contributor
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.snoyman.com/blog/2020/05/no-mutable-parameters-in-rust">Blog - S.Noyberg</a>
        </td>
        <td class="lightItem">
          Examples of aysnc/await, tokio, lifetime, ...
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="http://kmcallister.github.io/talks/rust/2015-contributing-to-rust/slides.html">Compilation details</a>
        </td>
        <td class="lightItem">
          kmcallister.github.io
        </td>
      </tr>
      <tr>
        <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
        <td class="darkItem" style="line-height:0.5em;">&nbsp;</td>
      </tr>
      <!--<tr>
        <td class="lightItem">
          <a href="https://www.javatpoint.com/rust-tutorial">Tutorial - javatpoint.com</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>-->
    </table>
  </bb-55>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>