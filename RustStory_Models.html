<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Prologue.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Rust Models</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="RustStory_Data.html">N</a>
  <a id="Prev" href="RustStory_Prologue.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Rust Models</h1>
      <!--<h3 id="subtitle">Why C++?, What&apos;s covered?</h3>-->
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">Top</a>, <a href="#refs">References</a>
     </rt-b>
   </toc-b>

  <bb-55 class="indent">
  <a id="prolog"></a>
  <hr class="spread" />
    <num-cont>
      <num-item1>1.0</num-item1><num-item4>Prologue:</num-item4>
    </num-cont>

  <a id="structure"></a>
  <hr class="spread" />
    <num-cont>
      <num-item1>1.1</num-item1><num-item4>Code Structure:</num-item4>
    </num-cont>
    <t-b>
      Rust code structure is based on <n-s>crates</n-s>. A <n-s>crate</n-s> for an executable is a folder containing a 
      file <n-s>Cargo.toml</n-s> and a subdirectory named <n-s>src</n-s>.  Inside <n-s>src</n-s> is a file 
      called <n-s>main.rs</n-s>.
    </t-b>
    <t-b>
      All of this is built with a Rust tool called <n-s>Cargo</n-s>.  <n-s>Cargo</n-s> is a package manager,
      that can build, run, and clean a Rust <n-s>crate</n-s> as well as create a new <n-s>crate</n-s>
      and download crates from <a href="https://Crates.io">https://crates.io</a>.
    </t-b>
    <div style="width:calc(100vw - 6rem);">
      <photosizer-block src="Pictures/Crate.JPG" width="700" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 1. Crate directories in VS Code
        </span>
      </photosizer-block>
    </div>
    <t-b>
      Figure 1. shows a newly created <n-s>crate</n-s>.  The process is simple.
      <indent-block class="pad10">
        <ol class="tight">
          <li>
            Open a Developer&apos;s command prompt
          </li>
          <li>
            Create a directory temp with <n-s>mkdir temp</n-s>
          </li>
          <li>
            Issue the command: <n-s>cargo new demo_crate</n-s>. That creates everything shown in Figure 1.
            <indent-block class="pad10">
              The image is a screen shot of Visual Studo Code with opened folder demo_crate.
            </indent-block>
            The <n-s>Cargo</n-s> tool is in your path after you install Rust.
          </li>
          <li>
            <n-s>main.rs</n-s> is a demonstration &quot;Hello World&quot; program.
          </li>
          <li>
            Build with the command <n-s>cargo build</n-s> and run with <n-s>cargo run</n-s>.
          </li>
          <li>
            Clean the crate with <n-s>cargo clean</n-s>.
          </li>
        </ol>
      </indent-block>
      <t-b>
        A typical Rust program consists of a binary crate (one with a main.rs) and perhaps several
        library crates that implement all the functionality used by main.
      </t-b>
      <t-b>
        You create a library crate with the command <n-s>cargo new [library name] --lib</n-s>.  That builds
        the same structure as shown here except that in the folder <n-s>src</n-s> you find a file
        <n-s>lib.rs</n-s> that has functions that implement the library&apos;s operations and a test fixture
        for running a sequence of tests on the library.
      </t-b>
      <t-b>
        The binary crate must specify each of the libraries it uses with dependencies in its <n-s>Cargo.toml</n-s>
        file. All of this is illustrated by the code in the two details dropdowns, below.
      </t-b>
    </t-b>
    <num-cont>
      <num-item1>1.1.1</num-item1><num-item4>Display Library</num-item4>
    </num-cont>
    <t-b>
      This display library provides a set of display functions to help generate demonstration and
      debug io for Rust programs.  It contains functions:
      <indent-block class="pad10">
        <ol class="tight">
          <li>
            <n-s>show_type&lt;T&gt;(_value: &amp;T)</n-s> - 
            Displays type and size of input
          </li>
          <li>
            <n-s>log&lt;T&gt;(value: &amp;T)</n-s> - 
            Displays type and size of input, followed by its value.
          </li>
          <li>
            <n-s>title(msg: String)</n-s> - 
            Displays msg followed by an underline.
          </li>
          <li>
            <n-s>putline()</n-s> - Emits a newline.
          </li>
          <li>
            <n-s>putlinen(n: usize)</n-s> - Emits n newlines.
          </li>
        </ol>
      </indent-block>
      The code in <n-s>display_test</n-s> shows how it imports the library, <n-s>display</n-s>.
      Look at the dependencies in <n-s>display_test::Cargo.toml</n-s> and at the extern crate
      declaration at the top of the code in <n-s>display_test::main.rs</n-s>
    </t-b>
    <indent-blocks>
    <details>
      <summary class="labelStyle, darkItem">display_test</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>display_test::Cargo.toml</defn-head>
            <defn-code>
[package]
name = "test_display"
version = "0.1.0"
authors = ["James W. Fawcett <jfawcett@twcny.rr.com>"]
edition = "2018"

[dependencies]
display = { path = "../display" }
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>

C:\github\JimFawcett\RustBasicDemos\display_test>
cargo -q run

 test types
------------
 TypeId: alloc::string::String, size: 12
 value:  String (8): a string
 TypeId: i8, size: 1
 value:  100
 TypeId: alloc::vec::Vec&lt;i32&gt;, size: 12
 value:  [-1, 0, 1]
 TypeId: test_display::main::Test, size: 1
 value:  Test1
 TypeId: test_display::main::Test, size: 1
 value:  Test2
 TypeId: test_display::Point, size: 24
 value:  Point { x: 1.0, y: 1.5, z: 2.0 }

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>display_test::main.rs</defn-head>
            <defn-code>
/////////////////////////////////////////////////////////////
// test_display::main.rs - test display library            //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 Feb 2020  //
/////////////////////////////////////////////////////////////
/*
  Usually you test a library using the library's built in
  test functions.  But those cannot write to the console
  because they are a compiled part of the library which
  has no console.

  So I've constructed this separate main that uses the
  library just like any other application.
*/

extern crate display;
use display::{ putline, title, log, putlinen };

#[derive(Debug)]
struct Point {
  x: f64,
  y: f64,
  z: f64,
}

fn main() {
  putline();
  title("test types".to_string());
  let mut str = String::new();
  str.push_str("a string");
  log(&amp;str);
  let an_i8: i8 = 100;
  log(&amp;an_i8);
  let mut vi : Vec&lt;i32&gt; = Vec::new();
  vi.push(-1);
  vi.push(0);
  vi.push(1);
  log(&amp;vi);
  #[derive(Debug)]
  enum Test { Test1, Test2, };
  log(&amp;Test::Test1);
  log(&amp;Test::Test2);
  let point = Point { x:1.0, y:1.5, z:2.0 };
  log(&amp;point);
  putlinen(1);
}
            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
  </indent-blocks>
  <t-b>
    The code in <n-s>display</n-s> shows the structure of a lib crate. Note how the library
    imports Rust std library facilities with a series of use std::xxxx statements. These
    do essentially the same thing that #include &lt;xxxx&gt; declarations do in C++.
  </t-b>
  <indent-blocks>
    <details>
      <summary class="labelStyle, darkItem">display library</summary>
      <t-b>
        <defn-outerBlock>
          <defn-block>
            <defn-head>display::Cargo.toml</defn-head>
            <defn-code>
[package]
name = "display"
version = "0.1.0"
authors = ["James W. Fawcett &lt;jfawcett@twcny.rr.com&gt;"]
edition = "2018"

[dependencies]

            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
C:\github\JimFawcett\RustBasicDemos\display>
cargo test
Compiling display v0.1.0
(C:\github\JimFawcett\RustBasicDemos\display)
Finished test [unoptimized + debuginfo]
target(s) in 0.63s
Running target\debug\deps
\display-7c39a3f9b415f17e.exe

running 1 test
test tests::test_types ... ok

test result: ok.
1 passed; 0 failed; 0 ignored; 0 measured;
0 filtered out

Doc-tests display

running 0 tests

test result: ok.
0 passed; 0 failed; 0 ignored; 0 measured;
0 filtered out

            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>display::lib.rs</defn-head>
            <defn-code>
///////////////////////////////////////////////////////////////
// display::main.rs tests - Demonstrate display types        //
//                                                           //
// Jim Fawcett, https://JimFawcett.github.io, 14 Feb 2020    //
///////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Debug)]
    struct Point {
        x: f64,
        y: f64,
        z: f64,
    }
    #[test]
    /*
       Library doesn't write to console, so all this tests is
       no panic occurred.  See test_display for useful tests.
    */
    fn test_types() {

        // test code elided

    }
}

/////////////////////////////////////////////////////////////
// display::main.rs - Demonstrate display types            //
//                                                         //
// Jim Fawcett, https://JimFawcett.github.io, 14 Feb 2020  //
/////////////////////////////////////////////////////////////
/*
   log and do_work are derived from:
   https://doc.rust-lang.org/beta/std/any/index.html

*/
use std::fmt::Debug;
use std::any::Any;
use std::any::type_name;
use std::mem::size_of;

/*---------------------------------------------------------
   show type name on console
   - expects T to implement Debug
   - see #[define(Debug)] attributes, above 
*/
pub fn show_type&lt;T: Any + Debug&gt;(_value: &amp;T) {
    let name = type_name::&lt;T&gt;();
    print!(
      "\n  TypeId: {}, size: {}", name, size_of::&lt;T&gt;()
    );
}

/*---------------------------------------------------------
   log type name and value to console
   - expects T to implement Debug
   - see #[define(Debug)] attributes, above 
*/
pub fn log&lt;T: Any + Debug&gt;(value: &amp;T) {
    let value_any = value as &amp;dyn Any;
    let name = type_name::&lt;T&gt;();
    print!(
      "\n  TypeId: {}, size: {}", name, size_of::&lt;T&gt;()
    );

    // Try to convert our value to a `String`. If successful, 
    // we want to output the String`'s length as well as its 
    // value. If not, it's a different type: just print it 
    // out unadorned.

    match value_any.downcast_ref::&lt;String&gt;() {
        Some(as_string) =&gt; {
            print!(
              "\n  value:  String ({}): {}", 
              as_string.len(), as_string
            );
        }
        None =&gt; {
            print!("\n  value:  {:?}", value);
        }
    }
}

/*---------------------------------------------------------
   Display underlined title on console
*/
pub fn title(msg: String) {
    print!("\n  {}", msg);
    let s = std::iter::repeat('-').take(msg.len() + 2)
            .collect::&lt;String&gt;();
    print!("\n {}", s);
}
/*-- push a single newline to console --*/

pub fn putline() {
    println!("\n");
}
/*-- pust n newlines to console --*/

pub fn putlinen(n: usize) {
    let s = std::iter::repeat('\n').take(n)
            .collect::&lt;String&gt;();
    println!("{}", s);
}

            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </t-b>
    </details>
    </indent-blocks>
    <h3>Build Process:</h3>
    <h3>Ownership:</h3>
    <h3>Types:</h3>
  </bb-55>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>