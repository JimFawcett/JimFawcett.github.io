<!DOCTYPE html>
<html>
<!--
  index.html
    Site home page
-->
<head>
  <title>RustStory Data</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--<link rel="stylesheet" href="css/StylesTemplate.css" />-->
  <!--<link rel="stylesheet" href="css/StylesDefault.css" />-->
  <!--<link rel="stylesheet" href="css/StylesBrownTheme.css" />-->
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeRust.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <!--<script src="js/ScriptsPageFrameDefaults.js"></script>-->
  <script src="js/ScriptsPageFrame.js"></script>
  <script src="js/ScriptsPageFramePagesRustStory.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <!-- No need for Pages script for pages with no next or prev pages -->
  <!--<script src="js/ScriptsPageFramePages.js"></script>-->
  <style>
    #github .note {
      border: 1px solid var(--dark);
      padding:0.75em 1.5em;
      margin-top:1.25em;
      margin-bottom:1.25em;
      background-color: var(--light);
      color: var(--dark);
      max-width:50em;
    }
    #github h2 {
      margin-top: 0.75em;
    }
    #github ol.tight li {
      margin-top:0.15em;
      margin-bottom:0.15em;
    }
  </style>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="RustStory_Operations.html">Next</a>
  <a id="Prev" href="RustStory_Models.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="page">RustStory Data</div>
      <div id="modified">6/8/2022</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 2. - Rust Data</h1>
      <h3 id="subtitle">Types, type deduction, ownership</h3>
    </hgroup>
  </header>
    <div style="height:0.5em;"></div>
    <a id="prologue"></a>
    <h2>1.0&nbsp;&nbsp;Prologue</h2>
    <t-b>
      Compiler enforced memory safety is one of the primary features of Rust. That is implemented
      with a strict ownership policy, ensuring that aliasing and mutation do not occur concurrently
      for any instance of a Rust type.    
    </t-b>
    <t-b>
      <div>
        <defn-outerBlock>
          <defn-block>
            <defn-head>Definition: Alias</defn-head>
            <defn-body>
              Two or more identifiers are bound to part or all of the same memory location.<br />
              Example: <c-s>let mut iden1 = vec![1,2,3]; let iden2 = &iden1[1];</c-s>
            </defn-body>
          </defn-block>
          <defn-block>
            <defn-head>Definition: Mutation</defn-head>
            <defn-body>
              Operations on an identifier change its bound value.<br />
              Example: <c-s>iden1.push(4);</c-s>
            </defn-body>
          </defn-block>
        </defn-outerBlock> 
      </div>
    </t-b>
    <t-b>
      By value, we mean the state of an identifier&apos;s bound instance.  The value of a String, for example,
      is the collection of all its characters. The issue for memory safety is that changes to the String&apos;s
      state may change its memory allocation if the original allocation did not have enough capacity for the 
      change.  Thus all aliases of the identifier responsible for the change will hold invalid references.
    </t-b>
    <t-b>
      When new names bind to an existing value, the value will, for blittable types, be copied, and
      will be moved for non-blittable types.  Note that a move is a tranfer of ownership, so the
      original owner may no longer access that value.  References support borrowing, providing access to the
      owning instance&apos;s value while suspending the owner&apos;s ability to mutate.  When borrowing
      terminates, the owner&apos;s ability to mutate is restored.
    </t-b>
    <t-b>
      All of these rules are enforced by the Rust compiler.  When a rule is violated, the compiler emits
      a useful error message that helps a designer fix the violation.
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="lifecycle"></a>
    <h3>1.1&nbsp;&nbsp;Data and its Life Cycle</h3>
    <t-b>
      Rust data comes in two flavors (see <a href="https://cheats.rs/#basic-types">basic-types</a> for details):
      <div class="pad5" style="margin-left:1em;">
        <ol class="tight">
          <li>
            <strong>Blittable types:</strong>
            <div class="pad5">
              Stored entirely in one contiguous block of stack memory.
              <indent-block>
                <ul class="tight">
                  <li>
                    Basic Types:
                    <div>
                      <c-s>
                        u8, i8, u16, i16, u32, i32, u64, i64, usize, isize,
                        f32, f64, bool, char, str
                      </c-s>
                    </div>
                  </li>
                  <li>
                    Aggregate Types:
                    <div>
                      <c-s>
                        array, tuple, struct <n-s style="font-size:1rem;">if all their items are blittable</n-s>
                      </c-s>
                    </div>
                  </li>
                </ul>
              </indent-block>
            </div>
          </li>
          <li>
            <strong>Non-Blittable types:</strong>
            <div class="pad5">
              Control block stored in one contiguous block of stack memory with references
              to data held in the heap.
              <indent-block>
                <ul class="tight">
                  <li>
                    Std Library Types:
                    <div>
                      <c-s>
                        String, Box, Vec, VecDeque, LinkedList, HashMap, HashSet, 
                        BTreeMap, BTreeSet, BinaryHeap
                      </c-s>
                    </div>
                  </li>
                  <li>
                    Aggregate Types:
                    <div>
                      <c-s>
                        array, tuple, struct <n-s style="font-size:1rem;">if each has at least one non-blittable member</n-s>
                      </c-s>
                    </div>
                  </li>
                </ul>
              </indent-block>
            </div>
          </li>
        </ol>
      </div>
    </t-b>
    <div style="width:calc(100vw - 6rem);">
      <photosizer-block src="Pictures/StringMove.jpg" width="500" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 1. String Move
        </span>
      </photosizer-block>
    </div>
    <t-b>
      Blittable data values are copied:
      <indent-block class="pad5">
        <div>
          <c-s>let x = 3.5;</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Creates an <c-s>x:f64</c-s> on the stack initialized with the value <c-s>3.5</c-s>. 
          </t-b>
        </div>
      </indent-block>
      <indent-block class="pad5">
        <div>
          <c-s>let y = x;</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Creates an <c-s>y:f64</c-s> on the stack and copies <c-s>x</c-s>&apos;s value into y.
            <c-s>x</c-s> is still valid.
          </t-b>
        </div>
      </indent-block>
    </t-b>
    <t-b>
      Non-Blittable data values are moved:
      <indent-block class="pad5">
        <div>
          <c-s>let s = String::from("a string");</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Creates an <c-s>s:String</c-s> control block on the stack pointing to continguous heap memory 
            containing the characters &quot;<c-s>a string</c-s>&quot;
          </t-b>
        </div>
      </indent-block>
      <indent-block class="pad5">
        <div>
          <c-s>let t = s;</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Copies the <c-s>s:String</c-s> control block to <c-s>t</c-s> (still pointing to <c-s>s</c-s>&apos;s characters)
            and marks <c-s>s</c-s> as moved.
          </t-b>
        </div>
      </indent-block>
    </t-b>
    <t-b>
      When <c-s>x</c-s> and <c-s>y</c-s> go out of scope, that is, the thread of execution leaves the scope
      in which <c-s>x</c-s> and <c-s>y</c-s> are defined, nothing happens other than the stack frame is marked as
      free and may be over-written at any time due to another stack allocation.
    </t-b>
    <t-b>
      When <c-s>s</c-s> and <c-s>t</c-s> go out of scope, the string Drop trait method is called on 
      <c-s>t</c-s>, deallocating its character memory in the heap. 
      The Drop trait method is not called on <c-s>s</c-s> since it no longer owns anything on the heap.
    </t-b>
    <div style="width:calc(100vw - 6rem);">
      <photosizer-block src="Pictures/StringClone.jpg" width="500" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 1. String Clone
        </span>
      </photosizer-block>
    </div>
    <t-b>
      <t-b>
        There is an alternative to that scenario. Many of the stdlibrary types, including <c-s>String</c-s>, implement
        the Clone trait, giving them a clone method. So, a designer can replace a move that invalidates its
        source with the construction of a clone, like this:
      </t-b>
      <indent-block class="pad5">
        <div>
          <c-s>let s = String::from("a string");</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Creates an <c-s>s:String</c-s> control block on the stack pointing to continguous heap memory 
            containing the characters &quot;<c-s>a string</c-s>&quot;
          </t-b>
        </div>
      </indent-block>
      <indent-block class="pad5">
        <div>
          <c-s>let t = s.clone();</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Creates a <c-s>t:String</c-s> control block on the stack pointing to continguous heap memory 
            containing a copy of the characters &quot;<c-s>a string</c-s>&quot;
          </t-b>
        </div>
      </indent-block>
    </t-b>
    <t-b>
      Now, both <c-s>s</c-s> and <c-s>t</c-s> are valid, each pointing to their own character allocations
      on the heap, which, immediately following the clone operation, have the same characters.
    </t-b>
    <t-b>
      When <c-s>s</c-s> and <c-s>t</c-s> go out of scope, the String Drop trait method drop() is called on
      both <c-s>s</c-s> and <c-s>t</c-s> because they each own unique character array allocations.
    </t-b>
    <div class="clear"></div>
    <div style="height:0.5em;"></div>
    <a id="deduction"></a>
    <h3>2.0&nbsp;&nbsp;Rust Types and Type Deduction</h3>
    <t-b>
      Rust has a strong type inference engine so you usually don&apos;t need to qualify newly
      created instances with their types as long as they are initialized in the definition.
    </t-b>
    <t-b>
      The Rust <c-s>let</c-s> declarator works much like the C++ <c-s>auto</c-s> declarator.
      This is illustrated in the code example, below.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Type Deduction</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Fully qualified types vs. deduced types</defn-head>
                <defn-code>
//mod types;
use std::fmt::{Debug};

#[allow(dead_code)]
pub fn run () {

    /*-- fully specified --*/
    let i:i32 = 5;
    let f:f64 = 3.4;
    let a:[f32; 5] = [1.0, 1.5, 2.0, 1.5, 1.0];
    let t:(i32, f64, String) = (1, 2.0, "three".to_string());
    #[derive(Debug)]
    struct S{i:i32, s:&amp;'static str, };
    let s:S = S{i:15, s:"a literal string" };
    #[derive(Debug)]
    enum E {BS(String), MS(String), PhD(String),};
    let e:E = E::MS("Computer Engineering".to_string());

    print!("\n  -- fully specified types --\n");
    print!("\n  i = {:?}", i);
    print!("\n  f = {:?}", f);
    print!("\n  a = {:?}", a);
    print!("\n  t = {:?}", t);
    print!("\n  s = {:?}", s);
    print!("\n  e = {:?}", e);

    /*-- using type deduction --*/
    let i = 5;
    let f = 3.4;
    let a = [1.0, 1.5, 2.0, 1.5, 1.0];
    let t = (1, 2.0, "three".to_string());
    let s = S{i:15, s:"a literal string" };
    let e = E::MS("Computer Engineering".to_string());

    print!("\n\n  -- using type deduction --\n");
    print!("\n  i = {:?}", i);
    print!("\n  f = {:?}", f);
    print!("\n  a = {:?}", a);
    print!("\n  t = {:?}", t);
    print!("\n  s = {:?}", s);
    print!("\n  e = {:?}", e);
}                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output:</defn-head>
                <defn-code>
C:\github\JimFawcett\RustBasicDemos\rust_probes> 
cargo -q run

  -- fully specified types --

  i = 5
  f = 3.4
  a = [1.0, 1.5, 2.0, 1.5, 1.0]
  t = (1, 2.0, "three")
  s = S { i: 15, s: "a literal string" }
  e = MS("Computer Engineering")

  -- using type deduction --

  i = 5
  f = 3.4
  a = [1.0, 1.5, 2.0, 1.5, 1.0]
  t = (1, 2.0, "three")
  s = S { i: 15, s: "a literal string" }
  e = MS("Computer Engineering")

                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
      </div>
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="basictypes"></a>
    <h3>2.1&nbsp;&nbsp;Basic Data Types</h3>
    <t-b>
      Rust basic types are:
      <indent-block class="pad5">
        i8, u8, i16, u16, i32, u32, i64, u64, i128, u128, isize, usize
        f32, f64, char, bool, ()
      </indent-block>
    </t-b>
    <t-b>
      The last of these, &quot;()&quot; is the unit type. It represents the absence of a value.
    </t-b>
    <t-b>
      Examples of all the basic types including code and output.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Basic Types</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Basic Types code from main:</defn-head>
                <defn-code>
    title("exploring basic types".to_string());
    /*
      Rust basic types:
      i8, u8, i16, u16, i32, u32, i64, u64, i128, u128, isize, usize
      f32, f64, char, bool, ()
    */
    let demo :i8 = 3;
    putln(&amp;"let demo :i8 = 3;");
    log(&amp;demo);

    separator();
    let demo = 5;
    putln(&amp;"let demo = 5;");
    log(&amp;demo);

    separator();
    let demo :usize = 7;
    putln(&amp;"let demo :usize = 7;");
    log(&amp;demo);

    /* Rust floats: f32, f64 */

    separator();
    let demo = 3.5;
    putln(&amp;"let demo = 3.5;");
    log(&amp;demo);

    separator();
    let demo :f32 = -3.5;
    putln(&amp;"let demo :f32 = -3.5;");
    log(&amp;demo);

    /* Rust chars: char */

    separator();
    let demo = 'a';
    putln(&amp;"let demo = 'a';");
    log(&amp;demo);

    separator();
    let demo :char = 'Z';
    putln(&amp;"let demo :char = 'Z';");
    log(&amp;demo);

    /* Rust boolean: bool */

    separator();
    let demo = true;
    putln(&amp;"let demo = true;");
    log(&amp;demo);

    separator();
    let demo :bool = false;
    putln(&amp;"let demo :bool = false");
    log(&amp;demo);

    /* Rust unit type: () */

    separator();
    let demo = ();
    putln(&amp;"let demo = ();");
    log(&amp;demo);

    separator();
    let demo :() = ();
    putln(&amp;"let demo :() = ();");
    log(&amp;demo);

                </defn-code>
                <defn-head class="defnBorderTop">main.rs - defines put, putln, and separator</defn-head>
                <defn-code>
#[allow(unused_imports)]
use display::{putline, title, show_type, log, putlinen};
use std::fmt::{Debug, Display};
use std::any::Any;

#[allow(dead_code)]
fn put&lt;T: Any + Debug + Display&gt;(value: &amp;T) {
    print!("{}", value);
}

fn putln&lt;T: Any + Debug + Display&gt;(value: &amp;T) {
    let mut str_temp = String::new();
    str_temp.push_str("\n  ");
    str_temp.push_str(&amp;value.to_string());
    print!("{}", str_temp);
}

fn separator() {
    put(&amp;"\n ---------------------------------");  
}

fn main() {
  // code elided - see panel above
}
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output for Basic Types:</defn-head>
                <defn-code>
C:\github\JimFawcett\RustBasicDemos\data_types>    
cargo -q run

  exploring basic types
 -----------------------
  let demo :i8 = 3;
  TypeId: i8, size: 1
  value:  3
 ---------------------------------
  let demo = 5;
  TypeId: i32, size: 4
  value:  5
 ---------------------------------
  let demo :usize = 7;
  TypeId: usize, size: 4
  value:  7
 ---------------------------------
  let demo = 3.5;
  TypeId: f64, size: 8
  value:  3.5
 ---------------------------------
  let demo :f32 = -3.5;
  TypeId: f32, size: 4
  value:  -3.5
 ---------------------------------
  let demo = 'a';
  TypeId: char, size: 4
  value:  'a'
 ---------------------------------
  let demo :char = 'Z';
  TypeId: char, size: 4
  value:  'Z'
 ---------------------------------
  let demo = true;
  TypeId: bool, size: 1
  value:  true
 ---------------------------------
  let demo :bool = false
  TypeId: bool, size: 1
  value:  false
 ---------------------------------
  let demo = ();
  TypeId: (), size: 0
  value:  ()
 ---------------------------------
  let demo :() = ();
  TypeId: (), size: 0
  value:  ()
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
      </div>
    </t-b>
    <t-b>
      The basic types are blittable, and so implement the Copy trait.
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="aggregates"></a>
    <h3>2.2&nbsp;&nbsp;Aggregate Data Types</h3>
    <t-b>
      Rust aggregate types are:
      <indent-block class="pad5">
        arrays, tuples, strings, references, structs, and enums 
      </indent-block>
    </t-b>
    <t-b>
      <div>
        <defn-block>
          <defn-head>References are borrows</defn-head>
          <defn-code>
/* attempt to mutate after borrow */

let mut s = String::from("s is owner");
slog(&amp;s);
{
    let rs = &amp;s;  // borrow s
    // statement below fails to compile
    // owner can't mutate after borrow 
    // s += " with stuff";
    slog(&amp;rs);
}  // borrow ends here
s += " with stuff";
slog(&amp;s);
          </defn-code>
        </defn-block>
      </div>
    </t-b>
    <t-b>
      Examples for all of the aggregate types, showing code and output from
      RustBasicDemos: data_types:
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Aggregate Types</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Aggregate Types code from main</defn-head>
                <defn-code>
// code elided

/* Rust arrays: [1,2,3] */

separator();
let demo = [1, 2, 3];
putln(&amp;"let demo = [1, 2, 3];");
log(&amp;demo);

separator();
let demo = [(1.5, 2.3), (3.1, 3.9)];
putln(&amp;"let demo = [(1.5, 2.3), (3.1, 3.9)];");
log(&amp;demo);

/* Rust tuples: (1,'z',3.5) */
    
separator();
let demo = (1, 2.5, (1,'a'), [1,2,3]);
putln(&amp;"let demo = (1, 2.5, (1,'a'), [1,2,3]);");
log(&amp;demo);

/* Rust Strings: String::from("a string") */
    
separator();
let demo = String::from("a demo String");
putln(
  &amp;"let demo = String::from(\"a demo String\");"
);
log(&amp;demo);

/* Rust references:  */
    
separator();
let mut demo = String::from("a demo String");
putln(
  &amp;"let demo = String::from(\"a demo String\");"
);
log(&amp;demo);
let rdemo = &amp;mut demo;
putln(&amp;"let rdemo = &amp;mut demo;");
putln(&amp;"redemo.push_str(\" more stuff\")");
rdemo.push_str(" more stuff");
// compile fails - this is attemp to make second
// mutable borrow because push_str takes &amp;self
// demo.push_str(" still more stuff");
log(rdemo);
putln(&amp;"demo.push_str(\" still more stuff\"");
// this call succeeds only because rdemo 
// is not used below call
demo.push_str(" still more stuff");
log(&amp;demo);
// log(rdemo);  // if this call is uncommented 
                // both calls above fail
putline();

/* attempt to mutate after borrow */

let mut s = String::from("s is owner");
slog(&amp;s);
{
    let rs = &amp;s;  // borrow s
    // statement below fails to compile
    // owner can't mutate after borrow 
    // s += " with stuff";
    slog(&amp;rs);
}  // borrow ends here
s += " with stuff";
slog(&amp;s);
putline();
    
/*-------------------------------------------
  Rust structs: 
    struct Point { x:f64, y:f64, z:f64, t:} 
*/
    
separator();
#[derive(Debug)]
struct Point { 
  x:f64, y:f64, z:f64, name:String, 
}
let demo = Point { 
  x:1.5, y:2.5, z:3.7, 
  name:String::from("Peter") 
};
putln(
  &amp;"struct Point { 
    x:f64, y:f64, z:f64, name:String, 
  }"
);
putln(
  &amp;"let demo = Point { 
    x:1.5, y:2.5, z:3.7, 
    name:String::from(\"Peter\") };"
);
log(&amp;demo);

/* Rust enums: enum POS { bs, ms, phd } */
    
separator();
#[derive(Debug)]
#[allow(dead_code)]
enum POS { 
  BS(String), MS(String), PhD(String), 
};
let demo = POS::MS(
  String::from("Computer Engineering")
);
putln(
  &amp;"enum POS { 
    BS(String), MS(String), PhD(String), 
  };"
);
putln(
  &amp;"let demo = 
    POS::MS(
      String::from(\"Computer Engineering\")
    );"
);
log(&amp;demo);

// code elided

                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output for Aggegate Types</defn-head>
                <defn-code>
C:\github\JimFawcett\RustBasicDemos\data_types>
cargo -q run

  exploring basic types
 -----------------------
  let demo :i8 = 3;
  TypeId: i8, size: 1
  value:  3
 ---------------------------------
  let demo = 5;
  TypeId: i32, size: 4
  value:  5
 ---------------------------------
  let demo :usize = 7;
  TypeId: usize, size: 4
  value:  7
 ---------------------------------
  let demo = 3.5;
  TypeId: f64, size: 8
  value:  3.5
 ---------------------------------
  let demo :f32 = -3.5;
  TypeId: f32, size: 4
  value:  -3.5
 ---------------------------------
  let demo = 'a';
  TypeId: char, size: 4
  value:  'a'
 ---------------------------------
  let demo :char = 'Z';
  TypeId: char, size: 4
  value:  'Z'
 ---------------------------------
  let demo = true;
  TypeId: bool, size: 1
  value:  true
 ---------------------------------
  let demo :bool = false
  TypeId: bool, size: 1
  value:  false
 ---------------------------------
  let demo = ();
  TypeId: (), size: 0
  value:  ()
 ---------------------------------
  let demo :() = ();
  TypeId: (), size: 0
  value:  ()
 ---------------------------------
  let demo = [1, 2, 3];
  TypeId: [i32; 3], size: 12
  value:  [1, 2, 3]
 ---------------------------------
  let demo = [(1.5, 2.3), (3.1, 3.9)];
  TypeId: [(f64, f64); 2], size: 32
  value:  [(1.5, 2.3), (3.1, 3.9)]
 ---------------------------------
  let demo = (1, 2.5, (1,'a'), [1,2,3]);
  TypeId: 
    (i32, f64, (i32, char), [i32; 3]), 
    size: 32
  value:  (1, 2.5, (1, 'a'), [1, 2, 3])
 ---------------------------------
  let demo = String::from("a demo String");
  TypeId: alloc::string::String, size: 12
  value:  String (13): a demo String
 ---------------------------------
  let demo = String::from("a demo String");
  TypeId: alloc::string::String, size: 12
  value:  String (13): a demo String
  let rdemo = &mut demo;
  redemo.push_str(" more stuff")
  TypeId: alloc::string::String, size: 12
  value:  String (24): a demo String more stuff
  demo.push_str(" still more stuff"
  TypeId: alloc::string::String, size: 12
  value:  String (41): 
    a demo String more stuff still more stuff

  TypeId: alloc::string::String, size: 12
  value:  "s is owner"
  TypeId: &alloc::string::String, size: 4
  value:  "s is owner"
  TypeId: alloc::string::String, size: 12
  value:  "s is owner with stuff"

 ---------------------------------
  struct Point { 
    x:f64, y:f64, z:f64, name:String, 
  }
  let demo = Point { 
    x:1.5, y:2.5, z:3.7, 
    name:String::from("Peter") 
  };
  TypeId: data_types::main::Point, size: 40
  value:  Point { 
    x: 1.5, y: 2.5, z: 3.7, name: "Peter" 
  }
 ---------------------------------
  enum POS { 
    BS(String), MS(String), PhD(String), 
  };
  let demo = 
    POS::MS(String::from(
              "Computer Engineering")
           );
  TypeId: data_types::main::POS, size: 16
  value:  MS("Computer Engineering")

                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
      </div>
    </t-b>
    <t-b>
      Aggregate types are blittable if and only if they have all blittable members, e.g.,
      no Strings, Vecs, ...  In that case they can acquire the Copy trait, simply by
      qualifying them as implementing derived Copy:
      <indent-block class="pad5">
        #[derive(Debug, Copy, Clone)]
        struct my_struct { ... }
      </indent-block>
      For this declaration the compiler generates these traits.  
      <div>
        <ul class="tight">
          <li>
            Debug allows you to use {:?} in a format which uses a standard formatting 
            process for each of the Rust types.
          </li>
          <li>
            Copy causes the compiler to copy an instance&apos;s value by blitting (memcpy) to 
            the new location. The compiler will refuse to derive Copy if any member is non-blittable
            or the type already implements the Drop trait.
          </li>
          <li>
            Clone is not called implicitly, but a designer can write code that calls clone() and
            then pays whatever performance penalty accrues for making the copy. If you implement Copy you 
            are also required to implement Clone.
          </li>
        </ul>
      </div>
    </t-b>
    <t-b style="margin-bottom:0px;">
      If an aggregate type is non-blittable, then attempting to derive the Copy trait is a compile error.
      However, you can implement Clone using the clone method on any non-blittable member if the member
      has the Clone trait.
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="slices"></a>
    <h3>2.3&nbsp;&nbsp;Slices of Aggregate Types:</h3>
    <t-b>
      A slice is a non-owning view into an aggregate data structure that may or may not be
      viewing the complete data structure.  Consider an array:
      <indent-block class="pad5">
        <c-s>let arr = [1, 2, 3, 4, 5, 6];</c-s>
        <ul class="tight">
          <li>
            <c-s>let slc1 = &arr[..];    // view the entire array</c-s>
          </li>
          <li>
            <c-s>let slc2 = &arr[0..6];  // same as slc1</c-s>
          </li>
          <li>
            <c-s>let slc3 = &arr[..3];   // views elements [1, 2, 3]</c-s>
          </li>
          <li>
            <c-s>let slc4 = &arr[1..];   // views elements [2, 3, 4, 5, 6]</c-s>
          </li>
          <li>
            <c-s>let slc5 = &arr[1..4];  // views elements [2, 3, 4]</c-s>
          </li>
        </ul>
      </indent-block>
    </t-b>
    <t-b>
      It only makes sense to take slices of array-like things, e.g., arrays, vectors, and strings.
      Also, string slices only make sense if all the string characters are ASCII.  We will discuss
      this further in the next section.
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="strings"></a>
    <h3>2.4&nbsp;&nbsp;String Types:</h3>
    <t-b>
      Rust provides two native string types: String and str, and two types intended for use with
      C language bindings: OsString and CString.  We will focus here on String and str.
    </t-b>
    <t-b style="margin-bottom:0px;">
      The str type is part of the core Rust language and String is provided in the std library.  Both
      contain sequences of utf-8 characters.  The size of utf-8 characters ranges from 1 to 4 bytes.
      But String is implemented using Vec&lt;u8&gt;, so indexing into the Vec only yields a byte which
      will be a whole character if ASCII, but only part of a character otherwise.  That means that you
      can&apos;t index Strings. 
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="string"></a>
    <h4>2.4.1&nbsp;&nbsp;String</h4>
    <t-b>
      You retrieve the ith utf-8 char from a String, s, using: 
      <indent-block class="pad5">
        <c-s>s.chars().nth(i).unwrap()</c-s>. 
      </indent-block>
      <c-s>chars()</c-s> is a String iterator that knows how to find utf-8 character boundaries.
      <c-s>nth(i)</c-s> calls <c-s>next</c-s> on the iterator <c-s>i</c-s> times.  That returns
      a <c-s>std::option</c-s> that contains either <c-s>Some(ch)</c-s> or <c-s>None</c-s>. If the
      indexing succeeded that returns <c-s>Some(ch)</c-s> and we can use ch directly. Note that this
      is an order N process because we walk down the string looking for character boundaries.
    </t-b>
    <t-b>
      Using <c-s>unwrap()</c-s> attempts to use the character directly.  If indexing failed that would
      result in a panic. In cases where a panic is not appropriate (flight navigation system for the
      Boeing 797) we use matching to react to the option.  We will discuss option processing in the
      next chapter, Operations.
    </t-b>
    <t-b>
      The method described above works for all utf-8 character sets.  However, for languages that use
      diacritics, the diacritics get encoded in a separate char even though a speaker of the language 
      would say that those are part of an adjacent character in that language (Hindi for example).
      the chars() iterator is not smart enough to handle that situation.
    </t-b>
    <t-b>
      Here&apos;s a reference: 
      <a href="https://doc.rust-lang.org/1.25.0/book/second-edition/ch08-02-strings.html">
         ch08-02-strings in the Rust Book
      </a>
    </t-b>
    <t-b style="margin-bottom:0px;">
      Note that Strings are not blittable, so rebinding a string to a new name transfers ownership, 
      and taking a borrow reference suspends the owner&apos;s ability to mutate until the borrow ends.
    </t-b>
    <div style="height:0.5em"></div>
    <a id="str"></a>
    <h4>2.4.2&nbsp;&nbsp;str</h4>
    <t-b>
      The str type represents litteral strings like &quot;a literal string&quot;. These are implemented
      with contiguous blocks of memory, often on the stack, and so are blittable.  You almost always 
      encounter literal strings as references, &s.
    </t-b>
    <t-b>
      strs can be converted to String instances in several ways.  Here&apos;s two:
      <indent-block class="pad5">
        <ol class="tight">
          <li>
            <c-s>let s = String::from("a literal string");</c-s>
          </li>
          <li>
            <c-s>let s = "a literal string".to_string();</c-s>
          </li>
        </ol>
      </indent-block>
      And we can create an str by taking a slice of a String or a literal string:
      <indent-block class="pad5">
        <ol class="tight">
          <li>
            <c-s>let s1 = "Hello world";  // slice of the whole literal</c-s>
          </li>
          <li>
            <c-s>let s2 = &s[1..3];  // second through 4th bytes of s</c-s>
          </li>
        </ol>
      </indent-block>
      Both <c-s>s1</c-s> and <c-s>s2</c-s> have type <c-s>&str</c-s>, a reference to a literal string.
    </t-b>
    <t-b style="margin-bottom:0px;">
      Taking a complete slice always works, but, since Rust chars are utf-8 with sizes that range from
      1 byte (ASCII characters) to 4 bytes for math symbols and emojis, a partial slice like s2 may not
      have a correct representation of the second through 4th characters of s.
    </t-b>
    <t-b style="margin-bottom:0px;">
      An excellent discussion of utf-8 strings is provided by <a href="https://fasterthanli.me/blog/2020/working-with-strings-in-rust/">amos</a>.
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="str_exmpls"></a>
    <h4>2.4.3&nbsp;&nbsp;String Examples:</h4>
    <t-b>
      The String type has methods:
      <div class="pad5">
        <ul class="tight">
          <li>
            <c-s>let s = String::new();</c-s><br />
            Creates new empty String instance
          </li>
          <li>
            <c-s>let s = String::from("a literal");</c-s><br />
            Creates instance from literal
          </li>
          <li>
            <c-s>let t = s.replace("abc","xyz");</c-s><br />
            <c-s>t</c-s> is a copy of <c-s>s</c-s> with every instance of <c-s>"abc"</c-s> 
            replaced with <c-s>"xyz"</c-s>
          </li>
          <li>
            <c-s>s.len();</c-s><br />
            returns length of <c-s>s</c-s> in bytes, not chars
          </li>
          <li>
            <c-s>let slice = s.as_str();</c-s><br />
            returns slice of entire String <c-s>s</c-s> contents
          </li>
          <li>
            <c-s>s.push('a');</c-s><br />
            append char <c-s>'a'</c-s> to end of <c-s>s</c-s>.
          </li>
          <li>
            <c-s>s.push_str("abc");</c-s><br />
            appends <c-s>"abc"</c-s> to the end of <c-s>s</c-s>
          </li>
          <li>
            <c-s>let st = s.trim();</c-s><br />
            returns string with leading and trailing whitespace removed.
          </li>
          <li>
            <c-s>let iter = s.split_whitespace();</c-s><br />
            returns iterator over whitespace separated tokens
          </li>
          <li>
            <c-s>let iter = s.split('\n');</c-s><br />
            returns iterator over lines
          </li>
          <li>
            <c-s>let iter = s.chars();</c-s><br />
            returns an iterator over the utf-8 chars of <c-s>s</c-s>
          </li>
        </ul>
      </div>
    </t-b>
    <t-b>
      Here&apos;s an example showing many of these methods in action.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">String Examples:</summary>
          <defn-outerBlock>
            <defn-block>
              <defn-head>string-probes::main.rs</defn-head>
              <defn-code>
#[allow(unused_imports)]
use display::{
  log, slog, show, show_type, show_value,
  putline, putlinen, main_title, sub_title
};

/*-----------------------------------------------------------
Note:
Strings hold utf8 characters, which vary in size, so you
you can't directly index String instances.
*/
#[allow(dead_code)]
pub fn at(s:&amp;String, i:usize) -&gt; char {
  s.chars().nth(i).unwrap()
}
/*-----------------------------------------------------------
note:
- order n, as str chars are utf8, e.g., from 1 to 5 bytes
-----------------------------------------------------------*/

fn main() {

  main_title("string_probes");
  putline();

  /*-- char --*/

  let v:Vec&lt;char&gt; = vec!['R', 'u', 's', 't'];
  log(&amp;v);
  log(&amp;'R');
  putline();

  let ch:u8 = 'a' as u8;
  log(&amp;ch);
  show("char is ", &amp;(ch as char));
  putline();

  /*-- String --*/

  let s:String = String::from("Rust");
  log(&amp;s);
  let i:usize = 2;
  let ch = at(&amp;s, i);
  print!("\n  in string \"{}\", char at {} is {}", &amp;s, i, ch);
  show("length in bytes of s = {:?}", &amp;s.len());
  putline();

  let s1 = s.clone();
  let v:Vec&lt;u8&gt; = Vec::from(s1);
  slog(&amp;v[0]);
  show("vec from string",&amp;v);
  putline();

  /*-- str --*/

  let s_slice = &amp;s[..];   // slice containing all chars of s
  slog(&amp;s_slice);
  show("s_slice = ", &amp;s_slice);
  putline();

  let s_slice2 = s.as_str();
  slog(&amp;s_slice2);
  putline();

  /*-- create string and mutate --*/

  let mut s = String::new();
  s.push('a');
  s.push(' ');
  s.push_str("test string");
  log(&amp;s);
  putline();

  let t = s.replace("string","Rust String");
  slog(&amp;t);
  putline();

  for tok in s.split_whitespace() {
    print!("\n  {}", tok);
  }
  putline();

  //-----------------------
  // this works too
  // let iter = s.split_whitespace();
  // for tok in iter {
  //   print!("\n  {}", tok);
  // }
  // putline();

  /*-----------------------------------------------------
  Another, order n, way to index string:
  - chars returns iterator over utf8 chars in string slice
  - nth(i) calls next on iterator until it gets to i
  - nth(i) returns std::option::Option&lt;char&gt;:
  - that contains Some(ch) or None if operation failed
  */
  let result = s.chars().nth(0);
  match result {
    Some(r) =&gt; show("s.chars().nth(0) = ", &amp;r),
    None =&gt; print!("\n  couldn't extract char"),
  }
  show("s = ", &amp;s);
  let result = s.chars().nth(2);
  match result {
    Some(r) =&gt; show("s.chars().nth(2) = ", &amp;r),
    None =&gt; print!("\n  couldn't extract char"),
  }
  show("s = ", &amp;s);
  putline();

  {
    /*-------------------------------------------------
    Caution here:
    - slice is returning array of bytes, not utf8 chars
    - this works only because we use all ASCII chars
    */
    /*-- slices are non-owning views and are borrows of s --*/
    let slice_all = &amp;s;
    slog(&amp;slice_all);
    show("slice_all = ", &amp;slice_all);
    putline();

    let third = &amp;s[2..3];       // string slice with one char
    slog(&amp;third);
    show("third = ",&amp;third);
    putline();

    /*-- this works for utf-8 encoding --*/
    let ch = third.chars().nth(0);  //
    log(&amp;ch);
    match ch {
      Some(x) =&gt; { log(&amp;x); show("match ch = ", &amp;x); },
      None =&gt; print!("\n can't return ch"),
    }

    ///////////////////////////////////////////////////
    // compile fails
    // - can't modify owner while borrows are active
    //------------------------------------------------
    // s.push('Z');
    // slog(&amp;slice_all);

  }   // borrow ends here

  s.push('Z');  // ok, borrow no longer active

  putline();
  sub_title("That's all Folks!");
  putlinen(2);
}
              </defn-code>
            </defn-block>
            <defn-block>
              <defn-head>Output</defn-head>
              <defn-code>
C:\github\JimFawcett\RustBasicDemos\string_probes>
cargo -q run

string_probes
===============

TypeId: alloc::vec::Vec<char>
, size: 12
value:  ['R', 'u', 's', 't']
TypeId: char, size: 4
value:  'R'

TypeId: u8, size: 1
value:  97
char is 'a'

TypeId: alloc::string::String, size: 12
value:  String (4): Rust
in string "Rust", char at 2 is s
length in bytes of s = {:?}4

TypeId: u8, size: 1
value:  82
vec from string[82, 117, 115, 116]

TypeId: &str, size: 8
value:  "Rust"
s_slice = "Rust"

TypeId: &str, size: 8
value:  "Rust"

TypeId: alloc::string::String, size: 12
value:  String (13): a test string

TypeId: alloc::string::String, size: 12
value:  "a test Rust String"

a
test
string

s.chars().nth(0) = 'a'
s = "a test string"
s.chars().nth(2) = 't'
s = "a test string"

TypeId: &alloc::string::String, size: 4
value:  "a test string"
slice_all = "a test string"

TypeId: &str, size: 8
value:  "t"
third = "t"

TypeId: core::option::Option<char>
  , size: 4
  value:  Some('t')
  TypeId: char, size: 4
  value:  't'
  match ch = 't'

  That's all Folks!
  -------------------

              </defn-code>
            </defn-block>
          </defn-outerBlock>
        </details>
      </div>
    </t-b>
    <t-b>
      The fact that Rust Strings hold utf-8 characters is good news and bad news.  The good news is
      they can represent virtually anything a console can emit, e.g., ASCII chars, math symbols,
      arabic fonts, european diacritics, and emojis.
    </t-b>
    <t-b style="margin-bottom:0px;">
      The bad news is that you can&apos;t index a Rust String in constant time; and converting to
      other data structures can get messy.
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="structs"></a>
    <h2>3.0&nbsp;&nbsp;Structs</h2>
    <t-b>
      In Rust, most structs are aggregates of one or more fields where the fields may be arbitray types,
      named types, or unit type:
      <indent-block class="pad5">
        <ol class="tight">
          <li>
            <n-s>StructExprStruct</n-s>:
            <defn-code class="pad5" style="font-size:1.05em;">struct Person {
  name:String, occupation:String, age:u32,
}</defn-code>
          </li>
          <li>
            <n-s>StructExprTuple</n-s>:
            <defn-code class="pad5" style="font-size:1.05em;">struct Person {
  String, String, u32,
}</defn-code>
          </li>
          <li>
            <n-s>StructExprUnit</n-s>:
            <defn-code class="pad5" style="font-size:1.05em;">struct Person;
</defn-code>
          </li>
        </ol>
      </indent-block>
    </t-b>
    <t-b>
      Here are some examples:
      <div class="pad5">
        <defn-outerBlock>
          <defn-block>
            <defn-head>Struct Code:</defn-head>
            <defn-code>
#[allow(unused_imports)]
use display::{*};
use std::fmt;

/*-- ExprStruct struct --*/
#[derive(Debug)]
struct Person1 {
    name:String, occup:String, id:u32,
}
#[allow(dead_code)]
impl Person1 {
    fn show(&self) {
        print!("\n  Person1: {:?}", &self);
    }
}
/*-- ExprTuple struct --*/
#[derive(Debug)]
struct Person2 (
    String, String, u32
);
#[allow(dead_code)]
impl Person2 {
    fn show(&self) {
        print!("\n  Person2: {:?}", &self);
    }
}
/*-- ExprUnit struct --*/
#[derive(Debug)]
struct Person3;
#[allow(dead_code)]
impl Person3 {
    fn show(&self) {
        print!("\n  Person3");
    }
}
            </defn-code>
          </defn-block>
          <defn-block>
            <defn-head>Using Code:</defn-head>
            <defn-code>
sub_title("Demonstrating Basic Structs");
let p1 = Person1 { 
    name:"Jim".to_string(), 
    occup:"dev".to_string(), 
    id:42 
};
p1.show();
let p2 = Person2 { 
    0:"Jim".to_string(),
    1:"dev".to_string(),
    2:42
};
p2.show();
let p3 = Person3;
p3.show();
putline();
            </defn-code>
            <defn-head class="defnBorderTop">Output:</defn-head>
            <defn-code>
  Demonstrating Basic Structs
 -----------------------------
  Person1: Person1 { name: "Jim", occup: "dev", id: 42 }
  Person2: Person2("Jim", "dev", 42)
  Person3

            </defn-code>
          </defn-block>
        </defn-outerBlock>
      </div>
    </t-b>
    <t-b>
      You may be puzzled by the &quot;Impl&quot; method implementations. They add methods to a struct
      that interact with the struct&apos;s fields. That creates a component type. When defining components
      we usually make the struct public, its fields private, and at least some of its methods public.
      We will discuss all this in the next two chapters.
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="enums"></a>
    <h2>4.0&nbsp;&nbsp;Enumerations</h2>
    <t-b class="mbz">
      An enumeration is a type identifier with a set of enumeration item fields.  Fields may be:
      <indent-block class="pad5">
        <ul class="tight">
          <li>
            <n-s>ItemDiscriminant</n-s>: a named integral value
            <indent-block>
              <c-s>enum Names { John, Sally = 35, Roger };</c-s>
            </indent-block>
          </li>
          <li>
            <n-s>ItemTuple</n-s>: a named tuple with items specified by type
            <indent-blocks>
              <defn-code style="font-size:1em;"> enum Names {
   Alok(String, f64), Priya(String, f64), Ram(String, f64) 
 };</defn-code>
            </indent-blocks>
          </li>
          <li>
            <n-s>ItemStruct</n-s>: a named struct with items specified by name and type
            <indent-blocks>
              <defn-code style="font-size:1em;"> enum Names {
   Jun  { occupation: String, age: f64 },
   Xing { occupation: String, age: f64 },
   Shi  { occupation: String, age: f64 },
 }
              </defn-code>
            </indent-blocks>
          </li>
        </ul>
      </indent-block>
    </t-b>
    <t-b class="mtz">
      Enumerations can be generic. A common example in Rust code is the Option:
      <indent-block class="pad5" style="font-size:1.05em;">
        <c-s>enum Option&lt;T&gt;{ Some(T), None }</c-s>
      </indent-block>
      which can be used as the return value of a function that may or may not generate a result.
    </t-b>
    <t-b>
      Here are some examples:
    </t-b>
    <t-b>
      <div>
        <defn-block>
          <defn-head>Three types of enumerations</defn-head>
          <defn-code>
/*-- discriminant enum --*/

enum Name { John, Jim=42, Jack }

/*-- tuple enum --*/

enum NameTuple { 
    John(String, u32), Jim(String, u32), Jack(String, u32) 
}

/*-- struct enum --*/

enum NameStruct {
    John { occup:String, id:u32 },
    Jim  { occup:String, id:u32 },
    Jack { occup:String, id:u32 }
}
          </defn-code>
        </defn-block>
      </div>
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="aliases"></a>
    <h2>5.0&nbsp;&nbsp;Type Aliases</h2>
    <t-b>
      Type aliases provide an alternate name for an existing type, but is in fact the same type.
      You construct an alias like this:
      <indent-block class="pad5">
        <ul class="tight">
          <li>
            <c-s>type PointF = (f64, f64, f64);  // tuple of three doubles</c-s>
          </li>
          <li>
            <c-s>type VecPoint = Vec&lt;PointF&gt;</c-s>
          </li>
        </ul>
      </indent-block>
      Aliases help us provide meaningful application domain names for standard types and shortcuts for 
      long type names. Note that the Rust naming convention uses snake_case for functions and CamelCase
      for types.
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="libtypes"></a>
    <h2>6.0&nbsp;&nbsp;Std Lib Data Types</h2>
    <t-b>
      The std collections types are:
      <indent-block class="pad5">
        Vec, VecDeque, LinkedList, HashMap, HashSet, BTreeMap, BTreeSet, BinaryHeap 
      </indent-block>
    </t-b>
    <t-b>
      There are many other types defined in the stdlib for fs (FileSystem), io, net (TCP, UDP types),
      process, thread, time, ... In this section we will only look briefly at Vec and HashMap.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">StdLib Data Types</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Stdlib Types code from main</defn-head>
                <defn-code>
    /* Rust Vectors: Vec&lt;(i32, f64, char)&gt; - vector of tuples */
    
    separator();
    let mut demo  :Vec&lt;(i32, f64, char)&gt; = Vec::new();
    demo.push((1, 2.5, 'z'));
    demo.push((2, 3.5, 'A'));
    putln(&amp;"let mut demo  :Vec&lt;(i32, f64, char)&gt; = Vec::new();");
    log(&amp;demo);

    /* Rust HashMap: HashMap&lt;String,i32&gt; */
    
    separator();
    use std::collections::HashMap;
    let mut demo :HashMap&lt;String, i32&gt; = HashMap::new();
    demo.insert("one".to_string(), 1);
    demo.insert("two".to_string(), 2);
    putln(&amp;"let mut demo :HashMap&lt;String, i32&gt; = HashMap::new();");
    log(&amp;demo);
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output for Stdlib Types</defn-head>
                <defn-code>
---------------------------------
  let mut demo  :Vec<(i32, f64, char)> = Vec::new();
  TypeId: alloc::vec::Vec<(i32, f64, char)>, size: 12
  value:  [(1, 2.5, 'z'), (2, 3.5, 'A')]
 ---------------------------------
  let mut demo :HashMap<String, i32> = HashMap::new();
  TypeId: std::collections::hash::map::HashMap<alloc::string::String, i32>, size: 40
  value:  {"one": 1, "two": 2}

                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
      </div>
    </t-b>
    <t-b>
      The std collections types are all non-blittable and are moved not copied. I expect that
      some implement the Clone trait, but have not worked with them enough to know.
    </t-b>
    <div style="height:0.5em;"></div>
    <a id="epilogue"></a>
    <h2>7.0&nbsp;&nbsp;Epilogue:</h2>
    <t-b>
      This chapter has been all about storing and presenting data in scalar, aggregate, and structured forms.
      In the next chapter we will be looking at ways to operate on this data with functions, operators, and
      lambdas.
    </t-b>
    <a id="exercises"></a>
    <hr class="spread" />
    <h3>7.1&nbsp;&nbsp;Exercises:</h3>
    <indent-block class="pad5">
      <ol class="tight">
        <li>
          Construct a vec of i32 elements, populate it with 5 arbitrary elements, then display the value
          and address of each element. This 
          <a href="https://doc.rust-lang.org/1.30.0/book/2018-edition/ch19-01-unsafe-rust.html">reference</a>
          may help. Note that you don&apos;t need an unsafe block for this exercise.
        </li>
        <li>
          Create an instance of std::collections::HashMap.  Populate it with information about projects
          on which you are working.  Use project name as the key, and provide a small collection of items about
          the project, i.e., purpose, programming language, and status. Display the results on the console.
        </li>
        <li>
          Create an array of Strings, populating with arbitrary values.  Convert the array to a Vec.
        </li>
        <li>
          Construct a str instance and convert it to a String. Evaluate the address of the str, the String,
          and the first element of the String. Now, convert the String back to another str. Display everything
          you have built and evaluated.
        </li>
        <li>
          Declare a struct that has fields to describe your current employment. Display that on the console.
        </li>
        <li>
          Repeat the last exercise, but use a tuple.  Use type aliases to make the tuple understandable.
        </li>
      </ol>
    </indent-block>
    <hr class="spread" />
    <a id="refs"></a>
    <h3>7.2&nbsp;&nbsp;References:</h3>
    <table style="width:calc(100vw - 12rem);">
      <tr>
        <th class="darkItem">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">
            Character sets
          </a>
        </td>
        <td class="lightItem">
          The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and
          Character Sets (No Escuses!) [author&apos;s title] - Joel Spolsky
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://fasterthanli.me/blog/2020/working-with-strings-in-rust/">utf-8 Strings - amos</a></td>
        <td class="lightItem">Illustrating how utf-8 strings work with C and with Rust code.</td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://doc.rust-lang.org/1.25.0/book/second-edition/ch08-02-strings.html">Rust Strings</a></td>
        <td class="lightItem">Rust Strings are implemented with Vec&lt;u8&gt; but interpreted as utf-8 chars</td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.rs/regex/1.3.4/regex/">regex Crate</a></td>
        <td class="lightItem">
          Rust regex crate provides facilities for parsing, compiling, and executing regular expressions. 
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://docs.google.com/presentation/d/1ySMGJqK9yKtx5JX6n7w8j8srkgCC9YdCFKPXKLZ6Fy4/edit#slide=id.p">Rust Lifetimes</a>
        </td>
        <td class="lightItem">
          Very clear presentation of borrow lifetimes.
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://doc.rust-lang.org/reference/expressions/struct-expr.html">Rust Reference: Structs</a>
        </td>
        <td class="lightItem">
          Rust Reference is the official language definition - surprisingly readable.
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
        <td class="lightItem">
          Container diagrams
        </td>
        </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.rust-lang.org/">rust-lang.org home page</a>
        </td>
        <td class="lightItem">
          Links to download and documentation
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.tutorialspoint.com/rust/index.htm">Tutorial&nbsp;-&nbsp;tutorialspoint.com</a>
        </td>
        <td class="lightItem">
          Tutorials for most of the Rust parts with code examples.
        </td>
      </tr>
      <!--<tr>
        <td class="lightItem">
          <a href="https://www.javatpoint.com/rust-tutorial">Tutorial - javatpoint.com</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>-->
    </table>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#exercises">exercises</a></menu-elem>
        <menu-elem class="secElem"><a href="#epilogue">epilogue</a></menu-elem>
        <menu-elem class="secElem"><a href="#libtypes">stdlib types</a></menu-elem>
        <menu-elem class="secElem"><a href="#aliases">typealias</a></menu-elem>
        <menu-elem class="secElem"><a href="#enums">enums</a></menu-elem>
        <menu-elem class="secElem"><a href="#structs">structs</a></menu-elem>
        <menu-elem class="secElem"><a href="#strings">stringtypes</a></menu-elem>
        <menu-elem class="secElem"><a href="#slices">slices</a></menu-elem>
        <menu-elem class="secElem"><a href="#aggregates">aggregates</a></menu-elem>
        <menu-elem class="secElem"><a href="#deduction">types</a></menu-elem>
        <menu-elem class="secElem"><a href="#lifecycle">lifecycle</a></menu-elem>
        <menu-elem class="secElem"><a href="#prologue">prologue</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <!--<menu-item style="width:1.0em;">&nbsp;</menu-item>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.decrZoomScreen()">Zout</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.normZoomScreen()">Zdef</menu-elem>
      <menu-elem style="font-size:0.75em;" onclick="storyHlpMenu.incrZoomScreen()">Zin</menu-elem>-->
    </frame-footer>
  </page-frame>
</body>
</html>