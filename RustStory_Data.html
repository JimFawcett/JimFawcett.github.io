<!DOCTYPE html>
<html id="top">
<head>
  <!--
   - CppStory_Prologue.html
   - ver 1.0 - 10 June 2019
   - Jim Fawcett, Emeritus Teaching Professor, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Projects. Code Samples. Software Links" />
  <meta name="keywords" content="Repository, Design, Code" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <title>Rust Data</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <script src="js/ScriptsStory.js"></script>
  <script src="js/ScriptsWebComponents.js"></script>
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesDefault.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <link rel="stylesheet" href="css/StylesRustTheme.css" />
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>

  <a id="Next" href="RustStory_Operations.html">N</a>
  <a id="Prev" href="RustStory_Models.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Chapter 2. - Rust Data</h1>
      <h3 id="subtitle">Types, type deduction, ownership</h3>
    </hgroup>
  </header>

   <toc-b id="toc">
     <div style="display:flex; flex-direction:row">
       <a href="Javascript:;" onclick="storyMenu.chaps()" style="color:darkred;">Chaps</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.sects()" style="color:darkred;">Sects</a>&nbsp;
       <a href="Javascript:;" onclick="storyMenu.closeTOC()" style="color:darkred;">close</a>&nbsp;
     </div>
     <up-b id="chaps" onmouseout="storyMenu.chaps()">
       <a href="RustStory_Prologue.html">Prologue</a><br />
       <a href="RustStory_Models.html">Models</a><br />
       <a href="RustStory_Data.html">Data</a><br />
       <a href="RustStory_Operations.html">Operations</a><br />
       <a href="RustStory_Structures.html">Structs</a><br />
       <a href="RustStory_References.html">References</a><br />
     </up-b>
     <rt-b id="sects">
       <a href="#top">Top</a>, <a href="#prologue">Prologue</a>, <a href="#lifecycle">Life Cycle</a>, 
       <a href="#types">Basic Types</a>, <a href="#aggregates">Aggregates</a>, <a href="#strings">Strings</a>
       <a href="#libtypes">Lib Types</a>, <a href="#epilogue">Epilogue</a>, <a href="#refs">References</a>
     </rt-b>
   </toc-b>

  <bb-55 class="indent">
    <a id="prologue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>2.0</num-item1><num-item4>Prologue</num-item4>
    </num-cont>
    <t-b>
      Compiler enforced memory safety is one of the primary features of Rust. That is implemented
      with a strict ownership policy, ensuring that aliasing and mutation do not occur concurrently
      for any instance of a Rust type.    
    </t-b>
    <t-b>
      <div>
        <defn-outerBlock>
          <defn-block>
            <defn-head>Definition: Alias</defn-head>
            <defn-body>
              Two or more identifiers are bound to the same value.
            </defn-body>
          </defn-block>
          <defn-block>
            <defn-head>Definition: Mutation</defn-head>
            <defn-body>
              Operations on an identifier change its bound value.
            </defn-body>
          </defn-block>
        </defn-outerBlock> 
      </div>
    </t-b>
    <t-b>
      By value, we mean the state of an identifier&apos;s bound instance.  The value of a String, for example,
      is the collection of all its characters. The issue for memory safety is that changes to the String&apos;s
      state may change its memory allocation if the original allocation did not have enough capacity for the 
      change.  Thus all aliases of the identifier responsible for the change will hold invalid references.
    </t-b>
    <t-b>
      When new names bind to an existing value, the value will, for blittable types, be copied, and
      will be moved for non-blittable types.  Note that a move is a tranfer of ownership, so the
      original owner may no longer access that value.  References support borrowing, providing access to the
      owning instance&apos;s value while suspending the owner&apos;s ability to mutate.  When borrowing
      terminates, the owner&apos;s ability to mutate is restored.
    </t-b>
    <t-b>
      All of these rules are enforced by the Rust compiler.  When a rule is violated, the compiler emits
      a useful error message that helps a designer fix the violation.
    </t-b>
    <a id="lifecycle"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>2.1</num-item1><num-item4>Data and its Life Cycle:</num-item4>
    </num-cont>
    <t-b>
      Rust data comes in two flavors (see <a href="https://cheats.rs/#basic-types">basic-types</a> for details):
      <indent-block class="pad5">
        <ol class="tight">
          <li>
            <strong>Blittable types:</strong>
            <div class="pad5">
              Stored entirely in one contiguous block of stack memory.
              <indent-block>
                <ul class="tight">
                  <li>
                    Basic Types:
                    <div>
                      <c-s>
                        u8, i8, u16, i16, u32, i32, u64, i64, usize, isize,
                        f32, f64, bool, char, str
                      </c-s>
                    </div>
                  </li>
                  <li>
                    Aggregate Types:
                    <div>
                      <c-s>
                        array, tuple, struct if all their items are blittable
                      </c-s>
                    </div>
                  </li>
                </ul>
              </indent-block>
            </div>
          </li>
          <li>
            <strong>Non-Blittable types:</strong>
            <div class="pad5">
              Control block stored in one contiguous block of stack memory with references
              to data held in the heap.
              <indent-block>
                <ul class="tight">
                  <li>
                    Std Library Types:
                    <div>
                      <c-s>
                        String, Box, Vec, VecDeque, LinkedList, HashMap, HashSet, 
                        BTreeMap, BTreeSet, BinaryHeap
                      </c-s>
                    </div>
                  </li>
                  <li>
                    Aggregate Types:
                    <div>
                      <c-s>
                        array, tuple, struct if each has at least one non-blittable member
                      </c-s>
                    </div>
                  </li>
                </ul>
              </indent-block>
            </div>
          </li>
        </ol>
      </indent-block>
    </t-b>
    <div style="width:calc(100vw - 6rem);">
      <photosizer-block src="Pictures/StringMove.jpg" width="400" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 1. String Move
        </span>
      </photosizer-block>
    </div>
    <t-b>
      Blittable data values are copied:
      <indent-block class="pad5">
        <div>
          <c-s>let x = 3.5;</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Creates an <c-s>x:f64</c-s> on the stack initialized with the value <c-s>3.5</c-s>. 
          </t-b>
        </div>
      </indent-block>
      <indent-block class="pad5">
        <div>
          <c-s>let y = x;</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Creates an <c-s>y:f64</c-s> on the stack and copies <c-s>x</c-s>&apos;s value into y.
            <c-s>x</c-s> is still valid.
          </t-b>
        </div>
      </indent-block>
    </t-b>
    <t-b>
      Non-Blittable data values are moved:
      <indent-block class="pad5">
        <div>
          <c-s>let s = String::from("a string");</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Creates an <c-s>s:String</c-s> control block on the stack pointing to continguous heap memory 
            containing the characters &quot;<c-s>a string</c-s>&quot;
          </t-b>
        </div>
      </indent-block>
      <indent-block class="pad5">
        <div>
          <c-s>let t = s;</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Copies the <c-s>s:String</c-s> control block to <c-s>t</c-s> (still pointing to <c-s>s</c-s>&apos;s characters)
            and marks <c-s>s</c-s> as moved.
          </t-b>
        </div>
      </indent-block>
    </t-b>
    <t-b>
      When <c-s>x</c-s> and <c-s>y</c-s> go out of scope, that is, the thread of execution leaves the scope
      in which <c-s>x</c-s> and <c-s>y</c-s> are defined, nothing happens other than the stack frame is marked as
      free and may be over-written at any time due to another stack allocation.
    </t-b>
    <t-b>
      When <c-s>s</c-s> and <c-s>t</c-s> go out of scope, the string Drop trait method is called on 
      <c-s>t</c-s>, deallocating its character memory in the heap. 
      The Drop trait method is not called on <c-s>s</c-s> since it no longer owns anything on the heap.
    </t-b>
    <div style="width:calc(100vw - 6rem);">
      <photosizer-block src="Pictures/StringClone.jpg" width="400" class="photoSizerBlock right" style="margin-top:0;">
        <span style="
          display: inline-block;
          font-weight: bold;
          font-family: 'Comic Sans MS, Tahoma';
          background-color: #ddd;
          width: 100%;
          padding: 5px 0px;
        ">
          Figure 1. String Clone
        </span>
      </photosizer-block>
    </div>
    <t-b>
      <t-b>
        There is an alternative to that scenario. Many of the stdlibrary types, including <c-s>String</c-s>, implement
        the Clone trait, giving them a clone method. So, a designer can replace a move that invalidates its
        source with the construction of a clone, like this:
      </t-b>
      <indent-block class="pad5">
        <div>
          <c-s>let s = String::from("a string");</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Creates an <c-s>s:String</c-s> control block on the stack pointing to continguous heap memory 
            containing the characters &quot;<c-s>a string</c-s>&quot;
          </t-b>
        </div>
      </indent-block>
      <indent-block class="pad5">
        <div>
          <c-s>let t = s.clone();</c-s>
          <t-b class="indent" style="font-size:0.95rem;">
            Creates a <c-s>t:String</c-s> control block on the stack pointing to continguous heap memory 
            containing a copy of the characters &quot;<c-s>a string</c-s>&quot;
          </t-b>
        </div>
      </indent-block>
    </t-b>
    <t-b>
      Now, both <c-s>s</c-s> and <c-s>t</c-s> are valid, each pointing to their own character allocations
      on the heap, which, immediately following the clone operation, have the same characters.
    </t-b>
    <t-b>
      When <c-s>s</c-s> and <c-s>t</c-s> go out of scope, the String Drop trait method drop() is called on
      both <c-s>s</c-s> and <c-s>t</c-s> because they each own unique character array allocations.
    </t-b>
    <div class="clear"></div>
    <num-cont>
      <num-item1>2.1.1</num-item1><num-item4>Type Deduction:</num-item4>
    </num-cont>
    <t-b>
      Rust has a strong type inference engine so you usually don&apos;t need to qualify newly
      created instances with their types as long as they are initialized in the definition.
    </t-b>
    <t-b>
      The Rust <c-s>let</c-s> declarator works much like the C++ <c-s>auto</c-s> declarator.
      This is illustrated in the code example, below.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Type Deduction</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Fully qualified types vs. deduced types</defn-head>
                <defn-code>
//mod types;
use std::fmt::{Debug};

#[allow(dead_code)]
pub fn run () {

    /*-- fully specified --*/
    let i:i32 = 5;
    let f:f64 = 3.4;
    let a:[f32; 5] = [1.0, 1.5, 2.0, 1.5, 1.0];
    let t:(i32, f64, String) = (1, 2.0, "three".to_string());
    #[derive(Debug)]
    struct S{i:i32, s:&amp;'static str, };
    let s:S = S{i:15, s:"a literal string" };
    #[derive(Debug)]
    enum E {BS(String), MS(String), PhD(String),};
    let e:E = E::MS("Computer Engineering".to_string());

    print!("\n  -- fully specified types --\n");
    print!("\n  i = {:?}", i);
    print!("\n  f = {:?}", f);
    print!("\n  a = {:?}", a);
    print!("\n  t = {:?}", t);
    print!("\n  s = {:?}", s);
    print!("\n  e = {:?}", e);

    /*-- using type deduction --*/
    let i = 5;
    let f = 3.4;
    let a = [1.0, 1.5, 2.0, 1.5, 1.0];
    let t = (1, 2.0, "three".to_string());
    let s = S{i:15, s:"a literal string" };
    let e = E::MS("Computer Engineering".to_string());

    print!("\n\n  -- using type deduction --\n");
    print!("\n  i = {:?}", i);
    print!("\n  f = {:?}", f);
    print!("\n  a = {:?}", a);
    print!("\n  t = {:?}", t);
    print!("\n  s = {:?}", s);
    print!("\n  e = {:?}", e);
}                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output:</defn-head>
                <defn-code>
C:\github\JimFawcett\RustBasicDemos\rust_probes> 
cargo -q run

  -- fully specified types --

  i = 5
  f = 3.4
  a = [1.0, 1.5, 2.0, 1.5, 1.0]
  t = (1, 2.0, "three")
  s = S { i: 15, s: "a literal string" }
  e = MS("Computer Engineering")

  -- using type deduction --

  i = 5
  f = 3.4
  a = [1.0, 1.5, 2.0, 1.5, 1.0]
  t = (1, 2.0, "three")
  s = S { i: 15, s: "a literal string" }
  e = MS("Computer Engineering")

                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
      </div>
    </t-b>
    <a id="types"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>2.2</num-item1><num-item4>Basic Data Types:</num-item4>
    </num-cont>
    <t-b>
      Rust basic types are:
      <indent-block class="pad5">
        i8, u8, i16, u16, i32, u32, i64, u64, i128, u128, isize, usize
        f32, f64, char, bool, ()
      </indent-block>
    </t-b>
    <t-b>
      The last of these, &quot;()&quot; is the unit type. It represents the absence of a value.
    </t-b>
    <t-b>
      Examples of all the basic types including code and output.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Basic Types</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Basic Types code from main:</defn-head>
                <defn-code>
    title("exploring basic types".to_string());
    /*
      Rust basic types:
      i8, u8, i16, u16, i32, u32, i64, u64, i128, u128, isize, usize
      f32, f64, char, bool, ()
    */
    let demo :i8 = 3;
    putln(&amp;"let demo :i8 = 3;");
    log(&amp;demo);

    separator();
    let demo = 5;
    putln(&amp;"let demo = 5;");
    log(&amp;demo);

    separator();
    let demo :usize = 7;
    putln(&amp;"let demo :usize = 7;");
    log(&amp;demo);

    /* Rust floats: f32, f64 */

    separator();
    let demo = 3.5;
    putln(&amp;"let demo = 3.5;");
    log(&amp;demo);

    separator();
    let demo :f32 = -3.5;
    putln(&amp;"let demo :f32 = -3.5;");
    log(&amp;demo);

    /* Rust chars: char */

    separator();
    let demo = 'a';
    putln(&amp;"let demo = 'a';");
    log(&amp;demo);

    separator();
    let demo :char = 'Z';
    putln(&amp;"let demo :char = 'Z';");
    log(&amp;demo);

    /* Rust boolean: bool */

    separator();
    let demo = true;
    putln(&amp;"let demo = true;");
    log(&amp;demo);

    separator();
    let demo :bool = false;
    putln(&amp;"let demo :bool = false");
    log(&amp;demo);

    /* Rust unit type: () */

    separator();
    let demo = ();
    putln(&amp;"let demo = ();");
    log(&amp;demo);

    separator();
    let demo :() = ();
    putln(&amp;"let demo :() = ();");
    log(&amp;demo);

                </defn-code>
                <defn-head class="defnBorderTop">main.rs - defines put, putln, and separator</defn-head>
                <defn-code>
#[allow(unused_imports)]
use display::{putline, title, show_type, log, putlinen};
use std::fmt::{Debug, Display};
use std::any::Any;

#[allow(dead_code)]
fn put&lt;T: Any + Debug + Display&gt;(value: &amp;T) {
    print!("{}", value);
}

fn putln&lt;T: Any + Debug + Display&gt;(value: &amp;T) {
    let mut str_temp = String::new();
    str_temp.push_str("\n  ");
    str_temp.push_str(&amp;value.to_string());
    print!("{}", str_temp);
}

fn separator() {
    put(&amp;"\n ---------------------------------");  
}

fn main() {
  // code elided
}
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output for Basic Types:</defn-head>
                <defn-code>
C:\github\JimFawcett\RustBasicDemos\data_types>    
cargo -q run

  exploring basic types
 -----------------------
  let demo :i8 = 3;
  TypeId: i8, size: 1
  value:  3
 ---------------------------------
  let demo = 5;
  TypeId: i32, size: 4
  value:  5
 ---------------------------------
  let demo :usize = 7;
  TypeId: usize, size: 4
  value:  7
 ---------------------------------
  let demo = 3.5;
  TypeId: f64, size: 8
  value:  3.5
 ---------------------------------
  let demo :f32 = -3.5;
  TypeId: f32, size: 4
  value:  -3.5
 ---------------------------------
  let demo = 'a';
  TypeId: char, size: 4
  value:  'a'
 ---------------------------------
  let demo :char = 'Z';
  TypeId: char, size: 4
  value:  'Z'
 ---------------------------------
  let demo = true;
  TypeId: bool, size: 1
  value:  true
 ---------------------------------
  let demo :bool = false
  TypeId: bool, size: 1
  value:  false
 ---------------------------------
  let demo = ();
  TypeId: (), size: 0
  value:  ()
 ---------------------------------
  let demo :() = ();
  TypeId: (), size: 0
  value:  ()
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
      </div>
    </t-b>
    <t-b>
      The basic types are blittable, and so implement the Copy trait.
    </t-b>
    <a id="aggregates"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>2.3</num-item1><num-item4>Aggregate Data Types:</num-item4>
    </num-cont>
    <t-b>
      Rust aggregate types are:
      <indent-block class="pad5">
        arrays, tuples, strings, references, structs, and enums 
      </indent-block>
    </t-b>
    <t-b>
      <div>
        <defn-block>
          <defn-head>References are borrows</defn-head>
          <defn-code>
let mut demo = String::from("a demo String");
putln(&amp;"let demo = String::from(\"a demo String\");");
log(&amp;demo);
let rdemo = &amp;mut demo;
putln(&amp;"let rdemo = &amp;mut demo;");
putln(&amp;"redemo.push_str(\" more stuff\")");
rdemo.push_str(" more stuff");
/////////////////////////////////////////////////////////
// Owner can&apos;t mutate while borrow is active
//-------------------------------------------------------
// compile fails - owner can't mutate until borrow ends
// demo.push_str(" still more stuff");
// This is borrow because log takes a ref and that's
// what rdemo is.
log(rdemo);  
/////////////////////////////////////////////////////////
// borrow ends when function returns
//-------------------------------------------------------
putln(&amp;"demo.push_str(\" still more stuff\"");
demo.push_str(" still more stuff");
log(&amp;demo);
          </defn-code>
        </defn-block>
      </div>
    </t-b>
    <t-b>
      Examples for all of the aggregate types, showing code and output:
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">Aggregate Types</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Aggregate Types code from main</defn-head>
                <defn-code>
    /* Rust arrays: [1,2,3] */

    separator();
    let demo = [1, 2, 3];
    putln(&amp;"let demo = [1, 2, 3];");
    log(&amp;demo);

    separator();
    let demo = [(1.5, 2.3), (3.1, 3.9)];
    putln(&amp;"let demo = [(1.5, 2.3), (3.1, 3.9)];");
    log(&amp;demo);

    /* Rust tuples: (1,'z',3.5) */
    
    separator();
    let demo = (1, 2.5, (1,'a'), [1,2,3]);
    putln(&amp;"let demo = (1, 2.5, (1,'a'), [1,2,3]);");
    log(&amp;demo);

    /* Rust Strings: String::from("a string") */
    
    separator();
    let demo = String::from("a demo String");
    putln(&amp;"let demo = String::from(\"a demo String\");");
    log(&amp;demo);

    /* Rust references:  */
    
    separator();
    let mut demo = String::from("a demo String");
    putln(&amp;"let demo = String::from(\"a demo String\");");
    log(&amp;demo);
    let rdemo = &amp;mut demo;
    putln(&amp;"let rdemo = &amp;mut demo;");
    putln(&amp;"redemo.push_str(\" more stuff\")");
    rdemo.push_str(" more stuff");
    // compile fails - owner can't mutate until borrow ends
    // demo.push_str(" still more stuff");
    // This is borrow because log takes a ref and that's
    // what rdemo is.
    log(rdemo);  // borrow ends when function returns
    putln(&amp;"demo.push_str(\" still more stuff\"");
    demo.push_str(" still more stuff");
    log(&amp;demo);

    /* Rust structs: struct Point { x:f64, y:f64, z:f64, t:} */
    
    separator();
    #[derive(Debug)]
    struct Point { x:f64, y:f64, z:f64, name:String, }
    let demo = 
      Point { x:1.5, y:2.5, z:3.7, name:String::from("Peter") };
    putln(
      &amp;"struct Point { x:f64, y:f64, z:f64, name:String, }"
    );
    putln(&amp;"let demo = 
      Point { 
        x:1.5, y:2.5, z:3.7, 
        name:String::from(\"Peter\") 
      };
    ");
    log(&amp;demo);

    /* Rust enums: enum POS { bs, ms, phd } */
    
    separator();
    #[derive(Debug)]
    #[allow(dead_code)]
    enum POS { BS(String), MS(String), PhD(String), };
    let demo = 
      POS::MS(String::from("Computer Engineering"));
    putln(
      &amp;"enum POS { 
              BS(String), MS(String), PhD(String), 
      };"
    );
    putln(
      &amp;"let demo = 
        POS::MS(String::from(\"Computer Engineering\"));
      ");
    log(&amp;demo);

                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output for Aggegate Types</defn-head>
                <defn-code>
 ---------------------------------
  let demo = [1, 2, 3];
  TypeId: [i32; 3], size: 12
  value:  [1, 2, 3]
 ---------------------------------
  let demo = [(1.5, 2.3), (3.1, 3.9)];
  TypeId: [(f64, f64); 2], size: 32
  value:  [(1.5, 2.3), (3.1, 3.9)]
 ---------------------------------
  let demo = (1, 2.5, (1,'a'), [1,2,3]);
  TypeId: (i32, f64, (i32, char), [i32; 3]), size: 32
  value:  (1, 2.5, (1, 'a'), [1, 2, 3])
 ---------------------------------
  let demo = String::from("a demo String");
  TypeId: alloc::string::String, size: 12
  value:  String (13): a demo String
 ---------------------------------
  let demo = String::from("a demo String");
  TypeId: alloc::string::String, size: 12
  value:  String (13): a demo String
  let rdemo = &mut demo;
  redemo.push_str(" more stuff")
  TypeId: alloc::string::String, size: 12
  value:  String (24): a demo String more stuff
  demo.push_str(" still more stuff")
  TypeId: alloc::string::String, size: 12
  value:  String (41): 
    a demo String more stuff still more stuff
 ---------------------------------
  struct Point { 
    x:f64, y:f64, z:f64, name:String, 
  }
  let demo = 
    Point { 
      x:1.5, y:2.5, z:3.7, 
      name:String::from("Peter") 
    };
  TypeId: 
    data_types::main::Point, size: 40
  value:  
    Point { 
      x: 1.5, y: 2.5, z: 3.7, 
      name: "Peter" 
    }
 ---------------------------------
  enum POS { 
    BS(String), MS(String), PhD(String), 
  };
  let demo = 
    POS::MS(
      String::from("Computer Engineering")
    );
  TypeId: data_types::main::POS, size: 16
  value:  MS("Computer Engineering")
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
      </div>
    </t-b>
    <t-b>
      Aggregate types are blittable if and only if they have all blittable members, e.g.,
      no Strings, Vecs, ...  In that case they can acquire the Copy trait, simply by
      qualifying them as implementing derived Copy:
      <indent-block class="pad5">
        #[derive(Debug, Copy, Clone)]
        struct my_struct { ... }
      </indent-block>
      The compiler generates these traits.  
      <indent-block>
        <ul class="tight">
          <li>
            Debug allows you to use {:?} in a format which uses a standard formatting 
            process for each of the Rust types.
          </li>
          <li>
            Copy causes the compiler to copy an instance&apos;s value by blitting (memcpy) to 
            the new location. The compiler will refuse to derive Copy if any member is non-blittable
            or the type already implements the Drop trait.
          </li>
          <li>
            Clone is not called implicitly, but a designer can write code that calls clone() and
            then pays whatever performance penalty accrues for making the copy. If you implement Copy you 
            are also required to implement Clone.
          </li>
        </ul>
      </indent-block>
    </t-b>
    <t-b>
      If an aggregate type is non-blittable, then attempting to derive the Copy trait is a compile error.
      However, you can implement Clone using the clone method on any non-blittable member if the member
      has the Clone trait.
    </t-b>

    <a id="strings"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>2.3</num-item1><num-item4>String Types:</num-item4>
    </num-cont>
    <t-b>
    <t-b>
      Rust provides two native string types: String and str, and two types intended for use with
      C language bindings: OsString and CString.  We will focus here on String and str.
    </t-b>
    The str type is part of the core Rust language and String is provided in the std library.  Both
    contain sequences of utf-8 characters.  The size of utf-8 characters ranges from 1 to 4 bytes.
    But String is implemented using Vec&lt;u8&gt;
    </t-b>
    <a id="libtypes"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>2.4</num-item1><num-item4>Std lib Data Types:</num-item4>
    </num-cont>
    <t-b>
      The std collections types are:
      <indent-block class="pad5">
        Vec, VecDeque, LinkedList, HashMap, HashSet, BTreeMap, BTreeSet, BinaryHeap 
      </indent-block>
    </t-b>
    <t-b>
      There are many other types defined in the stdlib for fs (FileSystem), io, net (TCP, UDP types),
      process, thread, time, ... In this section we will only look briefly at Vec and HashMap.
    </t-b>
    <t-b>
      <div>
        <details>
          <summary class="labelStyle darkItem">StdLib Data Types</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Stdlib Types code from main</defn-head>
                <defn-code>
    /* Rust Vectors: Vec&lt;(i32, f64, char)&gt; - vector of tuples */
    
    separator();
    let mut demo  :Vec&lt;(i32, f64, char)&gt; = Vec::new();
    demo.push((1, 2.5, 'z'));
    demo.push((2, 3.5, 'A'));
    putln(&amp;"let mut demo  :Vec&lt;(i32, f64, char)&gt; = Vec::new();");
    log(&amp;demo);

    /* Rust HashMap: HashMap&lt;String,i32&gt; */
    
    separator();
    use std::collections::HashMap;
    let mut demo :HashMap&lt;String, i32&gt; = HashMap::new();
    demo.insert("one".to_string(), 1);
    demo.insert("two".to_string(), 2);
    putln(&amp;"let mut demo :HashMap&lt;String, i32&gt; = HashMap::new();");
    log(&amp;demo);
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output for Stdlib Types</defn-head>
                <defn-code>
---------------------------------
  let mut demo  :Vec<(i32, f64, char)> = Vec::new();
  TypeId: alloc::vec::Vec<(i32, f64, char)>, size: 12
  value:  [(1, 2.5, 'z'), (2, 3.5, 'A')]
 ---------------------------------
  let mut demo :HashMap<String, i32> = HashMap::new();
  TypeId: std::collections::hash::map::HashMap<alloc::string::String, i32>, size: 40
  value:  {"one": 1, "two": 2}

                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
      </div>
    </t-b>
    <t-b>
      The std collections types are all non-blittable and are moved not copied. I expect that
      some implement the Clone trait, but have not worked with them enough to know.
    </t-b>
    <a id="epilogue"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>2.5</num-item1><num-item4>Epilogue:</num-item4>
    </num-cont>
    <t-b>
      There is one significant omission in this chapter.  We have not discussed slices, which are
      non-owning views into other aggregate types. This will be rectified in the next chapter, Operations.
    </t-b>
    <a id="refs"></a>
    <hr class="spread" />
    <num-cont>
      <num-item1>2.6</num-item1><num-item4>References:</num-item4>
    </num-cont>
    <table style="width:calc(100vw - 12rem);">
      <tr>
        <th class="darkItem">Reference Link</th>
        <th class="darkItem">Description</th>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">
            Character sets
          </a>
        </td>
        <td class="lightItem">
          The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and
          Character Sets (No Escuses!) - Joel Spolsky - [author&apos;s title]
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://doc.rust-lang.org/1.25.0/book/second-edition/ch08-02-strings.html">Rust Strings</a></td>
        <td class="lightItem">Rust Strings are implemented with Vec&lt;u8&gt; but interpreted as utf-8 chars</td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.rs/regex/1.3.4/regex/">regex Crate</a></td>
        <td class="lightItem">
          Rust regex crate provides facilities for parsing, compiling, and executing regular expressions. 
        </td>
      </tr>
      <tr>
        <td class="lightItem"><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust Containers</a></td>
        <td class="lightItem">
          Container diagrams
        </td>
        </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.rust-lang.org/">rust-lang.org home page</a>
        </td>
        <td class="lightItem">
          Links to download and documentation
        </td>
      </tr>
      <tr>
        <td class="lightItem">
          <a href="https://www.tutorialspoint.com/rust/index.htm">Tutorial&nbsp;-&nbsp;tutorialspoint.com</a>
        </td>
        <td class="lightItem">
          Tutorials for most of the Rust parts with code examples.
        </td>
      </tr>
      <!--<tr>
        <td class="lightItem">
          <a href="https://www.javatpoint.com/rust-tutorial">Tutorial - javatpoint.com</a>
        </td>
        <td class="lightItem">
          Quite extensive list of cheats and helpers.
        </td>
      </tr>-->
    </table>
  </bb-55>
  <spacer-25></spacer-25>
  <!--<img class="strip-photo" src="Pictures/CampusAtNight.jpg" alt="campus at night" />-->

  <info-bar></info-bar>
</body>
</html>