<!DOCTYPE html>
<html>
<!--
  BlogOOD.html
-->
<head>
  <title>Blog OOD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- <link rel="icon" type="image/x-icon" href="./images/favicon.ico" /> -->
  <link rel="stylesheet" href="css/StylesPhoto.css" />
  <link rel="stylesheet" href="css/StylesSizerComp.css" />
  <!-- PageFrame infrastructure -->
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemePython.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <!--<script src="js/ScriptsPageFrameDefaults.js"></script>-->
  <script src="js/ScriptsPageFramePosts.js"></script>
  <script src="js/ScriptsPageFramePagesPosts.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <!-- No need for Pages script for pages with no next or prev pages -->
  <!--<script src="js/ScriptsPageFramePages.js"></script>-->
  <!-- <script src="js/ScriptsTemplate.js"></script>
  <link rel="stylesheet" href="css/StylesTemplate.css" /> -->
  <style>
    h3 {
      margin-top: 1.5em;
    }

    #subtitle {
      margin-top: 0.4em;
      margin-bottom: 0.3em;
    }

    #github header summary {
      border: 1px solid var(--light);
    }

    #github summary {
      padding-right: 2em;
    }
    /* #github .menuHead {
          margin:0em -0.25em 0.0em -0.25em;
          padding:0.25em 0.5em;
        } */
  </style>
  <script>
    function load() {
      initialize();
      //loadif();
    }
  </script>
  <style>
    #github note {
      display: block;
      width:max-content;
      border:1px solid red;
      padding:0.5em 1.0em;
      margin:0.5em 0em;
    }
    #github .bargraph {
      border: 1px solid var(--dark);
      /* background-color: #bbb; */
      padding: 0.1em 0.5em;
      font-size:0.9em;
    }
    #github table {
      border:2px solid var(--dark);
    }
    #github table td {
      padding:0.25em 1.0em;
      border:none;
    }
    body {
      user-select:none;
    }
  </style>
  <script>
    function clickstat() {
      // prevent parent click event handling
      event.stopImmediatePropagation();
    }
  </script>
</head>
<body id="github" onload="load()" style="position:relative;">

  <a id="Next" href="BlogObjectModels.html">Next</a>
  <a id="Prev" href="BlogPrinciples.html">Prev</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main id="main">
      <div id="about" onclick="this.style.display = 'none'">about</div>
      <div id="page">Blog: Object Oriented Design</div>
      <div id="modified">11/23/2024</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content style="height:100vh; position:relative;">
        <header style="cursor:pointer;" onclick="loadif()">
          <!-- <a target="_blank" class="repoLink" href="https://github.com/JimFawcett">github Repositories</a> -->
          <hgroup id="pagetitle" style="border: 2px solid var(--dark);">
            <h1 id="title">Blog: Object Oriented Design</h1>
            <h3 class="indent" id="subtitle">
              Inheritance, composition, aggregation, using
            </h3>
          </hgroup>
          <!-- <img style="width:100%; margin:-0.1em 0em; border:2px solid var(--dark); padding:0.5em; background-color:var(--light);" src="Pictures/officestrip3a.svg" /> -->
          <div class="darkItem" onclick="loadif()" style="cursor:pointer; position:relative; padding:0.0em 0em 0.25em 0em; margin-top:-0.50em; border:2px solid var(--dark);">
            <a class="repoLinks" target="_blank" href="https://github.com/JimFawcett" style="color:var(--atten); margin-left:1.5em;">About</a>
            <div style="font-size:0.9em; position:absolute; top:0.1em; right:1.5em;">click to toggle Site Explorer</div>
            <div style="height:0.5em;"></div>
          </div>
        </header>

          <div style="height:1.5em;"></div>
          <h3>Initial Thoughts:</h3>
          <t-b>
            Programming languages tend to emphasize some style of constructing code.  There are many styles that
            have been and are currently used to develop programs, for example: Structured<sup>1</sup>,
            Functional<sup>2</sup>, Generic<sup>3</sup>, and Object Oriented programming<sup>4</sup>.
            <h3>Goals:</h3>
            The goals of object oriented design are to support program abstractions by encapsulating implementation details in class instances, provide composability through
            class relationships, and support extensibility through inheritance and paramaterization using C++ templates or generics with C# and Java.
          </t-b>
        
          <h3 id="encapsulation">Encapsulation:</h3>
          <div style="float:right; border:0px solid #4c2f27; padding-bottom:10px;">
            <img src="Pictures/InformationCluster.png" />
            <div style="text-align:center">
              Figure 1 - Encapsulation
            </div>
          </div>
          <t-b>
            The primary function of many solution side<sup>5</sup> classes is to manage some collection of state.  Encapsulation ensures that member state is always
            under the control of the managing class and only that class. Classes support encapsulation by providing access controls.
          </t-b>
          <ul>
            <li>
              Private methods and member data are accessible to every member of the class but inaccessible to clients and derived classes.
            </li>
            <li>
              Protected methods and member data are also accessible to derived classes, but not to clients.
            </li>
            <li>
              Public methods provide an interface for clients and derived classes.  We don't make member data public.
            </li>
          </ul>
          <p />
          <t-b>
            The private member data of a class is entirely under the control of its methods and cannot be changed by any other class or function.
            This ensures that member data is, for correctly designed classes, always in a valid state.  Providing protected member data weakens
            encapsulation since an incorrectly designed derived class can transform a correctly designed base's member data to an invalid state.
          </t-b>
        
          <h3 id="relations">Class Relationships:</h3>
          Classes support inheritance, composition, aggregation, and using relationships.
          <photosizer-block src="Pictures/ClassRelationships.png" width="500" class="photoSizerBlock right clear">
            <span style="font-family:'Comic Sans MS';">Fig 2. Class Relationships</span>
          </photosizer-block>
          <div style="height:1.0em;"></div>
          <div class="indent">
            <strong>Inheritance:</strong><br />
            <t-b>
              When a derived class D inherits from a base B it
              inherits all of the member functions and member data of the base class except, when using C++, for constructors, assignment operators, and destructors.
              The derived class may add additional methods and member data.
            </t-b>
            <strong>Composition:</strong><br />
            <t-b>
              composition is a strong ownership relation.  A composed part P becomes an integral part of the composer C.  P is constructed at the same time as C and shares
              its lifetime.  C++ supports composition with every user-defined type as well as types defined by the language.  Java and C# have two kinds of types, value types
              and reference types.  Composition of value types is supported by those languages, but composition of reference types is not supported.
            </t-b>
            <strong>Aggregation:</strong><br />
            <t-b>
              Aggregation is a weak ownership relation.  An aggregated part P may be instantiated by its aggregator A, but instantiation is not guaranteed to occur as that requires
              code in the aggregator to explicitly create an instance on the heap.  The aggregating class A composes a handle to the part P, but the instance of P itself
              resides on the heap from the time of its instantiation.  And so, the lifetime of P is less than the lifetime of the A.  C++ supports aggregation of
              user-defined types and types defined by the language, placing instances on the native heap.  Java and C# support aggregation for reference types and for
              value types if they are boxed, which wraps them with an instance of a reference type on the managed heap.
            </t-b>
            <strong>Using:</strong><br />
            <t-b>
              Using relationships provide access via references to instances of types R that are not owned by the using class U.  C++, Java, and C# support using relationships
            in the same way.  References to R are passed to an instance of U via a method argument.
          </div>
        
          <h3 id="lsp">Substitution:</h3>
          All Object Oriented Programming (OOP) languages support substitution:
          
          <t-b>
          <div class="indent">
            <strong>Liskov Substitution Principle:</strong>
            &quot;Functions that use pointers or references statically typed to some base class must be able to use objects of classes derived from the base through
            those pointers or references without any knowledge specialized to the derived classes.&quot;<sup>6</sup>
          </div>
          </t-b>
          <t-b>
          Substitution is a very powerful mechanism in OOP for building flexible software.  For example:
          <div class="indent">
          <t-b>
            In 2005 I designed a rule-based <a href="BlogParser.html">parser</a> for students to use for code analysis projects and also for research that a doctoral
            advisee, Murat Gungor, and I were working on.  Rules are detectors of specific syntactic constructs and derive from an IRule interface.  Each rule has one or more
            associated actions that derive from an IAction interface.  The parser is just a container for rules and rules are containers for their actions.  Parser passes token sequences
            obtained from an associated scanner to each rule.  When a rule matches it invokes its actions to save results for later use.
          </t-b>
          <t-b>
            What makes this useful is that we can add new rules at any time without affecting any of the other analysis code.  This flexibility comes about through
            Liskov Substitution.  The parser holds IRule pointers to its rules; and methods called on the IRule interface bind to the derived methods overridden by
            the concrete rule classes.  Liskov Substitution guarantees us that an IRule pointer can bind to an instance of a derived rule class.
          </t-b>
          </div>
        
          <h3 id="sharing">Sharing:</h3>
          <div style="width:calc(100vw - 9rem);">
            <photosizer-block src="Pictures/Tri-level-inheritance.png" width="400" class="photoSizerBlock right clear">
              <span style="font-family:'Comic Sans MS';">Fig 3. Sharing</span>
            </photosizer-block>
          </div>
          <t-b>
          Inheritance provides for sharing of interfaces, implementations, shared types, and shared instances.  This is illustrated in Figure 3.
          </t-b>
          <t-b>
          The IPackageInterface is inherited by AbstrCommonCode and its derived classes.
          </t-b>
          <t-b>
          The abstract class AbstrCommonCode provides shared method code
          and also sharing of the SharedResource.  Each derived class inherits the shared method implementations and an instance of SharedResource that is unique to each
          derived class.
          </t-b>
          <t-b>
          If the SharedResource is declared static in AbstrCommonCode, then each derived class shares the same instance of SharedResource.
          </t-b>
          <h3 id="isp">Interface Segregation:</h3>
          <t-b>
          When a class has many users it is tempting to add public methods in the class to support operations that may be required by only one or two client
          applications.  If the class remains popular its public interface may become very large with only a few methods used by any one client.
          This causes problems when the class has to change:
          </t-b>
          <t-b>
          <div class="indent">
            <strong>Interface Segregation Principle</strong>
            &quot;Clients should not be forced to depend upon interfaces they do not [fully] use.&quot; &quot;If we have to change an interface we affect even those clients
            that do not use the features we change&quot;<sup>6</sup>.
          </div>
          </t-b>
          <t-b>
          Changing an interface may cause the code of each client to require new layout even if they
          don't use the changed parts.  That means they must be recompiled, which for large systems, may be a non-trivial process.  We can avoid this by factoring
          the interface into several parts.  Each client can then use multiple inheritance to bind to just the features they need.  Often, to avoid multiple inheritance,
          we may factor not only the
          interface but the clients as well.  That's what was done in the <a href="blogparser.htm">parser</a>.  The parsing interface was separated into IRule, IAction,
          ITokenCollection, and IBuild.  The rules and actions were factored as well into small managable parts.
          </t-b>
          <h3 id="dip">Dependency Inversion:</h3>
          <div style="width:calc(100vw - 9rem);">
            <photosizer-block src="Pictures/DepInversion.png" width="400" class="photoSizerBlock right clear">
              <span style="font-family:'Comic Sans MS';">Fig 3. Dependency Inversion</span>
            </photosizer-block>
          </div>
          <t-b>
          It is common for a software design to factor into a policy layer of classes that implement the program's obligations, a lower implementation layer that provides
          solution artifacts like data structures, formatters, analyzers, and the like.  The implementation layer will probably bind to classes in utility libraries developed
          for the application domain.  If bindings are to concrete classes in each layer the design becomes very brittle.  A change in the bottom layer may cause changes to
          propagate up to the very top layers.
          </t-b>
          <t-b>
          <div class="indent">
            <strong>Dependency Inversion Principle:</strong>
            &quot;High level components should not depend upon low level components.  Instead, both should depend on abstractions.&quot;  &quot;Abstractions should not depend on details.
            Details should depend upon the abstractions.&quot;<sup>6</sup>
          </div>
          </t-b>
          <t-b>
          If we use interfaces, the text of the upper layer for all invocations into a lower layer will depend on the interface of the lower layer, not on its concrete classes.  If we use
          object factories, the text of the upper layer for all instantiations of lower level concrete classes will depend on the interface of the object factory
          not on the declarations of the specific objects being created.  This makes the upper layer's compilation independent of anything that may happen in the lower layer
          provided the interfaces don't change.
          </t-b>
          <h3 id="patterns">Patterns:</h3>
          <t-b>
          In CSE687 - Object Oriented Design, we discussed several patterns from the "Design Patterns" book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.  The book contains a catalog
          of 23 patterns that each pose a design problem and show how to use Object Oriented Design principles to address the problem.  These are  not intended to be
          recipes that you apply by rote.  Rather each presents a sound design using classes and class relationships to illustrate interesting design ideas.  You are expected
          to bend the ideas from the catalog to the situations you encounter in your own designs.
          </t-b>
          <t-b>
          Each of the examples I've presented here have elements of one or more of the design patterns but don't apply the exact solution from the pattern.  The parser
          uses elements of the Builder and strategy patterns.  The <a href="BlogMessagePassingComm.html">Message-Passing Communication System</a> uses a mediator similar to the
          Mediator Pattern.
          Where I don't use a recognizable deriviative of a pattern most of my designs are informed by the ideas developed in the pattern discussions.
          </t-b>
          <t-b>
          The course
          <a href="https://ecs.syr.edu/faculty/fawcett/handouts/webpages/CSE687.htm">CSE687 - Object Oriented Design</a> is the first part of a two part story.  The second part unfolds in
          <a href="https://ecs.syr.edu/faculty/fawcett/handouts/webpages/CSE776.htm">CSE776 - Design Patterns</a>.
          <p style="margin-bottom:30px;" />
          <hr />
          <ol>
            <li>
              Structured programming uses global functions assembled into packages to represent a program's structure and behavior.
              The C programming language provides facilities for structured programming exclusively.
            </li>
            <li>
              Functional programming attempts to bring the rigor of mathematics to program development. Initially based on the lambda calculus,
              functional languages like Haskell and Erlang use pure functions that have no side effects and accept and return other functions
              as part of their operation.  State in functional programs is immutable with loops implemented through recursion.
            </li>
            <li>
              Generic programming defines classes and functions using type parameters that can be instantiated with concrete types at the time
              an application is built.  Java generics and C++ templates support this programming style.
            </li>
            <li>
              Object Oriented Design is based on the use of classes and class relationships to structure programs.  In C++ a class may use, compose,
              or aggregate any other type and inherit from any non-primitive type, whether provided by the language or defined by a user.
              In Managed languages like C# and Java types are segregated into value types which are copy-able and reference types that are not.
              Value types and handles to reference types live in their program's set of stack frames while all instances of reference types live
              in the program's managed heap.  Reference types cannot compose other reference types.  They aggregate them, e.g., they compose a
              handle to the reference type which points to the handle's instance in the managed heap. They may inherit any single type that is not sealed
              and not primitive.  Java and C# do support multiple inheritance of interfaces.
            </li>
            <li>
              We categorize packages as &quot;application side&quot; or &quot;solution side&quot; depending on whether they focus on meeting
              the requirements of their program or some lower-level supporting role.  Solution side classes are very often
              constructed to be reusable in other programs by giving them flexiblity through template parameterization or inheritance hooks.
              Application side classes are far less often reusable as they focus on the obligations of one specific program.
            </li>
            <li>
              Robert Martin wrote a series of white papers, now hosted on his blog, which present the principles discussed here and others as well.
              Here's a link to one of his variations on these principles and related topics: <a href="http://www.butunclebob.com/">Principles</a>.
            </li>
          </ol>
          <t-b style="margin-top:1.5em;">
            <div align="center" style="width:calc(100vw - 9rem);">
              <img class="strip-photo" src="Pictures/BusStopStrip.jpg" alt="campus view" style="width:100%;" />
            </div>
          </t-b>
         
                <div style="height:1.0em;"></div>
        <a id="bottom"></a>
      </content>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <menu-elem style="width:0.0em">&nbsp;</menu-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#patterns">patterns</a></menu-elem>
        <menu-elem class="secElem"><a href="#dip">DIP</a></menu-elem>
        <menu-elem class="secElem"><a href="#isp">ISP</a></menu-elem>
        <menu-elem class="secElem"><a href="#sharing">sharing</a></menu-elem>
        <menu-elem class="secElem"><a href="#lsp">LSP</a></menu-elem>
        <menu-elem class="secElem"><a href="#relations">relations</a></menu-elem>
        <menu-elem class="secElem"><a href="#encapsulation">encapsulation</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
        <div class='darkItem popupHeader' style="padding:0.25em 2.0em;" onclick="this.parentElement.style.display='none'">Sections</div>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:2.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:1em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn + ":";
  </script>
</body>
</html>