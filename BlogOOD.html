<!DOCTYPE html>
<html>
<head>
  <!--
   - BlogOOD.htm - Code Artist Thoughts
   - ver 1.0 - 05 April 2014
   - Jim Fawcett, Syracuse University
  -->
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta name="description" content="Software Engineering course notes. Code Samples. Software Links" />
  <meta name="keywords" content="Lecture, Notes, Code, Syracuse,University" />
  <meta name="Author" content="Jim Fawcett" />
  <meta name="Author" content="James Fawcett" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <title>Blog.OOD</title>
  <script src="js/ScriptsUtilities.js"></script>
  <script src="js/ScriptsTemplate.js"></script>
  <script src="js/ScriptsKeyboard.js"></script>
  <script src="js/ScriptsMenu.js"></script>
  <link rel="stylesheet" href="css/StylesTemplate.css" />
  <link rel="stylesheet" href="css/StylesMenu.css" />
  <style>
    #github header {
      margin-left: 0px;
      margin-right: 0px;
    }

    #github #pagetitle {
      background-color: #e3dac9;
      color: #800020;
      border: 1px solid maroon;
    }

    #github #title {
      background-color: #e3dac9;
      color: #3f000f;
    }
  </style>
</head>
<body id="github" onload="initializeMenu()">

  <navKeys-Container>
    <nav-Key id="sKey" onclick="toggleSwipeEvents()">S</nav-Key>
    <nav-Key id="rKey" onclick="location.reload()">R</nav-Key>
    <nav-Key id="tKey" onclick="scrollPageTop()">T</nav-Key>
    <nav-Key id="bKey" onclick="scrollPageBottom()">B</nav-Key>
    <nav-Key id="hKey" onclick="helpWin()">H</nav-Key>
    <nav-Key id="pKey" onclick="loadPrev()">P</nav-Key>
    <nav-Key id="nKey" onclick="loadNext()">N</nav-Key>
  </navKeys-Container>

  <nav>
    <div id="navbar"></div>
  </nav>
  <a id="Next" href="BlogObjectModels.html">N</a>
  <a id="Prev" href="BlogPrinciples.html">P</a>

  <header>
    <hgroup id="pagetitle">
      <h1 id="title">Code Artistry - Object Oriented Design</h1>
    </hgroup>
  </header>

  <!-- page content -->

  <h3>Initial Thoughts:</h3>
  Programming languages tend to emphasize some style of constructing code.  There are many styles that
  have been and are currently used to develop programs, for example: Structured<sup>1</sup>,
  Functional<sup>2</sup>, Generic<sup>3</sup>, and Object Oriented programming<sup>4</sup>.
  <h3>Goals:</h3>
  The goals of object oriented design are to support program abstractions by encapsulating implementation details in class instances, provide composability through
  class relationships, and support extensibility through inheritance and paramaterization using C++ templates or generics with C# and Java.

  <h3>Encapsulation:</h3>
  <div style="float:right">
    <img src="Pictures/InformationCluster.png" />;
    <div style="text-align:center">
      Figure 1 - Encapsulation
    </div>
  </div>
  The primary function of many solution side<sup>5</sup> classes is to manage some collection of state.  Encapsulation ensures that member state is always
  under the control of the managing class and only that class. Classes support encapsulation by providing access controls.
  <ul>
    <li>
      Private methods and member data are accessible to every member of the class but inaccessible to clients and derived classes.
    </li>
    <li>
      Protected methods and member data are also accessible to derived classes, but not to clients.
    </li>
    <li>
      Public methods provide an interface for clients and derived classes.  We don't make member data public.
    </li>
  </ul>
  <p />
  The private member data of a class is entirely under the control of its methods and cannot be changed by any other class or function.
  This ensures that member data is, for correctly designed classes, always in a valid state.  Providing protected member data weakens
  encapsulation since an incorrectly designed derived class can transform a correctly designed base's member data to an invalid state.

  <h3>Class Relationships:</h3>
  Classes support inheritance, composition, aggregation, and using relationships.
  <div style="float:right">
    <div align="right" style="margin-right:40px; margin-top:0px;">
      Figure 2 - Class Relationships&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <input type="button" value="+" onclick="incrementSize(2);" />&nbsp;
      <input type="button" value="-" onclick="decrementSize(2);" />
    </div>
    <img id="2" src="Pictures/ClassRelationships.png" width="600" />
  </div>
  <p />
  <div class="indent">
    <strong>Inheritance:</strong><br />
    When a derived class D inherits from a base B it
    inherits all of the member functions and member data of the base class except, when using C++, for constructors, assignment operators, and destructors.
    The derived class may add additional methods and member data.
    <p />
    <strong>Composition:</strong><br />
    composition is a strong ownership relation.  A composed part P becomes an integral part of the composer C.  P is constructed at the same time as C and shares
    its lifetime.  C++ supports composition with every user-defined type as well as types defined by the language.  Java and C# have two kinds of types, value types
    and reference types.  Composition of value types is supported by those languages, but composition of reference types is not supported.
    <p />
    <strong>Aggregation:</strong><br />
    Aggregation is a weak ownership relation.  An aggregated part P may be instantiated by its aggregator A, but instantiation is not guaranteed to occur as that requires
    code in the aggregator to explicitly create an instance on the heap.  The aggregating class A composes a handle to the part P, but the instance of P itself
    resides on the heap from the time of its instantiation.  And so, the lifetime of P is less than the lifetime of the A.  C++ supports aggregation of
    user-defined types and types defined by the language, placing instances on the native heap.  Java and C# support aggregation for reference types and for
    value types if they are boxed, which wraps them with an instance of a reference type on the managed heap.
    <p />
    <strong>Using:</strong><br />
    Using relationships provide access via references to instances of types R that are not owned by the using class U.  C++, Java, and C# support using relationships
    in the same way.  References to R are passed to an instance of U via a method argument.
  </div>

  <h3>Substitution:</h3>
  All Object Oriented Programming (OOP) languages support substitution:
  <p />
  <div class="indent">
    <strong>Liskov Substitution Principle:</strong>
    &quot;Functions that use pointers or references statically typed to some base class must be able to use objects of classes derived from the base through
    those pointers or references without any knowledge specialized to the derived classes.&quot;<sup>6</sup>
  </div>
  <p />
  Substitution is a very powerful mechanism in OOP for building flexible software.  For example:
  <div class="indent">
    In 2005 I designed a rule-based <a href="BlogParser.html">parser</a> for students to use for code analysis projects and also for research that a doctoral
    advisee, Murat Gungor, and I were working on.  Rules are detectors of specific syntactic constructs and derive from an IRule interface.  Each rule has one or more
    associated actions that derive from an IAction interface.  The parser is just a container for rules and rules are containers for their actions.  Parser passes token sequences
    obtained from an associated scanner to each rule.  When a rule matches it invokes its actions to save results for later use.
    <p />
    What makes this useful is that we can add new rules at any time without affecting any of the other analysis code.  This flexibility comes about through
    Liskov Substitution.  The parser holds IRule pointers to its rules; and methods called on the IRule interface bind to the derived methods overridden by
    the concrete rule classes.  Liskov Substitution guarantees us that an IRule pointer can bind to an instance of a derived rule class.
  </div>

  <h3>Sharing:</h3>
  <div style="float:right; margin-left:20px;">
    <img src="Pictures/Tri-level-inheritance.png" width="600" />
    <div style="text-align:center">
      Figure 3 - Sharing
    </div>
  </div>
  Inheritance provides for sharing of interfaces, implementations, shared types, and shared instances.  This is illustrated in Figure 3.
  <p />
  The IPackageInterface is inherited by AbstrCommonCode and its derived classes.
  <p />
  The abstract class AbstrCommonCode provides shared method code
  and also sharing of the SharedResource.  Each derived class inherits the shared method implementations and an instance of SharedResource that is unique to each
  derived class.
  <p />
  If the SharedResource is declared static in AbstrCommonCode, then each derived class shares the same instance of SharedResource.

  <h3>Interface Segregation:</h3>
  When a class has many users it is tempting to add public methods in the class to support operations that may be required by only one or two client
  applications.  If the class remains popular its public interface may become very large with only a few methods used by any one client.
  This causes problems when the class has to change:
  <p />
  <div class="indent">
    <strong>Interface Segregation Principle</strong>
    &quot;Clients should not be forced to depend upon interfaces they do not [fully] use.&quot; &quot;If we have to change an interface we affect even those clients
    that do not use the features we change&quot;<sup>6</sup>.
  </div>
  <p />
  Changing an interface may cause the code of each client to require new layout even if they
  don't use the changed parts.  That means they must be recompiled, which for large systems, may be a non-trivial process.  We can avoid this by factoring
  the interface into several parts.  Each client can then use multiple inheritance to bind to just the features they need.  Often, to avoid multiple inheritance,
  we may factor not only the
  interface but the clients as well.  That's what was done in the <a href="blogparser.htm">parser</a>.  The parsing interface was separated into IRule, IAction,
  ITokenCollection, and IBuild.  The rules and actions were factored as well into small managable parts.

  <h3>Dependency Inversion:</h3>
  <div style="float:right">
    <img src="Pictures/DepInversion.png" width="600" />
    <div style="text-align:center; margin-bottom:20px;">
      Figure 4 - Dependency Inversion
    </div>
  </div>
  It is common for a software design to factor into a policy layer of classes that implement the program's obligations, a lower implementation layer that provides
  solution artifacts like data structures, formatters, analyzers, and the like.  The implementation layer will probably bind to classes in utility libraries developed
  for the application domain.  If bindings are to concrete classes in each layer the design becomes very brittle.  A change in the bottom layer may cause changes to
  propagate up to the very top layers.
  <p />
  <div class="indent">
    <strong>Dependency Inversion Principle:</strong>
    &quot;High level components should not depend upon low level components.  Instead, both should depend on abstractions.&quot;  &quot;Abstractions should not depend on details.
    Details should depend upon the abstractions.&quot;<sup>6</sup>
  </div>
  <p />
  If we use interfaces, the text of the upper layer for all invocations into a lower layer will depend on the interface of the lower layer, not on its concrete classes.  If we use
  object factories, the text of the upper layer for all instantiations of lower level concrete classes will depend on the interface of the object factory
  not on the declarations of the specific objects being created.  This makes the upper layer's compilation independent of anything that may happen in the lower layer
  provided the interfaces don't change.

  <h3>Patterns:</h3>
  In CSE687 - Object Oriented Design, we discussed several patterns from the "Design Patterns" book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.  The book contains a catalog
  of 23 patterns that each pose a design problem and show how to use Object Oriented Design principles to address the problem.  These are  not intended to be
  recipes that you apply by rote.  Rather each presents a sound design using classes and class relationships to illustrate interesting design ideas.  You are expected
  to bend the ideas from the catalog to the situations you encounter in your own designs.
  <p />
  Each of the examples I've presented here have elements of one or more of the design patterns but don't apply the exact solution from the pattern.  The parser
  uses elements of the Builder and strategy patterns.  The <a href="BlogMessagePassingComm.html">Message-Passing Communication System</a> uses a mediator similar to the
  Mediator Pattern.
  Where I don't use a recognizable deriviative of a pattern most of my designs are informed by the ideas developed in the pattern discussions.
  <p />
  The course
  <a href="https://ecs.syr.edu/faculty/fawcett/handouts/webpages/CSE687.htm">CSE687 - Object Oriented Design</a> is the first part of a two part story.  The second part unfolds in
  <a href="https://ecs.syr.edu/faculty/fawcett/handouts/webpages/CSE776.htm">CSE776 - Design Patterns</a>.
  <p style="margin-bottom:30px;" />
  <hr />
  <ol>
    <li>
      Structured programming uses global functions assembled into packages to represent a program's structure and behavior.
      The C programming language provides facilities for structured programming exclusively.
    </li>
    <li>
      Functional programming attempts to bring the rigor of mathematics to program development. Initially based on the lambda calculus,
      functional languages like Haskell and Erlang use pure functions that have no side effects and accept and return other functions
      as part of their operation.  State in functional programs is immutable with loops implemented through recursion.
    </li>
    <li>
      Generic programming defines classes and functions using type parameters that can be instantiated with concrete types at the time
      an application is built.  Java generics and C++ templates support this programming style.
    </li>
    <li>
      Object Oriented Design is based on the use of classes and class relationships to structure programs.  In C++ a class may use, compose,
      or aggregate any other type and inherit from any non-primitive type, whether provided by the language or defined by a user.
      In Managed languages like C# and Java types are segregated into value types which are copy-able and reference types that are not.
      Value types and handles to reference types live in their program's set of stack frames while all instances of reference types live
      in the program's managed heap.  Reference types cannot compose other reference types.  They aggregate them, e.g., they compose a
      handle to the reference type which points to the handle's instance in the managed heap. They may inherit any single type that is not sealed
      and not primitive.  Java and C# do support multiple inheritance of interfaces.
    </li>
    <li>
      We categorize packages as &quot;application side&quot; or &quot;solution side&quot; depending on whether they focus on meeting
      the requirements of their program or some lower-level supporting role.  Solution side classes are very often
      constructed to be reusable in other programs by giving them flexiblity through template parameterization or inheritance hooks.
      Application side classes are far less often reusable as they focus on the obligations of one specific program.
    </li>
    <li>
      Robert Martin wrote a series of white papers, now hosted on his blog, which present the principles discussed here and others as well.
      Here's a link to one of his variations on these principles and related topics: <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">Principles</a>.
    </li>
  </ol>
  <p>
    <div align="center">
      <img class="strip-photo" src="Pictures/campus5strip.jpg" alt="campus view" width="98%" />
    </div>
  </p>
  <info-bar></info-bar>
</body>

</html>