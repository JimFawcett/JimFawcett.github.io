<!DOCTYPE html>
<html>
<!--
  RustLogger.html
-->
<head>
  <title>Testing Repo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeBlue.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <!--<script src="js/ScriptsPageFrame.js"></script>-->
  <script src="js/ScriptsPageFrameCppRepos.js"></script>
  <script src="js/ScriptsPageFramePagesCppRepos.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }

    .container {
      display: grid;
      grid-template-columns: 0em 0.6fr 1.5fr 0.6fr 1fr 0em;
      /*link to pg, descrip, link to repo, status grid-column-gap: 0em;*/
      padding: 0.0em;
      margin: 0em 0.25em 1em 0.25em;
      border: 1px solid var(--dark);
    }

    .item1 {
      grid-column: 2;
      padding: 0.2em 1em;
      border: 2px solid var(--dark);
    }

    .item2 {
      grid-column: 3;
      padding: 0.2em 1em;
      border: 2px solid var(--dark);
    }

    .item3 {
      grid-column: 4;
      padding: 0.2em 1em;
      border: 2px solid var(--dark);
    }

    .item4 {
      grid-column: 5;
      padding: 0.2em 1em;
      border: 2px solid var(--dark);
    }

    .gray {
      background-color: #ddd;
    }

    .spread {
      margin: 1em;
    }

    .tightSpread {
      margin: 0.5em;
    }
/*    #github #pagetitle {
      background-color:var(--dark);
      color: var(--light);
    }

    #github #title {
      background-color: var(--dark);
      color: var(--light);
    }

    #github #subtitle {
      background-color: var(--dark);
      color: var(--light);
    }

    #github a.repoLink {
      background-color: var(--dark);
      color: var(--light);
    }
*/    #github indent-block {
      padding:0.5em 0em;
    }
  </style>
  <script>
    function loadifcpp() {
      var loc = window.location.href;
      if (window.self === window.top) {
        window.location.href = 'TOCCpp.html?src=' + loc;
        }
      else {
        window.top.location.href = loc;
        }
    }
  </script>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="Logger.html">N</a>
  <a id="Prev" href="FileUtilities.html">P</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about" onclick="this.style.display = 'none'">about</div>
      <div id="modified">11/30/2022</div>
      <div id="page">Testing Repo</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>
        <header>
          <a target="_blank" class="repoLink" href="https://github.com/JimFawcett/Testing">Testing code</a>
          <hgroup id="pagetitle" onclick="loadifcpp()" style="cursor:pointer;">
            <h1 id="title">Testing&nbsp;&nbsp;Repository</h1>
            <h3 id="subtitle" class="indent">Single-user Test Harness and Assertions</h3>
          </hgroup>

          <div onmouseleave="closeQuickStatus()" style="padding-right:25px; position:absolute; top:1.9em; right:0.25em;">
            <details>
              <summary class="darkItem quickStatus" style="border:1px solid var(--light);">Quick Status</summary>
              <status-grid style="padding:5px 10px;" class="lightItem border">
                <status-itemLeft>
                  Code functions correctly
                </status-itemLeft>
                <status-itemRight>
                  no known defects
                </status-itemRight>
                <status-itemLeft>
                  Demonstration code
                </status-itemLeft>
                <status-itemRight>
                  yes
                </status-itemRight>
                <status-itemLeft>
                  Documentation
                </status-itemLeft>
                <status-itemRight>
                  yes
                </status-itemRight>
                <status-itemLeft>
                  Test cases
                </status-itemLeft>
                <status-itemRight>
                  yes
                </status-itemRight>
                <status-itemLeft>
                  Static library
                </status-itemLeft>
                <status-itemRight>
                  not yet
                </status-itemRight>
                <status-itemLeft>
                  Planned design changes
                </status-itemLeft>
                <status-itemRight>
                  None for now
                </status-itemRight>
              </status-grid>
            </details>
          </div>
        </header>

        <indent-blocks>
          <h3 id="concept">1.0 Concept:</h3>
          <t-b>
            When a code project contains more than one or two packages adequate testing is likely to require
            a sequence of test cases. There are four types of tests needed for code in this repository: Construction,
            Unit, Regression, and Performance tests.
          </t-b>
          <t-b>
            <details>
              <summary class="labelStyle lightItem">Test Type details</summary>
              <t-b>
                <ol>
                  <li>
                    <span class="notice">Construction Tests:</span>
                    <div>
                      These tests are implemented as an integral part of the implementation of a package&apos;s
                      code<sup>1</sup>. We add a few lines of code or a small function, then add a test to ensure that the
                      new code functions as expected.  If we need more than one simple test to verify the new code, then
                      we aren&apos;t testing often enough.  If the test fails, we know where to find the problem - in
                      the last few lines of code.  The test code may be part of the package&apos;s main function or may
                      reside in a separate test package.
                    </div>
                  </li>
                  <li>
                    <span class="notice">Unit Tests:</span>
                    <div>
                      The intent of unit testing is to attempt to ensure that tested code meets all its obligations
                      in a robust manner.  That entails testing every path through the code and testing boundary conditions,
                      e.g., beginning and end of the computational range, all cases that it may need to execute, and success or
                      failure when executing operations that may fail, like opening streams or connecting a socket.
                      Unit tests are labor intensive, and we may elect to unit test only those packages on which many other
                      packages depend.
                    </div>
                  </li>
                  <li>
                    <span class="notice">Regression Tests:</span>
                    <div>
                      Regression tests are tests typically conducted over a library or large subsystem during their
                      implementation.  Each regression test contains a set of test cases that are executed individually
                      usually in a predetermined sequence.  It is very common to use a test harness to aggregate all the
                      tests and apply them to the library or subsystem whenever there is significant change.  The idea is
                      to discover problems early that are due to changes in dependencies or the platform on which
                      the code executes.
                    </div>
                  </li>
                  <li>
                    <span class="notice">Performance Tests:</span>
                    <div>
                      Performance testing attempts to construct tests that:
                      <ul class="tight">
                        <li>
                          Compare two processing streams satisfying the same obligations, to see which
                          has higher throughput, lower latency, or other performance metrics.
                        </li>
                        <li>
                          Attempt to make testing overhead a negligible part of the complete test process,
                          by pulling as much overhead as possible into initial and final activities that
                          are not included in measured outputs.
                        </li>
                        <li>
                          Run many times to amortize any remaining startup and shutdown, and average over
                          environmental effects that may have nothing to do with the comparison, but
                          happen to ocur during testing.
                        </li>
                      </ul>
                      Often, a single iteration of a test may run fast enough that it is not possible to accurately
                      measure the time consumed, so running many iterations is also a way of improving measurement
                      accuracy.
                    </div>
                  </li>
                </ol>
              </t-b>
            </details>
          </t-b>
          <t-b>
            For construction tests, we provide simple tests that are quick to write and don&apos;t require
            a lot of analysis to build.  For unit, regression, and performance tests we need to be more careful. These tests should
            satisfy three properties: they should be repeatable, test both normal and abnormal conditions, and
            present test output as information, not data.
          </t-b>
          <t-b>
            <details>
              <summary class="labelStyle lightItem">Test Properties details</summary>
              <ol>
                <li>
                  <span class="notice">Tests should be repeatable</span> with the same results every time.
                  <div>
                    That implies that each test has a &quot;setup&quot; process that guarentees the testing
                    environment is in a fixed state at the beginning of testing. We may choose to do that with
                    an initialize function or may use a test class for each test that sets up the
                    environment in its constructor.
                  </div>
                </li>
                <li>
                  <span class="notice">Test normal and abnormal conditions</span> as completely as practical.
                  <div>
                    We do that by planning each test, defining input data to provide both expected and
                    possible but unexpected conditions. It helps to define functions:
                    <ul class="tight">
                      <li>
                        <span class="notice">Requires(pred)</span>
                        <div>
                          defines condtions that are expected
                          to hold before an operation begins.
                        </div>
                      </li>
                      <li>
                        <span class="notice">Ensures(pedicate)</span>
                        <div>
                          defines condtions that are expected to hold after an operation.
                        </div>
                      </li>
                      <li>
                        <span class="notice">Assert(predicate)</span>
                        <div>
                          defines conditions that should be true at specific places in an operation.
                        </div>
                      </li>
                    </ul>
                  </div>
                  where predicate is a boolean valued operation on the test environment and/or code
                  state.
                </li>
                <li>
                  <span class="notice">Visualize operation results.</span>
                  <div>
                    Evaluating all the conditions above often results in a lot of raw data about the
                    environment and code states.  We need a way to selectively display that to a test
                    developer. That means we need a logging facility that can write to the console, to
                    test data files, or both.  We want to be able to select the levels of display, so
                    we get very little output when the tests are running successfully, but with a lot
                    more detail when operations fail or are not as expected.
                  </div>
                </li>
              </ol>
            </details>
          </t-b>
          <t-b>
            For these thorough tests it is common to write a brief test specification which clearly defines
            the expected test results, initial setup, and any additional instructions for test developers
            that may be needed (ideally none).
          </t-b>
          <t-b>
            When unit, regression, and performance tests are concluded, a test report, generated by a logging
            facility, is saved in the appropriate code repository. This should have a summary of
            what passed and what failed, along with whatever data was logged during the final tests.
          </t-b>
          <h3 id="design">2.0 Design:</h3>
          <t-b style="margin-bottom:0px;">
            This repository contains code that implements the concept. The code structure is shown in Fig 1., below.
            Here&apos;s the way it works:
          </t-b>
          <photosizer-block src="Pictures/Testing.jpg" width="500" class="photoSizerBlock left" style="margin-top:0;">
            <span style="font-family:'Comic Sans MS', Tahoma;">
              Fig 1. Test Harness Classes
            </span>
          </photosizer-block>
          <t-b>
            The test developer creates a TestExecutive package that may consist of
            one or more <c-s>TestClass</c-s> instances bound to code to test. Each <c-s>TestClass</c-s> derives from
            <c-s>ITest</c-s> and so is required to implement <c-s>bool TestClass::test()</c-s> which will be
            executed by the test harness.
          </t-b>
          <t-b>
            The TestExecutive main function registers each <c-s>TestClass</c-s> with the <c-s>TestSequencer</c-s>.
            The the sequencer is run with the method <c-s>bool TestSequencer::doTests()</c-s>. Each test is
            passed to the Executor to run in the context of a try-catch block and announces its results.
          </t-b>
          <t-b>
            Should a test throw an exception, that test fails and testing continues, as the Executor catches
            exceptions and simply announces failure, then continues with the next test.
          </t-b>
          <t-b>
            The main test method, <c-s>bool TestClass::test()</c-s> of a <c-s>TestClass</c-s> is likely to contain
            a series of child test methods with the same signature, e.g., <c-s>bool(TestClass::*)()</c-s>. So the main
            method can create a local <c-s>Executor</c-s> instance in which to run each of these test functions.
          </t-b>
          <t-b class="indent">
            <defn-outerBlock class="bb-55">
              <defn-block>
                <defn-head>Single-user Test Harness</defn-head>
                <defn-body>
                  The single-user test harness environment has four classes:
                  <t-b class="indent">
                    <ol class="tight">
                      <li>
                        <c-s class="notice">TestSequencer</c-s> runs test sequences. Each <c-s>TestClass</c-s>
                        of the sequence is registered with the <c-s>TestSequencer</c-s>. When started it iterates over its
                        <c-s>TestClass</c-s>es, and for each, passes the <c-s>TestClass</c-s> instance to an instance
                        of <c-s>Executor</c-s><sup>1</sup>.
                      </li>
                      <li>
                        <c-s class="notice">Executor</c-s> executes each test within a try-catch block and annunciates
                        the result. The purpose of this class is to avoid littering test code with try-catch blocks for
                        each test and with code to announce the results.
                      </li>
                      <li>
                        <c-s class="notice">TestClass</c-s> is provided by the test developer. It is required to implement
                        the <c-s>ITest</c-s> interface and to bind to code to be tested. The <c-s>Executor</c-s> tests
                        a single <c-s>bool TestClass::test()</c-s> function.  Often that function will execute several
                        lower-level test functions in a local <c-s>Executor</c-s> instance and return false unless all
                        of the internal test functions pass.
                      </li>
                      <li>
                        <c-s class="notice">TestExecutive</c-s>, created by the test developer, contains the <c-s>main</c-s>
                        entry point for testing<sup>2</sup>. It may be just that main or may have its own implementation class(es).
                      </li>
                    </ol>
                    <hr class="spreadup" />
                    <div class="footnote">
                      <ol class="tight">
                        <li>
                          The <c-s>TestSequencer</c-s> and <c-s>Executor</c-s> can also execute tests where each test
                          is defined by a pointer to a test function, e.g., has a function signature <c-s>bool(*)()</c-s>.
                        </li>
                        <li>
                          All of this is illustrated by code in this repository.
                        </li>
                      </ol>
                    </div>
                  </t-b>
                </defn-body>
              </defn-block>
            </defn-outerBlock>
            <t-b>
              The code contained in this repository has a demonstration test class <c-s>TestWidgetClass</c-s> and
              demonstration tested code <c-s>WidgetClass</c-s>. We show, in the blocks below, partial code and
              results of running the code.
            </t-b>
            <defn-outerBlock>
              <defn-block style="width:40%;">
                <defn-head>
                  Test Case:
                </defn-head>
                <defn-body>
                  A test case contains in comments:
                  <ol class="tight">
                    <li>A name</li>
                    <li>
                      Brief test description a.k.a. test story
                    </li>
                    <li>
                      Description of required environment and dependencies
                    </li>
                    <li>
                      Expected results
                    </li>
                  </ol>
                  <t-b>
                    The right panel illustrates:
                    <ol class="tight">
                      <li>
                        <c-s>TestWidgetClass</c-s> main method <c-s>bool&nbsp;TestWidgetClass::test()</c-s>
                      </li>
                      <li>
                        child test methods being executed with an <c-s>Executor</c-s> instance in that function.
                      </li>
                      <li>
                        Comments that describe each of the tests.
                      </li>
                    </ol>
                    These comments are relatively simple because this is demo code.
                  </t-b>
                </defn-body>
                <defn-head class="defnBorderTop">Test Output:</defn-head>
                <defn-code>
                  Testing TestClass
                  ===================
                  Testing TestWidgetClass
                  test1 passed
                  test2 passed
                  test3 passed
                  exception thrown
                  test4 failed

                  at least one test failed

                  Testing test functions
                  ------------------------
                  testing tester
                  testTester passed
                  alwaysFails failed

                  Testing TestSequencer
                  -----------------------
                  testing tester
                  testTester passed
                  alwaysFails failed
                  Testing TestWidgetClass
                  test1 passed
                  test2 passed
                  test3 passed
                  exception thrown
                  test4 failed
                  TestWidgetClass failed
                  Widget testItem destroyed
                  Widget testItem destroyed
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Demo Sample Code</defn-head>
                <defn-code>
                  /*---------------------------------------------------------
                  Test Description:
                  - Demonstrate testing using test harness TestSequencer
                  - Can be run outside the TestSequencer
                  Test Environment:
                  - All code built with C++17 option
                  Test Operation:
                  - run each of the implementing tests: test1 to test4
                  */
                  bool TestWidgetClass::test() {
                  std::cout &lt;&lt; "\n  Testing " &lt;&lt; name();
                  bool t1 = executor_.doTest(&amp;TestWidgetClass::test1, this);
                  executor_.showResult(t1, "test1");
                  bool t2 = executor_.doTest(&amp;TestWidgetClass::test2, this);
                  executor_.showResult(t2, "test2");
                  bool t3 = executor_.doTest(&amp;TestWidgetClass::test3, this);
                  executor_.showResult(t3, "test3");
                  bool t4 = executor_.doTest(&amp;TestWidgetClass::test4, this);
                  executor_.showResult(t4, "test4");
                  return t1 &amp;&amp; t2 &amp;&amp; t3 &amp;&amp; t4;
                  }
                  /*---------------------------------------------------------
                  Requirement #1 Widget Class
                  - Widget is initialized with name = "unknown"
                  */
                  bool TestWidgetClass::test1() {
                  return (pWidget_-&gt;name() == "unknown");
                  }

                  /*---------------------------------------------------------
                  Requirement #2 Widget Class
                  - Widget::name(const std::string&amp;) sets name_ member
                  - Widget::name() returns value of name_ member
                  */
                  bool TestWidgetClass::test2() {
                  pWidget_-&gt;name("testItem");
                  return (pWidget_-&gt;name() == "testItem");
                  }

                  /*---------------------------------------------------------
                  Requirement #3 Widget Class
                  - Widget::say() returns
                  "hi from Widget instance " + name_
                  - Requires test2() to run immediately before this test
                  */
                  bool TestWidgetClass::test3() {
                  std::string temp = pWidget_-&gt;say();
                  return temp == "hi from Widget instance testItem";
                  }

                  /*---------------------------------------------------------
                  Requirement #4 Executor
                  - Tests Executor::doTest(), required to return false
                  if exception is thrown during execution of test.
                  - Also tests Executor::showResult(r, msg)
                  */
                  bool TestWidgetClass::test4() {
                  throw(std::exception());
                  return true;
                  }
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
          <t-b>
            It is quite likely that a test developer will want to use a logger to provide
            selected output information, with some control over how much is displayed.
            The <a href="logger.html">Logger Repository</a> has a pair of loggers intended to work
            effectively with this test harness.
          </t-b>
          <h3 id="status">Status:</h3>
          <t-b>
            This test harness seems to deliver sequenced tests effectively.  I haven&apos;t used it
            yet on a major project in this collection of repositories, but will start that soon.  I will
            report back observations about those first few uses in this page.
          </t-b>
        </indent-blocks>
        <spacer-15></spacer-15>
        <div style="height:10em;"></div>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <sec-elem style="width:0.0em">&nbsp;</sec-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#status">status</a></menu-elem>
        <menu-elem class="secElem"><a href="#design">design</a></menu-elem>
        <menu-elem class="secElem"><a href="#concept">concept</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
        <div class='darkItem popupHeader' style="padding:0.25em 2.0em;" onclick="this.parentElement.style.display='none'">Sections</div>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:2.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:1em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn + ": ";
  </script>
</body>
</html>