<!DOCTYPE html>
<html>
<!--
  CppStory_LibraryStreams.html
-->
<head>
  <title>C++ Story LibraryStreams</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/StylesPageFrameDefaults.css" />
  <link rel="stylesheet" href="css/StylesPageFrameStructure.css" />
  <link rel="stylesheet" href="css/StylesPageFrameMenus.css" />
  <link rel="stylesheet" href="css/StylesPageFrameThemeBlue.css" />
  <link rel="stylesheet" href="css/StylesWebComponents.css" />
  <script src="js/ScriptsWebComponents.js"></script>
  <script src="js/ScriptsPageFrameCppStory.js"></script>
  <script src="js/ScriptsPageFramePagesCppStory.js"></script>
  <script src="js/ScriptsPageFrameKeyboard.js"></script>
  <style>
    summary {
      padding: 3px 0px 5px 0px;
    }


    .gray {
      background-color: #ddd;
    }

    .spread {
      margin: 1em;
    }

    .tightSpread {
      margin: 0.5em;
    }

    #github #pagetitle {
      background-color: #002147;
      color: #fafaff;
    }

    #github #title {
      background-color: #002147;
      color: #fafaff;
    }

    #github #subtitle {
      background-color: #002147;
      color: #fafaff;
    }

    #github a.repoLink {
      background-color: #002147;
      color: #fafaff;
    }

      #github a.repoLink:link {
        background-color: #002147;
        color: #fafaff;
      }

    #github c-s {
      font-size: small;
    }

    #github defn-code {
      font-size: small;
    }

    #github .codeStyle {
      font-family: Consolas;
      font-size: small;
      font-weight: bold;
    }

    #github h3 {
      margin-top: 1.0em;
      margin-bottom: 1.0em;
    }

    #github h4 {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }

    #github .normal {
      font-weight: normal;
      font-size: small;
    }

    #github .spreadup {
      margin-top: 1em;
    }

    #github defn-block {
      max-width: 50em;
    }
  </style>
  <script>
    function loadifcpp() {
      var loc = window.location.href;
      if (window.self === window.top) {
        /*alert('top');*/
        window.location.href = 'TOCCpp.html?src=' + loc;
      }
      else {
        /*alert('not top');*/
        /*window.top.location.href = loc;*/
        window.top.location.href = loc;
      }
    }
  </script>
</head>
<body id="github" onload="initialize()">

  <a id="Next" href="CppStory_LibrarySTL.html">N</a>
  <a id="Prev" href="CppStory_Libraries.html">P</a>

  <page-frame>
    <frame-header>
      <nav id="navbar"></nav>
    </frame-header>
    <main>
      <div id="about">about</div>
      <div id="modified">10/27/2022</div>
      <div id="page">C++ Story LibraryStreams</div>
      <div id="hlp"></div>
      <a id="top"></a>
      <content>

        <header>
          <a class="repoLink" target="_blank" href="https://github.com/JimFawcett/CppStory" style="margin:2.0em 1.0em; font-size:0.9em;">C++ Story Code</a>
          <!-- <a class="repoLink" style="margin-right:8.05em;" href="../../CppStoryRepo.html">C++ Story Docs</a> -->
          <hgroup id="pagetitle" onclick="loadifcpp()" style="cursor:pointer;">
            <h1 id="title">Chapter #10 - C++ Stream Libraries</h1>
            <h3 id="subtitle" class="indent">stream types and example code</h3>
          </hgroup>
        </header>

        <h3 id="prologue">10.0 Prologue</h3>
        <t-b>
          The C++ language comes with a great collection of standard libraries. There are scores of very
          well designed facilities and more are coming with the next standardization in C++20.
          In this part we will be discussing the standard I/O streams libraries.
        </t-b>
        <div style="width:calc(100vw - 12rem);">
          <photosizer-block src="Pictures/iostreams.JPG" width="400" class="photoSizerBlock right">
            <span style="font-family:'Comic Sans MS', Tahoma;">
              Fig 1. IOStream Hierarchy
            </span>
          </photosizer-block>
        </div>
        <h3 id="strms">10.1 Streams</h3>
        <t-b>
          The stream library is structured as shown in Fig 1.  <c-s>std::ios</c-s> is a class responsible
          for managing formatting and error information. All its derived classes, <c-s>std::istream</c-s>,
          <c-s>std::ostream</c-s>, ... provide an invariant interface for streams.  They make the language
          we use to interact with streams.
        </t-b>
        <t-b>
          The buffers <c-s>std::streambuf</c-s> and its derived classes have a number of virtual functions that
          support customization. This is a really elegant design. The interface is fixed so everyone knows how
          to deal with streams, but their semantics can be customized by implementing application specific
          buffer adapters.
        </t-b>
        <t-b>
          I did that as an example in a graduate course CSE776 - Design Patterns, using the &quot;Adapter Pattern&quot;.
          That example supported sending socket messages through a stream interface.
        </t-b>
        <t-b>
          All of the real stream functionality is provided by the buffers.  You can open, read, write, and close
          files, for example, just using an instance of std::filebuf.
        </t-b>
        <div class="clear"></div>
        <h3 id="frmt">10.2 Streams Formatting Code Examples</h3>
        <t-b>
          std::iostreams formatting is fairly simple. All the format settings are encoded in bits in
          a long int which you can access from the functions:
          <defn-code class="pad10">
            long frmt = flags();  // retrieve the current format settings
            flags(frmt);          // restore the original settings
          </defn-code>
          A lot of the settings can be activated by toggling individual bits when there are only two
          format choices.  However, there are three formats that each have three choices:
          <t-b indent>
            <div>
              <ol>
                <li>
                  right, left, and internal adjust in a specified field width:<br />
                  <c-s>std::cout.setf(ios::left, ios::adjustfield);</c-s>
                </li>
                <li>
                  scientific, fixed, and automatic for floating point numbers:<br />
                  <c-s>std::cout.setf(ios::scientific, ios::floatfield);</c-s>
                </li>
                <li>
                  dec, oct, and hex for number formatting:<br />
                  <c-s>std::cout.setf(ios::hex, ios::basefield);</c-s>
                </li>
              </ol>
            </div>
            <s-5px></s-5px>
            Each of the choices is encoded in a single bit, so it is possible, for example, that both left and right
            adjust could be set, resulting in undefined behavior. The adjustfield, floatfield, and basefield
            arguments cause all of the bits for that format to be zeroed, then the one you want is set with
            ios::left, for example.
          </t-b>
          <t-b>
            Formats can be set using <c-s>flags(frmt)</c-s> or <c-s>setf(frmt, field)</c-s>, as shown in the
            example, below.  They can also be set using iomanipulators. An iomanipulator is a function that
            sets some part of the <c-s>std::ios</c-s> state. That&apos;s done by inserting them into a stream.
            <indent-block class="pad10">
              <c-s>outstrm &lt;&lt; setw(15);</c-s>
            </indent-block>
            The insertion operator is overloaded to accept function pointers for just this purpose.
          </t-b>
          <t-b>
            <h4 style="display:inline-block">Table 1. - Partial list of io manipulators</h4>
            - <a href="https://en.cppreference.com/w/cpp/io/manip">full list</a>
            <table>
              <tr>
                <th class="darkItem pad10">manipulator</th>
                <th class="darkItem pad10">function</th>
              </tr>
              <tr>
                <th colspan="2" class="pad5">&lt;ios&gt; header included in &lt;iostream&gt; header</th>
              </tr>
              <tr>
                <td class="defn">boolalpha, noboolalpha</td>
                <td class="defn">
                  set text or numeric representations, respectively
                </td>
              </tr>
              <tr>
                <td class="defn">showpoint, noshowpoint</td>
                <td class="defn">
                  decimal point is always included in floating-point representation
                </td>
              </tr>
              <tr>
                <td class="defn">skipws, noskipws</td>
                <td class="defn">
                  leading whitespace is skipped on input
                </td>
              </tr>
              <tr>
                <td class="defn">internal, left, right</td>
                <td class="defn">
                  placement of fill characters
                </td>
              </tr>
              <tr>
                <td class="defn">dec, oct, hex</td>
                <td class="defn">sets base used for integer I/O</td>
              </tr>
              <tr>
                <td class="defn">fixed, scientific, hexfloat, defaultfloat</td>
                <td class="defn">sets formatting used for floating-point I/O</td>
              </tr>
              <tr>
                <th colspan="2" class="pad5">&lt;iostream&gt;</th>
              </tr>
              <tr>
                <td class="defn">ends</td>
                <td class="defn">emits trailing '\0' to terminate string</td>
              </tr>
              <tr>
                <td class="defn">flush</td>
                <td class="defn">
                  flushes output stream
                </td>
              </tr>
              <tr>
                <td class="defn">endl</td>
                <td class="defn">emits '\n' and flushes output stream</td>
              </tr>
              <tr>
                <th colspan="2" class="pad5">
                  &lt;iomanip&gt;
                </th>
              </tr>
              <tr>
                <td class="defn">resetiosflags</td>
                <td class="defn">clears specified ios_base flags</td>
              </tr>
              <tr>
                <td class="defn">setiosflags</td>
                <td class="defn">sets specified ios_base flags</td>
              </tr>
              <tr>
                <td class="defn">setfill</td>
                <td class="defn">changes fill character which is ' ' by default</td>
              </tr>
              <tr>
                <td class="defn">setprecision</td>
                <td class="defn">
                  specifies number of digits after the point (not precision of output)
                </td>
              </tr>
              <tr>
                <td class="defn">setw</td>
                <td class="defn">
                  changes width of the <span class="notice">next</span> input or output field
                </td>
              </tr>
              <tr>
                <td class="defn">get-time</td>
                <td class="defn">parses date/time value of specified format</td>
              </tr>
              <tr>
                <td class="defn">put-time</td>
                <td class="defn">formats and outputs a date/time value using specified format</td>
              </tr>
              <tr>
                <td class="defn">quoted</td>
                <td class="defn">inserts and extracts quoted strings with embedded spaces</td>
              </tr>
            </table>
          </t-b>
          <t-b>
            The code example, below, shows most of the formatting mechanisms in iostreams.
          </t-b>
        </t-b>
        <details>
          <summary class="labelStyle darkItem">Example: std::iostream formats</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Formats.cpp</defn-head>
                <defn-code style="font-size:0.7rem;">
                  ///////////////////////////////////////////////////////////
                  // formats.cpp                                           //
                  //   demonstrate ios formating                           //
                  //                                                       //
                  // Jim Fawcett, 24 Mar 96, modified 04 Mar 02            //
                  ///////////////////////////////////////////////////////////

                  #include &lt;iostream&gt;
                  #include &lt;iomanip&gt;
                  #include &lt;string&gt;
                  using namespace std;

                  void main() {

                  title("Demonstrating ios formatting",'=');

                  title("formating integers");

                  /////////////////////////////////////////////////////////////
                  // flags:                                                  //
                  //   skipws  showbase showpoint uppercase   showpos        //
                  //  unitbuf     stdio                                      //
                  /////////////////////////////////////////////////////////////
                  //  basefield:                                             //
                  //    dec       hex       oct                              //
                  /////////////////////////////////////////////////////////////

                  long save = cout.flags();    // save format state
                  cout.setf(ios::showbase|ios::uppercase);
                  cout &lt;&lt; "  " &lt;&lt; 59 &lt;&lt; " in hexadecimal is "
                  &lt;&lt; hex  &lt;&lt; 59 &lt;&lt; dec &lt;&lt; endl
                  &lt;&lt; "  " &lt;&lt; 59 &lt;&lt; " in octal is       "
                  &lt;&lt; oct  &lt;&lt; 59 &lt;&lt; dec &lt;&lt; endl;
                  cout.flags(save);            // restore original format state

                  title("formating doubles");

                  /////////////////////////////////////////////////////////////////
                  // function:                                                   //
                  //     width()     width(n)       fill()      fill(n)          //
                  // precision() precision(n)                                    //
                  /////////////////////////////////////////////////////////////////
                  // floatfield:                                                 //
                  //  scientific        fixed    automatic                       //
                  /////////////////////////////////////////////////////////////////

                  cout.precision(6);
                  cout.setf(ios::right, ios::adjustfield);
                  cout.setf(ios::scientific, ios::floatfield);
                  cout.setf(ios::showpoint);
                  double d = 9;
                  int i;
                  for(i=0; i&lt;5; i++)
                  cout &lt;&lt; setw(14) &lt;&lt; (d /= 3);
                  cout &lt;&lt; endl;
                  cout.flags(save);

                  title("adjust, fill, and width");

                  /////////////////////////////////////////////////////////////////
                  // adjustfield:                                                //
                  //        left        right     internal                       //
                  /////////////////////////////////////////////////////////////////

                  char *numbers[5] = { "zero", "one", "two", "three", "four" };
                  int nums[5] = { 0, 1, 2, 3, 4 };
                  cout.fill('.');
                  for(i=0; i&lt;5; i++) {
                  cout.setf(ios::left, ios::adjustfield);
                  cout &lt;&lt; "  " &lt;&lt; setw(30) &lt;&lt; numbers[i];
                  cout.setf(ios::right, ios::adjustfield);
                  cout &lt;&lt; setw(30) &lt;&lt; nums[i] &lt;&lt; endl;
                  }
                  cout.flags(save);

                  title("stream manipulators");

                  /////////////////////////////////////////////////////////////
                  // manipulators:                                           //
                  //   iostream.h -  dec, oct, hex, endl, ws, ends, flush,   //
                  //   iomanip.h  -                                          //
                  //     setfill(char), setw(int), setprecision(int),        //
                  //     setiosflags(long), resetiosflags(long)              //
                  /////////////////////////////////////////////////////////////

                  cout &lt;&lt; "  " &lt;&lt; setprecision(5) &lt;&lt; (d = 1.0/3.0) &lt;&lt; endl;
                  cout &lt;&lt; "  " &lt;&lt; setfill('.') &lt;&lt; setw(20) &lt;&lt; d &lt;&lt; endl;
                  cout &lt;&lt; "  " &lt;&lt; setiosflags(ios::left | ios::showpos)
                  &lt;&lt; setw(20) &lt;&lt; d &lt;&lt; endl;
                  cout &lt;&lt; "  " &lt;&lt; resetiosflags(ios::left | ios::showpos)
                  &lt;&lt; d &lt;&lt; endl;
                  cout.flags(save);
                  cout &lt;&lt; endl;
                  }
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output:</defn-head>
                <defn-code style="font-size:0.7rem;">
                  ==============================
                  Demonstrating ios formatting
                  ==============================

                  formating integers
                  --------------------
                  59 in hexadecimal is 0X3B
                  59 in octal is       073

                  formating doubles
                  -------------------
                  3.000000e+00  1.000000e+00  3.333333e-01  1.111111e-01  3.703704e-02

                  adjust, fill, and width
                  -------------------------
                  zero.......................................................0
                  one........................................................1
                  two........................................................2
                  three......................................................3
                  four.......................................................4

                  stream manipulators
                  ---------------------
                  0.33333
                  .............0.33333
                  +0.33333............
                  0.33333
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
        <h3 id="file">10.3 File Streams Code Examples</h3>
        <t-b>
          The next example illustrates working with file streams.  Many of the things you will need to
          do when working with files are presented in the example.
        </t-b>
        <t-b>
          Files can be opened in two ways and closed:
          <t-b>
            <div>
              <ol>
                <li><c-s>std::ifstream in(filename, ios::in);</c-s></li>
                <li><c-s>std::ifstream in; in.open(filename, ios::in);</c-s></li>
                <li><c-s>in.close();</c-s></li>
              </ol>
            </div>
          </t-b>
          When file streams go out of scope their destructors call <c-s>close()</c-s>, but it does no
          harm to close the file before it goes out of scope, freeing the internal OS file handle.
        </t-b>
        <t-b>
          The example, below, illustrates standard error handling.
          When you attempt to open a file that may or may not succeed.
          <t-b>
            <div>
              <ol>
                <li>The file name may be incorrect or the file may not exist.</li>
                <li>Other code may have that file opened.</li>
                <li>The user may not have permissions to open the file.</li>
              </ol>
            </div>
          </t-b>
          For this, standard streams have a simple error handling process.  Streams can be in any of
          three states:
          <t-b>
            <div>
              <ol>
                <li>
                  <span class="notice">good</span> state, tested with the function <c-s>bool good()</c-s>.  When good is true the
                  stream operates normally.
                </li>
                <li>
                  <span class="notice">bad</span> state, tested with <c-s>bool bad()</c-s>. Streams in a bad state are fully
                  functional, but will not respond to any commands until the stream error is cleared with
                  <c-s>void clear()</c-s>. A state can go bad when it attempts to read an end of file
                  integer, <c-s>eof</c-s>. To restore normal operation, clear the error and back up at
                  least one character by calling <c-s>strm.seek(-1);</c-s>
                </li>
                <li>
                  <span class="notice">fail</span> state, tested with <c-s>bool fail()</c-s>. Streams in a fail state have been corrupted.
                  The only thing you can do with a failed stream is to destroy it or re-initialize with an
                  <c-s>open(filename, ios attributes);</c-s>.
                </li>
              </ol>
            </div>
          </t-b>
          You should <span class="notice">always</span> check filestream state after opening, before any attempt
          to use it.  We often do that with:
          <indent-block class="pad10">
            <c-s>
              std::ofstream out(filename, ios::out);<br />
              if(!out.good()) {
              /* do some clean up and return */
              }
            </c-s>
          </indent-block>
          Finally, here&apos;s the example:
        </t-b>
        <details>
          <summary class="labelStyle darkItem">Example: std::fstreams I/O</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Fileio.cpp</defn-head>
                <defn-code style="font-size:0.7em;">
                  ///////////////////////////////////////////////////////////////
                  // fileio.cpp - demonstrate fstreams                         //
                  //                                                           //
                  // Jim Fawcett, 24 Mar 96, modified 04 Mar 02                //
                  ///////////////////////////////////////////////////////////////

                  #include &lt;iostream&gt;     // cout, &lt;&lt;
                  #include &lt;fstream&gt;      // ifstream(), &lt;&lt;, &gt;&gt;
                  #include &lt;cstdlib&gt;      // exit(1);
                  #include &lt;sstream&gt;
                  #include &lt;string&gt;
                  using namespace std;

                  //----&lt; display titles &gt;---------------------------------------

                  void title(const char *t, char ul = '-', ostream &amp;out = cout) {

                  int len = strlen(t) + 2;
                  string line(len,ul);
                  if(ul == '=')
                  out &lt;&lt; "\n " &lt;&lt; line;
                  out &lt;&lt; "\n  " &lt;&lt; t
                  &lt;&lt; "\n " &lt;&lt; line &lt;&lt; endl;
                  }

                  //----&lt; begin demonstration &gt;----------------------------------

                  void main(int argc, char *argv[]) {

                  /////////////////////////////////////////////////
                  title("Demonstrating Basic File Operations",'=');
                  /////////////////////////////////////////////////

                  if(argc &lt; 2) {
                  cout &lt;&lt; "\nplease enter name of text file on command line\n\n";
                  exit(1);
                  }
                  const int bufSize = 80;
                  char buffer[bufSize];

                  //

                  // create a scope with { } and define an input stream inside
                  // then read line-by-line and send to standard output
                  {
                  ifstream in(argv[argc-1]);
                  if(!in.good()) {
                  cout &lt;&lt; "can't open file " &lt;&lt; argv[argc-1] &lt;&lt; endl;
                  exit(1);
                  }
                  else {
                  ostringstream temp;
                  temp &lt;&lt; "processing file " &lt;&lt; argv[argc-1]
                  &lt;&lt; " using istream::getline()";

                  title(temp.str().c_str());
                  //////////////////////////
                  }

                  while(in.good()) {
                  in.getline(buffer,bufSize);
                  cout &lt;&lt; buffer &lt;&lt; endl;
                  }
                  }  // in goes out of scope and is destroyed

                  // define stream again at global level, get pointer to
                  // its filebuf and stream input directly to output

                  ostringstream temp;
                  temp &lt;&lt; "processing file " &lt;&lt; argv[argc-1]
                  &lt;&lt; " using filebuf::rdbuf()";
                  title(temp.str().c_str());
                  //////////////////////////

                  ifstream in(argv[argc-1]);
                  filebuf *bptr = in.rdbuf();    // get pointer to stream
                  cout &lt;&lt; bptr &lt;&lt; endl;          // stream input to output
                  in.close();                    // still in scope so close it

                  //

                  // open stream again, seek to end to find size, and
                  // backup half way, then send last half to stdout

                  in.open(argv[argc-1]);         // open it again
                  in.seekg(0, ios::end);         // go to end of file
                  streampos sp = in.tellg();     // size = number of bytes from beg
                  in.seekg(-sp/2, ios::end);     // go to middle
                  in.getline(buffer,bufSize);    // go to next newline

                  ostringstream temp2;
                  temp2 &lt;&lt; "processing last half of this " &lt;&lt; sp &lt;&lt; " byte file";
                  title(temp2.str().c_str());
                  ///////////////////////////

                  cout &lt;&lt; in.rdbuf() &lt;&lt; endl;    // output from that point to end

                  title("stream state goes bad when attempting to read past end of file");
                  ////////////////////////////////////////////////////////////////////////

                  char ch;
                  in &gt;&gt; ch;
                  if(!in.good())
                  cout &lt;&lt; "  attempting to read past EOF makes stream state"
                  &lt;&lt; " not good\n";

                  title("can't read any more until we clear stream to good state");
                  /////////////////////////////////////////////////////////////////

                  in.clear();
                  if(in.good())
                  cout &lt;&lt; "  stream state good after clear()\n";
                  in.seekg(-1,ios::end);         // back up to good char
                  in &gt;&gt; ch;
                  if(in.good())
                  cout &lt;&lt; "  after backing up and reading " &lt;&lt; ch
                  &lt;&lt; " stream state still good\n";
                  in &gt;&gt; ch;
                  if(!in.good())
                  cout &lt;&lt; "  after reading EOF stream state not good again\n";
                  cout &lt;&lt; endl;
                  }
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output:</defn-head>
                <defn-code style="font-size:0.7em;">
                  =====================================
                  Demonstrating Basic File Operations
                  =====================================

                  processing file test.txt using istream::getline()
                  ---------------------------------------------------
                  this is the first line
                  second line
                  third line
                  fourth line
                  fifth line
                  this is the sixth and final line

                  processing file test.txt using filebuf::rdbuf()
                  -------------------------------------------------
                  this is the first line
                  second line
                  third line
                  fourth line
                  fifth line
                  this is the sixth and final line

                  processing last half of this 106 byte file
                  --------------------------------------------
                  fifth line
                  this is the sixth and final line

                  stream state goes bad when attempting to read past end of file
                  ----------------------------------------------------------------
                  attempting to read past EOF makes stream state not good

                  can't read any more until we clear stream to good state
                  ---------------------------------------------------------
                  stream state good after clear()
                  after backing up and reading e stream state still good
                  after reading EOF stream state not good again
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
        <h3 id="fbuf">10.4 Filebuf I/O Code Examples</h3>
        <t-b>
          The next example illustrates that most things you can do with a standard stream object you can
          also do with its internal filebuf. In other words, the stream object presents a (non-virtual)
          interface and its filebuf does all the work.
        </t-b>
        <details>
          <summary class="labelStyle darkItem">Example: std::Filebuf I/O</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Filebuf.cpp</defn-head>
                <defn-code style="font-size:0.7em;">
                  /////////////////////////////////////////////////////////////////
                  // filebuf.cpp                                                 //
                  //   demonstrate low level input and output using streambufs   //
                  //   built from FILE pointer and stdout                        //
                  //                                                             //
                  // Jim Fawcett, 24 Mar 96, modified 23 Mar 97, 01 Mar 04       //
                  /////////////////////////////////////////////////////////////////

                  #include &lt;iostream&gt;    // cout, &lt;&lt;
                  #include &lt;fstream&gt;     // ifstream(), &lt;&lt;, &gt;&gt;
                  using namespace std;

                  //----&lt; display titles &gt;---------------------------------------

                  void title(const char *t, char ul = '-', ostream &amp;out = cout) {

                  int len = strlen(t) + 2;
                  std::string line(len,ul);
                  if(ul == '=')
                  out &lt;&lt; "\n " &lt;&lt; line.c_str();
                  out &lt;&lt; "\n  " &lt;&lt; t
                  &lt;&lt; "\n " &lt;&lt; line.c_str() &lt;&lt; endl;
                  }

                  //----&lt; begin demonstration &gt;----------------------------------

                  void main(int argc, char *argv[]) {

                  //////////////////////////////////////////////////////////////
                  title("Demonstrating use of Stream Buffers with File IO",'=');
                  //////////////////////////////////////////////////////////////

                  if(argc &lt; 2) {
                  cout &lt;&lt; "\nplease enter name of text file on command line\n";
                  exit(1);
                  }

                  title("using streambuf for input from file");
                  /////////////////////////////////////////////

                  filebuf ifb;                       // create filebuf
                  ifb.open(argv[argc-1],ios::in);    // attach to file
                  cout &lt;&lt; &amp;ifb &lt;&lt; endl;              // stream to cout
                  cout.flush();

                  title("using streambuf for output to stdout");
                  //////////////////////////////////////////////

                  istream in(&amp;ifb);            // make stream in, attached to ifb
                  in.seekg(0);                 // move to top of input buffer
                  ostream out(cout.rdbuf());   // make stream out, attached to cout streambuf
                  out &lt;&lt; &amp;ifb &lt;&lt; endl;         // stream it to out
                  out.flush();

                  // could replace last statement with the lower level
                  // gets and puts shown below

                  title("using low-level streambuf interface for output to stdout");
                  //////////////////////////////////////////////////////////////////

                  streambuf* pOfb = cout.rdbuf();
                  in.seekg(0);
                  char ch;
                  while((ch = ifb.sbumpc()) != EOF)
                  pOfb-&gt;sputc(ch);

                  cout &lt;&lt; "\n\n";
                  }
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output:</defn-head>
                <defn-code style="font-size:0.7em;">
                  ==================================================
                  Demonstrating use of Stream Buffers with File IO
                  ==================================================

                  using streambuf for input from file
                  -------------------------------------
                  this is the first line
                  second line
                  third line
                  fourth line
                  fifth line
                  this is the sixth and final line

                  using streambuf for output to stdout
                  --------------------------------------
                  this is the first line
                  second line
                  third line
                  fourth line
                  fifth line
                  this is the sixth and final line

                  using low-level streambuf interface for output to stdout
                  ----------------------------------------------------------
                  this is the first line
                  second line
                  third line
                  fourth line
                  fifth line
                  this is the sixth and final line
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
        <h3 id="rdwr">10.5 Read-Write Code Examples</h3>
        <t-b>
          The next example illustrates that you can read and write to the same file using a single filebuf
          for both reading and writing.  You might do that if you were building a database record manager
          where you need to read existing data but also enter new data into the same file.
        </t-b>
        <t-b>
          In order to make this work for something useful you will have to devise a schema which defines
          regions of the file where you read and write specific columns of a record.  That&apos;s what
          SQL databases do.
        </t-b>
        <t-b>
          This example just demonstrates that you can both read and write.  It doesn&apos;t do any schema-based
          record management (but that wouldn&apos;t be too hard to do). The way we get that to work is to
          wrap a common filebuf with both an input stream and an output stream.  Here&apos;s the details:
        </t-b>
        <details>
          <summary class="labelStyle darkItem">Read/Write Streams</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Readwrite.cpp</defn-head>
                <defn-code style="font-size:0.7rem;">
                  ///////////////////////////////////////////////////////////////
                  // readwrit.cpp - demonstrate read/write fstreams            //
                  //                with buffer location seeking               //
                  // Jim Fawcett, 24 Mar 96, modified 23 Mar 97                //
                  ///////////////////////////////////////////////////////////////

                  #include &lt;iostream&gt;     // cout, &lt;&lt;
                  #include &lt;fstream&gt;      // ifstream(), &lt;&lt;, &gt;&gt;
                  #include &lt;cstdlib&gt;      // exit(1);
                  #include &lt;string&gt;
                  using namespace std;

                  //----&lt; display titles &gt;---------------------------------------

                  void title(const char *t, char ul = '-', ostream &amp;out = cout) {

                  int len = strlen(t) + 2;
                  string line(len,ul);
                  if(ul == '=')
                  out &lt;&lt; "\n " &lt;&lt; line;
                  out &lt;&lt; "\n  " &lt;&lt; t
                  &lt;&lt; "\n " &lt;&lt; line &lt;&lt; endl;
                  }

                  //----&lt; begin demonstration &gt;----------------------------------

                  void main(int argc, char *argv[]) {

                  ///////////////////////////////////////////////////////////////
                  title("Demonstration of Reading AND Writing to a Common File",'=');
                  ///////////////////////////////////////////////////////////////

                  if(argc &lt; 2) {
                  cout &lt;&lt; "please enter file name on command line\n";
                  exit(1);
                  }

                  //

                  ///////////////////////////////////////////////////////////////
                  // file open modes:    in        out        app        ate   //
                  //                     nocreate  noreplace  trunc            //
                  ///////////////////////////////////////////////////////////////

                  // save input file contents in a temporary file
                  // for reading and writing

                  ifstream masterin(argv[argc-1]);
                  ofstream tempout("tmp.tmp");
                  tempout &lt;&lt; masterin.rdbuf();
                  masterin.close();
                  tempout.close();

                  // open temporary for input AND output processing
                  ifstream in("tmp.tmp", ios::in|ios::out);
                  if(!in.good()) {
                  cout &lt;&lt; "can't open file tmp.tmp" &lt;&lt; endl;
                  exit(1);
                  }

                  // use input stream buffer for output stream too
                  ostream out(in.rdbuf());

                  // now, try reading and writing

                  title("this is a test file for reading and writing");
                  /////////////////////////////////////////////////////

                  cout &lt;&lt; in.rdbuf();
                  out &lt;&lt; "---\nthis text is added to the end\n";

                  // how many bytes in file?
                  streampos sp = out.tellp();
                  out.seekp(-sp, ios::end);            // back up from end
                  out &lt;&lt; "this text overwrites beginning of file\n";
                  cout &lt;&lt; endl;

                  // write it out to see what happened

                  title("modified file:");
                  ////////////////////////

                  in.seekg(ios::beg);                  // go to beginning
                  cout &lt;&lt; in.rdbuf() &lt;&lt; endl;
                  }
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output:</defn-head>
                <defn-code style="font-size:0.7rem;">
                  =======================================================
                  Demonstration of Reading AND Writing to a Common File
                  =======================================================

                  this is a test file for reading and writing
                  ---------------------------------------------
                  this is the first line
                  second line
                  third line
                  fourth line
                  fifth line
                  this is the sixth and final line

                  modified file:
                  ----------------
                  this text overwrites beginning of file
                  rd line
                  fourth line
                  fifth line
                  this is the sixth and final line---
                  this text is added to the end
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
        <h3 id="strgs">10.6 String Streams Code Examples</h3>
        <t-b>
          The final example demonstrates stringstreams.  These are particularly useful for doing object to
          string and string to object transformations.  That&apos;s what a std::ostream does.  If you write:
          <indent-block class="pad10">
            double d{ 3.14159 };<br />
            std::cout << d;
          </indent-block>
          <c-s>std::cout</c-s> transforms its double input into a sequence of characters written to your
          terminal, e.g., a string. All the standard streams do this, and, with stringstream objects, we
          can retrieve the string for processing rather than write it to a terminal.
          Here&apos;s the demo:
        </t-b>
        <details>
          <summary class="labelStyle darkItem">Example: std::stringstreams</summary>
          <t-b>
            <defn-outerBlock>
              <defn-block>
                <defn-head>Strio.cpp</defn-head>
                <defn-code style="font-size:0.7rem;">
                  ///////////////////////////////////////////////////////////////
                  // strio.cpp - demonstrate stringstreams                     //
                  //                                                           //
                  // Jim Fawcett, 24 Mar 96, modified 04 Mar 02                //
                  ///////////////////////////////////////////////////////////////

                  #include &lt;iostream&gt;     // cout, &lt;&lt;
                  #include &lt;sstream&gt;      // istringstream(), ostringstream(), &lt;&lt;, &gt;&gt;
                  #include &lt;string&gt;

                  using namespace std;

                  //----&lt; display titles &gt;---------------------------------------

                  void title(const char *t, char ul = '-', ostream &amp;out = cout) {

                  int len = strlen(t) + 2;
                  string line(len,ul);
                  if(ul == '=')
                  out &lt;&lt; "\n " &lt;&lt; line;
                  out &lt;&lt; "\n  " &lt;&lt; t
                  &lt;&lt; "\n " &lt;&lt; line &lt;&lt; endl;
                  }

                  //----&lt; begin demonstration &gt;----------------------------------

                  void main() {

                  ///////////////////////////////////////////////////
                  title("Demonstrating stringstream operations",'=');
                  ///////////////////////////////////////////////////

                  title("reading from istringstream");
                  /////////////////////////////

                  istringstream source("15 3.1415927 Now is the hour");
                  cout &lt;&lt; "\n  " &lt;&lt; source.str() &lt;&lt; endl;

                  title("writing to ostringstream");
                  ////////////////////////////////////

                  ostringstream destin;
                  destin &lt;&lt; source.str();
                  stringbuf *pStringBuf = destin.rdbuf();
                  cout &lt;&lt; "\n--source-----" &lt;&lt; source.str();
                  cout &lt;&lt; "\n--destin-----" &lt;&lt; destin.str();
                  cout &lt;&lt; "\n--stringBuf--" &lt;&lt; pStringBuf-&gt;str() &lt;&lt; endl;

                  //

                  title("writing to custom buffer no longer supported in ostringstream");
                  ///////////////////////////////////////////////////////////////////////

                  title("parsing input buffer");
                  //////////////////////////////

                  int i;
                  const int bufSize=50;
                  double d;
                  char savebuf[bufSize];

                  source.seekg(0);
                  source &gt;&gt; i &gt;&gt; d;
                  cout &lt;&lt; endl;
                  cout &lt;&lt; "  i = " &lt;&lt; i &lt;&lt; endl;
                  cout &lt;&lt; "  d = " &lt;&lt; d &lt;&lt; endl;
                  int j;

                  // The following operation is dangerous!
                  //   extraction writes whole word into buffer,
                  //   even if word size is larger than buffer

                  for(j=0; j&lt;4; j++) {
                  source &gt;&gt; savebuf;
                  cout &lt;&lt; "  savebuf = " &lt;&lt; savebuf &lt;&lt; endl;
                  }

                  // Here is a saver, though less convenient way
                  // to read strings from a stream

                  title("safe parsing using destination string");
                  ///////////////////////////////////////////////

                  source.clear();
                  source.seekg(0);
                  string temp;
                  while(source.good()) {
                  source &gt;&gt; temp;
                  cout &lt;&lt; "\n  " &lt;&lt; temp;
                  }
                  cout &lt;&lt; "\n\n";

                  title("char-by-char parsing");
                  //////////////////////////////

                  source.clear();
                  source.seekg(0);
                  temp = "";
                  while(source.good()) {
                  char ch = source.get();
                  if(!isspace(ch))
                  temp += ch;
                  else if(temp.size() &gt; 0) {
                  cout &lt;&lt; "\n  " &lt;&lt; temp.c_str();
                  temp = "";
                  }
                  }
                  if(temp.size() &gt; 0)
                  cout &lt;&lt; "\n  " &lt;&lt; temp.c_str();
                  cout &lt;&lt; "\n\n";
                  }
                </defn-code>
              </defn-block>
              <defn-block>
                <defn-head>Output</defn-head>
                <defn-code style="font-size:0.7rem;">
                  =======================================
                  Demonstrating stringstream operations
                  =======================================

                  reading from istringstream
                  ----------------------------

                  15 3.1415927 Now is the hour

                  writing to ostringstream
                  --------------------------

                  --source-----15 3.1415927 Now is the hour
                  --destin-----15 3.1415927 Now is the hour
                  --stringBuf--15 3.1415927 Now is the hour

                  parsing input buffer
                  ----------------------

                  i = 15
                  d = 3.14159
                  savebuf = Now
                  savebuf = is
                  savebuf = the
                  savebuf = hour

                  safe parsing using destination string
                  ---------------------------------------

                  15
                  3.1415927
                  Now
                  is
                  the
                  hour

                  char-by-char parsing
                  ----------------------

                  15
                  3.1415927
                  Now
                  is
                  the
                  hour 
                </defn-code>
              </defn-block>
            </defn-outerBlock>
          </t-b>
        </details>
        <div class="clear"></div>
        <h3 id="epilogue">10.7 Epilogue</h3>
        <div style="height:3em;" class="indent">
          Commentary to be added later
        </div>
        <h3 id="refs">10.8 References</h3>
        <indent-block>
          <a href="https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf">string formatting (see answer 15) - stackoverflow</a><br />
        </indent-block>
        <spacer-25></spacer-25>
      </content>
      <a id="bottom"></a>
      <page-TOC id="pages" style="display:none;">
      </page-TOC>
      <page-sections id="sections" style="display:none;">
        <sec-elem style="width:0.0em">&nbsp;</sec-elem>
        <menu-elem class="secElem"><a href="#bottom">bottom</a></menu-elem>
        <menu-elem class="secElem"><a href="#refs">refs</a></menu-elem>
        <menu-elem class="secElem"><a href="#epilogue">epilogue</a></menu-elem>
        <menu-elem class="secElem"><a href="#strgs">stringstreams</a></menu-elem>
        <menu-elem class="secElem"><a href="#rdwr">readwrite</a></menu-elem>
        <menu-elem class="secElem"><a href="#fbuf">fbuffer</a></menu-elem>
        <menu-elem class="secElem"><a href="#file">file</a></menu-elem>
        <menu-elem class="secElem"><a href="#frmt">format</a></menu-elem>
        <menu-elem class="secElem"><a href="#strms">streams</a></menu-elem>
        <menu-elem class="secElem"><a href="#prologue">prologue</a></menu-elem>
        <menu-elem class="secElem"><a href="#top">top</a></menu-elem>
        <div class='darkItem popupHeader' onclick="location.reload()">Sections</div>
      </page-sections>
    </main>
    <frame-footer>
      <menu-item style="width:2.0em;">&nbsp;</menu-item>
      <menu-elem id="nextLink2" onclick="bottomMenu.next()">Next</menu-elem>
      <menu-elem id="prevLink2" onclick="bottomMenu.prev()">Prev</menu-elem>
      <menu-elem id="pgbtn" onclick="bottomMenu.pages()">Pages</menu-elem>
      <menu-elem onclick="bottomMenu.sections()">Sections</menu-elem>
      <menu-elem onclick="bottomMenu.about()">About</menu-elem>
      <menu-elem id="kysbtn" onclick="storyHlpMenu.keys()">Keys</menu-elem>
      <menu-elem style="margin-right:1em">
        <span id="loc" style="display:inline-block; font-weight:normal"></span>
      </menu-elem>
    </frame-footer>
  </page-frame>
  <script>
    let loc = document.getElementById("loc");
    let fn = window.location.href.split(/\/|\\/).pop();
    loc.innerHTML = fn + ": ";
  </script>
</body>
</html>